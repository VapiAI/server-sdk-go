// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/VapiAI/server-sdk-go/internal"
	big "math/big"
	time "time"
)

var (
	insightControllerFindAllRequestFieldId          = big.NewInt(1 << 0)
	insightControllerFindAllRequestFieldPage        = big.NewInt(1 << 1)
	insightControllerFindAllRequestFieldSortOrder   = big.NewInt(1 << 2)
	insightControllerFindAllRequestFieldLimit       = big.NewInt(1 << 3)
	insightControllerFindAllRequestFieldCreatedAtGt = big.NewInt(1 << 4)
	insightControllerFindAllRequestFieldCreatedAtLt = big.NewInt(1 << 5)
	insightControllerFindAllRequestFieldCreatedAtGe = big.NewInt(1 << 6)
	insightControllerFindAllRequestFieldCreatedAtLe = big.NewInt(1 << 7)
	insightControllerFindAllRequestFieldUpdatedAtGt = big.NewInt(1 << 8)
	insightControllerFindAllRequestFieldUpdatedAtLt = big.NewInt(1 << 9)
	insightControllerFindAllRequestFieldUpdatedAtGe = big.NewInt(1 << 10)
	insightControllerFindAllRequestFieldUpdatedAtLe = big.NewInt(1 << 11)
)

type InsightControllerFindAllRequest struct {
	Id *string `json:"-" url:"id,omitempty"`
	// This is the page number to return. Defaults to 1.
	Page *float64 `json:"-" url:"page,omitempty"`
	// This is the sort order for pagination. Defaults to 'DESC'.
	SortOrder *InsightControllerFindAllRequestSortOrder `json:"-" url:"sortOrder,omitempty"`
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InsightControllerFindAllRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetId(id *string) {
	i.Id = id
	i.require(insightControllerFindAllRequestFieldId)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetPage(page *float64) {
	i.Page = page
	i.require(insightControllerFindAllRequestFieldPage)
}

// SetSortOrder sets the SortOrder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetSortOrder(sortOrder *InsightControllerFindAllRequestSortOrder) {
	i.SortOrder = sortOrder
	i.require(insightControllerFindAllRequestFieldSortOrder)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetLimit(limit *float64) {
	i.Limit = limit
	i.require(insightControllerFindAllRequestFieldLimit)
}

// SetCreatedAtGt sets the CreatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetCreatedAtGt(createdAtGt *time.Time) {
	i.CreatedAtGt = createdAtGt
	i.require(insightControllerFindAllRequestFieldCreatedAtGt)
}

// SetCreatedAtLt sets the CreatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetCreatedAtLt(createdAtLt *time.Time) {
	i.CreatedAtLt = createdAtLt
	i.require(insightControllerFindAllRequestFieldCreatedAtLt)
}

// SetCreatedAtGe sets the CreatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetCreatedAtGe(createdAtGe *time.Time) {
	i.CreatedAtGe = createdAtGe
	i.require(insightControllerFindAllRequestFieldCreatedAtGe)
}

// SetCreatedAtLe sets the CreatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetCreatedAtLe(createdAtLe *time.Time) {
	i.CreatedAtLe = createdAtLe
	i.require(insightControllerFindAllRequestFieldCreatedAtLe)
}

// SetUpdatedAtGt sets the UpdatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetUpdatedAtGt(updatedAtGt *time.Time) {
	i.UpdatedAtGt = updatedAtGt
	i.require(insightControllerFindAllRequestFieldUpdatedAtGt)
}

// SetUpdatedAtLt sets the UpdatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetUpdatedAtLt(updatedAtLt *time.Time) {
	i.UpdatedAtLt = updatedAtLt
	i.require(insightControllerFindAllRequestFieldUpdatedAtLt)
}

// SetUpdatedAtGe sets the UpdatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetUpdatedAtGe(updatedAtGe *time.Time) {
	i.UpdatedAtGe = updatedAtGe
	i.require(insightControllerFindAllRequestFieldUpdatedAtGe)
}

// SetUpdatedAtLe sets the UpdatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindAllRequest) SetUpdatedAtLe(updatedAtLe *time.Time) {
	i.UpdatedAtLe = updatedAtLe
	i.require(insightControllerFindAllRequestFieldUpdatedAtLe)
}

var (
	insightControllerFindOneRequestFieldId = big.NewInt(1 << 0)
)

type InsightControllerFindOneRequest struct {
	Id string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InsightControllerFindOneRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerFindOneRequest) SetId(id string) {
	i.Id = id
	i.require(insightControllerFindOneRequestFieldId)
}

var (
	insightControllerRemoveRequestFieldId = big.NewInt(1 << 0)
)

type InsightControllerRemoveRequest struct {
	Id string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InsightControllerRemoveRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerRemoveRequest) SetId(id string) {
	i.Id = id
	i.require(insightControllerRemoveRequestFieldId)
}

var (
	insightRunDtoFieldId                = big.NewInt(1 << 0)
	insightRunDtoFieldFormatPlan        = big.NewInt(1 << 1)
	insightRunDtoFieldTimeRangeOverride = big.NewInt(1 << 2)
)

type InsightRunDto struct {
	Id         string                `json:"-" url:"-"`
	FormatPlan *InsightRunFormatPlan `json:"formatPlan,omitempty" url:"-"`
	// This is the optional time range override for the insight.
	// If provided, overrides every field in the insight's timeRange.
	// If this is provided with missing fields, defaults will be used, not the insight's timeRange.
	// start default - "-7d"
	// end default - "now"
	// step default - "day"
	// For Pie and Text Insights, step will be ignored even if provided.
	TimeRangeOverride *InsightTimeRangeWithStep `json:"timeRangeOverride,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InsightRunDto) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightRunDto) SetId(id string) {
	i.Id = id
	i.require(insightRunDtoFieldId)
}

// SetFormatPlan sets the FormatPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightRunDto) SetFormatPlan(formatPlan *InsightRunFormatPlan) {
	i.FormatPlan = formatPlan
	i.require(insightRunDtoFieldFormatPlan)
}

// SetTimeRangeOverride sets the TimeRangeOverride field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightRunDto) SetTimeRangeOverride(timeRangeOverride *InsightTimeRangeWithStep) {
	i.TimeRangeOverride = timeRangeOverride
	i.require(insightRunDtoFieldTimeRangeOverride)
}

var (
	insightControllerUpdateRequestFieldId = big.NewInt(1 << 0)
)

type InsightControllerUpdateRequest struct {
	Id   string                              `json:"-" url:"-"`
	Body *InsightControllerUpdateRequestBody `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InsightControllerUpdateRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightControllerUpdateRequest) SetId(id string) {
	i.Id = id
	i.require(insightControllerUpdateRequestFieldId)
}

func (i *InsightControllerUpdateRequest) UnmarshalJSON(data []byte) error {
	body := new(InsightControllerUpdateRequestBody)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	i.Body = body
	return nil
}

func (i *InsightControllerUpdateRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.Body)
}

var (
	barInsightFieldName      = big.NewInt(1 << 0)
	barInsightFieldFormulas  = big.NewInt(1 << 1)
	barInsightFieldMetadata  = big.NewInt(1 << 2)
	barInsightFieldTimeRange = big.NewInt(1 << 3)
	barInsightFieldGroupBy   = big.NewInt(1 << 4)
	barInsightFieldQueries   = big.NewInt(1 << 5)
	barInsightFieldId        = big.NewInt(1 << 6)
	barInsightFieldOrgId     = big.NewInt(1 << 7)
	barInsightFieldCreatedAt = big.NewInt(1 << 8)
	barInsightFieldUpdatedAt = big.NewInt(1 << 9)
)

type BarInsight struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formulas []*InsightFormula `json:"formulas,omitempty" url:"formulas,omitempty"`
	// This is the metadata for the insight.
	Metadata  *BarInsightMetadata       `json:"metadata,omitempty" url:"metadata,omitempty"`
	TimeRange *InsightTimeRangeWithStep `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the group by column for the insight when table is `call`.
	// These are the columns to group the results by.
	// All results are grouped by the time range step by default.
	GroupBy *BarInsightGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// These are the queries to run to generate the insight.
	Queries []*BarInsightQueriesItem `json:"queries" url:"queries"`
	// This is the unique identifier for the Insight.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this Insight belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the Insight was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the Insight was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BarInsight) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *BarInsight) GetFormulas() []*InsightFormula {
	if b == nil {
		return nil
	}
	return b.Formulas
}

func (b *BarInsight) GetMetadata() *BarInsightMetadata {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BarInsight) GetTimeRange() *InsightTimeRangeWithStep {
	if b == nil {
		return nil
	}
	return b.TimeRange
}

func (b *BarInsight) GetGroupBy() *BarInsightGroupBy {
	if b == nil {
		return nil
	}
	return b.GroupBy
}

func (b *BarInsight) GetQueries() []*BarInsightQueriesItem {
	if b == nil {
		return nil
	}
	return b.Queries
}

func (b *BarInsight) GetId() string {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *BarInsight) GetOrgId() string {
	if b == nil {
		return ""
	}
	return b.OrgId
}

func (b *BarInsight) GetCreatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.CreatedAt
}

func (b *BarInsight) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *BarInsight) Type() string {
	return b.type_
}

func (b *BarInsight) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BarInsight) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsight) SetName(name *string) {
	b.Name = name
	b.require(barInsightFieldName)
}

// SetFormulas sets the Formulas field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsight) SetFormulas(formulas []*InsightFormula) {
	b.Formulas = formulas
	b.require(barInsightFieldFormulas)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsight) SetMetadata(metadata *BarInsightMetadata) {
	b.Metadata = metadata
	b.require(barInsightFieldMetadata)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsight) SetTimeRange(timeRange *InsightTimeRangeWithStep) {
	b.TimeRange = timeRange
	b.require(barInsightFieldTimeRange)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsight) SetGroupBy(groupBy *BarInsightGroupBy) {
	b.GroupBy = groupBy
	b.require(barInsightFieldGroupBy)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsight) SetQueries(queries []*BarInsightQueriesItem) {
	b.Queries = queries
	b.require(barInsightFieldQueries)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsight) SetId(id string) {
	b.Id = id
	b.require(barInsightFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsight) SetOrgId(orgId string) {
	b.OrgId = orgId
	b.require(barInsightFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsight) SetCreatedAt(createdAt time.Time) {
	b.CreatedAt = createdAt
	b.require(barInsightFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsight) SetUpdatedAt(updatedAt time.Time) {
	b.UpdatedAt = updatedAt
	b.require(barInsightFieldUpdatedAt)
}

func (b *BarInsight) UnmarshalJSON(data []byte) error {
	type embed BarInsight
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BarInsight(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "bar" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "bar", unmarshaler.Type)
	}
	b.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *b, "type")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BarInsight) MarshalJSON() ([]byte, error) {
	type embed BarInsight
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewDateTime(b.CreatedAt),
		UpdatedAt: internal.NewDateTime(b.UpdatedAt),
		Type:      "bar",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BarInsight) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// This is the group by column for the insight when table is `call`.
// These are the columns to group the results by.
// All results are grouped by the time range step by default.
type BarInsightGroupBy string

const (
	BarInsightGroupByAssistantId                       BarInsightGroupBy = "assistantId"
	BarInsightGroupByWorkflowId                        BarInsightGroupBy = "workflowId"
	BarInsightGroupBySquadId                           BarInsightGroupBy = "squadId"
	BarInsightGroupByPhoneNumberId                     BarInsightGroupBy = "phoneNumberId"
	BarInsightGroupByType                              BarInsightGroupBy = "type"
	BarInsightGroupByEndedReason                       BarInsightGroupBy = "endedReason"
	BarInsightGroupByCampaignId                        BarInsightGroupBy = "campaignId"
	BarInsightGroupByArtifactStructuredOutputsOutputId BarInsightGroupBy = "artifact.structuredOutputs[OutputID]"
)

func NewBarInsightGroupByFromString(s string) (BarInsightGroupBy, error) {
	switch s {
	case "assistantId":
		return BarInsightGroupByAssistantId, nil
	case "workflowId":
		return BarInsightGroupByWorkflowId, nil
	case "squadId":
		return BarInsightGroupBySquadId, nil
	case "phoneNumberId":
		return BarInsightGroupByPhoneNumberId, nil
	case "type":
		return BarInsightGroupByType, nil
	case "endedReason":
		return BarInsightGroupByEndedReason, nil
	case "campaignId":
		return BarInsightGroupByCampaignId, nil
	case "artifact.structuredOutputs[OutputID]":
		return BarInsightGroupByArtifactStructuredOutputsOutputId, nil
	}
	var t BarInsightGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BarInsightGroupBy) Ptr() *BarInsightGroupBy {
	return &b
}

var (
	barInsightMetadataFieldXAxisLabel = big.NewInt(1 << 0)
	barInsightMetadataFieldYAxisLabel = big.NewInt(1 << 1)
	barInsightMetadataFieldYAxisMin   = big.NewInt(1 << 2)
	barInsightMetadataFieldYAxisMax   = big.NewInt(1 << 3)
	barInsightMetadataFieldName       = big.NewInt(1 << 4)
)

type BarInsightMetadata struct {
	XAxisLabel *string  `json:"xAxisLabel,omitempty" url:"xAxisLabel,omitempty"`
	YAxisLabel *string  `json:"yAxisLabel,omitempty" url:"yAxisLabel,omitempty"`
	YAxisMin   *float64 `json:"yAxisMin,omitempty" url:"yAxisMin,omitempty"`
	YAxisMax   *float64 `json:"yAxisMax,omitempty" url:"yAxisMax,omitempty"`
	Name       *string  `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BarInsightMetadata) GetXAxisLabel() *string {
	if b == nil {
		return nil
	}
	return b.XAxisLabel
}

func (b *BarInsightMetadata) GetYAxisLabel() *string {
	if b == nil {
		return nil
	}
	return b.YAxisLabel
}

func (b *BarInsightMetadata) GetYAxisMin() *float64 {
	if b == nil {
		return nil
	}
	return b.YAxisMin
}

func (b *BarInsightMetadata) GetYAxisMax() *float64 {
	if b == nil {
		return nil
	}
	return b.YAxisMax
}

func (b *BarInsightMetadata) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *BarInsightMetadata) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BarInsightMetadata) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetXAxisLabel sets the XAxisLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsightMetadata) SetXAxisLabel(xAxisLabel *string) {
	b.XAxisLabel = xAxisLabel
	b.require(barInsightMetadataFieldXAxisLabel)
}

// SetYAxisLabel sets the YAxisLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsightMetadata) SetYAxisLabel(yAxisLabel *string) {
	b.YAxisLabel = yAxisLabel
	b.require(barInsightMetadataFieldYAxisLabel)
}

// SetYAxisMin sets the YAxisMin field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsightMetadata) SetYAxisMin(yAxisMin *float64) {
	b.YAxisMin = yAxisMin
	b.require(barInsightMetadataFieldYAxisMin)
}

// SetYAxisMax sets the YAxisMax field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsightMetadata) SetYAxisMax(yAxisMax *float64) {
	b.YAxisMax = yAxisMax
	b.require(barInsightMetadataFieldYAxisMax)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarInsightMetadata) SetName(name *string) {
	b.Name = name
	b.require(barInsightMetadataFieldName)
}

func (b *BarInsightMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler BarInsightMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BarInsightMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BarInsightMetadata) MarshalJSON() ([]byte, error) {
	type embed BarInsightMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BarInsightMetadata) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BarInsightQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (b *BarInsightQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if b == nil {
		return nil
	}
	return b.JsonQueryOnCallTableWithStringTypeColumn
}

func (b *BarInsightQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if b == nil {
		return nil
	}
	return b.JsonQueryOnCallTableWithNumberTypeColumn
}

func (b *BarInsightQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if b == nil {
		return nil
	}
	return b.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (b *BarInsightQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		b.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		b.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		b.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		b.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		b.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		b.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BarInsightQueriesItem) MarshalJSON() ([]byte, error) {
	if b.typ == "JsonQueryOnCallTableWithStringTypeColumn" || b.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(b.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if b.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || b.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(b.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if b.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || b.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(b.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BarInsightQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (b *BarInsightQueriesItem) Accept(visitor BarInsightQueriesItemVisitor) error {
	if b.typ == "JsonQueryOnCallTableWithStringTypeColumn" || b.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(b.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if b.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || b.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(b.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if b.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || b.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(b.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

var (
	createBarInsightFromCallTableDtoFieldName      = big.NewInt(1 << 0)
	createBarInsightFromCallTableDtoFieldFormulas  = big.NewInt(1 << 1)
	createBarInsightFromCallTableDtoFieldMetadata  = big.NewInt(1 << 2)
	createBarInsightFromCallTableDtoFieldTimeRange = big.NewInt(1 << 3)
	createBarInsightFromCallTableDtoFieldGroupBy   = big.NewInt(1 << 4)
	createBarInsightFromCallTableDtoFieldQueries   = big.NewInt(1 << 5)
)

type CreateBarInsightFromCallTableDto struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formulas []*InsightFormula `json:"formulas,omitempty" url:"formulas,omitempty"`
	// This is the metadata for the insight.
	Metadata  *BarInsightMetadata       `json:"metadata,omitempty" url:"metadata,omitempty"`
	TimeRange *InsightTimeRangeWithStep `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the group by column for the insight when table is `call`.
	// These are the columns to group the results by.
	// All results are grouped by the time range step by default.
	GroupBy *CreateBarInsightFromCallTableDtoGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// These are the queries to run to generate the insight.
	Queries []*CreateBarInsightFromCallTableDtoQueriesItem `json:"queries" url:"queries"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateBarInsightFromCallTableDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateBarInsightFromCallTableDto) GetFormulas() []*InsightFormula {
	if c == nil {
		return nil
	}
	return c.Formulas
}

func (c *CreateBarInsightFromCallTableDto) GetMetadata() *BarInsightMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateBarInsightFromCallTableDto) GetTimeRange() *InsightTimeRangeWithStep {
	if c == nil {
		return nil
	}
	return c.TimeRange
}

func (c *CreateBarInsightFromCallTableDto) GetGroupBy() *CreateBarInsightFromCallTableDtoGroupBy {
	if c == nil {
		return nil
	}
	return c.GroupBy
}

func (c *CreateBarInsightFromCallTableDto) GetQueries() []*CreateBarInsightFromCallTableDtoQueriesItem {
	if c == nil {
		return nil
	}
	return c.Queries
}

func (c *CreateBarInsightFromCallTableDto) Type() string {
	return c.type_
}

func (c *CreateBarInsightFromCallTableDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBarInsightFromCallTableDto) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateBarInsightFromCallTableDto) SetName(name *string) {
	c.Name = name
	c.require(createBarInsightFromCallTableDtoFieldName)
}

// SetFormulas sets the Formulas field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateBarInsightFromCallTableDto) SetFormulas(formulas []*InsightFormula) {
	c.Formulas = formulas
	c.require(createBarInsightFromCallTableDtoFieldFormulas)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateBarInsightFromCallTableDto) SetMetadata(metadata *BarInsightMetadata) {
	c.Metadata = metadata
	c.require(createBarInsightFromCallTableDtoFieldMetadata)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateBarInsightFromCallTableDto) SetTimeRange(timeRange *InsightTimeRangeWithStep) {
	c.TimeRange = timeRange
	c.require(createBarInsightFromCallTableDtoFieldTimeRange)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateBarInsightFromCallTableDto) SetGroupBy(groupBy *CreateBarInsightFromCallTableDtoGroupBy) {
	c.GroupBy = groupBy
	c.require(createBarInsightFromCallTableDtoFieldGroupBy)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateBarInsightFromCallTableDto) SetQueries(queries []*CreateBarInsightFromCallTableDtoQueriesItem) {
	c.Queries = queries
	c.require(createBarInsightFromCallTableDtoFieldQueries)
}

func (c *CreateBarInsightFromCallTableDto) UnmarshalJSON(data []byte) error {
	type embed CreateBarInsightFromCallTableDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateBarInsightFromCallTableDto(unmarshaler.embed)
	if unmarshaler.Type != "bar" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "bar", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBarInsightFromCallTableDto) MarshalJSON() ([]byte, error) {
	type embed CreateBarInsightFromCallTableDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "bar",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateBarInsightFromCallTableDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the group by column for the insight when table is `call`.
// These are the columns to group the results by.
// All results are grouped by the time range step by default.
type CreateBarInsightFromCallTableDtoGroupBy string

const (
	CreateBarInsightFromCallTableDtoGroupByAssistantId                       CreateBarInsightFromCallTableDtoGroupBy = "assistantId"
	CreateBarInsightFromCallTableDtoGroupByWorkflowId                        CreateBarInsightFromCallTableDtoGroupBy = "workflowId"
	CreateBarInsightFromCallTableDtoGroupBySquadId                           CreateBarInsightFromCallTableDtoGroupBy = "squadId"
	CreateBarInsightFromCallTableDtoGroupByPhoneNumberId                     CreateBarInsightFromCallTableDtoGroupBy = "phoneNumberId"
	CreateBarInsightFromCallTableDtoGroupByType                              CreateBarInsightFromCallTableDtoGroupBy = "type"
	CreateBarInsightFromCallTableDtoGroupByEndedReason                       CreateBarInsightFromCallTableDtoGroupBy = "endedReason"
	CreateBarInsightFromCallTableDtoGroupByCampaignId                        CreateBarInsightFromCallTableDtoGroupBy = "campaignId"
	CreateBarInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId CreateBarInsightFromCallTableDtoGroupBy = "artifact.structuredOutputs[OutputID]"
)

func NewCreateBarInsightFromCallTableDtoGroupByFromString(s string) (CreateBarInsightFromCallTableDtoGroupBy, error) {
	switch s {
	case "assistantId":
		return CreateBarInsightFromCallTableDtoGroupByAssistantId, nil
	case "workflowId":
		return CreateBarInsightFromCallTableDtoGroupByWorkflowId, nil
	case "squadId":
		return CreateBarInsightFromCallTableDtoGroupBySquadId, nil
	case "phoneNumberId":
		return CreateBarInsightFromCallTableDtoGroupByPhoneNumberId, nil
	case "type":
		return CreateBarInsightFromCallTableDtoGroupByType, nil
	case "endedReason":
		return CreateBarInsightFromCallTableDtoGroupByEndedReason, nil
	case "campaignId":
		return CreateBarInsightFromCallTableDtoGroupByCampaignId, nil
	case "artifact.structuredOutputs[OutputID]":
		return CreateBarInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId, nil
	}
	var t CreateBarInsightFromCallTableDtoGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateBarInsightFromCallTableDtoGroupBy) Ptr() *CreateBarInsightFromCallTableDtoGroupBy {
	return &c
}

type CreateBarInsightFromCallTableDtoQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (c *CreateBarInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithStringTypeColumn
}

func (c *CreateBarInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithNumberTypeColumn
}

func (c *CreateBarInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (c *CreateBarInsightFromCallTableDtoQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		c.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		c.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		c.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateBarInsightFromCallTableDtoQueriesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "JsonQueryOnCallTableWithStringTypeColumn" || c.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || c.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || c.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateBarInsightFromCallTableDtoQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (c *CreateBarInsightFromCallTableDtoQueriesItem) Accept(visitor CreateBarInsightFromCallTableDtoQueriesItemVisitor) error {
	if c.typ == "JsonQueryOnCallTableWithStringTypeColumn" || c.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(c.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || c.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(c.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || c.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(c.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

var (
	createLineInsightFromCallTableDtoFieldName      = big.NewInt(1 << 0)
	createLineInsightFromCallTableDtoFieldFormulas  = big.NewInt(1 << 1)
	createLineInsightFromCallTableDtoFieldMetadata  = big.NewInt(1 << 2)
	createLineInsightFromCallTableDtoFieldTimeRange = big.NewInt(1 << 3)
	createLineInsightFromCallTableDtoFieldGroupBy   = big.NewInt(1 << 4)
	createLineInsightFromCallTableDtoFieldQueries   = big.NewInt(1 << 5)
)

type CreateLineInsightFromCallTableDto struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formulas []*InsightFormula `json:"formulas,omitempty" url:"formulas,omitempty"`
	// This is the metadata for the insight.
	Metadata  *LineInsightMetadata      `json:"metadata,omitempty" url:"metadata,omitempty"`
	TimeRange *InsightTimeRangeWithStep `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the group by column for the insight when table is `call`.
	// These are the columns to group the results by.
	// All results are grouped by the time range step by default.
	GroupBy *CreateLineInsightFromCallTableDtoGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// These are the queries to run to generate the insight.
	Queries []*CreateLineInsightFromCallTableDtoQueriesItem `json:"queries" url:"queries"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLineInsightFromCallTableDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLineInsightFromCallTableDto) GetFormulas() []*InsightFormula {
	if c == nil {
		return nil
	}
	return c.Formulas
}

func (c *CreateLineInsightFromCallTableDto) GetMetadata() *LineInsightMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateLineInsightFromCallTableDto) GetTimeRange() *InsightTimeRangeWithStep {
	if c == nil {
		return nil
	}
	return c.TimeRange
}

func (c *CreateLineInsightFromCallTableDto) GetGroupBy() *CreateLineInsightFromCallTableDtoGroupBy {
	if c == nil {
		return nil
	}
	return c.GroupBy
}

func (c *CreateLineInsightFromCallTableDto) GetQueries() []*CreateLineInsightFromCallTableDtoQueriesItem {
	if c == nil {
		return nil
	}
	return c.Queries
}

func (c *CreateLineInsightFromCallTableDto) Type() string {
	return c.type_
}

func (c *CreateLineInsightFromCallTableDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLineInsightFromCallTableDto) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateLineInsightFromCallTableDto) SetName(name *string) {
	c.Name = name
	c.require(createLineInsightFromCallTableDtoFieldName)
}

// SetFormulas sets the Formulas field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateLineInsightFromCallTableDto) SetFormulas(formulas []*InsightFormula) {
	c.Formulas = formulas
	c.require(createLineInsightFromCallTableDtoFieldFormulas)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateLineInsightFromCallTableDto) SetMetadata(metadata *LineInsightMetadata) {
	c.Metadata = metadata
	c.require(createLineInsightFromCallTableDtoFieldMetadata)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateLineInsightFromCallTableDto) SetTimeRange(timeRange *InsightTimeRangeWithStep) {
	c.TimeRange = timeRange
	c.require(createLineInsightFromCallTableDtoFieldTimeRange)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateLineInsightFromCallTableDto) SetGroupBy(groupBy *CreateLineInsightFromCallTableDtoGroupBy) {
	c.GroupBy = groupBy
	c.require(createLineInsightFromCallTableDtoFieldGroupBy)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateLineInsightFromCallTableDto) SetQueries(queries []*CreateLineInsightFromCallTableDtoQueriesItem) {
	c.Queries = queries
	c.require(createLineInsightFromCallTableDtoFieldQueries)
}

func (c *CreateLineInsightFromCallTableDto) UnmarshalJSON(data []byte) error {
	type embed CreateLineInsightFromCallTableDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateLineInsightFromCallTableDto(unmarshaler.embed)
	if unmarshaler.Type != "line" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "line", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLineInsightFromCallTableDto) MarshalJSON() ([]byte, error) {
	type embed CreateLineInsightFromCallTableDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "line",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateLineInsightFromCallTableDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the group by column for the insight when table is `call`.
// These are the columns to group the results by.
// All results are grouped by the time range step by default.
type CreateLineInsightFromCallTableDtoGroupBy string

const (
	CreateLineInsightFromCallTableDtoGroupByAssistantId                       CreateLineInsightFromCallTableDtoGroupBy = "assistantId"
	CreateLineInsightFromCallTableDtoGroupByWorkflowId                        CreateLineInsightFromCallTableDtoGroupBy = "workflowId"
	CreateLineInsightFromCallTableDtoGroupBySquadId                           CreateLineInsightFromCallTableDtoGroupBy = "squadId"
	CreateLineInsightFromCallTableDtoGroupByPhoneNumberId                     CreateLineInsightFromCallTableDtoGroupBy = "phoneNumberId"
	CreateLineInsightFromCallTableDtoGroupByType                              CreateLineInsightFromCallTableDtoGroupBy = "type"
	CreateLineInsightFromCallTableDtoGroupByEndedReason                       CreateLineInsightFromCallTableDtoGroupBy = "endedReason"
	CreateLineInsightFromCallTableDtoGroupByCampaignId                        CreateLineInsightFromCallTableDtoGroupBy = "campaignId"
	CreateLineInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId CreateLineInsightFromCallTableDtoGroupBy = "artifact.structuredOutputs[OutputID]"
)

func NewCreateLineInsightFromCallTableDtoGroupByFromString(s string) (CreateLineInsightFromCallTableDtoGroupBy, error) {
	switch s {
	case "assistantId":
		return CreateLineInsightFromCallTableDtoGroupByAssistantId, nil
	case "workflowId":
		return CreateLineInsightFromCallTableDtoGroupByWorkflowId, nil
	case "squadId":
		return CreateLineInsightFromCallTableDtoGroupBySquadId, nil
	case "phoneNumberId":
		return CreateLineInsightFromCallTableDtoGroupByPhoneNumberId, nil
	case "type":
		return CreateLineInsightFromCallTableDtoGroupByType, nil
	case "endedReason":
		return CreateLineInsightFromCallTableDtoGroupByEndedReason, nil
	case "campaignId":
		return CreateLineInsightFromCallTableDtoGroupByCampaignId, nil
	case "artifact.structuredOutputs[OutputID]":
		return CreateLineInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId, nil
	}
	var t CreateLineInsightFromCallTableDtoGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateLineInsightFromCallTableDtoGroupBy) Ptr() *CreateLineInsightFromCallTableDtoGroupBy {
	return &c
}

type CreateLineInsightFromCallTableDtoQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (c *CreateLineInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithStringTypeColumn
}

func (c *CreateLineInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithNumberTypeColumn
}

func (c *CreateLineInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (c *CreateLineInsightFromCallTableDtoQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		c.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		c.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		c.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateLineInsightFromCallTableDtoQueriesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "JsonQueryOnCallTableWithStringTypeColumn" || c.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || c.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || c.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateLineInsightFromCallTableDtoQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (c *CreateLineInsightFromCallTableDtoQueriesItem) Accept(visitor CreateLineInsightFromCallTableDtoQueriesItemVisitor) error {
	if c.typ == "JsonQueryOnCallTableWithStringTypeColumn" || c.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(c.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || c.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(c.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || c.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(c.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

var (
	createPieInsightFromCallTableDtoFieldName      = big.NewInt(1 << 0)
	createPieInsightFromCallTableDtoFieldFormulas  = big.NewInt(1 << 1)
	createPieInsightFromCallTableDtoFieldTimeRange = big.NewInt(1 << 2)
	createPieInsightFromCallTableDtoFieldGroupBy   = big.NewInt(1 << 3)
	createPieInsightFromCallTableDtoFieldQueries   = big.NewInt(1 << 4)
)

type CreatePieInsightFromCallTableDto struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formulas  []*InsightFormula `json:"formulas,omitempty" url:"formulas,omitempty"`
	TimeRange *InsightTimeRange `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the group by column for the insight when table is `call`.
	// These are the columns to group the results by.
	// All results are grouped by the time range step by default.
	GroupBy *CreatePieInsightFromCallTableDtoGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// These are the queries to run to generate the insight.
	Queries []*CreatePieInsightFromCallTableDtoQueriesItem `json:"queries" url:"queries"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreatePieInsightFromCallTableDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreatePieInsightFromCallTableDto) GetFormulas() []*InsightFormula {
	if c == nil {
		return nil
	}
	return c.Formulas
}

func (c *CreatePieInsightFromCallTableDto) GetTimeRange() *InsightTimeRange {
	if c == nil {
		return nil
	}
	return c.TimeRange
}

func (c *CreatePieInsightFromCallTableDto) GetGroupBy() *CreatePieInsightFromCallTableDtoGroupBy {
	if c == nil {
		return nil
	}
	return c.GroupBy
}

func (c *CreatePieInsightFromCallTableDto) GetQueries() []*CreatePieInsightFromCallTableDtoQueriesItem {
	if c == nil {
		return nil
	}
	return c.Queries
}

func (c *CreatePieInsightFromCallTableDto) Type() string {
	return c.type_
}

func (c *CreatePieInsightFromCallTableDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePieInsightFromCallTableDto) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreatePieInsightFromCallTableDto) SetName(name *string) {
	c.Name = name
	c.require(createPieInsightFromCallTableDtoFieldName)
}

// SetFormulas sets the Formulas field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreatePieInsightFromCallTableDto) SetFormulas(formulas []*InsightFormula) {
	c.Formulas = formulas
	c.require(createPieInsightFromCallTableDtoFieldFormulas)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreatePieInsightFromCallTableDto) SetTimeRange(timeRange *InsightTimeRange) {
	c.TimeRange = timeRange
	c.require(createPieInsightFromCallTableDtoFieldTimeRange)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreatePieInsightFromCallTableDto) SetGroupBy(groupBy *CreatePieInsightFromCallTableDtoGroupBy) {
	c.GroupBy = groupBy
	c.require(createPieInsightFromCallTableDtoFieldGroupBy)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreatePieInsightFromCallTableDto) SetQueries(queries []*CreatePieInsightFromCallTableDtoQueriesItem) {
	c.Queries = queries
	c.require(createPieInsightFromCallTableDtoFieldQueries)
}

func (c *CreatePieInsightFromCallTableDto) UnmarshalJSON(data []byte) error {
	type embed CreatePieInsightFromCallTableDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreatePieInsightFromCallTableDto(unmarshaler.embed)
	if unmarshaler.Type != "pie" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "pie", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePieInsightFromCallTableDto) MarshalJSON() ([]byte, error) {
	type embed CreatePieInsightFromCallTableDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "pie",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreatePieInsightFromCallTableDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the group by column for the insight when table is `call`.
// These are the columns to group the results by.
// All results are grouped by the time range step by default.
type CreatePieInsightFromCallTableDtoGroupBy string

const (
	CreatePieInsightFromCallTableDtoGroupByAssistantId                       CreatePieInsightFromCallTableDtoGroupBy = "assistantId"
	CreatePieInsightFromCallTableDtoGroupByWorkflowId                        CreatePieInsightFromCallTableDtoGroupBy = "workflowId"
	CreatePieInsightFromCallTableDtoGroupBySquadId                           CreatePieInsightFromCallTableDtoGroupBy = "squadId"
	CreatePieInsightFromCallTableDtoGroupByPhoneNumberId                     CreatePieInsightFromCallTableDtoGroupBy = "phoneNumberId"
	CreatePieInsightFromCallTableDtoGroupByType                              CreatePieInsightFromCallTableDtoGroupBy = "type"
	CreatePieInsightFromCallTableDtoGroupByEndedReason                       CreatePieInsightFromCallTableDtoGroupBy = "endedReason"
	CreatePieInsightFromCallTableDtoGroupByCampaignId                        CreatePieInsightFromCallTableDtoGroupBy = "campaignId"
	CreatePieInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId CreatePieInsightFromCallTableDtoGroupBy = "artifact.structuredOutputs[OutputID]"
)

func NewCreatePieInsightFromCallTableDtoGroupByFromString(s string) (CreatePieInsightFromCallTableDtoGroupBy, error) {
	switch s {
	case "assistantId":
		return CreatePieInsightFromCallTableDtoGroupByAssistantId, nil
	case "workflowId":
		return CreatePieInsightFromCallTableDtoGroupByWorkflowId, nil
	case "squadId":
		return CreatePieInsightFromCallTableDtoGroupBySquadId, nil
	case "phoneNumberId":
		return CreatePieInsightFromCallTableDtoGroupByPhoneNumberId, nil
	case "type":
		return CreatePieInsightFromCallTableDtoGroupByType, nil
	case "endedReason":
		return CreatePieInsightFromCallTableDtoGroupByEndedReason, nil
	case "campaignId":
		return CreatePieInsightFromCallTableDtoGroupByCampaignId, nil
	case "artifact.structuredOutputs[OutputID]":
		return CreatePieInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId, nil
	}
	var t CreatePieInsightFromCallTableDtoGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreatePieInsightFromCallTableDtoGroupBy) Ptr() *CreatePieInsightFromCallTableDtoGroupBy {
	return &c
}

type CreatePieInsightFromCallTableDtoQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (c *CreatePieInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithStringTypeColumn
}

func (c *CreatePieInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithNumberTypeColumn
}

func (c *CreatePieInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (c *CreatePieInsightFromCallTableDtoQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		c.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		c.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		c.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreatePieInsightFromCallTableDtoQueriesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "JsonQueryOnCallTableWithStringTypeColumn" || c.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || c.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || c.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreatePieInsightFromCallTableDtoQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (c *CreatePieInsightFromCallTableDtoQueriesItem) Accept(visitor CreatePieInsightFromCallTableDtoQueriesItemVisitor) error {
	if c.typ == "JsonQueryOnCallTableWithStringTypeColumn" || c.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(c.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || c.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(c.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || c.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(c.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

var (
	createTextInsightFromCallTableDtoFieldName      = big.NewInt(1 << 0)
	createTextInsightFromCallTableDtoFieldFormula   = big.NewInt(1 << 1)
	createTextInsightFromCallTableDtoFieldTimeRange = big.NewInt(1 << 2)
	createTextInsightFromCallTableDtoFieldQueries   = big.NewInt(1 << 3)
)

type CreateTextInsightFromCallTableDto struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formula   map[string]interface{} `json:"formula,omitempty" url:"formula,omitempty"`
	TimeRange *InsightTimeRange      `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// These are the queries to run to generate the insight.
	// For Text Insights, we only allow a single query, or require a formula if multiple queries are provided
	Queries []*CreateTextInsightFromCallTableDtoQueriesItem `json:"queries" url:"queries"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTextInsightFromCallTableDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTextInsightFromCallTableDto) GetFormula() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Formula
}

func (c *CreateTextInsightFromCallTableDto) GetTimeRange() *InsightTimeRange {
	if c == nil {
		return nil
	}
	return c.TimeRange
}

func (c *CreateTextInsightFromCallTableDto) GetQueries() []*CreateTextInsightFromCallTableDtoQueriesItem {
	if c == nil {
		return nil
	}
	return c.Queries
}

func (c *CreateTextInsightFromCallTableDto) Type() string {
	return c.type_
}

func (c *CreateTextInsightFromCallTableDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTextInsightFromCallTableDto) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTextInsightFromCallTableDto) SetName(name *string) {
	c.Name = name
	c.require(createTextInsightFromCallTableDtoFieldName)
}

// SetFormula sets the Formula field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTextInsightFromCallTableDto) SetFormula(formula map[string]interface{}) {
	c.Formula = formula
	c.require(createTextInsightFromCallTableDtoFieldFormula)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTextInsightFromCallTableDto) SetTimeRange(timeRange *InsightTimeRange) {
	c.TimeRange = timeRange
	c.require(createTextInsightFromCallTableDtoFieldTimeRange)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTextInsightFromCallTableDto) SetQueries(queries []*CreateTextInsightFromCallTableDtoQueriesItem) {
	c.Queries = queries
	c.require(createTextInsightFromCallTableDtoFieldQueries)
}

func (c *CreateTextInsightFromCallTableDto) UnmarshalJSON(data []byte) error {
	type embed CreateTextInsightFromCallTableDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTextInsightFromCallTableDto(unmarshaler.embed)
	if unmarshaler.Type != "text" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "text", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTextInsightFromCallTableDto) MarshalJSON() ([]byte, error) {
	type embed CreateTextInsightFromCallTableDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "text",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateTextInsightFromCallTableDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTextInsightFromCallTableDtoQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (c *CreateTextInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithStringTypeColumn
}

func (c *CreateTextInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithNumberTypeColumn
}

func (c *CreateTextInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if c == nil {
		return nil
	}
	return c.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (c *CreateTextInsightFromCallTableDtoQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		c.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		c.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		c.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		c.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTextInsightFromCallTableDtoQueriesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "JsonQueryOnCallTableWithStringTypeColumn" || c.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || c.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || c.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(c.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTextInsightFromCallTableDtoQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (c *CreateTextInsightFromCallTableDtoQueriesItem) Accept(visitor CreateTextInsightFromCallTableDtoQueriesItemVisitor) error {
	if c.typ == "JsonQueryOnCallTableWithStringTypeColumn" || c.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(c.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || c.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(c.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if c.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || c.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(c.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

var (
	filterDateTypeColumnOnCallTableFieldColumn   = big.NewInt(1 << 0)
	filterDateTypeColumnOnCallTableFieldOperator = big.NewInt(1 << 1)
	filterDateTypeColumnOnCallTableFieldValue    = big.NewInt(1 << 2)
)

type FilterDateTypeColumnOnCallTable struct {
	// This is the column in the call table that will be filtered on.
	// Date Type columns are columns where the rows store data as a date.
	// Must be a valid column for the selected table.
	Column FilterDateTypeColumnOnCallTableColumn `json:"column" url:"column"`
	// This is the operator to use for the filter.
	// For date type columns, the operator must be "=", ">", "<", ">=", "<="
	Operator FilterDateTypeColumnOnCallTableOperator `json:"operator" url:"operator"`
	// This is the value to filter on.
	// Must be a valid ISO 8601 date-time string.
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FilterDateTypeColumnOnCallTable) GetColumn() FilterDateTypeColumnOnCallTableColumn {
	if f == nil {
		return ""
	}
	return f.Column
}

func (f *FilterDateTypeColumnOnCallTable) GetOperator() FilterDateTypeColumnOnCallTableOperator {
	if f == nil {
		return ""
	}
	return f.Operator
}

func (f *FilterDateTypeColumnOnCallTable) GetValue() string {
	if f == nil {
		return ""
	}
	return f.Value
}

func (f *FilterDateTypeColumnOnCallTable) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilterDateTypeColumnOnCallTable) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetColumn sets the Column field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterDateTypeColumnOnCallTable) SetColumn(column FilterDateTypeColumnOnCallTableColumn) {
	f.Column = column
	f.require(filterDateTypeColumnOnCallTableFieldColumn)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterDateTypeColumnOnCallTable) SetOperator(operator FilterDateTypeColumnOnCallTableOperator) {
	f.Operator = operator
	f.require(filterDateTypeColumnOnCallTableFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterDateTypeColumnOnCallTable) SetValue(value string) {
	f.Value = value
	f.require(filterDateTypeColumnOnCallTableFieldValue)
}

func (f *FilterDateTypeColumnOnCallTable) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterDateTypeColumnOnCallTable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterDateTypeColumnOnCallTable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilterDateTypeColumnOnCallTable) MarshalJSON() ([]byte, error) {
	type embed FilterDateTypeColumnOnCallTable
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FilterDateTypeColumnOnCallTable) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the column in the call table that will be filtered on.
// Date Type columns are columns where the rows store data as a date.
// Must be a valid column for the selected table.
type FilterDateTypeColumnOnCallTableColumn string

const (
	FilterDateTypeColumnOnCallTableColumnStartedAt FilterDateTypeColumnOnCallTableColumn = "startedAt"
	FilterDateTypeColumnOnCallTableColumnEndedAt   FilterDateTypeColumnOnCallTableColumn = "endedAt"
)

func NewFilterDateTypeColumnOnCallTableColumnFromString(s string) (FilterDateTypeColumnOnCallTableColumn, error) {
	switch s {
	case "startedAt":
		return FilterDateTypeColumnOnCallTableColumnStartedAt, nil
	case "endedAt":
		return FilterDateTypeColumnOnCallTableColumnEndedAt, nil
	}
	var t FilterDateTypeColumnOnCallTableColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterDateTypeColumnOnCallTableColumn) Ptr() *FilterDateTypeColumnOnCallTableColumn {
	return &f
}

// This is the operator to use for the filter.
// For date type columns, the operator must be "=", ">", "<", ">=", "<="
type FilterDateTypeColumnOnCallTableOperator string

const (
	FilterDateTypeColumnOnCallTableOperatorEqualTo              FilterDateTypeColumnOnCallTableOperator = "="
	FilterDateTypeColumnOnCallTableOperatorNotEquals            FilterDateTypeColumnOnCallTableOperator = "!="
	FilterDateTypeColumnOnCallTableOperatorGreaterThan          FilterDateTypeColumnOnCallTableOperator = ">"
	FilterDateTypeColumnOnCallTableOperatorLessThan             FilterDateTypeColumnOnCallTableOperator = "<"
	FilterDateTypeColumnOnCallTableOperatorGreaterThanOrEqualTo FilterDateTypeColumnOnCallTableOperator = ">="
	FilterDateTypeColumnOnCallTableOperatorLessThanOrEqualTo    FilterDateTypeColumnOnCallTableOperator = "<="
)

func NewFilterDateTypeColumnOnCallTableOperatorFromString(s string) (FilterDateTypeColumnOnCallTableOperator, error) {
	switch s {
	case "=":
		return FilterDateTypeColumnOnCallTableOperatorEqualTo, nil
	case "!=":
		return FilterDateTypeColumnOnCallTableOperatorNotEquals, nil
	case ">":
		return FilterDateTypeColumnOnCallTableOperatorGreaterThan, nil
	case "<":
		return FilterDateTypeColumnOnCallTableOperatorLessThan, nil
	case ">=":
		return FilterDateTypeColumnOnCallTableOperatorGreaterThanOrEqualTo, nil
	case "<=":
		return FilterDateTypeColumnOnCallTableOperatorLessThanOrEqualTo, nil
	}
	var t FilterDateTypeColumnOnCallTableOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterDateTypeColumnOnCallTableOperator) Ptr() *FilterDateTypeColumnOnCallTableOperator {
	return &f
}

var (
	filterNumberArrayTypeColumnOnCallTableFieldColumn   = big.NewInt(1 << 0)
	filterNumberArrayTypeColumnOnCallTableFieldOperator = big.NewInt(1 << 1)
	filterNumberArrayTypeColumnOnCallTableFieldValue    = big.NewInt(1 << 2)
)

type FilterNumberArrayTypeColumnOnCallTable struct {
	// This is the column in the call table that will be filtered on.
	// Number Array Type columns are the same as Number Type columns, but provides the ability to filter on multiple values provided as an array.
	// Must be a valid column for the selected table.
	Column FilterNumberArrayTypeColumnOnCallTableColumn `json:"column" url:"column"`
	// This is the operator to use for the filter.
	// The operator must be `in` or `not_in`.
	Operator FilterNumberArrayTypeColumnOnCallTableOperator `json:"operator" url:"operator"`
	// This is the value to filter on.
	Value []float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FilterNumberArrayTypeColumnOnCallTable) GetColumn() FilterNumberArrayTypeColumnOnCallTableColumn {
	if f == nil {
		return ""
	}
	return f.Column
}

func (f *FilterNumberArrayTypeColumnOnCallTable) GetOperator() FilterNumberArrayTypeColumnOnCallTableOperator {
	if f == nil {
		return ""
	}
	return f.Operator
}

func (f *FilterNumberArrayTypeColumnOnCallTable) GetValue() []float64 {
	if f == nil {
		return nil
	}
	return f.Value
}

func (f *FilterNumberArrayTypeColumnOnCallTable) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilterNumberArrayTypeColumnOnCallTable) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetColumn sets the Column field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterNumberArrayTypeColumnOnCallTable) SetColumn(column FilterNumberArrayTypeColumnOnCallTableColumn) {
	f.Column = column
	f.require(filterNumberArrayTypeColumnOnCallTableFieldColumn)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterNumberArrayTypeColumnOnCallTable) SetOperator(operator FilterNumberArrayTypeColumnOnCallTableOperator) {
	f.Operator = operator
	f.require(filterNumberArrayTypeColumnOnCallTableFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterNumberArrayTypeColumnOnCallTable) SetValue(value []float64) {
	f.Value = value
	f.require(filterNumberArrayTypeColumnOnCallTableFieldValue)
}

func (f *FilterNumberArrayTypeColumnOnCallTable) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterNumberArrayTypeColumnOnCallTable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterNumberArrayTypeColumnOnCallTable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilterNumberArrayTypeColumnOnCallTable) MarshalJSON() ([]byte, error) {
	type embed FilterNumberArrayTypeColumnOnCallTable
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FilterNumberArrayTypeColumnOnCallTable) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the column in the call table that will be filtered on.
// Number Array Type columns are the same as Number Type columns, but provides the ability to filter on multiple values provided as an array.
// Must be a valid column for the selected table.
type FilterNumberArrayTypeColumnOnCallTableColumn string

const (
	FilterNumberArrayTypeColumnOnCallTableColumnDuration                  FilterNumberArrayTypeColumnOnCallTableColumn = "duration"
	FilterNumberArrayTypeColumnOnCallTableColumnCost                      FilterNumberArrayTypeColumnOnCallTableColumn = "cost"
	FilterNumberArrayTypeColumnOnCallTableColumnAverageModelLatency       FilterNumberArrayTypeColumnOnCallTableColumn = "averageModelLatency"
	FilterNumberArrayTypeColumnOnCallTableColumnAverageVoiceLatency       FilterNumberArrayTypeColumnOnCallTableColumn = "averageVoiceLatency"
	FilterNumberArrayTypeColumnOnCallTableColumnAverageTranscriberLatency FilterNumberArrayTypeColumnOnCallTableColumn = "averageTranscriberLatency"
	FilterNumberArrayTypeColumnOnCallTableColumnAverageTurnLatency        FilterNumberArrayTypeColumnOnCallTableColumn = "averageTurnLatency"
	FilterNumberArrayTypeColumnOnCallTableColumnAverageEndpointingLatency FilterNumberArrayTypeColumnOnCallTableColumn = "averageEndpointingLatency"
)

func NewFilterNumberArrayTypeColumnOnCallTableColumnFromString(s string) (FilterNumberArrayTypeColumnOnCallTableColumn, error) {
	switch s {
	case "duration":
		return FilterNumberArrayTypeColumnOnCallTableColumnDuration, nil
	case "cost":
		return FilterNumberArrayTypeColumnOnCallTableColumnCost, nil
	case "averageModelLatency":
		return FilterNumberArrayTypeColumnOnCallTableColumnAverageModelLatency, nil
	case "averageVoiceLatency":
		return FilterNumberArrayTypeColumnOnCallTableColumnAverageVoiceLatency, nil
	case "averageTranscriberLatency":
		return FilterNumberArrayTypeColumnOnCallTableColumnAverageTranscriberLatency, nil
	case "averageTurnLatency":
		return FilterNumberArrayTypeColumnOnCallTableColumnAverageTurnLatency, nil
	case "averageEndpointingLatency":
		return FilterNumberArrayTypeColumnOnCallTableColumnAverageEndpointingLatency, nil
	}
	var t FilterNumberArrayTypeColumnOnCallTableColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterNumberArrayTypeColumnOnCallTableColumn) Ptr() *FilterNumberArrayTypeColumnOnCallTableColumn {
	return &f
}

// This is the operator to use for the filter.
// The operator must be `in` or `not_in`.
type FilterNumberArrayTypeColumnOnCallTableOperator string

const (
	FilterNumberArrayTypeColumnOnCallTableOperatorIn    FilterNumberArrayTypeColumnOnCallTableOperator = "in"
	FilterNumberArrayTypeColumnOnCallTableOperatorNotIn FilterNumberArrayTypeColumnOnCallTableOperator = "not_in"
)

func NewFilterNumberArrayTypeColumnOnCallTableOperatorFromString(s string) (FilterNumberArrayTypeColumnOnCallTableOperator, error) {
	switch s {
	case "in":
		return FilterNumberArrayTypeColumnOnCallTableOperatorIn, nil
	case "not_in":
		return FilterNumberArrayTypeColumnOnCallTableOperatorNotIn, nil
	}
	var t FilterNumberArrayTypeColumnOnCallTableOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterNumberArrayTypeColumnOnCallTableOperator) Ptr() *FilterNumberArrayTypeColumnOnCallTableOperator {
	return &f
}

var (
	filterNumberTypeColumnOnCallTableFieldColumn   = big.NewInt(1 << 0)
	filterNumberTypeColumnOnCallTableFieldOperator = big.NewInt(1 << 1)
	filterNumberTypeColumnOnCallTableFieldValue    = big.NewInt(1 << 2)
)

type FilterNumberTypeColumnOnCallTable struct {
	// This is the column in the call table that will be filtered on.
	// Number Type columns are columns where the rows store data as a number.
	// Must be a valid column for the selected table.
	Column FilterNumberTypeColumnOnCallTableColumn `json:"column" url:"column"`
	// This is the operator to use for the filter.
	// For number type columns, the operator must be "=", ">", "<", ">=", "<="
	Operator FilterNumberTypeColumnOnCallTableOperator `json:"operator" url:"operator"`
	// This is the value to filter on.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FilterNumberTypeColumnOnCallTable) GetColumn() FilterNumberTypeColumnOnCallTableColumn {
	if f == nil {
		return ""
	}
	return f.Column
}

func (f *FilterNumberTypeColumnOnCallTable) GetOperator() FilterNumberTypeColumnOnCallTableOperator {
	if f == nil {
		return ""
	}
	return f.Operator
}

func (f *FilterNumberTypeColumnOnCallTable) GetValue() float64 {
	if f == nil {
		return 0
	}
	return f.Value
}

func (f *FilterNumberTypeColumnOnCallTable) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilterNumberTypeColumnOnCallTable) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetColumn sets the Column field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterNumberTypeColumnOnCallTable) SetColumn(column FilterNumberTypeColumnOnCallTableColumn) {
	f.Column = column
	f.require(filterNumberTypeColumnOnCallTableFieldColumn)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterNumberTypeColumnOnCallTable) SetOperator(operator FilterNumberTypeColumnOnCallTableOperator) {
	f.Operator = operator
	f.require(filterNumberTypeColumnOnCallTableFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterNumberTypeColumnOnCallTable) SetValue(value float64) {
	f.Value = value
	f.require(filterNumberTypeColumnOnCallTableFieldValue)
}

func (f *FilterNumberTypeColumnOnCallTable) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterNumberTypeColumnOnCallTable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterNumberTypeColumnOnCallTable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilterNumberTypeColumnOnCallTable) MarshalJSON() ([]byte, error) {
	type embed FilterNumberTypeColumnOnCallTable
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FilterNumberTypeColumnOnCallTable) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the column in the call table that will be filtered on.
// Number Type columns are columns where the rows store data as a number.
// Must be a valid column for the selected table.
type FilterNumberTypeColumnOnCallTableColumn string

const (
	FilterNumberTypeColumnOnCallTableColumnDuration                  FilterNumberTypeColumnOnCallTableColumn = "duration"
	FilterNumberTypeColumnOnCallTableColumnCost                      FilterNumberTypeColumnOnCallTableColumn = "cost"
	FilterNumberTypeColumnOnCallTableColumnAverageModelLatency       FilterNumberTypeColumnOnCallTableColumn = "averageModelLatency"
	FilterNumberTypeColumnOnCallTableColumnAverageVoiceLatency       FilterNumberTypeColumnOnCallTableColumn = "averageVoiceLatency"
	FilterNumberTypeColumnOnCallTableColumnAverageTranscriberLatency FilterNumberTypeColumnOnCallTableColumn = "averageTranscriberLatency"
	FilterNumberTypeColumnOnCallTableColumnAverageTurnLatency        FilterNumberTypeColumnOnCallTableColumn = "averageTurnLatency"
	FilterNumberTypeColumnOnCallTableColumnAverageEndpointingLatency FilterNumberTypeColumnOnCallTableColumn = "averageEndpointingLatency"
)

func NewFilterNumberTypeColumnOnCallTableColumnFromString(s string) (FilterNumberTypeColumnOnCallTableColumn, error) {
	switch s {
	case "duration":
		return FilterNumberTypeColumnOnCallTableColumnDuration, nil
	case "cost":
		return FilterNumberTypeColumnOnCallTableColumnCost, nil
	case "averageModelLatency":
		return FilterNumberTypeColumnOnCallTableColumnAverageModelLatency, nil
	case "averageVoiceLatency":
		return FilterNumberTypeColumnOnCallTableColumnAverageVoiceLatency, nil
	case "averageTranscriberLatency":
		return FilterNumberTypeColumnOnCallTableColumnAverageTranscriberLatency, nil
	case "averageTurnLatency":
		return FilterNumberTypeColumnOnCallTableColumnAverageTurnLatency, nil
	case "averageEndpointingLatency":
		return FilterNumberTypeColumnOnCallTableColumnAverageEndpointingLatency, nil
	}
	var t FilterNumberTypeColumnOnCallTableColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterNumberTypeColumnOnCallTableColumn) Ptr() *FilterNumberTypeColumnOnCallTableColumn {
	return &f
}

// This is the operator to use for the filter.
// For number type columns, the operator must be "=", ">", "<", ">=", "<="
type FilterNumberTypeColumnOnCallTableOperator string

const (
	FilterNumberTypeColumnOnCallTableOperatorEqualTo              FilterNumberTypeColumnOnCallTableOperator = "="
	FilterNumberTypeColumnOnCallTableOperatorNotEquals            FilterNumberTypeColumnOnCallTableOperator = "!="
	FilterNumberTypeColumnOnCallTableOperatorGreaterThan          FilterNumberTypeColumnOnCallTableOperator = ">"
	FilterNumberTypeColumnOnCallTableOperatorLessThan             FilterNumberTypeColumnOnCallTableOperator = "<"
	FilterNumberTypeColumnOnCallTableOperatorGreaterThanOrEqualTo FilterNumberTypeColumnOnCallTableOperator = ">="
	FilterNumberTypeColumnOnCallTableOperatorLessThanOrEqualTo    FilterNumberTypeColumnOnCallTableOperator = "<="
)

func NewFilterNumberTypeColumnOnCallTableOperatorFromString(s string) (FilterNumberTypeColumnOnCallTableOperator, error) {
	switch s {
	case "=":
		return FilterNumberTypeColumnOnCallTableOperatorEqualTo, nil
	case "!=":
		return FilterNumberTypeColumnOnCallTableOperatorNotEquals, nil
	case ">":
		return FilterNumberTypeColumnOnCallTableOperatorGreaterThan, nil
	case "<":
		return FilterNumberTypeColumnOnCallTableOperatorLessThan, nil
	case ">=":
		return FilterNumberTypeColumnOnCallTableOperatorGreaterThanOrEqualTo, nil
	case "<=":
		return FilterNumberTypeColumnOnCallTableOperatorLessThanOrEqualTo, nil
	}
	var t FilterNumberTypeColumnOnCallTableOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterNumberTypeColumnOnCallTableOperator) Ptr() *FilterNumberTypeColumnOnCallTableOperator {
	return &f
}

var (
	filterStringArrayTypeColumnOnCallTableFieldColumn   = big.NewInt(1 << 0)
	filterStringArrayTypeColumnOnCallTableFieldOperator = big.NewInt(1 << 1)
	filterStringArrayTypeColumnOnCallTableFieldValue    = big.NewInt(1 << 2)
)

type FilterStringArrayTypeColumnOnCallTable struct {
	// This is the column in the call table that will be filtered on.
	// String Array Type columns are the same as String Type columns, but provides the ability to filter on multiple values provided as an array.
	// Must be a valid column for the selected table.
	Column FilterStringArrayTypeColumnOnCallTableColumn `json:"column" url:"column"`
	// This is the operator to use for the filter.
	// The operator must be `in` or `not_in`.
	Operator FilterStringArrayTypeColumnOnCallTableOperator `json:"operator" url:"operator"`
	// These are the values to filter on.
	Value []string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FilterStringArrayTypeColumnOnCallTable) GetColumn() FilterStringArrayTypeColumnOnCallTableColumn {
	if f == nil {
		return ""
	}
	return f.Column
}

func (f *FilterStringArrayTypeColumnOnCallTable) GetOperator() FilterStringArrayTypeColumnOnCallTableOperator {
	if f == nil {
		return ""
	}
	return f.Operator
}

func (f *FilterStringArrayTypeColumnOnCallTable) GetValue() []string {
	if f == nil {
		return nil
	}
	return f.Value
}

func (f *FilterStringArrayTypeColumnOnCallTable) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilterStringArrayTypeColumnOnCallTable) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetColumn sets the Column field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterStringArrayTypeColumnOnCallTable) SetColumn(column FilterStringArrayTypeColumnOnCallTableColumn) {
	f.Column = column
	f.require(filterStringArrayTypeColumnOnCallTableFieldColumn)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterStringArrayTypeColumnOnCallTable) SetOperator(operator FilterStringArrayTypeColumnOnCallTableOperator) {
	f.Operator = operator
	f.require(filterStringArrayTypeColumnOnCallTableFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterStringArrayTypeColumnOnCallTable) SetValue(value []string) {
	f.Value = value
	f.require(filterStringArrayTypeColumnOnCallTableFieldValue)
}

func (f *FilterStringArrayTypeColumnOnCallTable) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterStringArrayTypeColumnOnCallTable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterStringArrayTypeColumnOnCallTable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilterStringArrayTypeColumnOnCallTable) MarshalJSON() ([]byte, error) {
	type embed FilterStringArrayTypeColumnOnCallTable
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FilterStringArrayTypeColumnOnCallTable) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the column in the call table that will be filtered on.
// String Array Type columns are the same as String Type columns, but provides the ability to filter on multiple values provided as an array.
// Must be a valid column for the selected table.
type FilterStringArrayTypeColumnOnCallTableColumn string

const (
	FilterStringArrayTypeColumnOnCallTableColumnAssistantId          FilterStringArrayTypeColumnOnCallTableColumn = "assistantId"
	FilterStringArrayTypeColumnOnCallTableColumnWorkflowId           FilterStringArrayTypeColumnOnCallTableColumn = "workflowId"
	FilterStringArrayTypeColumnOnCallTableColumnSquadId              FilterStringArrayTypeColumnOnCallTableColumn = "squadId"
	FilterStringArrayTypeColumnOnCallTableColumnPhoneNumberId        FilterStringArrayTypeColumnOnCallTableColumn = "phoneNumberId"
	FilterStringArrayTypeColumnOnCallTableColumnType                 FilterStringArrayTypeColumnOnCallTableColumn = "type"
	FilterStringArrayTypeColumnOnCallTableColumnCustomerNumber       FilterStringArrayTypeColumnOnCallTableColumn = "customerNumber"
	FilterStringArrayTypeColumnOnCallTableColumnStatus               FilterStringArrayTypeColumnOnCallTableColumn = "status"
	FilterStringArrayTypeColumnOnCallTableColumnEndedReason          FilterStringArrayTypeColumnOnCallTableColumn = "endedReason"
	FilterStringArrayTypeColumnOnCallTableColumnForwardedPhoneNumber FilterStringArrayTypeColumnOnCallTableColumn = "forwardedPhoneNumber"
	FilterStringArrayTypeColumnOnCallTableColumnCampaignId           FilterStringArrayTypeColumnOnCallTableColumn = "campaignId"
)

func NewFilterStringArrayTypeColumnOnCallTableColumnFromString(s string) (FilterStringArrayTypeColumnOnCallTableColumn, error) {
	switch s {
	case "assistantId":
		return FilterStringArrayTypeColumnOnCallTableColumnAssistantId, nil
	case "workflowId":
		return FilterStringArrayTypeColumnOnCallTableColumnWorkflowId, nil
	case "squadId":
		return FilterStringArrayTypeColumnOnCallTableColumnSquadId, nil
	case "phoneNumberId":
		return FilterStringArrayTypeColumnOnCallTableColumnPhoneNumberId, nil
	case "type":
		return FilterStringArrayTypeColumnOnCallTableColumnType, nil
	case "customerNumber":
		return FilterStringArrayTypeColumnOnCallTableColumnCustomerNumber, nil
	case "status":
		return FilterStringArrayTypeColumnOnCallTableColumnStatus, nil
	case "endedReason":
		return FilterStringArrayTypeColumnOnCallTableColumnEndedReason, nil
	case "forwardedPhoneNumber":
		return FilterStringArrayTypeColumnOnCallTableColumnForwardedPhoneNumber, nil
	case "campaignId":
		return FilterStringArrayTypeColumnOnCallTableColumnCampaignId, nil
	}
	var t FilterStringArrayTypeColumnOnCallTableColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterStringArrayTypeColumnOnCallTableColumn) Ptr() *FilterStringArrayTypeColumnOnCallTableColumn {
	return &f
}

// This is the operator to use for the filter.
// The operator must be `in` or `not_in`.
type FilterStringArrayTypeColumnOnCallTableOperator string

const (
	FilterStringArrayTypeColumnOnCallTableOperatorIn    FilterStringArrayTypeColumnOnCallTableOperator = "in"
	FilterStringArrayTypeColumnOnCallTableOperatorNotIn FilterStringArrayTypeColumnOnCallTableOperator = "not_in"
)

func NewFilterStringArrayTypeColumnOnCallTableOperatorFromString(s string) (FilterStringArrayTypeColumnOnCallTableOperator, error) {
	switch s {
	case "in":
		return FilterStringArrayTypeColumnOnCallTableOperatorIn, nil
	case "not_in":
		return FilterStringArrayTypeColumnOnCallTableOperatorNotIn, nil
	}
	var t FilterStringArrayTypeColumnOnCallTableOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterStringArrayTypeColumnOnCallTableOperator) Ptr() *FilterStringArrayTypeColumnOnCallTableOperator {
	return &f
}

var (
	filterStringTypeColumnOnCallTableFieldColumn   = big.NewInt(1 << 0)
	filterStringTypeColumnOnCallTableFieldOperator = big.NewInt(1 << 1)
	filterStringTypeColumnOnCallTableFieldValue    = big.NewInt(1 << 2)
)

type FilterStringTypeColumnOnCallTable struct {
	// This is the column in the call table that will be filtered on.
	// String Type columns are columns where the rows store data as a string.
	// Must be a valid column for the selected table.
	Column FilterStringTypeColumnOnCallTableColumn `json:"column" url:"column"`
	// This is the operator to use for the filter.
	// For string type columns, the operator must be "=", "!=", "contains", "not contains"
	Operator FilterStringTypeColumnOnCallTableOperator `json:"operator" url:"operator"`
	// This is the value to filter on.
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FilterStringTypeColumnOnCallTable) GetColumn() FilterStringTypeColumnOnCallTableColumn {
	if f == nil {
		return ""
	}
	return f.Column
}

func (f *FilterStringTypeColumnOnCallTable) GetOperator() FilterStringTypeColumnOnCallTableOperator {
	if f == nil {
		return ""
	}
	return f.Operator
}

func (f *FilterStringTypeColumnOnCallTable) GetValue() string {
	if f == nil {
		return ""
	}
	return f.Value
}

func (f *FilterStringTypeColumnOnCallTable) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilterStringTypeColumnOnCallTable) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetColumn sets the Column field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterStringTypeColumnOnCallTable) SetColumn(column FilterStringTypeColumnOnCallTableColumn) {
	f.Column = column
	f.require(filterStringTypeColumnOnCallTableFieldColumn)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterStringTypeColumnOnCallTable) SetOperator(operator FilterStringTypeColumnOnCallTableOperator) {
	f.Operator = operator
	f.require(filterStringTypeColumnOnCallTableFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterStringTypeColumnOnCallTable) SetValue(value string) {
	f.Value = value
	f.require(filterStringTypeColumnOnCallTableFieldValue)
}

func (f *FilterStringTypeColumnOnCallTable) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterStringTypeColumnOnCallTable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterStringTypeColumnOnCallTable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilterStringTypeColumnOnCallTable) MarshalJSON() ([]byte, error) {
	type embed FilterStringTypeColumnOnCallTable
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FilterStringTypeColumnOnCallTable) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the column in the call table that will be filtered on.
// String Type columns are columns where the rows store data as a string.
// Must be a valid column for the selected table.
type FilterStringTypeColumnOnCallTableColumn string

const (
	FilterStringTypeColumnOnCallTableColumnAssistantId          FilterStringTypeColumnOnCallTableColumn = "assistantId"
	FilterStringTypeColumnOnCallTableColumnWorkflowId           FilterStringTypeColumnOnCallTableColumn = "workflowId"
	FilterStringTypeColumnOnCallTableColumnSquadId              FilterStringTypeColumnOnCallTableColumn = "squadId"
	FilterStringTypeColumnOnCallTableColumnPhoneNumberId        FilterStringTypeColumnOnCallTableColumn = "phoneNumberId"
	FilterStringTypeColumnOnCallTableColumnType                 FilterStringTypeColumnOnCallTableColumn = "type"
	FilterStringTypeColumnOnCallTableColumnCustomerNumber       FilterStringTypeColumnOnCallTableColumn = "customerNumber"
	FilterStringTypeColumnOnCallTableColumnStatus               FilterStringTypeColumnOnCallTableColumn = "status"
	FilterStringTypeColumnOnCallTableColumnEndedReason          FilterStringTypeColumnOnCallTableColumn = "endedReason"
	FilterStringTypeColumnOnCallTableColumnForwardedPhoneNumber FilterStringTypeColumnOnCallTableColumn = "forwardedPhoneNumber"
	FilterStringTypeColumnOnCallTableColumnCampaignId           FilterStringTypeColumnOnCallTableColumn = "campaignId"
)

func NewFilterStringTypeColumnOnCallTableColumnFromString(s string) (FilterStringTypeColumnOnCallTableColumn, error) {
	switch s {
	case "assistantId":
		return FilterStringTypeColumnOnCallTableColumnAssistantId, nil
	case "workflowId":
		return FilterStringTypeColumnOnCallTableColumnWorkflowId, nil
	case "squadId":
		return FilterStringTypeColumnOnCallTableColumnSquadId, nil
	case "phoneNumberId":
		return FilterStringTypeColumnOnCallTableColumnPhoneNumberId, nil
	case "type":
		return FilterStringTypeColumnOnCallTableColumnType, nil
	case "customerNumber":
		return FilterStringTypeColumnOnCallTableColumnCustomerNumber, nil
	case "status":
		return FilterStringTypeColumnOnCallTableColumnStatus, nil
	case "endedReason":
		return FilterStringTypeColumnOnCallTableColumnEndedReason, nil
	case "forwardedPhoneNumber":
		return FilterStringTypeColumnOnCallTableColumnForwardedPhoneNumber, nil
	case "campaignId":
		return FilterStringTypeColumnOnCallTableColumnCampaignId, nil
	}
	var t FilterStringTypeColumnOnCallTableColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterStringTypeColumnOnCallTableColumn) Ptr() *FilterStringTypeColumnOnCallTableColumn {
	return &f
}

// This is the operator to use for the filter.
// For string type columns, the operator must be "=", "!=", "contains", "not contains"
type FilterStringTypeColumnOnCallTableOperator string

const (
	FilterStringTypeColumnOnCallTableOperatorEqualTo     FilterStringTypeColumnOnCallTableOperator = "="
	FilterStringTypeColumnOnCallTableOperatorNotEquals   FilterStringTypeColumnOnCallTableOperator = "!="
	FilterStringTypeColumnOnCallTableOperatorContains    FilterStringTypeColumnOnCallTableOperator = "contains"
	FilterStringTypeColumnOnCallTableOperatorNotContains FilterStringTypeColumnOnCallTableOperator = "not_contains"
)

func NewFilterStringTypeColumnOnCallTableOperatorFromString(s string) (FilterStringTypeColumnOnCallTableOperator, error) {
	switch s {
	case "=":
		return FilterStringTypeColumnOnCallTableOperatorEqualTo, nil
	case "!=":
		return FilterStringTypeColumnOnCallTableOperatorNotEquals, nil
	case "contains":
		return FilterStringTypeColumnOnCallTableOperatorContains, nil
	case "not_contains":
		return FilterStringTypeColumnOnCallTableOperatorNotContains, nil
	}
	var t FilterStringTypeColumnOnCallTableOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterStringTypeColumnOnCallTableOperator) Ptr() *FilterStringTypeColumnOnCallTableOperator {
	return &f
}

var (
	filterStructuredOutputColumnOnCallTableFieldColumn   = big.NewInt(1 << 0)
	filterStructuredOutputColumnOnCallTableFieldOperator = big.NewInt(1 << 1)
	filterStructuredOutputColumnOnCallTableFieldValue    = big.NewInt(1 << 2)
)

type FilterStructuredOutputColumnOnCallTable struct {
	// This is the column in the call table that will be filtered on.
	// Structured Output Type columns are only to filter on artifact.structuredOutputs[OutputID] column.
	Column FilterStructuredOutputColumnOnCallTableColumn `json:"column" url:"column"`
	// This is the operator to use for the filter.
	// The operator depends on the value type of the structured output.
	// If the structured output is a string or boolean, the operator must be "=", "!="
	// If the structured output is a number, the operator must be "=", ">", "<", ">=", "<="
	// If the structured output is an array, the operator must be "in" or "not_in"
	Operator FilterStructuredOutputColumnOnCallTableOperator `json:"operator" url:"operator"`
	// This is the value to filter on.
	// The value type depends on the structured output type being filtered.
	Value map[string]interface{} `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FilterStructuredOutputColumnOnCallTable) GetColumn() FilterStructuredOutputColumnOnCallTableColumn {
	if f == nil {
		return ""
	}
	return f.Column
}

func (f *FilterStructuredOutputColumnOnCallTable) GetOperator() FilterStructuredOutputColumnOnCallTableOperator {
	if f == nil {
		return ""
	}
	return f.Operator
}

func (f *FilterStructuredOutputColumnOnCallTable) GetValue() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Value
}

func (f *FilterStructuredOutputColumnOnCallTable) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilterStructuredOutputColumnOnCallTable) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetColumn sets the Column field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterStructuredOutputColumnOnCallTable) SetColumn(column FilterStructuredOutputColumnOnCallTableColumn) {
	f.Column = column
	f.require(filterStructuredOutputColumnOnCallTableFieldColumn)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterStructuredOutputColumnOnCallTable) SetOperator(operator FilterStructuredOutputColumnOnCallTableOperator) {
	f.Operator = operator
	f.require(filterStructuredOutputColumnOnCallTableFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilterStructuredOutputColumnOnCallTable) SetValue(value map[string]interface{}) {
	f.Value = value
	f.require(filterStructuredOutputColumnOnCallTableFieldValue)
}

func (f *FilterStructuredOutputColumnOnCallTable) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterStructuredOutputColumnOnCallTable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterStructuredOutputColumnOnCallTable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilterStructuredOutputColumnOnCallTable) MarshalJSON() ([]byte, error) {
	type embed FilterStructuredOutputColumnOnCallTable
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FilterStructuredOutputColumnOnCallTable) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the column in the call table that will be filtered on.
// Structured Output Type columns are only to filter on artifact.structuredOutputs[OutputID] column.
type FilterStructuredOutputColumnOnCallTableColumn string

const (
	FilterStructuredOutputColumnOnCallTableColumnArtifactStructuredOutputsOutputId FilterStructuredOutputColumnOnCallTableColumn = "artifact.structuredOutputs[OutputID]"
)

func NewFilterStructuredOutputColumnOnCallTableColumnFromString(s string) (FilterStructuredOutputColumnOnCallTableColumn, error) {
	switch s {
	case "artifact.structuredOutputs[OutputID]":
		return FilterStructuredOutputColumnOnCallTableColumnArtifactStructuredOutputsOutputId, nil
	}
	var t FilterStructuredOutputColumnOnCallTableColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterStructuredOutputColumnOnCallTableColumn) Ptr() *FilterStructuredOutputColumnOnCallTableColumn {
	return &f
}

// This is the operator to use for the filter.
// The operator depends on the value type of the structured output.
// If the structured output is a string or boolean, the operator must be "=", "!="
// If the structured output is a number, the operator must be "=", ">", "<", ">=", "<="
// If the structured output is an array, the operator must be "in" or "not_in"
type FilterStructuredOutputColumnOnCallTableOperator string

const (
	FilterStructuredOutputColumnOnCallTableOperatorEqualTo              FilterStructuredOutputColumnOnCallTableOperator = "="
	FilterStructuredOutputColumnOnCallTableOperatorNotEquals            FilterStructuredOutputColumnOnCallTableOperator = "!="
	FilterStructuredOutputColumnOnCallTableOperatorGreaterThan          FilterStructuredOutputColumnOnCallTableOperator = ">"
	FilterStructuredOutputColumnOnCallTableOperatorLessThan             FilterStructuredOutputColumnOnCallTableOperator = "<"
	FilterStructuredOutputColumnOnCallTableOperatorGreaterThanOrEqualTo FilterStructuredOutputColumnOnCallTableOperator = ">="
	FilterStructuredOutputColumnOnCallTableOperatorLessThanOrEqualTo    FilterStructuredOutputColumnOnCallTableOperator = "<="
	FilterStructuredOutputColumnOnCallTableOperatorIn                   FilterStructuredOutputColumnOnCallTableOperator = "in"
	FilterStructuredOutputColumnOnCallTableOperatorNotIn                FilterStructuredOutputColumnOnCallTableOperator = "not_in"
	FilterStructuredOutputColumnOnCallTableOperatorContains             FilterStructuredOutputColumnOnCallTableOperator = "contains"
	FilterStructuredOutputColumnOnCallTableOperatorNotContains          FilterStructuredOutputColumnOnCallTableOperator = "not_contains"
)

func NewFilterStructuredOutputColumnOnCallTableOperatorFromString(s string) (FilterStructuredOutputColumnOnCallTableOperator, error) {
	switch s {
	case "=":
		return FilterStructuredOutputColumnOnCallTableOperatorEqualTo, nil
	case "!=":
		return FilterStructuredOutputColumnOnCallTableOperatorNotEquals, nil
	case ">":
		return FilterStructuredOutputColumnOnCallTableOperatorGreaterThan, nil
	case "<":
		return FilterStructuredOutputColumnOnCallTableOperatorLessThan, nil
	case ">=":
		return FilterStructuredOutputColumnOnCallTableOperatorGreaterThanOrEqualTo, nil
	case "<=":
		return FilterStructuredOutputColumnOnCallTableOperatorLessThanOrEqualTo, nil
	case "in":
		return FilterStructuredOutputColumnOnCallTableOperatorIn, nil
	case "not_in":
		return FilterStructuredOutputColumnOnCallTableOperatorNotIn, nil
	case "contains":
		return FilterStructuredOutputColumnOnCallTableOperatorContains, nil
	case "not_contains":
		return FilterStructuredOutputColumnOnCallTableOperatorNotContains, nil
	}
	var t FilterStructuredOutputColumnOnCallTableOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterStructuredOutputColumnOnCallTableOperator) Ptr() *FilterStructuredOutputColumnOnCallTableOperator {
	return &f
}

var (
	insightFieldName      = big.NewInt(1 << 0)
	insightFieldType      = big.NewInt(1 << 1)
	insightFieldId        = big.NewInt(1 << 2)
	insightFieldOrgId     = big.NewInt(1 << 3)
	insightFieldCreatedAt = big.NewInt(1 << 4)
	insightFieldUpdatedAt = big.NewInt(1 << 5)
)

type Insight struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the type of the Insight.
	Type InsightType `json:"type" url:"type"`
	// This is the unique identifier for the Insight.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this Insight belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the Insight was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the Insight was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Insight) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *Insight) GetType() InsightType {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *Insight) GetId() string {
	if i == nil {
		return ""
	}
	return i.Id
}

func (i *Insight) GetOrgId() string {
	if i == nil {
		return ""
	}
	return i.OrgId
}

func (i *Insight) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *Insight) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *Insight) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Insight) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Insight) SetName(name *string) {
	i.Name = name
	i.require(insightFieldName)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Insight) SetType(type_ InsightType) {
	i.Type = type_
	i.require(insightFieldType)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Insight) SetId(id string) {
	i.Id = id
	i.require(insightFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Insight) SetOrgId(orgId string) {
	i.OrgId = orgId
	i.require(insightFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Insight) SetCreatedAt(createdAt time.Time) {
	i.CreatedAt = createdAt
	i.require(insightFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Insight) SetUpdatedAt(updatedAt time.Time) {
	i.UpdatedAt = updatedAt
	i.require(insightFieldUpdatedAt)
}

func (i *Insight) UnmarshalJSON(data []byte) error {
	type embed Insight
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = Insight(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Insight) MarshalJSON() ([]byte, error) {
	type embed Insight
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *Insight) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	insightFormulaFieldName    = big.NewInt(1 << 0)
	insightFormulaFieldFormula = big.NewInt(1 << 1)
)

type InsightFormula struct {
	// This is the name of the formula.
	// It will be used to label the formula in the insight board on the UI.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the formula to calculate the insight from the queries.
	// The formula needs to be a valid mathematical expression.
	// The formula must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// Any MathJS formula is allowed - https://mathjs.org/docs/expressions/syntax.html
	//
	// Common valid math operations are +, -, *, /, %
	Formula string `json:"formula" url:"formula"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InsightFormula) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InsightFormula) GetFormula() string {
	if i == nil {
		return ""
	}
	return i.Formula
}

func (i *InsightFormula) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InsightFormula) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightFormula) SetName(name *string) {
	i.Name = name
	i.require(insightFormulaFieldName)
}

// SetFormula sets the Formula field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightFormula) SetFormula(formula string) {
	i.Formula = formula
	i.require(insightFormulaFieldFormula)
}

func (i *InsightFormula) UnmarshalJSON(data []byte) error {
	type unmarshaler InsightFormula
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InsightFormula(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InsightFormula) MarshalJSON() ([]byte, error) {
	type embed InsightFormula
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InsightFormula) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	insightPaginatedResponseFieldResults  = big.NewInt(1 << 0)
	insightPaginatedResponseFieldMetadata = big.NewInt(1 << 1)
)

type InsightPaginatedResponse struct {
	Results  []*Insight      `json:"results" url:"results"`
	Metadata *PaginationMeta `json:"metadata" url:"metadata"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InsightPaginatedResponse) GetResults() []*Insight {
	if i == nil {
		return nil
	}
	return i.Results
}

func (i *InsightPaginatedResponse) GetMetadata() *PaginationMeta {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InsightPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InsightPaginatedResponse) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightPaginatedResponse) SetResults(results []*Insight) {
	i.Results = results
	i.require(insightPaginatedResponseFieldResults)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightPaginatedResponse) SetMetadata(metadata *PaginationMeta) {
	i.Metadata = metadata
	i.require(insightPaginatedResponseFieldMetadata)
}

func (i *InsightPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InsightPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InsightPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InsightPaginatedResponse) MarshalJSON() ([]byte, error) {
	type embed InsightPaginatedResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InsightPaginatedResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	insightRunFormatPlanFieldFormat = big.NewInt(1 << 0)
)

type InsightRunFormatPlan struct {
	// This is the format of the data to return.
	// If not provided, defaults to "raw".
	// Raw provides the data as fetched from the database, with formulas evaluated.
	// Recharts provides the data in a format that can is ready to be used by recharts.js to render charts.
	Format *InsightRunFormatPlanFormat `json:"format,omitempty" url:"format,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InsightRunFormatPlan) GetFormat() *InsightRunFormatPlanFormat {
	if i == nil {
		return nil
	}
	return i.Format
}

func (i *InsightRunFormatPlan) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InsightRunFormatPlan) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetFormat sets the Format field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightRunFormatPlan) SetFormat(format *InsightRunFormatPlanFormat) {
	i.Format = format
	i.require(insightRunFormatPlanFieldFormat)
}

func (i *InsightRunFormatPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler InsightRunFormatPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InsightRunFormatPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InsightRunFormatPlan) MarshalJSON() ([]byte, error) {
	type embed InsightRunFormatPlan
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InsightRunFormatPlan) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// This is the format of the data to return.
// If not provided, defaults to "raw".
// Raw provides the data as fetched from the database, with formulas evaluated.
// Recharts provides the data in a format that can is ready to be used by recharts.js to render charts.
type InsightRunFormatPlanFormat string

const (
	InsightRunFormatPlanFormatRaw      InsightRunFormatPlanFormat = "raw"
	InsightRunFormatPlanFormatRecharts InsightRunFormatPlanFormat = "recharts"
)

func NewInsightRunFormatPlanFormatFromString(s string) (InsightRunFormatPlanFormat, error) {
	switch s {
	case "raw":
		return InsightRunFormatPlanFormatRaw, nil
	case "recharts":
		return InsightRunFormatPlanFormatRecharts, nil
	}
	var t InsightRunFormatPlanFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InsightRunFormatPlanFormat) Ptr() *InsightRunFormatPlanFormat {
	return &i
}

var (
	insightRunResponseFieldId        = big.NewInt(1 << 0)
	insightRunResponseFieldInsightId = big.NewInt(1 << 1)
	insightRunResponseFieldOrgId     = big.NewInt(1 << 2)
	insightRunResponseFieldCreatedAt = big.NewInt(1 << 3)
	insightRunResponseFieldUpdatedAt = big.NewInt(1 << 4)
)

type InsightRunResponse struct {
	Id        string    `json:"id" url:"id"`
	InsightId string    `json:"insightId" url:"insightId"`
	OrgId     string    `json:"orgId" url:"orgId"`
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InsightRunResponse) GetId() string {
	if i == nil {
		return ""
	}
	return i.Id
}

func (i *InsightRunResponse) GetInsightId() string {
	if i == nil {
		return ""
	}
	return i.InsightId
}

func (i *InsightRunResponse) GetOrgId() string {
	if i == nil {
		return ""
	}
	return i.OrgId
}

func (i *InsightRunResponse) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InsightRunResponse) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InsightRunResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InsightRunResponse) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightRunResponse) SetId(id string) {
	i.Id = id
	i.require(insightRunResponseFieldId)
}

// SetInsightId sets the InsightId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightRunResponse) SetInsightId(insightId string) {
	i.InsightId = insightId
	i.require(insightRunResponseFieldInsightId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightRunResponse) SetOrgId(orgId string) {
	i.OrgId = orgId
	i.require(insightRunResponseFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightRunResponse) SetCreatedAt(createdAt time.Time) {
	i.CreatedAt = createdAt
	i.require(insightRunResponseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightRunResponse) SetUpdatedAt(updatedAt time.Time) {
	i.UpdatedAt = updatedAt
	i.require(insightRunResponseFieldUpdatedAt)
}

func (i *InsightRunResponse) UnmarshalJSON(data []byte) error {
	type embed InsightRunResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InsightRunResponse(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InsightRunResponse) MarshalJSON() ([]byte, error) {
	type embed InsightRunResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InsightRunResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	insightTimeRangeFieldStart    = big.NewInt(1 << 0)
	insightTimeRangeFieldEnd      = big.NewInt(1 << 1)
	insightTimeRangeFieldTimezone = big.NewInt(1 << 2)
)

type InsightTimeRange struct {
	// This is the start date for the time range.
	//
	// Should be a valid ISO 8601 date-time string or relative time string.
	// If not provided, defaults to the 7 days ago.
	//
	// Relative time strings of the format "-{number}{unit}" are allowed.
	//
	// Valid units are:
	// - d: days
	// - h: hours
	// - w: weeks
	// - m: months
	// - y: years
	Start map[string]interface{} `json:"start,omitempty" url:"start,omitempty"`
	// This is the end date for the time range.
	//
	// Should be a valid ISO 8601 date-time string or relative time string.
	// If not provided, defaults to now.
	//
	// Relative time strings of the format "-{number}{unit}" are allowed.
	//
	// Valid units are:
	// - d: days
	// - h: hours
	// - w: weeks
	// - m: months
	// - y: years
	End map[string]interface{} `json:"end,omitempty" url:"end,omitempty"`
	// This is the timezone you want to set for the query.
	//
	// If not provided, defaults to UTC.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InsightTimeRange) GetStart() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.Start
}

func (i *InsightTimeRange) GetEnd() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.End
}

func (i *InsightTimeRange) GetTimezone() *string {
	if i == nil {
		return nil
	}
	return i.Timezone
}

func (i *InsightTimeRange) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InsightTimeRange) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightTimeRange) SetStart(start map[string]interface{}) {
	i.Start = start
	i.require(insightTimeRangeFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightTimeRange) SetEnd(end map[string]interface{}) {
	i.End = end
	i.require(insightTimeRangeFieldEnd)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightTimeRange) SetTimezone(timezone *string) {
	i.Timezone = timezone
	i.require(insightTimeRangeFieldTimezone)
}

func (i *InsightTimeRange) UnmarshalJSON(data []byte) error {
	type unmarshaler InsightTimeRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InsightTimeRange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InsightTimeRange) MarshalJSON() ([]byte, error) {
	type embed InsightTimeRange
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InsightTimeRange) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	insightTimeRangeWithStepFieldStep     = big.NewInt(1 << 0)
	insightTimeRangeWithStepFieldStart    = big.NewInt(1 << 1)
	insightTimeRangeWithStepFieldEnd      = big.NewInt(1 << 2)
	insightTimeRangeWithStepFieldTimezone = big.NewInt(1 << 3)
)

type InsightTimeRangeWithStep struct {
	// This is the group by step for aggregation.
	//
	// If not provided, defaults to group by day.
	Step *InsightTimeRangeWithStepStep `json:"step,omitempty" url:"step,omitempty"`
	// This is the start date for the time range.
	//
	// Should be a valid ISO 8601 date-time string or relative time string.
	// If not provided, defaults to the 7 days ago.
	//
	// Relative time strings of the format "-{number}{unit}" are allowed.
	//
	// Valid units are:
	// - d: days
	// - h: hours
	// - w: weeks
	// - m: months
	// - y: years
	Start map[string]interface{} `json:"start,omitempty" url:"start,omitempty"`
	// This is the end date for the time range.
	//
	// Should be a valid ISO 8601 date-time string or relative time string.
	// If not provided, defaults to now.
	//
	// Relative time strings of the format "-{number}{unit}" are allowed.
	//
	// Valid units are:
	// - d: days
	// - h: hours
	// - w: weeks
	// - m: months
	// - y: years
	End map[string]interface{} `json:"end,omitempty" url:"end,omitempty"`
	// This is the timezone you want to set for the query.
	//
	// If not provided, defaults to UTC.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InsightTimeRangeWithStep) GetStep() *InsightTimeRangeWithStepStep {
	if i == nil {
		return nil
	}
	return i.Step
}

func (i *InsightTimeRangeWithStep) GetStart() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.Start
}

func (i *InsightTimeRangeWithStep) GetEnd() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.End
}

func (i *InsightTimeRangeWithStep) GetTimezone() *string {
	if i == nil {
		return nil
	}
	return i.Timezone
}

func (i *InsightTimeRangeWithStep) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InsightTimeRangeWithStep) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetStep sets the Step field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightTimeRangeWithStep) SetStep(step *InsightTimeRangeWithStepStep) {
	i.Step = step
	i.require(insightTimeRangeWithStepFieldStep)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightTimeRangeWithStep) SetStart(start map[string]interface{}) {
	i.Start = start
	i.require(insightTimeRangeWithStepFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightTimeRangeWithStep) SetEnd(end map[string]interface{}) {
	i.End = end
	i.require(insightTimeRangeWithStepFieldEnd)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsightTimeRangeWithStep) SetTimezone(timezone *string) {
	i.Timezone = timezone
	i.require(insightTimeRangeWithStepFieldTimezone)
}

func (i *InsightTimeRangeWithStep) UnmarshalJSON(data []byte) error {
	type unmarshaler InsightTimeRangeWithStep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InsightTimeRangeWithStep(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InsightTimeRangeWithStep) MarshalJSON() ([]byte, error) {
	type embed InsightTimeRangeWithStep
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InsightTimeRangeWithStep) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// This is the group by step for aggregation.
//
// If not provided, defaults to group by day.
type InsightTimeRangeWithStepStep string

const (
	InsightTimeRangeWithStepStepMinute  InsightTimeRangeWithStepStep = "minute"
	InsightTimeRangeWithStepStepHour    InsightTimeRangeWithStepStep = "hour"
	InsightTimeRangeWithStepStepDay     InsightTimeRangeWithStepStep = "day"
	InsightTimeRangeWithStepStepWeek    InsightTimeRangeWithStepStep = "week"
	InsightTimeRangeWithStepStepMonth   InsightTimeRangeWithStepStep = "month"
	InsightTimeRangeWithStepStepQuarter InsightTimeRangeWithStepStep = "quarter"
	InsightTimeRangeWithStepStepYear    InsightTimeRangeWithStepStep = "year"
)

func NewInsightTimeRangeWithStepStepFromString(s string) (InsightTimeRangeWithStepStep, error) {
	switch s {
	case "minute":
		return InsightTimeRangeWithStepStepMinute, nil
	case "hour":
		return InsightTimeRangeWithStepStepHour, nil
	case "day":
		return InsightTimeRangeWithStepStepDay, nil
	case "week":
		return InsightTimeRangeWithStepStepWeek, nil
	case "month":
		return InsightTimeRangeWithStepStepMonth, nil
	case "quarter":
		return InsightTimeRangeWithStepStepQuarter, nil
	case "year":
		return InsightTimeRangeWithStepStepYear, nil
	}
	var t InsightTimeRangeWithStepStep
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InsightTimeRangeWithStepStep) Ptr() *InsightTimeRangeWithStepStep {
	return &i
}

// This is the type of the Insight.
type InsightType string

const (
	InsightTypeBar  InsightType = "bar"
	InsightTypeLine InsightType = "line"
	InsightTypePie  InsightType = "pie"
	InsightTypeText InsightType = "text"
)

func NewInsightTypeFromString(s string) (InsightType, error) {
	switch s {
	case "bar":
		return InsightTypeBar, nil
	case "line":
		return InsightTypeLine, nil
	case "pie":
		return InsightTypePie, nil
	case "text":
		return InsightTypeText, nil
	}
	var t InsightType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InsightType) Ptr() *InsightType {
	return &i
}

var (
	jsonQueryOnCallTableWithNumberTypeColumnFieldType      = big.NewInt(1 << 0)
	jsonQueryOnCallTableWithNumberTypeColumnFieldTable     = big.NewInt(1 << 1)
	jsonQueryOnCallTableWithNumberTypeColumnFieldFilters   = big.NewInt(1 << 2)
	jsonQueryOnCallTableWithNumberTypeColumnFieldColumn    = big.NewInt(1 << 3)
	jsonQueryOnCallTableWithNumberTypeColumnFieldOperation = big.NewInt(1 << 4)
	jsonQueryOnCallTableWithNumberTypeColumnFieldName      = big.NewInt(1 << 5)
)

type JsonQueryOnCallTableWithNumberTypeColumn struct {
	// This is the type of query. Only allowed type is "vapiql-json".
	Type JsonQueryOnCallTableWithNumberTypeColumnType `json:"type" url:"type"`
	// This is the table that will be queried.
	Table JsonQueryOnCallTableWithNumberTypeColumnTable `json:"table" url:"table"`
	// This is the filters to apply to the insight.
	// The discriminator automatically selects the correct filter type based on column and operator.
	Filters []*JsonQueryOnCallTableWithNumberTypeColumnFiltersItem `json:"filters,omitempty" url:"filters,omitempty"`
	// This is the column that will be queried in the selected table.
	// Available columns depend on the selected table.
	// Number Type columns are columns where the rows store Number data
	Column JsonQueryOnCallTableWithNumberTypeColumnColumn `json:"column" url:"column"`
	// This is the aggregation operation to perform on the column.
	// When the column is a number type, the operation must be one of the following:
	// - average
	// - sum
	// - min
	// - max
	Operation JsonQueryOnCallTableWithNumberTypeColumnOperation `json:"operation" url:"operation"`
	// This is the name of the query.
	// It will be used to label the query in the insight board on the UI.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) GetType() JsonQueryOnCallTableWithNumberTypeColumnType {
	if j == nil {
		return ""
	}
	return j.Type
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) GetTable() JsonQueryOnCallTableWithNumberTypeColumnTable {
	if j == nil {
		return ""
	}
	return j.Table
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) GetFilters() []*JsonQueryOnCallTableWithNumberTypeColumnFiltersItem {
	if j == nil {
		return nil
	}
	return j.Filters
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) GetColumn() JsonQueryOnCallTableWithNumberTypeColumnColumn {
	if j == nil {
		return ""
	}
	return j.Column
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) GetOperation() JsonQueryOnCallTableWithNumberTypeColumnOperation {
	if j == nil {
		return ""
	}
	return j.Operation
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) GetName() *string {
	if j == nil {
		return nil
	}
	return j.Name
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithNumberTypeColumn) SetType(type_ JsonQueryOnCallTableWithNumberTypeColumnType) {
	j.Type = type_
	j.require(jsonQueryOnCallTableWithNumberTypeColumnFieldType)
}

// SetTable sets the Table field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithNumberTypeColumn) SetTable(table JsonQueryOnCallTableWithNumberTypeColumnTable) {
	j.Table = table
	j.require(jsonQueryOnCallTableWithNumberTypeColumnFieldTable)
}

// SetFilters sets the Filters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithNumberTypeColumn) SetFilters(filters []*JsonQueryOnCallTableWithNumberTypeColumnFiltersItem) {
	j.Filters = filters
	j.require(jsonQueryOnCallTableWithNumberTypeColumnFieldFilters)
}

// SetColumn sets the Column field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithNumberTypeColumn) SetColumn(column JsonQueryOnCallTableWithNumberTypeColumnColumn) {
	j.Column = column
	j.require(jsonQueryOnCallTableWithNumberTypeColumnFieldColumn)
}

// SetOperation sets the Operation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithNumberTypeColumn) SetOperation(operation JsonQueryOnCallTableWithNumberTypeColumnOperation) {
	j.Operation = operation
	j.require(jsonQueryOnCallTableWithNumberTypeColumnFieldOperation)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithNumberTypeColumn) SetName(name *string) {
	j.Name = name
	j.require(jsonQueryOnCallTableWithNumberTypeColumnFieldName)
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonQueryOnCallTableWithNumberTypeColumn
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonQueryOnCallTableWithNumberTypeColumn(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) MarshalJSON() ([]byte, error) {
	type embed JsonQueryOnCallTableWithNumberTypeColumn
	var marshaler = struct {
		embed
	}{
		embed: embed(*j),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, j.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (j *JsonQueryOnCallTableWithNumberTypeColumn) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// This is the column that will be queried in the selected table.
// Available columns depend on the selected table.
// Number Type columns are columns where the rows store Number data
type JsonQueryOnCallTableWithNumberTypeColumnColumn string

const (
	JsonQueryOnCallTableWithNumberTypeColumnColumnCost                              JsonQueryOnCallTableWithNumberTypeColumnColumn = "cost"
	JsonQueryOnCallTableWithNumberTypeColumnColumnDuration                          JsonQueryOnCallTableWithNumberTypeColumnColumn = "duration"
	JsonQueryOnCallTableWithNumberTypeColumnColumnAverageModelLatency               JsonQueryOnCallTableWithNumberTypeColumnColumn = "averageModelLatency"
	JsonQueryOnCallTableWithNumberTypeColumnColumnAverageVoiceLatency               JsonQueryOnCallTableWithNumberTypeColumnColumn = "averageVoiceLatency"
	JsonQueryOnCallTableWithNumberTypeColumnColumnAverageTranscriberLatency         JsonQueryOnCallTableWithNumberTypeColumnColumn = "averageTranscriberLatency"
	JsonQueryOnCallTableWithNumberTypeColumnColumnAverageTurnLatency                JsonQueryOnCallTableWithNumberTypeColumnColumn = "averageTurnLatency"
	JsonQueryOnCallTableWithNumberTypeColumnColumnAverageEndpointingLatency         JsonQueryOnCallTableWithNumberTypeColumnColumn = "averageEndpointingLatency"
	JsonQueryOnCallTableWithNumberTypeColumnColumnArtifactStructuredOutputsOutputId JsonQueryOnCallTableWithNumberTypeColumnColumn = "artifact.structuredOutputs[OutputID]"
)

func NewJsonQueryOnCallTableWithNumberTypeColumnColumnFromString(s string) (JsonQueryOnCallTableWithNumberTypeColumnColumn, error) {
	switch s {
	case "cost":
		return JsonQueryOnCallTableWithNumberTypeColumnColumnCost, nil
	case "duration":
		return JsonQueryOnCallTableWithNumberTypeColumnColumnDuration, nil
	case "averageModelLatency":
		return JsonQueryOnCallTableWithNumberTypeColumnColumnAverageModelLatency, nil
	case "averageVoiceLatency":
		return JsonQueryOnCallTableWithNumberTypeColumnColumnAverageVoiceLatency, nil
	case "averageTranscriberLatency":
		return JsonQueryOnCallTableWithNumberTypeColumnColumnAverageTranscriberLatency, nil
	case "averageTurnLatency":
		return JsonQueryOnCallTableWithNumberTypeColumnColumnAverageTurnLatency, nil
	case "averageEndpointingLatency":
		return JsonQueryOnCallTableWithNumberTypeColumnColumnAverageEndpointingLatency, nil
	case "artifact.structuredOutputs[OutputID]":
		return JsonQueryOnCallTableWithNumberTypeColumnColumnArtifactStructuredOutputsOutputId, nil
	}
	var t JsonQueryOnCallTableWithNumberTypeColumnColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithNumberTypeColumnColumn) Ptr() *JsonQueryOnCallTableWithNumberTypeColumnColumn {
	return &j
}

type JsonQueryOnCallTableWithNumberTypeColumnFiltersItem struct {
	FilterStringTypeColumnOnCallTable       *FilterStringTypeColumnOnCallTable
	FilterStringArrayTypeColumnOnCallTable  *FilterStringArrayTypeColumnOnCallTable
	FilterNumberTypeColumnOnCallTable       *FilterNumberTypeColumnOnCallTable
	FilterNumberArrayTypeColumnOnCallTable  *FilterNumberArrayTypeColumnOnCallTable
	FilterDateTypeColumnOnCallTable         *FilterDateTypeColumnOnCallTable
	FilterStructuredOutputColumnOnCallTable *FilterStructuredOutputColumnOnCallTable

	typ string
}

func (j *JsonQueryOnCallTableWithNumberTypeColumnFiltersItem) GetFilterStringTypeColumnOnCallTable() *FilterStringTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterStringTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithNumberTypeColumnFiltersItem) GetFilterStringArrayTypeColumnOnCallTable() *FilterStringArrayTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterStringArrayTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithNumberTypeColumnFiltersItem) GetFilterNumberTypeColumnOnCallTable() *FilterNumberTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterNumberTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithNumberTypeColumnFiltersItem) GetFilterNumberArrayTypeColumnOnCallTable() *FilterNumberArrayTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterNumberArrayTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithNumberTypeColumnFiltersItem) GetFilterDateTypeColumnOnCallTable() *FilterDateTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterDateTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithNumberTypeColumnFiltersItem) GetFilterStructuredOutputColumnOnCallTable() *FilterStructuredOutputColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterStructuredOutputColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithNumberTypeColumnFiltersItem) UnmarshalJSON(data []byte) error {
	valueFilterStringTypeColumnOnCallTable := new(FilterStringTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterStringTypeColumnOnCallTable); err == nil {
		j.typ = "FilterStringTypeColumnOnCallTable"
		j.FilterStringTypeColumnOnCallTable = valueFilterStringTypeColumnOnCallTable
		return nil
	}
	valueFilterStringArrayTypeColumnOnCallTable := new(FilterStringArrayTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterStringArrayTypeColumnOnCallTable); err == nil {
		j.typ = "FilterStringArrayTypeColumnOnCallTable"
		j.FilterStringArrayTypeColumnOnCallTable = valueFilterStringArrayTypeColumnOnCallTable
		return nil
	}
	valueFilterNumberTypeColumnOnCallTable := new(FilterNumberTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterNumberTypeColumnOnCallTable); err == nil {
		j.typ = "FilterNumberTypeColumnOnCallTable"
		j.FilterNumberTypeColumnOnCallTable = valueFilterNumberTypeColumnOnCallTable
		return nil
	}
	valueFilterNumberArrayTypeColumnOnCallTable := new(FilterNumberArrayTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterNumberArrayTypeColumnOnCallTable); err == nil {
		j.typ = "FilterNumberArrayTypeColumnOnCallTable"
		j.FilterNumberArrayTypeColumnOnCallTable = valueFilterNumberArrayTypeColumnOnCallTable
		return nil
	}
	valueFilterDateTypeColumnOnCallTable := new(FilterDateTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterDateTypeColumnOnCallTable); err == nil {
		j.typ = "FilterDateTypeColumnOnCallTable"
		j.FilterDateTypeColumnOnCallTable = valueFilterDateTypeColumnOnCallTable
		return nil
	}
	valueFilterStructuredOutputColumnOnCallTable := new(FilterStructuredOutputColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterStructuredOutputColumnOnCallTable); err == nil {
		j.typ = "FilterStructuredOutputColumnOnCallTable"
		j.FilterStructuredOutputColumnOnCallTable = valueFilterStructuredOutputColumnOnCallTable
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JsonQueryOnCallTableWithNumberTypeColumnFiltersItem) MarshalJSON() ([]byte, error) {
	if j.typ == "FilterStringTypeColumnOnCallTable" || j.FilterStringTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterStringTypeColumnOnCallTable)
	}
	if j.typ == "FilterStringArrayTypeColumnOnCallTable" || j.FilterStringArrayTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterStringArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberTypeColumnOnCallTable" || j.FilterNumberTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterNumberTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberArrayTypeColumnOnCallTable" || j.FilterNumberArrayTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterNumberArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterDateTypeColumnOnCallTable" || j.FilterDateTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterDateTypeColumnOnCallTable)
	}
	if j.typ == "FilterStructuredOutputColumnOnCallTable" || j.FilterStructuredOutputColumnOnCallTable != nil {
		return json.Marshal(j.FilterStructuredOutputColumnOnCallTable)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JsonQueryOnCallTableWithNumberTypeColumnFiltersItemVisitor interface {
	VisitFilterStringTypeColumnOnCallTable(*FilterStringTypeColumnOnCallTable) error
	VisitFilterStringArrayTypeColumnOnCallTable(*FilterStringArrayTypeColumnOnCallTable) error
	VisitFilterNumberTypeColumnOnCallTable(*FilterNumberTypeColumnOnCallTable) error
	VisitFilterNumberArrayTypeColumnOnCallTable(*FilterNumberArrayTypeColumnOnCallTable) error
	VisitFilterDateTypeColumnOnCallTable(*FilterDateTypeColumnOnCallTable) error
	VisitFilterStructuredOutputColumnOnCallTable(*FilterStructuredOutputColumnOnCallTable) error
}

func (j *JsonQueryOnCallTableWithNumberTypeColumnFiltersItem) Accept(visitor JsonQueryOnCallTableWithNumberTypeColumnFiltersItemVisitor) error {
	if j.typ == "FilterStringTypeColumnOnCallTable" || j.FilterStringTypeColumnOnCallTable != nil {
		return visitor.VisitFilterStringTypeColumnOnCallTable(j.FilterStringTypeColumnOnCallTable)
	}
	if j.typ == "FilterStringArrayTypeColumnOnCallTable" || j.FilterStringArrayTypeColumnOnCallTable != nil {
		return visitor.VisitFilterStringArrayTypeColumnOnCallTable(j.FilterStringArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberTypeColumnOnCallTable" || j.FilterNumberTypeColumnOnCallTable != nil {
		return visitor.VisitFilterNumberTypeColumnOnCallTable(j.FilterNumberTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberArrayTypeColumnOnCallTable" || j.FilterNumberArrayTypeColumnOnCallTable != nil {
		return visitor.VisitFilterNumberArrayTypeColumnOnCallTable(j.FilterNumberArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterDateTypeColumnOnCallTable" || j.FilterDateTypeColumnOnCallTable != nil {
		return visitor.VisitFilterDateTypeColumnOnCallTable(j.FilterDateTypeColumnOnCallTable)
	}
	if j.typ == "FilterStructuredOutputColumnOnCallTable" || j.FilterStructuredOutputColumnOnCallTable != nil {
		return visitor.VisitFilterStructuredOutputColumnOnCallTable(j.FilterStructuredOutputColumnOnCallTable)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// This is the aggregation operation to perform on the column.
// When the column is a number type, the operation must be one of the following:
// - average
// - sum
// - min
// - max
type JsonQueryOnCallTableWithNumberTypeColumnOperation string

const (
	JsonQueryOnCallTableWithNumberTypeColumnOperationAverage JsonQueryOnCallTableWithNumberTypeColumnOperation = "average"
	JsonQueryOnCallTableWithNumberTypeColumnOperationSum     JsonQueryOnCallTableWithNumberTypeColumnOperation = "sum"
	JsonQueryOnCallTableWithNumberTypeColumnOperationMin     JsonQueryOnCallTableWithNumberTypeColumnOperation = "min"
	JsonQueryOnCallTableWithNumberTypeColumnOperationMax     JsonQueryOnCallTableWithNumberTypeColumnOperation = "max"
)

func NewJsonQueryOnCallTableWithNumberTypeColumnOperationFromString(s string) (JsonQueryOnCallTableWithNumberTypeColumnOperation, error) {
	switch s {
	case "average":
		return JsonQueryOnCallTableWithNumberTypeColumnOperationAverage, nil
	case "sum":
		return JsonQueryOnCallTableWithNumberTypeColumnOperationSum, nil
	case "min":
		return JsonQueryOnCallTableWithNumberTypeColumnOperationMin, nil
	case "max":
		return JsonQueryOnCallTableWithNumberTypeColumnOperationMax, nil
	}
	var t JsonQueryOnCallTableWithNumberTypeColumnOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithNumberTypeColumnOperation) Ptr() *JsonQueryOnCallTableWithNumberTypeColumnOperation {
	return &j
}

// This is the table that will be queried.
type JsonQueryOnCallTableWithNumberTypeColumnTable string

const (
	JsonQueryOnCallTableWithNumberTypeColumnTableCall JsonQueryOnCallTableWithNumberTypeColumnTable = "call"
)

func NewJsonQueryOnCallTableWithNumberTypeColumnTableFromString(s string) (JsonQueryOnCallTableWithNumberTypeColumnTable, error) {
	switch s {
	case "call":
		return JsonQueryOnCallTableWithNumberTypeColumnTableCall, nil
	}
	var t JsonQueryOnCallTableWithNumberTypeColumnTable
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithNumberTypeColumnTable) Ptr() *JsonQueryOnCallTableWithNumberTypeColumnTable {
	return &j
}

// This is the type of query. Only allowed type is "vapiql-json".
type JsonQueryOnCallTableWithNumberTypeColumnType string

const (
	JsonQueryOnCallTableWithNumberTypeColumnTypeVapiqlJson JsonQueryOnCallTableWithNumberTypeColumnType = "vapiql-json"
)

func NewJsonQueryOnCallTableWithNumberTypeColumnTypeFromString(s string) (JsonQueryOnCallTableWithNumberTypeColumnType, error) {
	switch s {
	case "vapiql-json":
		return JsonQueryOnCallTableWithNumberTypeColumnTypeVapiqlJson, nil
	}
	var t JsonQueryOnCallTableWithNumberTypeColumnType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithNumberTypeColumnType) Ptr() *JsonQueryOnCallTableWithNumberTypeColumnType {
	return &j
}

var (
	jsonQueryOnCallTableWithStringTypeColumnFieldType      = big.NewInt(1 << 0)
	jsonQueryOnCallTableWithStringTypeColumnFieldTable     = big.NewInt(1 << 1)
	jsonQueryOnCallTableWithStringTypeColumnFieldFilters   = big.NewInt(1 << 2)
	jsonQueryOnCallTableWithStringTypeColumnFieldColumn    = big.NewInt(1 << 3)
	jsonQueryOnCallTableWithStringTypeColumnFieldOperation = big.NewInt(1 << 4)
	jsonQueryOnCallTableWithStringTypeColumnFieldName      = big.NewInt(1 << 5)
)

type JsonQueryOnCallTableWithStringTypeColumn struct {
	// This is the type of query. Only allowed type is "vapiql-json".
	Type JsonQueryOnCallTableWithStringTypeColumnType `json:"type" url:"type"`
	// This is the table that will be queried.
	Table JsonQueryOnCallTableWithStringTypeColumnTable `json:"table" url:"table"`
	// This is the filters to apply to the insight.
	// The discriminator automatically selects the correct filter type based on column and operator.
	Filters []*JsonQueryOnCallTableWithStringTypeColumnFiltersItem `json:"filters,omitempty" url:"filters,omitempty"`
	// This is the column that will be queried in the selected table.
	// Available columns depend on the selected table.
	// String Type columns are columns where the rows store String data
	Column JsonQueryOnCallTableWithStringTypeColumnColumn `json:"column" url:"column"`
	// This is the aggregation operation to perform on the column.
	// When the column is a string type, the operation must be "count".
	Operation JsonQueryOnCallTableWithStringTypeColumnOperation `json:"operation" url:"operation"`
	// This is the name of the query.
	// It will be used to label the query in the insight board on the UI.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) GetType() JsonQueryOnCallTableWithStringTypeColumnType {
	if j == nil {
		return ""
	}
	return j.Type
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) GetTable() JsonQueryOnCallTableWithStringTypeColumnTable {
	if j == nil {
		return ""
	}
	return j.Table
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) GetFilters() []*JsonQueryOnCallTableWithStringTypeColumnFiltersItem {
	if j == nil {
		return nil
	}
	return j.Filters
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) GetColumn() JsonQueryOnCallTableWithStringTypeColumnColumn {
	if j == nil {
		return ""
	}
	return j.Column
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) GetOperation() JsonQueryOnCallTableWithStringTypeColumnOperation {
	if j == nil {
		return ""
	}
	return j.Operation
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) GetName() *string {
	if j == nil {
		return nil
	}
	return j.Name
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStringTypeColumn) SetType(type_ JsonQueryOnCallTableWithStringTypeColumnType) {
	j.Type = type_
	j.require(jsonQueryOnCallTableWithStringTypeColumnFieldType)
}

// SetTable sets the Table field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStringTypeColumn) SetTable(table JsonQueryOnCallTableWithStringTypeColumnTable) {
	j.Table = table
	j.require(jsonQueryOnCallTableWithStringTypeColumnFieldTable)
}

// SetFilters sets the Filters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStringTypeColumn) SetFilters(filters []*JsonQueryOnCallTableWithStringTypeColumnFiltersItem) {
	j.Filters = filters
	j.require(jsonQueryOnCallTableWithStringTypeColumnFieldFilters)
}

// SetColumn sets the Column field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStringTypeColumn) SetColumn(column JsonQueryOnCallTableWithStringTypeColumnColumn) {
	j.Column = column
	j.require(jsonQueryOnCallTableWithStringTypeColumnFieldColumn)
}

// SetOperation sets the Operation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStringTypeColumn) SetOperation(operation JsonQueryOnCallTableWithStringTypeColumnOperation) {
	j.Operation = operation
	j.require(jsonQueryOnCallTableWithStringTypeColumnFieldOperation)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStringTypeColumn) SetName(name *string) {
	j.Name = name
	j.require(jsonQueryOnCallTableWithStringTypeColumnFieldName)
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonQueryOnCallTableWithStringTypeColumn
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonQueryOnCallTableWithStringTypeColumn(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) MarshalJSON() ([]byte, error) {
	type embed JsonQueryOnCallTableWithStringTypeColumn
	var marshaler = struct {
		embed
	}{
		embed: embed(*j),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, j.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (j *JsonQueryOnCallTableWithStringTypeColumn) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// This is the column that will be queried in the selected table.
// Available columns depend on the selected table.
// String Type columns are columns where the rows store String data
type JsonQueryOnCallTableWithStringTypeColumnColumn string

const (
	JsonQueryOnCallTableWithStringTypeColumnColumnId                                JsonQueryOnCallTableWithStringTypeColumnColumn = "id"
	JsonQueryOnCallTableWithStringTypeColumnColumnArtifactStructuredOutputsOutputId JsonQueryOnCallTableWithStringTypeColumnColumn = "artifact.structuredOutputs[OutputID]"
)

func NewJsonQueryOnCallTableWithStringTypeColumnColumnFromString(s string) (JsonQueryOnCallTableWithStringTypeColumnColumn, error) {
	switch s {
	case "id":
		return JsonQueryOnCallTableWithStringTypeColumnColumnId, nil
	case "artifact.structuredOutputs[OutputID]":
		return JsonQueryOnCallTableWithStringTypeColumnColumnArtifactStructuredOutputsOutputId, nil
	}
	var t JsonQueryOnCallTableWithStringTypeColumnColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithStringTypeColumnColumn) Ptr() *JsonQueryOnCallTableWithStringTypeColumnColumn {
	return &j
}

type JsonQueryOnCallTableWithStringTypeColumnFiltersItem struct {
	FilterStringTypeColumnOnCallTable       *FilterStringTypeColumnOnCallTable
	FilterStringArrayTypeColumnOnCallTable  *FilterStringArrayTypeColumnOnCallTable
	FilterNumberTypeColumnOnCallTable       *FilterNumberTypeColumnOnCallTable
	FilterNumberArrayTypeColumnOnCallTable  *FilterNumberArrayTypeColumnOnCallTable
	FilterDateTypeColumnOnCallTable         *FilterDateTypeColumnOnCallTable
	FilterStructuredOutputColumnOnCallTable *FilterStructuredOutputColumnOnCallTable

	typ string
}

func (j *JsonQueryOnCallTableWithStringTypeColumnFiltersItem) GetFilterStringTypeColumnOnCallTable() *FilterStringTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterStringTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStringTypeColumnFiltersItem) GetFilterStringArrayTypeColumnOnCallTable() *FilterStringArrayTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterStringArrayTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStringTypeColumnFiltersItem) GetFilterNumberTypeColumnOnCallTable() *FilterNumberTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterNumberTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStringTypeColumnFiltersItem) GetFilterNumberArrayTypeColumnOnCallTable() *FilterNumberArrayTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterNumberArrayTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStringTypeColumnFiltersItem) GetFilterDateTypeColumnOnCallTable() *FilterDateTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterDateTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStringTypeColumnFiltersItem) GetFilterStructuredOutputColumnOnCallTable() *FilterStructuredOutputColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterStructuredOutputColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStringTypeColumnFiltersItem) UnmarshalJSON(data []byte) error {
	valueFilterStringTypeColumnOnCallTable := new(FilterStringTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterStringTypeColumnOnCallTable); err == nil {
		j.typ = "FilterStringTypeColumnOnCallTable"
		j.FilterStringTypeColumnOnCallTable = valueFilterStringTypeColumnOnCallTable
		return nil
	}
	valueFilterStringArrayTypeColumnOnCallTable := new(FilterStringArrayTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterStringArrayTypeColumnOnCallTable); err == nil {
		j.typ = "FilterStringArrayTypeColumnOnCallTable"
		j.FilterStringArrayTypeColumnOnCallTable = valueFilterStringArrayTypeColumnOnCallTable
		return nil
	}
	valueFilterNumberTypeColumnOnCallTable := new(FilterNumberTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterNumberTypeColumnOnCallTable); err == nil {
		j.typ = "FilterNumberTypeColumnOnCallTable"
		j.FilterNumberTypeColumnOnCallTable = valueFilterNumberTypeColumnOnCallTable
		return nil
	}
	valueFilterNumberArrayTypeColumnOnCallTable := new(FilterNumberArrayTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterNumberArrayTypeColumnOnCallTable); err == nil {
		j.typ = "FilterNumberArrayTypeColumnOnCallTable"
		j.FilterNumberArrayTypeColumnOnCallTable = valueFilterNumberArrayTypeColumnOnCallTable
		return nil
	}
	valueFilterDateTypeColumnOnCallTable := new(FilterDateTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterDateTypeColumnOnCallTable); err == nil {
		j.typ = "FilterDateTypeColumnOnCallTable"
		j.FilterDateTypeColumnOnCallTable = valueFilterDateTypeColumnOnCallTable
		return nil
	}
	valueFilterStructuredOutputColumnOnCallTable := new(FilterStructuredOutputColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterStructuredOutputColumnOnCallTable); err == nil {
		j.typ = "FilterStructuredOutputColumnOnCallTable"
		j.FilterStructuredOutputColumnOnCallTable = valueFilterStructuredOutputColumnOnCallTable
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JsonQueryOnCallTableWithStringTypeColumnFiltersItem) MarshalJSON() ([]byte, error) {
	if j.typ == "FilterStringTypeColumnOnCallTable" || j.FilterStringTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterStringTypeColumnOnCallTable)
	}
	if j.typ == "FilterStringArrayTypeColumnOnCallTable" || j.FilterStringArrayTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterStringArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberTypeColumnOnCallTable" || j.FilterNumberTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterNumberTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberArrayTypeColumnOnCallTable" || j.FilterNumberArrayTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterNumberArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterDateTypeColumnOnCallTable" || j.FilterDateTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterDateTypeColumnOnCallTable)
	}
	if j.typ == "FilterStructuredOutputColumnOnCallTable" || j.FilterStructuredOutputColumnOnCallTable != nil {
		return json.Marshal(j.FilterStructuredOutputColumnOnCallTable)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JsonQueryOnCallTableWithStringTypeColumnFiltersItemVisitor interface {
	VisitFilterStringTypeColumnOnCallTable(*FilterStringTypeColumnOnCallTable) error
	VisitFilterStringArrayTypeColumnOnCallTable(*FilterStringArrayTypeColumnOnCallTable) error
	VisitFilterNumberTypeColumnOnCallTable(*FilterNumberTypeColumnOnCallTable) error
	VisitFilterNumberArrayTypeColumnOnCallTable(*FilterNumberArrayTypeColumnOnCallTable) error
	VisitFilterDateTypeColumnOnCallTable(*FilterDateTypeColumnOnCallTable) error
	VisitFilterStructuredOutputColumnOnCallTable(*FilterStructuredOutputColumnOnCallTable) error
}

func (j *JsonQueryOnCallTableWithStringTypeColumnFiltersItem) Accept(visitor JsonQueryOnCallTableWithStringTypeColumnFiltersItemVisitor) error {
	if j.typ == "FilterStringTypeColumnOnCallTable" || j.FilterStringTypeColumnOnCallTable != nil {
		return visitor.VisitFilterStringTypeColumnOnCallTable(j.FilterStringTypeColumnOnCallTable)
	}
	if j.typ == "FilterStringArrayTypeColumnOnCallTable" || j.FilterStringArrayTypeColumnOnCallTable != nil {
		return visitor.VisitFilterStringArrayTypeColumnOnCallTable(j.FilterStringArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberTypeColumnOnCallTable" || j.FilterNumberTypeColumnOnCallTable != nil {
		return visitor.VisitFilterNumberTypeColumnOnCallTable(j.FilterNumberTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberArrayTypeColumnOnCallTable" || j.FilterNumberArrayTypeColumnOnCallTable != nil {
		return visitor.VisitFilterNumberArrayTypeColumnOnCallTable(j.FilterNumberArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterDateTypeColumnOnCallTable" || j.FilterDateTypeColumnOnCallTable != nil {
		return visitor.VisitFilterDateTypeColumnOnCallTable(j.FilterDateTypeColumnOnCallTable)
	}
	if j.typ == "FilterStructuredOutputColumnOnCallTable" || j.FilterStructuredOutputColumnOnCallTable != nil {
		return visitor.VisitFilterStructuredOutputColumnOnCallTable(j.FilterStructuredOutputColumnOnCallTable)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// This is the aggregation operation to perform on the column.
// When the column is a string type, the operation must be "count".
type JsonQueryOnCallTableWithStringTypeColumnOperation string

const (
	JsonQueryOnCallTableWithStringTypeColumnOperationCount JsonQueryOnCallTableWithStringTypeColumnOperation = "count"
)

func NewJsonQueryOnCallTableWithStringTypeColumnOperationFromString(s string) (JsonQueryOnCallTableWithStringTypeColumnOperation, error) {
	switch s {
	case "count":
		return JsonQueryOnCallTableWithStringTypeColumnOperationCount, nil
	}
	var t JsonQueryOnCallTableWithStringTypeColumnOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithStringTypeColumnOperation) Ptr() *JsonQueryOnCallTableWithStringTypeColumnOperation {
	return &j
}

// This is the table that will be queried.
type JsonQueryOnCallTableWithStringTypeColumnTable string

const (
	JsonQueryOnCallTableWithStringTypeColumnTableCall JsonQueryOnCallTableWithStringTypeColumnTable = "call"
)

func NewJsonQueryOnCallTableWithStringTypeColumnTableFromString(s string) (JsonQueryOnCallTableWithStringTypeColumnTable, error) {
	switch s {
	case "call":
		return JsonQueryOnCallTableWithStringTypeColumnTableCall, nil
	}
	var t JsonQueryOnCallTableWithStringTypeColumnTable
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithStringTypeColumnTable) Ptr() *JsonQueryOnCallTableWithStringTypeColumnTable {
	return &j
}

// This is the type of query. Only allowed type is "vapiql-json".
type JsonQueryOnCallTableWithStringTypeColumnType string

const (
	JsonQueryOnCallTableWithStringTypeColumnTypeVapiqlJson JsonQueryOnCallTableWithStringTypeColumnType = "vapiql-json"
)

func NewJsonQueryOnCallTableWithStringTypeColumnTypeFromString(s string) (JsonQueryOnCallTableWithStringTypeColumnType, error) {
	switch s {
	case "vapiql-json":
		return JsonQueryOnCallTableWithStringTypeColumnTypeVapiqlJson, nil
	}
	var t JsonQueryOnCallTableWithStringTypeColumnType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithStringTypeColumnType) Ptr() *JsonQueryOnCallTableWithStringTypeColumnType {
	return &j
}

var (
	jsonQueryOnCallTableWithStructuredOutputColumnFieldType      = big.NewInt(1 << 0)
	jsonQueryOnCallTableWithStructuredOutputColumnFieldTable     = big.NewInt(1 << 1)
	jsonQueryOnCallTableWithStructuredOutputColumnFieldFilters   = big.NewInt(1 << 2)
	jsonQueryOnCallTableWithStructuredOutputColumnFieldColumn    = big.NewInt(1 << 3)
	jsonQueryOnCallTableWithStructuredOutputColumnFieldOperation = big.NewInt(1 << 4)
	jsonQueryOnCallTableWithStructuredOutputColumnFieldName      = big.NewInt(1 << 5)
)

type JsonQueryOnCallTableWithStructuredOutputColumn struct {
	// This is the type of query. Only allowed type is "vapiql-json".
	Type JsonQueryOnCallTableWithStructuredOutputColumnType `json:"type" url:"type"`
	// This is the table that will be queried.
	Table JsonQueryOnCallTableWithStructuredOutputColumnTable `json:"table" url:"table"`
	// This is the filters to apply to the insight.
	// The discriminator automatically selects the correct filter type based on column and operator.
	Filters []*JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem `json:"filters,omitempty" url:"filters,omitempty"`
	// This is the column that will be queried in the call table.
	// Structured Output Type columns are only to query on artifact.structuredOutputs[OutputID] column.
	Column JsonQueryOnCallTableWithStructuredOutputColumnColumn `json:"column" url:"column"`
	// This is the aggregation operation to perform on the column.
	// When the column is a structured output type, the operation depends on the value of the structured output.
	// If the structured output is a string or boolean, the operation must be "count".
	// If the structured output is a number, the operation can be "average", "sum", "min", or "max".
	Operation JsonQueryOnCallTableWithStructuredOutputColumnOperation `json:"operation" url:"operation"`
	// This is the name of the query.
	// It will be used to label the query in the insight board on the UI.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) GetType() JsonQueryOnCallTableWithStructuredOutputColumnType {
	if j == nil {
		return ""
	}
	return j.Type
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) GetTable() JsonQueryOnCallTableWithStructuredOutputColumnTable {
	if j == nil {
		return ""
	}
	return j.Table
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) GetFilters() []*JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem {
	if j == nil {
		return nil
	}
	return j.Filters
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) GetColumn() JsonQueryOnCallTableWithStructuredOutputColumnColumn {
	if j == nil {
		return ""
	}
	return j.Column
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) GetOperation() JsonQueryOnCallTableWithStructuredOutputColumnOperation {
	if j == nil {
		return ""
	}
	return j.Operation
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) GetName() *string {
	if j == nil {
		return nil
	}
	return j.Name
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStructuredOutputColumn) SetType(type_ JsonQueryOnCallTableWithStructuredOutputColumnType) {
	j.Type = type_
	j.require(jsonQueryOnCallTableWithStructuredOutputColumnFieldType)
}

// SetTable sets the Table field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStructuredOutputColumn) SetTable(table JsonQueryOnCallTableWithStructuredOutputColumnTable) {
	j.Table = table
	j.require(jsonQueryOnCallTableWithStructuredOutputColumnFieldTable)
}

// SetFilters sets the Filters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStructuredOutputColumn) SetFilters(filters []*JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem) {
	j.Filters = filters
	j.require(jsonQueryOnCallTableWithStructuredOutputColumnFieldFilters)
}

// SetColumn sets the Column field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStructuredOutputColumn) SetColumn(column JsonQueryOnCallTableWithStructuredOutputColumnColumn) {
	j.Column = column
	j.require(jsonQueryOnCallTableWithStructuredOutputColumnFieldColumn)
}

// SetOperation sets the Operation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStructuredOutputColumn) SetOperation(operation JsonQueryOnCallTableWithStructuredOutputColumnOperation) {
	j.Operation = operation
	j.require(jsonQueryOnCallTableWithStructuredOutputColumnFieldOperation)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JsonQueryOnCallTableWithStructuredOutputColumn) SetName(name *string) {
	j.Name = name
	j.require(jsonQueryOnCallTableWithStructuredOutputColumnFieldName)
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonQueryOnCallTableWithStructuredOutputColumn
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonQueryOnCallTableWithStructuredOutputColumn(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) MarshalJSON() ([]byte, error) {
	type embed JsonQueryOnCallTableWithStructuredOutputColumn
	var marshaler = struct {
		embed
	}{
		embed: embed(*j),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, j.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumn) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// This is the column that will be queried in the call table.
// Structured Output Type columns are only to query on artifact.structuredOutputs[OutputID] column.
type JsonQueryOnCallTableWithStructuredOutputColumnColumn string

const (
	JsonQueryOnCallTableWithStructuredOutputColumnColumnArtifactStructuredOutputsOutputId JsonQueryOnCallTableWithStructuredOutputColumnColumn = "artifact.structuredOutputs[OutputID]"
)

func NewJsonQueryOnCallTableWithStructuredOutputColumnColumnFromString(s string) (JsonQueryOnCallTableWithStructuredOutputColumnColumn, error) {
	switch s {
	case "artifact.structuredOutputs[OutputID]":
		return JsonQueryOnCallTableWithStructuredOutputColumnColumnArtifactStructuredOutputsOutputId, nil
	}
	var t JsonQueryOnCallTableWithStructuredOutputColumnColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithStructuredOutputColumnColumn) Ptr() *JsonQueryOnCallTableWithStructuredOutputColumnColumn {
	return &j
}

type JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem struct {
	FilterStringTypeColumnOnCallTable       *FilterStringTypeColumnOnCallTable
	FilterStringArrayTypeColumnOnCallTable  *FilterStringArrayTypeColumnOnCallTable
	FilterNumberTypeColumnOnCallTable       *FilterNumberTypeColumnOnCallTable
	FilterNumberArrayTypeColumnOnCallTable  *FilterNumberArrayTypeColumnOnCallTable
	FilterDateTypeColumnOnCallTable         *FilterDateTypeColumnOnCallTable
	FilterStructuredOutputColumnOnCallTable *FilterStructuredOutputColumnOnCallTable

	typ string
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem) GetFilterStringTypeColumnOnCallTable() *FilterStringTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterStringTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem) GetFilterStringArrayTypeColumnOnCallTable() *FilterStringArrayTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterStringArrayTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem) GetFilterNumberTypeColumnOnCallTable() *FilterNumberTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterNumberTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem) GetFilterNumberArrayTypeColumnOnCallTable() *FilterNumberArrayTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterNumberArrayTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem) GetFilterDateTypeColumnOnCallTable() *FilterDateTypeColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterDateTypeColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem) GetFilterStructuredOutputColumnOnCallTable() *FilterStructuredOutputColumnOnCallTable {
	if j == nil {
		return nil
	}
	return j.FilterStructuredOutputColumnOnCallTable
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem) UnmarshalJSON(data []byte) error {
	valueFilterStringTypeColumnOnCallTable := new(FilterStringTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterStringTypeColumnOnCallTable); err == nil {
		j.typ = "FilterStringTypeColumnOnCallTable"
		j.FilterStringTypeColumnOnCallTable = valueFilterStringTypeColumnOnCallTable
		return nil
	}
	valueFilterStringArrayTypeColumnOnCallTable := new(FilterStringArrayTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterStringArrayTypeColumnOnCallTable); err == nil {
		j.typ = "FilterStringArrayTypeColumnOnCallTable"
		j.FilterStringArrayTypeColumnOnCallTable = valueFilterStringArrayTypeColumnOnCallTable
		return nil
	}
	valueFilterNumberTypeColumnOnCallTable := new(FilterNumberTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterNumberTypeColumnOnCallTable); err == nil {
		j.typ = "FilterNumberTypeColumnOnCallTable"
		j.FilterNumberTypeColumnOnCallTable = valueFilterNumberTypeColumnOnCallTable
		return nil
	}
	valueFilterNumberArrayTypeColumnOnCallTable := new(FilterNumberArrayTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterNumberArrayTypeColumnOnCallTable); err == nil {
		j.typ = "FilterNumberArrayTypeColumnOnCallTable"
		j.FilterNumberArrayTypeColumnOnCallTable = valueFilterNumberArrayTypeColumnOnCallTable
		return nil
	}
	valueFilterDateTypeColumnOnCallTable := new(FilterDateTypeColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterDateTypeColumnOnCallTable); err == nil {
		j.typ = "FilterDateTypeColumnOnCallTable"
		j.FilterDateTypeColumnOnCallTable = valueFilterDateTypeColumnOnCallTable
		return nil
	}
	valueFilterStructuredOutputColumnOnCallTable := new(FilterStructuredOutputColumnOnCallTable)
	if err := json.Unmarshal(data, &valueFilterStructuredOutputColumnOnCallTable); err == nil {
		j.typ = "FilterStructuredOutputColumnOnCallTable"
		j.FilterStructuredOutputColumnOnCallTable = valueFilterStructuredOutputColumnOnCallTable
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem) MarshalJSON() ([]byte, error) {
	if j.typ == "FilterStringTypeColumnOnCallTable" || j.FilterStringTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterStringTypeColumnOnCallTable)
	}
	if j.typ == "FilterStringArrayTypeColumnOnCallTable" || j.FilterStringArrayTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterStringArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberTypeColumnOnCallTable" || j.FilterNumberTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterNumberTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberArrayTypeColumnOnCallTable" || j.FilterNumberArrayTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterNumberArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterDateTypeColumnOnCallTable" || j.FilterDateTypeColumnOnCallTable != nil {
		return json.Marshal(j.FilterDateTypeColumnOnCallTable)
	}
	if j.typ == "FilterStructuredOutputColumnOnCallTable" || j.FilterStructuredOutputColumnOnCallTable != nil {
		return json.Marshal(j.FilterStructuredOutputColumnOnCallTable)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JsonQueryOnCallTableWithStructuredOutputColumnFiltersItemVisitor interface {
	VisitFilterStringTypeColumnOnCallTable(*FilterStringTypeColumnOnCallTable) error
	VisitFilterStringArrayTypeColumnOnCallTable(*FilterStringArrayTypeColumnOnCallTable) error
	VisitFilterNumberTypeColumnOnCallTable(*FilterNumberTypeColumnOnCallTable) error
	VisitFilterNumberArrayTypeColumnOnCallTable(*FilterNumberArrayTypeColumnOnCallTable) error
	VisitFilterDateTypeColumnOnCallTable(*FilterDateTypeColumnOnCallTable) error
	VisitFilterStructuredOutputColumnOnCallTable(*FilterStructuredOutputColumnOnCallTable) error
}

func (j *JsonQueryOnCallTableWithStructuredOutputColumnFiltersItem) Accept(visitor JsonQueryOnCallTableWithStructuredOutputColumnFiltersItemVisitor) error {
	if j.typ == "FilterStringTypeColumnOnCallTable" || j.FilterStringTypeColumnOnCallTable != nil {
		return visitor.VisitFilterStringTypeColumnOnCallTable(j.FilterStringTypeColumnOnCallTable)
	}
	if j.typ == "FilterStringArrayTypeColumnOnCallTable" || j.FilterStringArrayTypeColumnOnCallTable != nil {
		return visitor.VisitFilterStringArrayTypeColumnOnCallTable(j.FilterStringArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberTypeColumnOnCallTable" || j.FilterNumberTypeColumnOnCallTable != nil {
		return visitor.VisitFilterNumberTypeColumnOnCallTable(j.FilterNumberTypeColumnOnCallTable)
	}
	if j.typ == "FilterNumberArrayTypeColumnOnCallTable" || j.FilterNumberArrayTypeColumnOnCallTable != nil {
		return visitor.VisitFilterNumberArrayTypeColumnOnCallTable(j.FilterNumberArrayTypeColumnOnCallTable)
	}
	if j.typ == "FilterDateTypeColumnOnCallTable" || j.FilterDateTypeColumnOnCallTable != nil {
		return visitor.VisitFilterDateTypeColumnOnCallTable(j.FilterDateTypeColumnOnCallTable)
	}
	if j.typ == "FilterStructuredOutputColumnOnCallTable" || j.FilterStructuredOutputColumnOnCallTable != nil {
		return visitor.VisitFilterStructuredOutputColumnOnCallTable(j.FilterStructuredOutputColumnOnCallTable)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// This is the aggregation operation to perform on the column.
// When the column is a structured output type, the operation depends on the value of the structured output.
// If the structured output is a string or boolean, the operation must be "count".
// If the structured output is a number, the operation can be "average", "sum", "min", or "max".
type JsonQueryOnCallTableWithStructuredOutputColumnOperation string

const (
	JsonQueryOnCallTableWithStructuredOutputColumnOperationAverage JsonQueryOnCallTableWithStructuredOutputColumnOperation = "average"
	JsonQueryOnCallTableWithStructuredOutputColumnOperationCount   JsonQueryOnCallTableWithStructuredOutputColumnOperation = "count"
	JsonQueryOnCallTableWithStructuredOutputColumnOperationSum     JsonQueryOnCallTableWithStructuredOutputColumnOperation = "sum"
	JsonQueryOnCallTableWithStructuredOutputColumnOperationMin     JsonQueryOnCallTableWithStructuredOutputColumnOperation = "min"
	JsonQueryOnCallTableWithStructuredOutputColumnOperationMax     JsonQueryOnCallTableWithStructuredOutputColumnOperation = "max"
)

func NewJsonQueryOnCallTableWithStructuredOutputColumnOperationFromString(s string) (JsonQueryOnCallTableWithStructuredOutputColumnOperation, error) {
	switch s {
	case "average":
		return JsonQueryOnCallTableWithStructuredOutputColumnOperationAverage, nil
	case "count":
		return JsonQueryOnCallTableWithStructuredOutputColumnOperationCount, nil
	case "sum":
		return JsonQueryOnCallTableWithStructuredOutputColumnOperationSum, nil
	case "min":
		return JsonQueryOnCallTableWithStructuredOutputColumnOperationMin, nil
	case "max":
		return JsonQueryOnCallTableWithStructuredOutputColumnOperationMax, nil
	}
	var t JsonQueryOnCallTableWithStructuredOutputColumnOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithStructuredOutputColumnOperation) Ptr() *JsonQueryOnCallTableWithStructuredOutputColumnOperation {
	return &j
}

// This is the table that will be queried.
type JsonQueryOnCallTableWithStructuredOutputColumnTable string

const (
	JsonQueryOnCallTableWithStructuredOutputColumnTableCall JsonQueryOnCallTableWithStructuredOutputColumnTable = "call"
)

func NewJsonQueryOnCallTableWithStructuredOutputColumnTableFromString(s string) (JsonQueryOnCallTableWithStructuredOutputColumnTable, error) {
	switch s {
	case "call":
		return JsonQueryOnCallTableWithStructuredOutputColumnTableCall, nil
	}
	var t JsonQueryOnCallTableWithStructuredOutputColumnTable
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithStructuredOutputColumnTable) Ptr() *JsonQueryOnCallTableWithStructuredOutputColumnTable {
	return &j
}

// This is the type of query. Only allowed type is "vapiql-json".
type JsonQueryOnCallTableWithStructuredOutputColumnType string

const (
	JsonQueryOnCallTableWithStructuredOutputColumnTypeVapiqlJson JsonQueryOnCallTableWithStructuredOutputColumnType = "vapiql-json"
)

func NewJsonQueryOnCallTableWithStructuredOutputColumnTypeFromString(s string) (JsonQueryOnCallTableWithStructuredOutputColumnType, error) {
	switch s {
	case "vapiql-json":
		return JsonQueryOnCallTableWithStructuredOutputColumnTypeVapiqlJson, nil
	}
	var t JsonQueryOnCallTableWithStructuredOutputColumnType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonQueryOnCallTableWithStructuredOutputColumnType) Ptr() *JsonQueryOnCallTableWithStructuredOutputColumnType {
	return &j
}

var (
	lineInsightFieldName      = big.NewInt(1 << 0)
	lineInsightFieldFormulas  = big.NewInt(1 << 1)
	lineInsightFieldMetadata  = big.NewInt(1 << 2)
	lineInsightFieldTimeRange = big.NewInt(1 << 3)
	lineInsightFieldGroupBy   = big.NewInt(1 << 4)
	lineInsightFieldQueries   = big.NewInt(1 << 5)
	lineInsightFieldId        = big.NewInt(1 << 6)
	lineInsightFieldOrgId     = big.NewInt(1 << 7)
	lineInsightFieldCreatedAt = big.NewInt(1 << 8)
	lineInsightFieldUpdatedAt = big.NewInt(1 << 9)
)

type LineInsight struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formulas []*InsightFormula `json:"formulas,omitempty" url:"formulas,omitempty"`
	// This is the metadata for the insight.
	Metadata  *LineInsightMetadata      `json:"metadata,omitempty" url:"metadata,omitempty"`
	TimeRange *InsightTimeRangeWithStep `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the group by column for the insight when table is `call`.
	// These are the columns to group the results by.
	// All results are grouped by the time range step by default.
	GroupBy *LineInsightGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// These are the queries to run to generate the insight.
	Queries []*LineInsightQueriesItem `json:"queries" url:"queries"`
	// This is the unique identifier for the Insight.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this Insight belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the Insight was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the Insight was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LineInsight) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LineInsight) GetFormulas() []*InsightFormula {
	if l == nil {
		return nil
	}
	return l.Formulas
}

func (l *LineInsight) GetMetadata() *LineInsightMetadata {
	if l == nil {
		return nil
	}
	return l.Metadata
}

func (l *LineInsight) GetTimeRange() *InsightTimeRangeWithStep {
	if l == nil {
		return nil
	}
	return l.TimeRange
}

func (l *LineInsight) GetGroupBy() *LineInsightGroupBy {
	if l == nil {
		return nil
	}
	return l.GroupBy
}

func (l *LineInsight) GetQueries() []*LineInsightQueriesItem {
	if l == nil {
		return nil
	}
	return l.Queries
}

func (l *LineInsight) GetId() string {
	if l == nil {
		return ""
	}
	return l.Id
}

func (l *LineInsight) GetOrgId() string {
	if l == nil {
		return ""
	}
	return l.OrgId
}

func (l *LineInsight) GetCreatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.CreatedAt
}

func (l *LineInsight) GetUpdatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.UpdatedAt
}

func (l *LineInsight) Type() string {
	return l.type_
}

func (l *LineInsight) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LineInsight) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsight) SetName(name *string) {
	l.Name = name
	l.require(lineInsightFieldName)
}

// SetFormulas sets the Formulas field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsight) SetFormulas(formulas []*InsightFormula) {
	l.Formulas = formulas
	l.require(lineInsightFieldFormulas)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsight) SetMetadata(metadata *LineInsightMetadata) {
	l.Metadata = metadata
	l.require(lineInsightFieldMetadata)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsight) SetTimeRange(timeRange *InsightTimeRangeWithStep) {
	l.TimeRange = timeRange
	l.require(lineInsightFieldTimeRange)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsight) SetGroupBy(groupBy *LineInsightGroupBy) {
	l.GroupBy = groupBy
	l.require(lineInsightFieldGroupBy)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsight) SetQueries(queries []*LineInsightQueriesItem) {
	l.Queries = queries
	l.require(lineInsightFieldQueries)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsight) SetId(id string) {
	l.Id = id
	l.require(lineInsightFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsight) SetOrgId(orgId string) {
	l.OrgId = orgId
	l.require(lineInsightFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsight) SetCreatedAt(createdAt time.Time) {
	l.CreatedAt = createdAt
	l.require(lineInsightFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsight) SetUpdatedAt(updatedAt time.Time) {
	l.UpdatedAt = updatedAt
	l.require(lineInsightFieldUpdatedAt)
}

func (l *LineInsight) UnmarshalJSON(data []byte) error {
	type embed LineInsight
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LineInsight(unmarshaler.embed)
	l.CreatedAt = unmarshaler.CreatedAt.Time()
	l.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "line" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "line", unmarshaler.Type)
	}
	l.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *l, "type")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LineInsight) MarshalJSON() ([]byte, error) {
	type embed LineInsight
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*l),
		CreatedAt: internal.NewDateTime(l.CreatedAt),
		UpdatedAt: internal.NewDateTime(l.UpdatedAt),
		Type:      "line",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LineInsight) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// This is the group by column for the insight when table is `call`.
// These are the columns to group the results by.
// All results are grouped by the time range step by default.
type LineInsightGroupBy string

const (
	LineInsightGroupByAssistantId                       LineInsightGroupBy = "assistantId"
	LineInsightGroupByWorkflowId                        LineInsightGroupBy = "workflowId"
	LineInsightGroupBySquadId                           LineInsightGroupBy = "squadId"
	LineInsightGroupByPhoneNumberId                     LineInsightGroupBy = "phoneNumberId"
	LineInsightGroupByType                              LineInsightGroupBy = "type"
	LineInsightGroupByEndedReason                       LineInsightGroupBy = "endedReason"
	LineInsightGroupByCampaignId                        LineInsightGroupBy = "campaignId"
	LineInsightGroupByArtifactStructuredOutputsOutputId LineInsightGroupBy = "artifact.structuredOutputs[OutputID]"
)

func NewLineInsightGroupByFromString(s string) (LineInsightGroupBy, error) {
	switch s {
	case "assistantId":
		return LineInsightGroupByAssistantId, nil
	case "workflowId":
		return LineInsightGroupByWorkflowId, nil
	case "squadId":
		return LineInsightGroupBySquadId, nil
	case "phoneNumberId":
		return LineInsightGroupByPhoneNumberId, nil
	case "type":
		return LineInsightGroupByType, nil
	case "endedReason":
		return LineInsightGroupByEndedReason, nil
	case "campaignId":
		return LineInsightGroupByCampaignId, nil
	case "artifact.structuredOutputs[OutputID]":
		return LineInsightGroupByArtifactStructuredOutputsOutputId, nil
	}
	var t LineInsightGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LineInsightGroupBy) Ptr() *LineInsightGroupBy {
	return &l
}

var (
	lineInsightMetadataFieldXAxisLabel = big.NewInt(1 << 0)
	lineInsightMetadataFieldYAxisLabel = big.NewInt(1 << 1)
	lineInsightMetadataFieldYAxisMin   = big.NewInt(1 << 2)
	lineInsightMetadataFieldYAxisMax   = big.NewInt(1 << 3)
	lineInsightMetadataFieldName       = big.NewInt(1 << 4)
)

type LineInsightMetadata struct {
	XAxisLabel *string  `json:"xAxisLabel,omitempty" url:"xAxisLabel,omitempty"`
	YAxisLabel *string  `json:"yAxisLabel,omitempty" url:"yAxisLabel,omitempty"`
	YAxisMin   *float64 `json:"yAxisMin,omitempty" url:"yAxisMin,omitempty"`
	YAxisMax   *float64 `json:"yAxisMax,omitempty" url:"yAxisMax,omitempty"`
	Name       *string  `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LineInsightMetadata) GetXAxisLabel() *string {
	if l == nil {
		return nil
	}
	return l.XAxisLabel
}

func (l *LineInsightMetadata) GetYAxisLabel() *string {
	if l == nil {
		return nil
	}
	return l.YAxisLabel
}

func (l *LineInsightMetadata) GetYAxisMin() *float64 {
	if l == nil {
		return nil
	}
	return l.YAxisMin
}

func (l *LineInsightMetadata) GetYAxisMax() *float64 {
	if l == nil {
		return nil
	}
	return l.YAxisMax
}

func (l *LineInsightMetadata) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LineInsightMetadata) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LineInsightMetadata) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetXAxisLabel sets the XAxisLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsightMetadata) SetXAxisLabel(xAxisLabel *string) {
	l.XAxisLabel = xAxisLabel
	l.require(lineInsightMetadataFieldXAxisLabel)
}

// SetYAxisLabel sets the YAxisLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsightMetadata) SetYAxisLabel(yAxisLabel *string) {
	l.YAxisLabel = yAxisLabel
	l.require(lineInsightMetadataFieldYAxisLabel)
}

// SetYAxisMin sets the YAxisMin field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsightMetadata) SetYAxisMin(yAxisMin *float64) {
	l.YAxisMin = yAxisMin
	l.require(lineInsightMetadataFieldYAxisMin)
}

// SetYAxisMax sets the YAxisMax field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsightMetadata) SetYAxisMax(yAxisMax *float64) {
	l.YAxisMax = yAxisMax
	l.require(lineInsightMetadataFieldYAxisMax)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineInsightMetadata) SetName(name *string) {
	l.Name = name
	l.require(lineInsightMetadataFieldName)
}

func (l *LineInsightMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler LineInsightMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LineInsightMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LineInsightMetadata) MarshalJSON() ([]byte, error) {
	type embed LineInsightMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LineInsightMetadata) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LineInsightQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (l *LineInsightQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if l == nil {
		return nil
	}
	return l.JsonQueryOnCallTableWithStringTypeColumn
}

func (l *LineInsightQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if l == nil {
		return nil
	}
	return l.JsonQueryOnCallTableWithNumberTypeColumn
}

func (l *LineInsightQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if l == nil {
		return nil
	}
	return l.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (l *LineInsightQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		l.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		l.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		l.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		l.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		l.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		l.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LineInsightQueriesItem) MarshalJSON() ([]byte, error) {
	if l.typ == "JsonQueryOnCallTableWithStringTypeColumn" || l.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(l.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if l.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || l.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(l.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if l.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || l.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(l.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LineInsightQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (l *LineInsightQueriesItem) Accept(visitor LineInsightQueriesItemVisitor) error {
	if l.typ == "JsonQueryOnCallTableWithStringTypeColumn" || l.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(l.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if l.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || l.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(l.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if l.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || l.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(l.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

var (
	pieInsightFieldName      = big.NewInt(1 << 0)
	pieInsightFieldFormulas  = big.NewInt(1 << 1)
	pieInsightFieldTimeRange = big.NewInt(1 << 2)
	pieInsightFieldGroupBy   = big.NewInt(1 << 3)
	pieInsightFieldQueries   = big.NewInt(1 << 4)
	pieInsightFieldId        = big.NewInt(1 << 5)
	pieInsightFieldOrgId     = big.NewInt(1 << 6)
	pieInsightFieldCreatedAt = big.NewInt(1 << 7)
	pieInsightFieldUpdatedAt = big.NewInt(1 << 8)
)

type PieInsight struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formulas  []*InsightFormula `json:"formulas,omitempty" url:"formulas,omitempty"`
	TimeRange *InsightTimeRange `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the group by column for the insight when table is `call`.
	// These are the columns to group the results by.
	// All results are grouped by the time range step by default.
	GroupBy *PieInsightGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// These are the queries to run to generate the insight.
	Queries []*PieInsightQueriesItem `json:"queries" url:"queries"`
	// This is the unique identifier for the Insight.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this Insight belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the Insight was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the Insight was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PieInsight) GetName() *string {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PieInsight) GetFormulas() []*InsightFormula {
	if p == nil {
		return nil
	}
	return p.Formulas
}

func (p *PieInsight) GetTimeRange() *InsightTimeRange {
	if p == nil {
		return nil
	}
	return p.TimeRange
}

func (p *PieInsight) GetGroupBy() *PieInsightGroupBy {
	if p == nil {
		return nil
	}
	return p.GroupBy
}

func (p *PieInsight) GetQueries() []*PieInsightQueriesItem {
	if p == nil {
		return nil
	}
	return p.Queries
}

func (p *PieInsight) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PieInsight) GetOrgId() string {
	if p == nil {
		return ""
	}
	return p.OrgId
}

func (p *PieInsight) GetCreatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.CreatedAt
}

func (p *PieInsight) GetUpdatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.UpdatedAt
}

func (p *PieInsight) Type() string {
	return p.type_
}

func (p *PieInsight) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PieInsight) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PieInsight) SetName(name *string) {
	p.Name = name
	p.require(pieInsightFieldName)
}

// SetFormulas sets the Formulas field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PieInsight) SetFormulas(formulas []*InsightFormula) {
	p.Formulas = formulas
	p.require(pieInsightFieldFormulas)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PieInsight) SetTimeRange(timeRange *InsightTimeRange) {
	p.TimeRange = timeRange
	p.require(pieInsightFieldTimeRange)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PieInsight) SetGroupBy(groupBy *PieInsightGroupBy) {
	p.GroupBy = groupBy
	p.require(pieInsightFieldGroupBy)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PieInsight) SetQueries(queries []*PieInsightQueriesItem) {
	p.Queries = queries
	p.require(pieInsightFieldQueries)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PieInsight) SetId(id string) {
	p.Id = id
	p.require(pieInsightFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PieInsight) SetOrgId(orgId string) {
	p.OrgId = orgId
	p.require(pieInsightFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PieInsight) SetCreatedAt(createdAt time.Time) {
	p.CreatedAt = createdAt
	p.require(pieInsightFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PieInsight) SetUpdatedAt(updatedAt time.Time) {
	p.UpdatedAt = updatedAt
	p.require(pieInsightFieldUpdatedAt)
}

func (p *PieInsight) UnmarshalJSON(data []byte) error {
	type embed PieInsight
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PieInsight(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "pie" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "pie", unmarshaler.Type)
	}
	p.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "type")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PieInsight) MarshalJSON() ([]byte, error) {
	type embed PieInsight
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*p),
		CreatedAt: internal.NewDateTime(p.CreatedAt),
		UpdatedAt: internal.NewDateTime(p.UpdatedAt),
		Type:      "pie",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PieInsight) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// This is the group by column for the insight when table is `call`.
// These are the columns to group the results by.
// All results are grouped by the time range step by default.
type PieInsightGroupBy string

const (
	PieInsightGroupByAssistantId                       PieInsightGroupBy = "assistantId"
	PieInsightGroupByWorkflowId                        PieInsightGroupBy = "workflowId"
	PieInsightGroupBySquadId                           PieInsightGroupBy = "squadId"
	PieInsightGroupByPhoneNumberId                     PieInsightGroupBy = "phoneNumberId"
	PieInsightGroupByType                              PieInsightGroupBy = "type"
	PieInsightGroupByEndedReason                       PieInsightGroupBy = "endedReason"
	PieInsightGroupByCampaignId                        PieInsightGroupBy = "campaignId"
	PieInsightGroupByArtifactStructuredOutputsOutputId PieInsightGroupBy = "artifact.structuredOutputs[OutputID]"
)

func NewPieInsightGroupByFromString(s string) (PieInsightGroupBy, error) {
	switch s {
	case "assistantId":
		return PieInsightGroupByAssistantId, nil
	case "workflowId":
		return PieInsightGroupByWorkflowId, nil
	case "squadId":
		return PieInsightGroupBySquadId, nil
	case "phoneNumberId":
		return PieInsightGroupByPhoneNumberId, nil
	case "type":
		return PieInsightGroupByType, nil
	case "endedReason":
		return PieInsightGroupByEndedReason, nil
	case "campaignId":
		return PieInsightGroupByCampaignId, nil
	case "artifact.structuredOutputs[OutputID]":
		return PieInsightGroupByArtifactStructuredOutputsOutputId, nil
	}
	var t PieInsightGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PieInsightGroupBy) Ptr() *PieInsightGroupBy {
	return &p
}

type PieInsightQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (p *PieInsightQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if p == nil {
		return nil
	}
	return p.JsonQueryOnCallTableWithStringTypeColumn
}

func (p *PieInsightQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if p == nil {
		return nil
	}
	return p.JsonQueryOnCallTableWithNumberTypeColumn
}

func (p *PieInsightQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if p == nil {
		return nil
	}
	return p.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (p *PieInsightQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		p.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		p.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		p.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		p.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		p.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		p.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PieInsightQueriesItem) MarshalJSON() ([]byte, error) {
	if p.typ == "JsonQueryOnCallTableWithStringTypeColumn" || p.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(p.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if p.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || p.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(p.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if p.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || p.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(p.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PieInsightQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (p *PieInsightQueriesItem) Accept(visitor PieInsightQueriesItemVisitor) error {
	if p.typ == "JsonQueryOnCallTableWithStringTypeColumn" || p.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(p.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if p.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || p.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(p.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if p.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || p.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(p.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

var (
	textInsightFieldName      = big.NewInt(1 << 0)
	textInsightFieldFormula   = big.NewInt(1 << 1)
	textInsightFieldTimeRange = big.NewInt(1 << 2)
	textInsightFieldQueries   = big.NewInt(1 << 3)
	textInsightFieldId        = big.NewInt(1 << 4)
	textInsightFieldOrgId     = big.NewInt(1 << 5)
	textInsightFieldCreatedAt = big.NewInt(1 << 6)
	textInsightFieldUpdatedAt = big.NewInt(1 << 7)
)

type TextInsight struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formula   map[string]interface{} `json:"formula,omitempty" url:"formula,omitempty"`
	TimeRange *InsightTimeRange      `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// These are the queries to run to generate the insight.
	// For Text Insights, we only allow a single query, or require a formula if multiple queries are provided
	Queries []*TextInsightQueriesItem `json:"queries" url:"queries"`
	// This is the unique identifier for the Insight.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this Insight belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the Insight was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the Insight was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TextInsight) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TextInsight) GetFormula() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Formula
}

func (t *TextInsight) GetTimeRange() *InsightTimeRange {
	if t == nil {
		return nil
	}
	return t.TimeRange
}

func (t *TextInsight) GetQueries() []*TextInsightQueriesItem {
	if t == nil {
		return nil
	}
	return t.Queries
}

func (t *TextInsight) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TextInsight) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TextInsight) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TextInsight) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TextInsight) Type() string {
	return t.type_
}

func (t *TextInsight) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TextInsight) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextInsight) SetName(name *string) {
	t.Name = name
	t.require(textInsightFieldName)
}

// SetFormula sets the Formula field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextInsight) SetFormula(formula map[string]interface{}) {
	t.Formula = formula
	t.require(textInsightFieldFormula)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextInsight) SetTimeRange(timeRange *InsightTimeRange) {
	t.TimeRange = timeRange
	t.require(textInsightFieldTimeRange)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextInsight) SetQueries(queries []*TextInsightQueriesItem) {
	t.Queries = queries
	t.require(textInsightFieldQueries)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextInsight) SetId(id string) {
	t.Id = id
	t.require(textInsightFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextInsight) SetOrgId(orgId string) {
	t.OrgId = orgId
	t.require(textInsightFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextInsight) SetCreatedAt(createdAt time.Time) {
	t.CreatedAt = createdAt
	t.require(textInsightFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextInsight) SetUpdatedAt(updatedAt time.Time) {
	t.UpdatedAt = updatedAt
	t.require(textInsightFieldUpdatedAt)
}

func (t *TextInsight) UnmarshalJSON(data []byte) error {
	type embed TextInsight
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TextInsight(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "text" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "text", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextInsight) MarshalJSON() ([]byte, error) {
	type embed TextInsight
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Type:      "text",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TextInsight) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextInsightQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (t *TextInsightQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if t == nil {
		return nil
	}
	return t.JsonQueryOnCallTableWithStringTypeColumn
}

func (t *TextInsightQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if t == nil {
		return nil
	}
	return t.JsonQueryOnCallTableWithNumberTypeColumn
}

func (t *TextInsightQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if t == nil {
		return nil
	}
	return t.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (t *TextInsightQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		t.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		t.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		t.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		t.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		t.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		t.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TextInsightQueriesItem) MarshalJSON() ([]byte, error) {
	if t.typ == "JsonQueryOnCallTableWithStringTypeColumn" || t.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(t.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if t.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || t.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(t.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if t.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || t.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(t.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TextInsightQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (t *TextInsightQueriesItem) Accept(visitor TextInsightQueriesItemVisitor) error {
	if t.typ == "JsonQueryOnCallTableWithStringTypeColumn" || t.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(t.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if t.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || t.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(t.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if t.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || t.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(t.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

var (
	updateBarInsightFromCallTableDtoFieldName      = big.NewInt(1 << 0)
	updateBarInsightFromCallTableDtoFieldFormulas  = big.NewInt(1 << 1)
	updateBarInsightFromCallTableDtoFieldMetadata  = big.NewInt(1 << 2)
	updateBarInsightFromCallTableDtoFieldTimeRange = big.NewInt(1 << 3)
	updateBarInsightFromCallTableDtoFieldGroupBy   = big.NewInt(1 << 4)
	updateBarInsightFromCallTableDtoFieldQueries   = big.NewInt(1 << 5)
)

type UpdateBarInsightFromCallTableDto struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formulas []*InsightFormula `json:"formulas,omitempty" url:"formulas,omitempty"`
	// This is the metadata for the insight.
	Metadata  *BarInsightMetadata       `json:"metadata,omitempty" url:"metadata,omitempty"`
	TimeRange *InsightTimeRangeWithStep `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the group by column for the insight when table is `call`.
	// These are the columns to group the results by.
	// All results are grouped by the time range step by default.
	GroupBy *UpdateBarInsightFromCallTableDtoGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// These are the queries to run to generate the insight.
	Queries []*UpdateBarInsightFromCallTableDtoQueriesItem `json:"queries,omitempty" url:"queries,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateBarInsightFromCallTableDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateBarInsightFromCallTableDto) GetFormulas() []*InsightFormula {
	if u == nil {
		return nil
	}
	return u.Formulas
}

func (u *UpdateBarInsightFromCallTableDto) GetMetadata() *BarInsightMetadata {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UpdateBarInsightFromCallTableDto) GetTimeRange() *InsightTimeRangeWithStep {
	if u == nil {
		return nil
	}
	return u.TimeRange
}

func (u *UpdateBarInsightFromCallTableDto) GetGroupBy() *UpdateBarInsightFromCallTableDtoGroupBy {
	if u == nil {
		return nil
	}
	return u.GroupBy
}

func (u *UpdateBarInsightFromCallTableDto) GetQueries() []*UpdateBarInsightFromCallTableDtoQueriesItem {
	if u == nil {
		return nil
	}
	return u.Queries
}

func (u *UpdateBarInsightFromCallTableDto) Type() string {
	return u.type_
}

func (u *UpdateBarInsightFromCallTableDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateBarInsightFromCallTableDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBarInsightFromCallTableDto) SetName(name *string) {
	u.Name = name
	u.require(updateBarInsightFromCallTableDtoFieldName)
}

// SetFormulas sets the Formulas field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBarInsightFromCallTableDto) SetFormulas(formulas []*InsightFormula) {
	u.Formulas = formulas
	u.require(updateBarInsightFromCallTableDtoFieldFormulas)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBarInsightFromCallTableDto) SetMetadata(metadata *BarInsightMetadata) {
	u.Metadata = metadata
	u.require(updateBarInsightFromCallTableDtoFieldMetadata)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBarInsightFromCallTableDto) SetTimeRange(timeRange *InsightTimeRangeWithStep) {
	u.TimeRange = timeRange
	u.require(updateBarInsightFromCallTableDtoFieldTimeRange)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBarInsightFromCallTableDto) SetGroupBy(groupBy *UpdateBarInsightFromCallTableDtoGroupBy) {
	u.GroupBy = groupBy
	u.require(updateBarInsightFromCallTableDtoFieldGroupBy)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBarInsightFromCallTableDto) SetQueries(queries []*UpdateBarInsightFromCallTableDtoQueriesItem) {
	u.Queries = queries
	u.require(updateBarInsightFromCallTableDtoFieldQueries)
}

func (u *UpdateBarInsightFromCallTableDto) UnmarshalJSON(data []byte) error {
	type embed UpdateBarInsightFromCallTableDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateBarInsightFromCallTableDto(unmarshaler.embed)
	if unmarshaler.Type != "bar" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "bar", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBarInsightFromCallTableDto) MarshalJSON() ([]byte, error) {
	type embed UpdateBarInsightFromCallTableDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "bar",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateBarInsightFromCallTableDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This is the group by column for the insight when table is `call`.
// These are the columns to group the results by.
// All results are grouped by the time range step by default.
type UpdateBarInsightFromCallTableDtoGroupBy string

const (
	UpdateBarInsightFromCallTableDtoGroupByAssistantId                       UpdateBarInsightFromCallTableDtoGroupBy = "assistantId"
	UpdateBarInsightFromCallTableDtoGroupByWorkflowId                        UpdateBarInsightFromCallTableDtoGroupBy = "workflowId"
	UpdateBarInsightFromCallTableDtoGroupBySquadId                           UpdateBarInsightFromCallTableDtoGroupBy = "squadId"
	UpdateBarInsightFromCallTableDtoGroupByPhoneNumberId                     UpdateBarInsightFromCallTableDtoGroupBy = "phoneNumberId"
	UpdateBarInsightFromCallTableDtoGroupByType                              UpdateBarInsightFromCallTableDtoGroupBy = "type"
	UpdateBarInsightFromCallTableDtoGroupByEndedReason                       UpdateBarInsightFromCallTableDtoGroupBy = "endedReason"
	UpdateBarInsightFromCallTableDtoGroupByCampaignId                        UpdateBarInsightFromCallTableDtoGroupBy = "campaignId"
	UpdateBarInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId UpdateBarInsightFromCallTableDtoGroupBy = "artifact.structuredOutputs[OutputID]"
)

func NewUpdateBarInsightFromCallTableDtoGroupByFromString(s string) (UpdateBarInsightFromCallTableDtoGroupBy, error) {
	switch s {
	case "assistantId":
		return UpdateBarInsightFromCallTableDtoGroupByAssistantId, nil
	case "workflowId":
		return UpdateBarInsightFromCallTableDtoGroupByWorkflowId, nil
	case "squadId":
		return UpdateBarInsightFromCallTableDtoGroupBySquadId, nil
	case "phoneNumberId":
		return UpdateBarInsightFromCallTableDtoGroupByPhoneNumberId, nil
	case "type":
		return UpdateBarInsightFromCallTableDtoGroupByType, nil
	case "endedReason":
		return UpdateBarInsightFromCallTableDtoGroupByEndedReason, nil
	case "campaignId":
		return UpdateBarInsightFromCallTableDtoGroupByCampaignId, nil
	case "artifact.structuredOutputs[OutputID]":
		return UpdateBarInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId, nil
	}
	var t UpdateBarInsightFromCallTableDtoGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateBarInsightFromCallTableDtoGroupBy) Ptr() *UpdateBarInsightFromCallTableDtoGroupBy {
	return &u
}

type UpdateBarInsightFromCallTableDtoQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (u *UpdateBarInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithStringTypeColumn
}

func (u *UpdateBarInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithNumberTypeColumn
}

func (u *UpdateBarInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (u *UpdateBarInsightFromCallTableDtoQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		u.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		u.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		u.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateBarInsightFromCallTableDtoQueriesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "JsonQueryOnCallTableWithStringTypeColumn" || u.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || u.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || u.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateBarInsightFromCallTableDtoQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (u *UpdateBarInsightFromCallTableDtoQueriesItem) Accept(visitor UpdateBarInsightFromCallTableDtoQueriesItemVisitor) error {
	if u.typ == "JsonQueryOnCallTableWithStringTypeColumn" || u.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(u.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || u.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(u.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || u.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(u.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateLineInsightFromCallTableDtoFieldName      = big.NewInt(1 << 0)
	updateLineInsightFromCallTableDtoFieldFormulas  = big.NewInt(1 << 1)
	updateLineInsightFromCallTableDtoFieldMetadata  = big.NewInt(1 << 2)
	updateLineInsightFromCallTableDtoFieldTimeRange = big.NewInt(1 << 3)
	updateLineInsightFromCallTableDtoFieldGroupBy   = big.NewInt(1 << 4)
	updateLineInsightFromCallTableDtoFieldQueries   = big.NewInt(1 << 5)
)

type UpdateLineInsightFromCallTableDto struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formulas []*InsightFormula `json:"formulas,omitempty" url:"formulas,omitempty"`
	// This is the metadata for the insight.
	Metadata  *LineInsightMetadata      `json:"metadata,omitempty" url:"metadata,omitempty"`
	TimeRange *InsightTimeRangeWithStep `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the group by column for the insight when table is `call`.
	// These are the columns to group the results by.
	// All results are grouped by the time range step by default.
	GroupBy *UpdateLineInsightFromCallTableDtoGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// These are the queries to run to generate the insight.
	Queries []*UpdateLineInsightFromCallTableDtoQueriesItem `json:"queries,omitempty" url:"queries,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateLineInsightFromCallTableDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateLineInsightFromCallTableDto) GetFormulas() []*InsightFormula {
	if u == nil {
		return nil
	}
	return u.Formulas
}

func (u *UpdateLineInsightFromCallTableDto) GetMetadata() *LineInsightMetadata {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UpdateLineInsightFromCallTableDto) GetTimeRange() *InsightTimeRangeWithStep {
	if u == nil {
		return nil
	}
	return u.TimeRange
}

func (u *UpdateLineInsightFromCallTableDto) GetGroupBy() *UpdateLineInsightFromCallTableDtoGroupBy {
	if u == nil {
		return nil
	}
	return u.GroupBy
}

func (u *UpdateLineInsightFromCallTableDto) GetQueries() []*UpdateLineInsightFromCallTableDtoQueriesItem {
	if u == nil {
		return nil
	}
	return u.Queries
}

func (u *UpdateLineInsightFromCallTableDto) Type() string {
	return u.type_
}

func (u *UpdateLineInsightFromCallTableDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateLineInsightFromCallTableDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateLineInsightFromCallTableDto) SetName(name *string) {
	u.Name = name
	u.require(updateLineInsightFromCallTableDtoFieldName)
}

// SetFormulas sets the Formulas field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateLineInsightFromCallTableDto) SetFormulas(formulas []*InsightFormula) {
	u.Formulas = formulas
	u.require(updateLineInsightFromCallTableDtoFieldFormulas)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateLineInsightFromCallTableDto) SetMetadata(metadata *LineInsightMetadata) {
	u.Metadata = metadata
	u.require(updateLineInsightFromCallTableDtoFieldMetadata)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateLineInsightFromCallTableDto) SetTimeRange(timeRange *InsightTimeRangeWithStep) {
	u.TimeRange = timeRange
	u.require(updateLineInsightFromCallTableDtoFieldTimeRange)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateLineInsightFromCallTableDto) SetGroupBy(groupBy *UpdateLineInsightFromCallTableDtoGroupBy) {
	u.GroupBy = groupBy
	u.require(updateLineInsightFromCallTableDtoFieldGroupBy)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateLineInsightFromCallTableDto) SetQueries(queries []*UpdateLineInsightFromCallTableDtoQueriesItem) {
	u.Queries = queries
	u.require(updateLineInsightFromCallTableDtoFieldQueries)
}

func (u *UpdateLineInsightFromCallTableDto) UnmarshalJSON(data []byte) error {
	type embed UpdateLineInsightFromCallTableDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateLineInsightFromCallTableDto(unmarshaler.embed)
	if unmarshaler.Type != "line" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "line", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateLineInsightFromCallTableDto) MarshalJSON() ([]byte, error) {
	type embed UpdateLineInsightFromCallTableDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "line",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateLineInsightFromCallTableDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This is the group by column for the insight when table is `call`.
// These are the columns to group the results by.
// All results are grouped by the time range step by default.
type UpdateLineInsightFromCallTableDtoGroupBy string

const (
	UpdateLineInsightFromCallTableDtoGroupByAssistantId                       UpdateLineInsightFromCallTableDtoGroupBy = "assistantId"
	UpdateLineInsightFromCallTableDtoGroupByWorkflowId                        UpdateLineInsightFromCallTableDtoGroupBy = "workflowId"
	UpdateLineInsightFromCallTableDtoGroupBySquadId                           UpdateLineInsightFromCallTableDtoGroupBy = "squadId"
	UpdateLineInsightFromCallTableDtoGroupByPhoneNumberId                     UpdateLineInsightFromCallTableDtoGroupBy = "phoneNumberId"
	UpdateLineInsightFromCallTableDtoGroupByType                              UpdateLineInsightFromCallTableDtoGroupBy = "type"
	UpdateLineInsightFromCallTableDtoGroupByEndedReason                       UpdateLineInsightFromCallTableDtoGroupBy = "endedReason"
	UpdateLineInsightFromCallTableDtoGroupByCampaignId                        UpdateLineInsightFromCallTableDtoGroupBy = "campaignId"
	UpdateLineInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId UpdateLineInsightFromCallTableDtoGroupBy = "artifact.structuredOutputs[OutputID]"
)

func NewUpdateLineInsightFromCallTableDtoGroupByFromString(s string) (UpdateLineInsightFromCallTableDtoGroupBy, error) {
	switch s {
	case "assistantId":
		return UpdateLineInsightFromCallTableDtoGroupByAssistantId, nil
	case "workflowId":
		return UpdateLineInsightFromCallTableDtoGroupByWorkflowId, nil
	case "squadId":
		return UpdateLineInsightFromCallTableDtoGroupBySquadId, nil
	case "phoneNumberId":
		return UpdateLineInsightFromCallTableDtoGroupByPhoneNumberId, nil
	case "type":
		return UpdateLineInsightFromCallTableDtoGroupByType, nil
	case "endedReason":
		return UpdateLineInsightFromCallTableDtoGroupByEndedReason, nil
	case "campaignId":
		return UpdateLineInsightFromCallTableDtoGroupByCampaignId, nil
	case "artifact.structuredOutputs[OutputID]":
		return UpdateLineInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId, nil
	}
	var t UpdateLineInsightFromCallTableDtoGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateLineInsightFromCallTableDtoGroupBy) Ptr() *UpdateLineInsightFromCallTableDtoGroupBy {
	return &u
}

type UpdateLineInsightFromCallTableDtoQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (u *UpdateLineInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithStringTypeColumn
}

func (u *UpdateLineInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithNumberTypeColumn
}

func (u *UpdateLineInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (u *UpdateLineInsightFromCallTableDtoQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		u.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		u.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		u.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateLineInsightFromCallTableDtoQueriesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "JsonQueryOnCallTableWithStringTypeColumn" || u.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || u.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || u.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateLineInsightFromCallTableDtoQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (u *UpdateLineInsightFromCallTableDtoQueriesItem) Accept(visitor UpdateLineInsightFromCallTableDtoQueriesItemVisitor) error {
	if u.typ == "JsonQueryOnCallTableWithStringTypeColumn" || u.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(u.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || u.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(u.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || u.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(u.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updatePieInsightFromCallTableDtoFieldName      = big.NewInt(1 << 0)
	updatePieInsightFromCallTableDtoFieldFormulas  = big.NewInt(1 << 1)
	updatePieInsightFromCallTableDtoFieldTimeRange = big.NewInt(1 << 2)
	updatePieInsightFromCallTableDtoFieldGroupBy   = big.NewInt(1 << 3)
	updatePieInsightFromCallTableDtoFieldQueries   = big.NewInt(1 << 4)
)

type UpdatePieInsightFromCallTableDto struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formulas  []*InsightFormula `json:"formulas,omitempty" url:"formulas,omitempty"`
	TimeRange *InsightTimeRange `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the group by column for the insight when table is `call`.
	// These are the columns to group the results by.
	// All results are grouped by the time range step by default.
	GroupBy *UpdatePieInsightFromCallTableDtoGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// These are the queries to run to generate the insight.
	Queries []*UpdatePieInsightFromCallTableDtoQueriesItem `json:"queries,omitempty" url:"queries,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdatePieInsightFromCallTableDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdatePieInsightFromCallTableDto) GetFormulas() []*InsightFormula {
	if u == nil {
		return nil
	}
	return u.Formulas
}

func (u *UpdatePieInsightFromCallTableDto) GetTimeRange() *InsightTimeRange {
	if u == nil {
		return nil
	}
	return u.TimeRange
}

func (u *UpdatePieInsightFromCallTableDto) GetGroupBy() *UpdatePieInsightFromCallTableDtoGroupBy {
	if u == nil {
		return nil
	}
	return u.GroupBy
}

func (u *UpdatePieInsightFromCallTableDto) GetQueries() []*UpdatePieInsightFromCallTableDtoQueriesItem {
	if u == nil {
		return nil
	}
	return u.Queries
}

func (u *UpdatePieInsightFromCallTableDto) Type() string {
	return u.type_
}

func (u *UpdatePieInsightFromCallTableDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePieInsightFromCallTableDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdatePieInsightFromCallTableDto) SetName(name *string) {
	u.Name = name
	u.require(updatePieInsightFromCallTableDtoFieldName)
}

// SetFormulas sets the Formulas field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdatePieInsightFromCallTableDto) SetFormulas(formulas []*InsightFormula) {
	u.Formulas = formulas
	u.require(updatePieInsightFromCallTableDtoFieldFormulas)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdatePieInsightFromCallTableDto) SetTimeRange(timeRange *InsightTimeRange) {
	u.TimeRange = timeRange
	u.require(updatePieInsightFromCallTableDtoFieldTimeRange)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdatePieInsightFromCallTableDto) SetGroupBy(groupBy *UpdatePieInsightFromCallTableDtoGroupBy) {
	u.GroupBy = groupBy
	u.require(updatePieInsightFromCallTableDtoFieldGroupBy)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdatePieInsightFromCallTableDto) SetQueries(queries []*UpdatePieInsightFromCallTableDtoQueriesItem) {
	u.Queries = queries
	u.require(updatePieInsightFromCallTableDtoFieldQueries)
}

func (u *UpdatePieInsightFromCallTableDto) UnmarshalJSON(data []byte) error {
	type embed UpdatePieInsightFromCallTableDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdatePieInsightFromCallTableDto(unmarshaler.embed)
	if unmarshaler.Type != "pie" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "pie", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePieInsightFromCallTableDto) MarshalJSON() ([]byte, error) {
	type embed UpdatePieInsightFromCallTableDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "pie",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdatePieInsightFromCallTableDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This is the group by column for the insight when table is `call`.
// These are the columns to group the results by.
// All results are grouped by the time range step by default.
type UpdatePieInsightFromCallTableDtoGroupBy string

const (
	UpdatePieInsightFromCallTableDtoGroupByAssistantId                       UpdatePieInsightFromCallTableDtoGroupBy = "assistantId"
	UpdatePieInsightFromCallTableDtoGroupByWorkflowId                        UpdatePieInsightFromCallTableDtoGroupBy = "workflowId"
	UpdatePieInsightFromCallTableDtoGroupBySquadId                           UpdatePieInsightFromCallTableDtoGroupBy = "squadId"
	UpdatePieInsightFromCallTableDtoGroupByPhoneNumberId                     UpdatePieInsightFromCallTableDtoGroupBy = "phoneNumberId"
	UpdatePieInsightFromCallTableDtoGroupByType                              UpdatePieInsightFromCallTableDtoGroupBy = "type"
	UpdatePieInsightFromCallTableDtoGroupByEndedReason                       UpdatePieInsightFromCallTableDtoGroupBy = "endedReason"
	UpdatePieInsightFromCallTableDtoGroupByCampaignId                        UpdatePieInsightFromCallTableDtoGroupBy = "campaignId"
	UpdatePieInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId UpdatePieInsightFromCallTableDtoGroupBy = "artifact.structuredOutputs[OutputID]"
)

func NewUpdatePieInsightFromCallTableDtoGroupByFromString(s string) (UpdatePieInsightFromCallTableDtoGroupBy, error) {
	switch s {
	case "assistantId":
		return UpdatePieInsightFromCallTableDtoGroupByAssistantId, nil
	case "workflowId":
		return UpdatePieInsightFromCallTableDtoGroupByWorkflowId, nil
	case "squadId":
		return UpdatePieInsightFromCallTableDtoGroupBySquadId, nil
	case "phoneNumberId":
		return UpdatePieInsightFromCallTableDtoGroupByPhoneNumberId, nil
	case "type":
		return UpdatePieInsightFromCallTableDtoGroupByType, nil
	case "endedReason":
		return UpdatePieInsightFromCallTableDtoGroupByEndedReason, nil
	case "campaignId":
		return UpdatePieInsightFromCallTableDtoGroupByCampaignId, nil
	case "artifact.structuredOutputs[OutputID]":
		return UpdatePieInsightFromCallTableDtoGroupByArtifactStructuredOutputsOutputId, nil
	}
	var t UpdatePieInsightFromCallTableDtoGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdatePieInsightFromCallTableDtoGroupBy) Ptr() *UpdatePieInsightFromCallTableDtoGroupBy {
	return &u
}

type UpdatePieInsightFromCallTableDtoQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (u *UpdatePieInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithStringTypeColumn
}

func (u *UpdatePieInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithNumberTypeColumn
}

func (u *UpdatePieInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (u *UpdatePieInsightFromCallTableDtoQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		u.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		u.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		u.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdatePieInsightFromCallTableDtoQueriesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "JsonQueryOnCallTableWithStringTypeColumn" || u.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || u.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || u.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdatePieInsightFromCallTableDtoQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (u *UpdatePieInsightFromCallTableDtoQueriesItem) Accept(visitor UpdatePieInsightFromCallTableDtoQueriesItemVisitor) error {
	if u.typ == "JsonQueryOnCallTableWithStringTypeColumn" || u.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(u.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || u.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(u.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || u.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(u.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateTextInsightFromCallTableDtoFieldName      = big.NewInt(1 << 0)
	updateTextInsightFromCallTableDtoFieldFormula   = big.NewInt(1 << 1)
	updateTextInsightFromCallTableDtoFieldTimeRange = big.NewInt(1 << 2)
	updateTextInsightFromCallTableDtoFieldQueries   = big.NewInt(1 << 3)
)

type UpdateTextInsightFromCallTableDto struct {
	// This is the name of the Insight.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Formulas are mathematical expressions applied on the data returned by the queries to transform them before being used to create the insight.
	// The formulas needs to be a valid mathematical expression, supported by MathJS - https://mathjs.org/docs/expressions/syntax.html
	// A formula is created by using the query names as the variable.
	// The formulas must contain at least one query name in the LiquidJS format {{query_name}} or {{['query name']}} which will be substituted with the query result.
	// For example, if you have 2 queries, 'Was Booking Made' and 'Average Call Duration', you can create a formula like this:
	// ```
	// {{['Query 1']}} / {{['Query 2']}} * 100
	// ```
	//
	// ```
	// ({{[Query 1]}} * 10) + {{[Query 2]}}
	// ```
	// This will take the
	//
	// You can also use the query names as the variable in the formula.
	Formula   map[string]interface{} `json:"formula,omitempty" url:"formula,omitempty"`
	TimeRange *InsightTimeRange      `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// These are the queries to run to generate the insight.
	// For Text Insights, we only allow a single query, or require a formula if multiple queries are provided
	Queries []*UpdateTextInsightFromCallTableDtoQueriesItem `json:"queries,omitempty" url:"queries,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTextInsightFromCallTableDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTextInsightFromCallTableDto) GetFormula() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Formula
}

func (u *UpdateTextInsightFromCallTableDto) GetTimeRange() *InsightTimeRange {
	if u == nil {
		return nil
	}
	return u.TimeRange
}

func (u *UpdateTextInsightFromCallTableDto) GetQueries() []*UpdateTextInsightFromCallTableDtoQueriesItem {
	if u == nil {
		return nil
	}
	return u.Queries
}

func (u *UpdateTextInsightFromCallTableDto) Type() string {
	return u.type_
}

func (u *UpdateTextInsightFromCallTableDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTextInsightFromCallTableDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTextInsightFromCallTableDto) SetName(name *string) {
	u.Name = name
	u.require(updateTextInsightFromCallTableDtoFieldName)
}

// SetFormula sets the Formula field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTextInsightFromCallTableDto) SetFormula(formula map[string]interface{}) {
	u.Formula = formula
	u.require(updateTextInsightFromCallTableDtoFieldFormula)
}

// SetTimeRange sets the TimeRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTextInsightFromCallTableDto) SetTimeRange(timeRange *InsightTimeRange) {
	u.TimeRange = timeRange
	u.require(updateTextInsightFromCallTableDtoFieldTimeRange)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTextInsightFromCallTableDto) SetQueries(queries []*UpdateTextInsightFromCallTableDtoQueriesItem) {
	u.Queries = queries
	u.require(updateTextInsightFromCallTableDtoFieldQueries)
}

func (u *UpdateTextInsightFromCallTableDto) UnmarshalJSON(data []byte) error {
	type embed UpdateTextInsightFromCallTableDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateTextInsightFromCallTableDto(unmarshaler.embed)
	if unmarshaler.Type != "text" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "text", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTextInsightFromCallTableDto) MarshalJSON() ([]byte, error) {
	type embed UpdateTextInsightFromCallTableDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "text",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateTextInsightFromCallTableDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTextInsightFromCallTableDtoQueriesItem struct {
	JsonQueryOnCallTableWithStringTypeColumn       *JsonQueryOnCallTableWithStringTypeColumn
	JsonQueryOnCallTableWithNumberTypeColumn       *JsonQueryOnCallTableWithNumberTypeColumn
	JsonQueryOnCallTableWithStructuredOutputColumn *JsonQueryOnCallTableWithStructuredOutputColumn

	typ string
}

func (u *UpdateTextInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStringTypeColumn() *JsonQueryOnCallTableWithStringTypeColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithStringTypeColumn
}

func (u *UpdateTextInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithNumberTypeColumn() *JsonQueryOnCallTableWithNumberTypeColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithNumberTypeColumn
}

func (u *UpdateTextInsightFromCallTableDtoQueriesItem) GetJsonQueryOnCallTableWithStructuredOutputColumn() *JsonQueryOnCallTableWithStructuredOutputColumn {
	if u == nil {
		return nil
	}
	return u.JsonQueryOnCallTableWithStructuredOutputColumn
}

func (u *UpdateTextInsightFromCallTableDtoQueriesItem) UnmarshalJSON(data []byte) error {
	valueJsonQueryOnCallTableWithStringTypeColumn := new(JsonQueryOnCallTableWithStringTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStringTypeColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithStringTypeColumn"
		u.JsonQueryOnCallTableWithStringTypeColumn = valueJsonQueryOnCallTableWithStringTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithNumberTypeColumn := new(JsonQueryOnCallTableWithNumberTypeColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithNumberTypeColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithNumberTypeColumn"
		u.JsonQueryOnCallTableWithNumberTypeColumn = valueJsonQueryOnCallTableWithNumberTypeColumn
		return nil
	}
	valueJsonQueryOnCallTableWithStructuredOutputColumn := new(JsonQueryOnCallTableWithStructuredOutputColumn)
	if err := json.Unmarshal(data, &valueJsonQueryOnCallTableWithStructuredOutputColumn); err == nil {
		u.typ = "JsonQueryOnCallTableWithStructuredOutputColumn"
		u.JsonQueryOnCallTableWithStructuredOutputColumn = valueJsonQueryOnCallTableWithStructuredOutputColumn
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateTextInsightFromCallTableDtoQueriesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "JsonQueryOnCallTableWithStringTypeColumn" || u.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || u.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || u.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return json.Marshal(u.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTextInsightFromCallTableDtoQueriesItemVisitor interface {
	VisitJsonQueryOnCallTableWithStringTypeColumn(*JsonQueryOnCallTableWithStringTypeColumn) error
	VisitJsonQueryOnCallTableWithNumberTypeColumn(*JsonQueryOnCallTableWithNumberTypeColumn) error
	VisitJsonQueryOnCallTableWithStructuredOutputColumn(*JsonQueryOnCallTableWithStructuredOutputColumn) error
}

func (u *UpdateTextInsightFromCallTableDtoQueriesItem) Accept(visitor UpdateTextInsightFromCallTableDtoQueriesItemVisitor) error {
	if u.typ == "JsonQueryOnCallTableWithStringTypeColumn" || u.JsonQueryOnCallTableWithStringTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStringTypeColumn(u.JsonQueryOnCallTableWithStringTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithNumberTypeColumn" || u.JsonQueryOnCallTableWithNumberTypeColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithNumberTypeColumn(u.JsonQueryOnCallTableWithNumberTypeColumn)
	}
	if u.typ == "JsonQueryOnCallTableWithStructuredOutputColumn" || u.JsonQueryOnCallTableWithStructuredOutputColumn != nil {
		return visitor.VisitJsonQueryOnCallTableWithStructuredOutputColumn(u.JsonQueryOnCallTableWithStructuredOutputColumn)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type InsightControllerCreateRequest struct {
	CreateBarInsightFromCallTableDto  *CreateBarInsightFromCallTableDto
	CreatePieInsightFromCallTableDto  *CreatePieInsightFromCallTableDto
	CreateLineInsightFromCallTableDto *CreateLineInsightFromCallTableDto
	CreateTextInsightFromCallTableDto *CreateTextInsightFromCallTableDto

	typ string
}

func (i *InsightControllerCreateRequest) GetCreateBarInsightFromCallTableDto() *CreateBarInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.CreateBarInsightFromCallTableDto
}

func (i *InsightControllerCreateRequest) GetCreatePieInsightFromCallTableDto() *CreatePieInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.CreatePieInsightFromCallTableDto
}

func (i *InsightControllerCreateRequest) GetCreateLineInsightFromCallTableDto() *CreateLineInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.CreateLineInsightFromCallTableDto
}

func (i *InsightControllerCreateRequest) GetCreateTextInsightFromCallTableDto() *CreateTextInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.CreateTextInsightFromCallTableDto
}

func (i *InsightControllerCreateRequest) UnmarshalJSON(data []byte) error {
	valueCreateBarInsightFromCallTableDto := new(CreateBarInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueCreateBarInsightFromCallTableDto); err == nil {
		i.typ = "CreateBarInsightFromCallTableDto"
		i.CreateBarInsightFromCallTableDto = valueCreateBarInsightFromCallTableDto
		return nil
	}
	valueCreatePieInsightFromCallTableDto := new(CreatePieInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueCreatePieInsightFromCallTableDto); err == nil {
		i.typ = "CreatePieInsightFromCallTableDto"
		i.CreatePieInsightFromCallTableDto = valueCreatePieInsightFromCallTableDto
		return nil
	}
	valueCreateLineInsightFromCallTableDto := new(CreateLineInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueCreateLineInsightFromCallTableDto); err == nil {
		i.typ = "CreateLineInsightFromCallTableDto"
		i.CreateLineInsightFromCallTableDto = valueCreateLineInsightFromCallTableDto
		return nil
	}
	valueCreateTextInsightFromCallTableDto := new(CreateTextInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueCreateTextInsightFromCallTableDto); err == nil {
		i.typ = "CreateTextInsightFromCallTableDto"
		i.CreateTextInsightFromCallTableDto = valueCreateTextInsightFromCallTableDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InsightControllerCreateRequest) MarshalJSON() ([]byte, error) {
	if i.typ == "CreateBarInsightFromCallTableDto" || i.CreateBarInsightFromCallTableDto != nil {
		return json.Marshal(i.CreateBarInsightFromCallTableDto)
	}
	if i.typ == "CreatePieInsightFromCallTableDto" || i.CreatePieInsightFromCallTableDto != nil {
		return json.Marshal(i.CreatePieInsightFromCallTableDto)
	}
	if i.typ == "CreateLineInsightFromCallTableDto" || i.CreateLineInsightFromCallTableDto != nil {
		return json.Marshal(i.CreateLineInsightFromCallTableDto)
	}
	if i.typ == "CreateTextInsightFromCallTableDto" || i.CreateTextInsightFromCallTableDto != nil {
		return json.Marshal(i.CreateTextInsightFromCallTableDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerCreateRequestVisitor interface {
	VisitCreateBarInsightFromCallTableDto(*CreateBarInsightFromCallTableDto) error
	VisitCreatePieInsightFromCallTableDto(*CreatePieInsightFromCallTableDto) error
	VisitCreateLineInsightFromCallTableDto(*CreateLineInsightFromCallTableDto) error
	VisitCreateTextInsightFromCallTableDto(*CreateTextInsightFromCallTableDto) error
}

func (i *InsightControllerCreateRequest) Accept(visitor InsightControllerCreateRequestVisitor) error {
	if i.typ == "CreateBarInsightFromCallTableDto" || i.CreateBarInsightFromCallTableDto != nil {
		return visitor.VisitCreateBarInsightFromCallTableDto(i.CreateBarInsightFromCallTableDto)
	}
	if i.typ == "CreatePieInsightFromCallTableDto" || i.CreatePieInsightFromCallTableDto != nil {
		return visitor.VisitCreatePieInsightFromCallTableDto(i.CreatePieInsightFromCallTableDto)
	}
	if i.typ == "CreateLineInsightFromCallTableDto" || i.CreateLineInsightFromCallTableDto != nil {
		return visitor.VisitCreateLineInsightFromCallTableDto(i.CreateLineInsightFromCallTableDto)
	}
	if i.typ == "CreateTextInsightFromCallTableDto" || i.CreateTextInsightFromCallTableDto != nil {
		return visitor.VisitCreateTextInsightFromCallTableDto(i.CreateTextInsightFromCallTableDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerCreateResponse struct {
	BarInsight  *BarInsight
	PieInsight  *PieInsight
	LineInsight *LineInsight
	TextInsight *TextInsight

	typ string
}

func (i *InsightControllerCreateResponse) GetBarInsight() *BarInsight {
	if i == nil {
		return nil
	}
	return i.BarInsight
}

func (i *InsightControllerCreateResponse) GetPieInsight() *PieInsight {
	if i == nil {
		return nil
	}
	return i.PieInsight
}

func (i *InsightControllerCreateResponse) GetLineInsight() *LineInsight {
	if i == nil {
		return nil
	}
	return i.LineInsight
}

func (i *InsightControllerCreateResponse) GetTextInsight() *TextInsight {
	if i == nil {
		return nil
	}
	return i.TextInsight
}

func (i *InsightControllerCreateResponse) UnmarshalJSON(data []byte) error {
	valueBarInsight := new(BarInsight)
	if err := json.Unmarshal(data, &valueBarInsight); err == nil {
		i.typ = "BarInsight"
		i.BarInsight = valueBarInsight
		return nil
	}
	valuePieInsight := new(PieInsight)
	if err := json.Unmarshal(data, &valuePieInsight); err == nil {
		i.typ = "PieInsight"
		i.PieInsight = valuePieInsight
		return nil
	}
	valueLineInsight := new(LineInsight)
	if err := json.Unmarshal(data, &valueLineInsight); err == nil {
		i.typ = "LineInsight"
		i.LineInsight = valueLineInsight
		return nil
	}
	valueTextInsight := new(TextInsight)
	if err := json.Unmarshal(data, &valueTextInsight); err == nil {
		i.typ = "TextInsight"
		i.TextInsight = valueTextInsight
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InsightControllerCreateResponse) MarshalJSON() ([]byte, error) {
	if i.typ == "BarInsight" || i.BarInsight != nil {
		return json.Marshal(i.BarInsight)
	}
	if i.typ == "PieInsight" || i.PieInsight != nil {
		return json.Marshal(i.PieInsight)
	}
	if i.typ == "LineInsight" || i.LineInsight != nil {
		return json.Marshal(i.LineInsight)
	}
	if i.typ == "TextInsight" || i.TextInsight != nil {
		return json.Marshal(i.TextInsight)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerCreateResponseVisitor interface {
	VisitBarInsight(*BarInsight) error
	VisitPieInsight(*PieInsight) error
	VisitLineInsight(*LineInsight) error
	VisitTextInsight(*TextInsight) error
}

func (i *InsightControllerCreateResponse) Accept(visitor InsightControllerCreateResponseVisitor) error {
	if i.typ == "BarInsight" || i.BarInsight != nil {
		return visitor.VisitBarInsight(i.BarInsight)
	}
	if i.typ == "PieInsight" || i.PieInsight != nil {
		return visitor.VisitPieInsight(i.PieInsight)
	}
	if i.typ == "LineInsight" || i.LineInsight != nil {
		return visitor.VisitLineInsight(i.LineInsight)
	}
	if i.typ == "TextInsight" || i.TextInsight != nil {
		return visitor.VisitTextInsight(i.TextInsight)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerFindAllRequestSortOrder string

const (
	InsightControllerFindAllRequestSortOrderAsc  InsightControllerFindAllRequestSortOrder = "ASC"
	InsightControllerFindAllRequestSortOrderDesc InsightControllerFindAllRequestSortOrder = "DESC"
)

func NewInsightControllerFindAllRequestSortOrderFromString(s string) (InsightControllerFindAllRequestSortOrder, error) {
	switch s {
	case "ASC":
		return InsightControllerFindAllRequestSortOrderAsc, nil
	case "DESC":
		return InsightControllerFindAllRequestSortOrderDesc, nil
	}
	var t InsightControllerFindAllRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InsightControllerFindAllRequestSortOrder) Ptr() *InsightControllerFindAllRequestSortOrder {
	return &i
}

type InsightControllerFindOneResponse struct {
	BarInsight  *BarInsight
	PieInsight  *PieInsight
	LineInsight *LineInsight
	TextInsight *TextInsight

	typ string
}

func (i *InsightControllerFindOneResponse) GetBarInsight() *BarInsight {
	if i == nil {
		return nil
	}
	return i.BarInsight
}

func (i *InsightControllerFindOneResponse) GetPieInsight() *PieInsight {
	if i == nil {
		return nil
	}
	return i.PieInsight
}

func (i *InsightControllerFindOneResponse) GetLineInsight() *LineInsight {
	if i == nil {
		return nil
	}
	return i.LineInsight
}

func (i *InsightControllerFindOneResponse) GetTextInsight() *TextInsight {
	if i == nil {
		return nil
	}
	return i.TextInsight
}

func (i *InsightControllerFindOneResponse) UnmarshalJSON(data []byte) error {
	valueBarInsight := new(BarInsight)
	if err := json.Unmarshal(data, &valueBarInsight); err == nil {
		i.typ = "BarInsight"
		i.BarInsight = valueBarInsight
		return nil
	}
	valuePieInsight := new(PieInsight)
	if err := json.Unmarshal(data, &valuePieInsight); err == nil {
		i.typ = "PieInsight"
		i.PieInsight = valuePieInsight
		return nil
	}
	valueLineInsight := new(LineInsight)
	if err := json.Unmarshal(data, &valueLineInsight); err == nil {
		i.typ = "LineInsight"
		i.LineInsight = valueLineInsight
		return nil
	}
	valueTextInsight := new(TextInsight)
	if err := json.Unmarshal(data, &valueTextInsight); err == nil {
		i.typ = "TextInsight"
		i.TextInsight = valueTextInsight
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InsightControllerFindOneResponse) MarshalJSON() ([]byte, error) {
	if i.typ == "BarInsight" || i.BarInsight != nil {
		return json.Marshal(i.BarInsight)
	}
	if i.typ == "PieInsight" || i.PieInsight != nil {
		return json.Marshal(i.PieInsight)
	}
	if i.typ == "LineInsight" || i.LineInsight != nil {
		return json.Marshal(i.LineInsight)
	}
	if i.typ == "TextInsight" || i.TextInsight != nil {
		return json.Marshal(i.TextInsight)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerFindOneResponseVisitor interface {
	VisitBarInsight(*BarInsight) error
	VisitPieInsight(*PieInsight) error
	VisitLineInsight(*LineInsight) error
	VisitTextInsight(*TextInsight) error
}

func (i *InsightControllerFindOneResponse) Accept(visitor InsightControllerFindOneResponseVisitor) error {
	if i.typ == "BarInsight" || i.BarInsight != nil {
		return visitor.VisitBarInsight(i.BarInsight)
	}
	if i.typ == "PieInsight" || i.PieInsight != nil {
		return visitor.VisitPieInsight(i.PieInsight)
	}
	if i.typ == "LineInsight" || i.LineInsight != nil {
		return visitor.VisitLineInsight(i.LineInsight)
	}
	if i.typ == "TextInsight" || i.TextInsight != nil {
		return visitor.VisitTextInsight(i.TextInsight)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerPreviewRequest struct {
	CreateBarInsightFromCallTableDto  *CreateBarInsightFromCallTableDto
	CreatePieInsightFromCallTableDto  *CreatePieInsightFromCallTableDto
	CreateLineInsightFromCallTableDto *CreateLineInsightFromCallTableDto
	CreateTextInsightFromCallTableDto *CreateTextInsightFromCallTableDto

	typ string
}

func (i *InsightControllerPreviewRequest) GetCreateBarInsightFromCallTableDto() *CreateBarInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.CreateBarInsightFromCallTableDto
}

func (i *InsightControllerPreviewRequest) GetCreatePieInsightFromCallTableDto() *CreatePieInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.CreatePieInsightFromCallTableDto
}

func (i *InsightControllerPreviewRequest) GetCreateLineInsightFromCallTableDto() *CreateLineInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.CreateLineInsightFromCallTableDto
}

func (i *InsightControllerPreviewRequest) GetCreateTextInsightFromCallTableDto() *CreateTextInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.CreateTextInsightFromCallTableDto
}

func (i *InsightControllerPreviewRequest) UnmarshalJSON(data []byte) error {
	valueCreateBarInsightFromCallTableDto := new(CreateBarInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueCreateBarInsightFromCallTableDto); err == nil {
		i.typ = "CreateBarInsightFromCallTableDto"
		i.CreateBarInsightFromCallTableDto = valueCreateBarInsightFromCallTableDto
		return nil
	}
	valueCreatePieInsightFromCallTableDto := new(CreatePieInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueCreatePieInsightFromCallTableDto); err == nil {
		i.typ = "CreatePieInsightFromCallTableDto"
		i.CreatePieInsightFromCallTableDto = valueCreatePieInsightFromCallTableDto
		return nil
	}
	valueCreateLineInsightFromCallTableDto := new(CreateLineInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueCreateLineInsightFromCallTableDto); err == nil {
		i.typ = "CreateLineInsightFromCallTableDto"
		i.CreateLineInsightFromCallTableDto = valueCreateLineInsightFromCallTableDto
		return nil
	}
	valueCreateTextInsightFromCallTableDto := new(CreateTextInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueCreateTextInsightFromCallTableDto); err == nil {
		i.typ = "CreateTextInsightFromCallTableDto"
		i.CreateTextInsightFromCallTableDto = valueCreateTextInsightFromCallTableDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InsightControllerPreviewRequest) MarshalJSON() ([]byte, error) {
	if i.typ == "CreateBarInsightFromCallTableDto" || i.CreateBarInsightFromCallTableDto != nil {
		return json.Marshal(i.CreateBarInsightFromCallTableDto)
	}
	if i.typ == "CreatePieInsightFromCallTableDto" || i.CreatePieInsightFromCallTableDto != nil {
		return json.Marshal(i.CreatePieInsightFromCallTableDto)
	}
	if i.typ == "CreateLineInsightFromCallTableDto" || i.CreateLineInsightFromCallTableDto != nil {
		return json.Marshal(i.CreateLineInsightFromCallTableDto)
	}
	if i.typ == "CreateTextInsightFromCallTableDto" || i.CreateTextInsightFromCallTableDto != nil {
		return json.Marshal(i.CreateTextInsightFromCallTableDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerPreviewRequestVisitor interface {
	VisitCreateBarInsightFromCallTableDto(*CreateBarInsightFromCallTableDto) error
	VisitCreatePieInsightFromCallTableDto(*CreatePieInsightFromCallTableDto) error
	VisitCreateLineInsightFromCallTableDto(*CreateLineInsightFromCallTableDto) error
	VisitCreateTextInsightFromCallTableDto(*CreateTextInsightFromCallTableDto) error
}

func (i *InsightControllerPreviewRequest) Accept(visitor InsightControllerPreviewRequestVisitor) error {
	if i.typ == "CreateBarInsightFromCallTableDto" || i.CreateBarInsightFromCallTableDto != nil {
		return visitor.VisitCreateBarInsightFromCallTableDto(i.CreateBarInsightFromCallTableDto)
	}
	if i.typ == "CreatePieInsightFromCallTableDto" || i.CreatePieInsightFromCallTableDto != nil {
		return visitor.VisitCreatePieInsightFromCallTableDto(i.CreatePieInsightFromCallTableDto)
	}
	if i.typ == "CreateLineInsightFromCallTableDto" || i.CreateLineInsightFromCallTableDto != nil {
		return visitor.VisitCreateLineInsightFromCallTableDto(i.CreateLineInsightFromCallTableDto)
	}
	if i.typ == "CreateTextInsightFromCallTableDto" || i.CreateTextInsightFromCallTableDto != nil {
		return visitor.VisitCreateTextInsightFromCallTableDto(i.CreateTextInsightFromCallTableDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerRemoveResponse struct {
	BarInsight  *BarInsight
	PieInsight  *PieInsight
	LineInsight *LineInsight
	TextInsight *TextInsight

	typ string
}

func (i *InsightControllerRemoveResponse) GetBarInsight() *BarInsight {
	if i == nil {
		return nil
	}
	return i.BarInsight
}

func (i *InsightControllerRemoveResponse) GetPieInsight() *PieInsight {
	if i == nil {
		return nil
	}
	return i.PieInsight
}

func (i *InsightControllerRemoveResponse) GetLineInsight() *LineInsight {
	if i == nil {
		return nil
	}
	return i.LineInsight
}

func (i *InsightControllerRemoveResponse) GetTextInsight() *TextInsight {
	if i == nil {
		return nil
	}
	return i.TextInsight
}

func (i *InsightControllerRemoveResponse) UnmarshalJSON(data []byte) error {
	valueBarInsight := new(BarInsight)
	if err := json.Unmarshal(data, &valueBarInsight); err == nil {
		i.typ = "BarInsight"
		i.BarInsight = valueBarInsight
		return nil
	}
	valuePieInsight := new(PieInsight)
	if err := json.Unmarshal(data, &valuePieInsight); err == nil {
		i.typ = "PieInsight"
		i.PieInsight = valuePieInsight
		return nil
	}
	valueLineInsight := new(LineInsight)
	if err := json.Unmarshal(data, &valueLineInsight); err == nil {
		i.typ = "LineInsight"
		i.LineInsight = valueLineInsight
		return nil
	}
	valueTextInsight := new(TextInsight)
	if err := json.Unmarshal(data, &valueTextInsight); err == nil {
		i.typ = "TextInsight"
		i.TextInsight = valueTextInsight
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InsightControllerRemoveResponse) MarshalJSON() ([]byte, error) {
	if i.typ == "BarInsight" || i.BarInsight != nil {
		return json.Marshal(i.BarInsight)
	}
	if i.typ == "PieInsight" || i.PieInsight != nil {
		return json.Marshal(i.PieInsight)
	}
	if i.typ == "LineInsight" || i.LineInsight != nil {
		return json.Marshal(i.LineInsight)
	}
	if i.typ == "TextInsight" || i.TextInsight != nil {
		return json.Marshal(i.TextInsight)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerRemoveResponseVisitor interface {
	VisitBarInsight(*BarInsight) error
	VisitPieInsight(*PieInsight) error
	VisitLineInsight(*LineInsight) error
	VisitTextInsight(*TextInsight) error
}

func (i *InsightControllerRemoveResponse) Accept(visitor InsightControllerRemoveResponseVisitor) error {
	if i.typ == "BarInsight" || i.BarInsight != nil {
		return visitor.VisitBarInsight(i.BarInsight)
	}
	if i.typ == "PieInsight" || i.PieInsight != nil {
		return visitor.VisitPieInsight(i.PieInsight)
	}
	if i.typ == "LineInsight" || i.LineInsight != nil {
		return visitor.VisitLineInsight(i.LineInsight)
	}
	if i.typ == "TextInsight" || i.TextInsight != nil {
		return visitor.VisitTextInsight(i.TextInsight)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerUpdateRequestBody struct {
	UpdateBarInsightFromCallTableDto  *UpdateBarInsightFromCallTableDto
	UpdatePieInsightFromCallTableDto  *UpdatePieInsightFromCallTableDto
	UpdateLineInsightFromCallTableDto *UpdateLineInsightFromCallTableDto
	UpdateTextInsightFromCallTableDto *UpdateTextInsightFromCallTableDto

	typ string
}

func (i *InsightControllerUpdateRequestBody) GetUpdateBarInsightFromCallTableDto() *UpdateBarInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.UpdateBarInsightFromCallTableDto
}

func (i *InsightControllerUpdateRequestBody) GetUpdatePieInsightFromCallTableDto() *UpdatePieInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.UpdatePieInsightFromCallTableDto
}

func (i *InsightControllerUpdateRequestBody) GetUpdateLineInsightFromCallTableDto() *UpdateLineInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.UpdateLineInsightFromCallTableDto
}

func (i *InsightControllerUpdateRequestBody) GetUpdateTextInsightFromCallTableDto() *UpdateTextInsightFromCallTableDto {
	if i == nil {
		return nil
	}
	return i.UpdateTextInsightFromCallTableDto
}

func (i *InsightControllerUpdateRequestBody) UnmarshalJSON(data []byte) error {
	valueUpdateBarInsightFromCallTableDto := new(UpdateBarInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueUpdateBarInsightFromCallTableDto); err == nil {
		i.typ = "UpdateBarInsightFromCallTableDto"
		i.UpdateBarInsightFromCallTableDto = valueUpdateBarInsightFromCallTableDto
		return nil
	}
	valueUpdatePieInsightFromCallTableDto := new(UpdatePieInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueUpdatePieInsightFromCallTableDto); err == nil {
		i.typ = "UpdatePieInsightFromCallTableDto"
		i.UpdatePieInsightFromCallTableDto = valueUpdatePieInsightFromCallTableDto
		return nil
	}
	valueUpdateLineInsightFromCallTableDto := new(UpdateLineInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueUpdateLineInsightFromCallTableDto); err == nil {
		i.typ = "UpdateLineInsightFromCallTableDto"
		i.UpdateLineInsightFromCallTableDto = valueUpdateLineInsightFromCallTableDto
		return nil
	}
	valueUpdateTextInsightFromCallTableDto := new(UpdateTextInsightFromCallTableDto)
	if err := json.Unmarshal(data, &valueUpdateTextInsightFromCallTableDto); err == nil {
		i.typ = "UpdateTextInsightFromCallTableDto"
		i.UpdateTextInsightFromCallTableDto = valueUpdateTextInsightFromCallTableDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InsightControllerUpdateRequestBody) MarshalJSON() ([]byte, error) {
	if i.typ == "UpdateBarInsightFromCallTableDto" || i.UpdateBarInsightFromCallTableDto != nil {
		return json.Marshal(i.UpdateBarInsightFromCallTableDto)
	}
	if i.typ == "UpdatePieInsightFromCallTableDto" || i.UpdatePieInsightFromCallTableDto != nil {
		return json.Marshal(i.UpdatePieInsightFromCallTableDto)
	}
	if i.typ == "UpdateLineInsightFromCallTableDto" || i.UpdateLineInsightFromCallTableDto != nil {
		return json.Marshal(i.UpdateLineInsightFromCallTableDto)
	}
	if i.typ == "UpdateTextInsightFromCallTableDto" || i.UpdateTextInsightFromCallTableDto != nil {
		return json.Marshal(i.UpdateTextInsightFromCallTableDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerUpdateRequestBodyVisitor interface {
	VisitUpdateBarInsightFromCallTableDto(*UpdateBarInsightFromCallTableDto) error
	VisitUpdatePieInsightFromCallTableDto(*UpdatePieInsightFromCallTableDto) error
	VisitUpdateLineInsightFromCallTableDto(*UpdateLineInsightFromCallTableDto) error
	VisitUpdateTextInsightFromCallTableDto(*UpdateTextInsightFromCallTableDto) error
}

func (i *InsightControllerUpdateRequestBody) Accept(visitor InsightControllerUpdateRequestBodyVisitor) error {
	if i.typ == "UpdateBarInsightFromCallTableDto" || i.UpdateBarInsightFromCallTableDto != nil {
		return visitor.VisitUpdateBarInsightFromCallTableDto(i.UpdateBarInsightFromCallTableDto)
	}
	if i.typ == "UpdatePieInsightFromCallTableDto" || i.UpdatePieInsightFromCallTableDto != nil {
		return visitor.VisitUpdatePieInsightFromCallTableDto(i.UpdatePieInsightFromCallTableDto)
	}
	if i.typ == "UpdateLineInsightFromCallTableDto" || i.UpdateLineInsightFromCallTableDto != nil {
		return visitor.VisitUpdateLineInsightFromCallTableDto(i.UpdateLineInsightFromCallTableDto)
	}
	if i.typ == "UpdateTextInsightFromCallTableDto" || i.UpdateTextInsightFromCallTableDto != nil {
		return visitor.VisitUpdateTextInsightFromCallTableDto(i.UpdateTextInsightFromCallTableDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerUpdateResponse struct {
	BarInsight  *BarInsight
	PieInsight  *PieInsight
	LineInsight *LineInsight
	TextInsight *TextInsight

	typ string
}

func (i *InsightControllerUpdateResponse) GetBarInsight() *BarInsight {
	if i == nil {
		return nil
	}
	return i.BarInsight
}

func (i *InsightControllerUpdateResponse) GetPieInsight() *PieInsight {
	if i == nil {
		return nil
	}
	return i.PieInsight
}

func (i *InsightControllerUpdateResponse) GetLineInsight() *LineInsight {
	if i == nil {
		return nil
	}
	return i.LineInsight
}

func (i *InsightControllerUpdateResponse) GetTextInsight() *TextInsight {
	if i == nil {
		return nil
	}
	return i.TextInsight
}

func (i *InsightControllerUpdateResponse) UnmarshalJSON(data []byte) error {
	valueBarInsight := new(BarInsight)
	if err := json.Unmarshal(data, &valueBarInsight); err == nil {
		i.typ = "BarInsight"
		i.BarInsight = valueBarInsight
		return nil
	}
	valuePieInsight := new(PieInsight)
	if err := json.Unmarshal(data, &valuePieInsight); err == nil {
		i.typ = "PieInsight"
		i.PieInsight = valuePieInsight
		return nil
	}
	valueLineInsight := new(LineInsight)
	if err := json.Unmarshal(data, &valueLineInsight); err == nil {
		i.typ = "LineInsight"
		i.LineInsight = valueLineInsight
		return nil
	}
	valueTextInsight := new(TextInsight)
	if err := json.Unmarshal(data, &valueTextInsight); err == nil {
		i.typ = "TextInsight"
		i.TextInsight = valueTextInsight
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InsightControllerUpdateResponse) MarshalJSON() ([]byte, error) {
	if i.typ == "BarInsight" || i.BarInsight != nil {
		return json.Marshal(i.BarInsight)
	}
	if i.typ == "PieInsight" || i.PieInsight != nil {
		return json.Marshal(i.PieInsight)
	}
	if i.typ == "LineInsight" || i.LineInsight != nil {
		return json.Marshal(i.LineInsight)
	}
	if i.typ == "TextInsight" || i.TextInsight != nil {
		return json.Marshal(i.TextInsight)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InsightControllerUpdateResponseVisitor interface {
	VisitBarInsight(*BarInsight) error
	VisitPieInsight(*PieInsight) error
	VisitLineInsight(*LineInsight) error
	VisitTextInsight(*TextInsight) error
}

func (i *InsightControllerUpdateResponse) Accept(visitor InsightControllerUpdateResponseVisitor) error {
	if i.typ == "BarInsight" || i.BarInsight != nil {
		return visitor.VisitBarInsight(i.BarInsight)
	}
	if i.typ == "PieInsight" || i.PieInsight != nil {
		return visitor.VisitPieInsight(i.PieInsight)
	}
	if i.typ == "LineInsight" || i.LineInsight != nil {
		return visitor.VisitLineInsight(i.LineInsight)
	}
	if i.typ == "TextInsight" || i.TextInsight != nil {
		return visitor.VisitTextInsight(i.TextInsight)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}
