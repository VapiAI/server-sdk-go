// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/VapiAI/server-sdk-go/internal"
	time "time"
)

type AssistantsListRequest struct {
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`
}

type Assistant struct {
	// These are the options for the assistant's transcriber.
	Transcriber *AssistantTranscriber `json:"transcriber,omitempty" url:"transcriber,omitempty"`
	// These are the options for the assistant's LLM.
	Model *AssistantModel `json:"model,omitempty" url:"model,omitempty"`
	// These are the options for the assistant's voice.
	Voice *AssistantVoice `json:"voice,omitempty" url:"voice,omitempty"`
	// This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
	//
	// If unspecified, assistant will wait for user to speak and use the model to respond once they speak.
	FirstMessage *string `json:"firstMessage,omitempty" url:"firstMessage,omitempty"`
	// This is the mode for the first message. Default is 'assistant-speaks-first'.
	//
	// Use:
	// - 'assistant-speaks-first' to have the assistant speak first.
	// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
	// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
	//
	// @default 'assistant-speaks-first'
	FirstMessageMode *AssistantFirstMessageMode `json:"firstMessageMode,omitempty" url:"firstMessageMode,omitempty"`
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input. You can check the shape of the messages in ClientMessage schema.
	ClientMessages []AssistantClientMessagesItem `json:"clientMessages,omitempty" url:"clientMessages,omitempty"`
	// These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
	ServerMessages []AssistantServerMessagesItem `json:"serverMessages,omitempty" url:"serverMessages,omitempty"`
	// How many seconds of silence to wait before ending the call. Defaults to 30.
	//
	// @default 30
	SilenceTimeoutSeconds *float64 `json:"silenceTimeoutSeconds,omitempty" url:"silenceTimeoutSeconds,omitempty"`
	// This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
	//
	// @default 600 (10 minutes)
	MaxDurationSeconds *float64 `json:"maxDurationSeconds,omitempty" url:"maxDurationSeconds,omitempty"`
	// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
	BackgroundSound *AssistantBackgroundSound `json:"backgroundSound,omitempty" url:"backgroundSound,omitempty"`
	// This enables filtering of noise and background speech while the user is talking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackgroundDenoisingEnabled *bool `json:"backgroundDenoisingEnabled,omitempty" url:"backgroundDenoisingEnabled,omitempty"`
	// This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
	//
	// Default `false` while in beta.
	//
	// @default false
	ModelOutputInMessagesEnabled *bool `json:"modelOutputInMessagesEnabled,omitempty" url:"modelOutputInMessagesEnabled,omitempty"`
	// These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
	TransportConfigurations []*TransportConfigurationTwilio `json:"transportConfigurations,omitempty" url:"transportConfigurations,omitempty"`
	// This is the name of the assistant.
	//
	// This is required when you want to transfer between assistants in a call.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
	// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
	// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
	VoicemailDetection *TwilioVoicemailDetection `json:"voicemailDetection,omitempty" url:"voicemailDetection,omitempty"`
	// This is the message that the assistant will say if the call is forwarded to voicemail.
	//
	// If unspecified, it will hang up.
	VoicemailMessage *string `json:"voicemailMessage,omitempty" url:"voicemailMessage,omitempty"`
	// This is the message that the assistant will say if it ends the call.
	//
	// If unspecified, it will hang up without saying anything.
	EndCallMessage *string `json:"endCallMessage,omitempty" url:"endCallMessage,omitempty"`
	// This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
	EndCallPhrases []string `json:"endCallPhrases,omitempty" url:"endCallPhrases,omitempty"`
	// This is for metadata you want to store on the assistant.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the plan for analysis of assistant's calls. Stored in `call.analysis`.
	AnalysisPlan *AnalysisPlan `json:"analysisPlan,omitempty" url:"analysisPlan,omitempty"`
	// This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.
	//
	// Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"artifactPlan,omitempty"`
	// This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.
	//
	// Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.
	MessagePlan *MessagePlan `json:"messagePlan,omitempty" url:"messagePlan,omitempty"`
	// This is the plan for when the assistant should start talking.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to start talking after the customer is done speaking.
	// - The assistant is too fast to start talking after the customer is done speaking.
	// - The assistant is so fast that it's actually interrupting the customer.
	StartSpeakingPlan *StartSpeakingPlan `json:"startSpeakingPlan,omitempty" url:"startSpeakingPlan,omitempty"`
	// This is the plan for when assistant should stop talking on customer interruption.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to recognize customer's interruption.
	// - The assistant is too fast to recognize customer's interruption.
	// - The assistant is getting interrupted by phrases that are just acknowledgments.
	// - The assistant is getting interrupted by background noises.
	// - The assistant is not properly stopping -- it starts talking right after getting interrupted.
	StopSpeakingPlan *StopSpeakingPlan `json:"stopSpeakingPlan,omitempty" url:"stopSpeakingPlan,omitempty"`
	// This is the plan for real-time monitoring of the assistant's calls.
	//
	// Usage:
	// - To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.
	// - To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.
	//
	// Note, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible
	MonitorPlan *MonitorPlan `json:"monitorPlan,omitempty" url:"monitorPlan,omitempty"`
	// These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
	CredentialIds []string `json:"credentialIds,omitempty" url:"credentialIds,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server.url
	// 2. phoneNumber.serverUrl
	// 3. org.serverUrl
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the unique identifier for the assistant.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this assistant belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the assistant was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Assistant) GetTranscriber() *AssistantTranscriber {
	if a == nil {
		return nil
	}
	return a.Transcriber
}

func (a *Assistant) GetModel() *AssistantModel {
	if a == nil {
		return nil
	}
	return a.Model
}

func (a *Assistant) GetVoice() *AssistantVoice {
	if a == nil {
		return nil
	}
	return a.Voice
}

func (a *Assistant) GetFirstMessage() *string {
	if a == nil {
		return nil
	}
	return a.FirstMessage
}

func (a *Assistant) GetFirstMessageMode() *AssistantFirstMessageMode {
	if a == nil {
		return nil
	}
	return a.FirstMessageMode
}

func (a *Assistant) GetHipaaEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.HipaaEnabled
}

func (a *Assistant) GetClientMessages() []AssistantClientMessagesItem {
	if a == nil {
		return nil
	}
	return a.ClientMessages
}

func (a *Assistant) GetServerMessages() []AssistantServerMessagesItem {
	if a == nil {
		return nil
	}
	return a.ServerMessages
}

func (a *Assistant) GetSilenceTimeoutSeconds() *float64 {
	if a == nil {
		return nil
	}
	return a.SilenceTimeoutSeconds
}

func (a *Assistant) GetMaxDurationSeconds() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxDurationSeconds
}

func (a *Assistant) GetBackgroundSound() *AssistantBackgroundSound {
	if a == nil {
		return nil
	}
	return a.BackgroundSound
}

func (a *Assistant) GetBackgroundDenoisingEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.BackgroundDenoisingEnabled
}

func (a *Assistant) GetModelOutputInMessagesEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.ModelOutputInMessagesEnabled
}

func (a *Assistant) GetTransportConfigurations() []*TransportConfigurationTwilio {
	if a == nil {
		return nil
	}
	return a.TransportConfigurations
}

func (a *Assistant) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *Assistant) GetVoicemailDetection() *TwilioVoicemailDetection {
	if a == nil {
		return nil
	}
	return a.VoicemailDetection
}

func (a *Assistant) GetVoicemailMessage() *string {
	if a == nil {
		return nil
	}
	return a.VoicemailMessage
}

func (a *Assistant) GetEndCallMessage() *string {
	if a == nil {
		return nil
	}
	return a.EndCallMessage
}

func (a *Assistant) GetEndCallPhrases() []string {
	if a == nil {
		return nil
	}
	return a.EndCallPhrases
}

func (a *Assistant) GetMetadata() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.Metadata
}

func (a *Assistant) GetAnalysisPlan() *AnalysisPlan {
	if a == nil {
		return nil
	}
	return a.AnalysisPlan
}

func (a *Assistant) GetArtifactPlan() *ArtifactPlan {
	if a == nil {
		return nil
	}
	return a.ArtifactPlan
}

func (a *Assistant) GetMessagePlan() *MessagePlan {
	if a == nil {
		return nil
	}
	return a.MessagePlan
}

func (a *Assistant) GetStartSpeakingPlan() *StartSpeakingPlan {
	if a == nil {
		return nil
	}
	return a.StartSpeakingPlan
}

func (a *Assistant) GetStopSpeakingPlan() *StopSpeakingPlan {
	if a == nil {
		return nil
	}
	return a.StopSpeakingPlan
}

func (a *Assistant) GetMonitorPlan() *MonitorPlan {
	if a == nil {
		return nil
	}
	return a.MonitorPlan
}

func (a *Assistant) GetCredentialIds() []string {
	if a == nil {
		return nil
	}
	return a.CredentialIds
}

func (a *Assistant) GetServer() *Server {
	if a == nil {
		return nil
	}
	return a.Server
}

func (a *Assistant) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *Assistant) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *Assistant) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *Assistant) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *Assistant) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Assistant) UnmarshalJSON(data []byte) error {
	type embed Assistant
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Assistant(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Assistant) MarshalJSON() ([]byte, error) {
	type embed Assistant
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Assistant) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
type AssistantBackgroundSound string

const (
	AssistantBackgroundSoundOff    AssistantBackgroundSound = "off"
	AssistantBackgroundSoundOffice AssistantBackgroundSound = "office"
)

func NewAssistantBackgroundSoundFromString(s string) (AssistantBackgroundSound, error) {
	switch s {
	case "off":
		return AssistantBackgroundSoundOff, nil
	case "office":
		return AssistantBackgroundSoundOffice, nil
	}
	var t AssistantBackgroundSound
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantBackgroundSound) Ptr() *AssistantBackgroundSound {
	return &a
}

type AssistantClientMessagesItem string

const (
	AssistantClientMessagesItemConversationUpdate AssistantClientMessagesItem = "conversation-update"
	AssistantClientMessagesItemFunctionCall       AssistantClientMessagesItem = "function-call"
	AssistantClientMessagesItemFunctionCallResult AssistantClientMessagesItem = "function-call-result"
	AssistantClientMessagesItemHang               AssistantClientMessagesItem = "hang"
	AssistantClientMessagesItemLanguageChanged    AssistantClientMessagesItem = "language-changed"
	AssistantClientMessagesItemMetadata           AssistantClientMessagesItem = "metadata"
	AssistantClientMessagesItemModelOutput        AssistantClientMessagesItem = "model-output"
	AssistantClientMessagesItemSpeechUpdate       AssistantClientMessagesItem = "speech-update"
	AssistantClientMessagesItemStatusUpdate       AssistantClientMessagesItem = "status-update"
	AssistantClientMessagesItemTranscript         AssistantClientMessagesItem = "transcript"
	AssistantClientMessagesItemToolCalls          AssistantClientMessagesItem = "tool-calls"
	AssistantClientMessagesItemToolCallsResult    AssistantClientMessagesItem = "tool-calls-result"
	AssistantClientMessagesItemTransferUpdate     AssistantClientMessagesItem = "transfer-update"
	AssistantClientMessagesItemUserInterrupted    AssistantClientMessagesItem = "user-interrupted"
	AssistantClientMessagesItemVoiceInput         AssistantClientMessagesItem = "voice-input"
)

func NewAssistantClientMessagesItemFromString(s string) (AssistantClientMessagesItem, error) {
	switch s {
	case "conversation-update":
		return AssistantClientMessagesItemConversationUpdate, nil
	case "function-call":
		return AssistantClientMessagesItemFunctionCall, nil
	case "function-call-result":
		return AssistantClientMessagesItemFunctionCallResult, nil
	case "hang":
		return AssistantClientMessagesItemHang, nil
	case "language-changed":
		return AssistantClientMessagesItemLanguageChanged, nil
	case "metadata":
		return AssistantClientMessagesItemMetadata, nil
	case "model-output":
		return AssistantClientMessagesItemModelOutput, nil
	case "speech-update":
		return AssistantClientMessagesItemSpeechUpdate, nil
	case "status-update":
		return AssistantClientMessagesItemStatusUpdate, nil
	case "transcript":
		return AssistantClientMessagesItemTranscript, nil
	case "tool-calls":
		return AssistantClientMessagesItemToolCalls, nil
	case "tool-calls-result":
		return AssistantClientMessagesItemToolCallsResult, nil
	case "transfer-update":
		return AssistantClientMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return AssistantClientMessagesItemUserInterrupted, nil
	case "voice-input":
		return AssistantClientMessagesItemVoiceInput, nil
	}
	var t AssistantClientMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantClientMessagesItem) Ptr() *AssistantClientMessagesItem {
	return &a
}

// This is the mode for the first message. Default is 'assistant-speaks-first'.
//
// Use:
// - 'assistant-speaks-first' to have the assistant speak first.
// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
//
// @default 'assistant-speaks-first'
type AssistantFirstMessageMode string

const (
	AssistantFirstMessageModeAssistantSpeaksFirst                          AssistantFirstMessageMode = "assistant-speaks-first"
	AssistantFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage AssistantFirstMessageMode = "assistant-speaks-first-with-model-generated-message"
	AssistantFirstMessageModeAssistantWaitsForUser                         AssistantFirstMessageMode = "assistant-waits-for-user"
)

func NewAssistantFirstMessageModeFromString(s string) (AssistantFirstMessageMode, error) {
	switch s {
	case "assistant-speaks-first":
		return AssistantFirstMessageModeAssistantSpeaksFirst, nil
	case "assistant-speaks-first-with-model-generated-message":
		return AssistantFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage, nil
	case "assistant-waits-for-user":
		return AssistantFirstMessageModeAssistantWaitsForUser, nil
	}
	var t AssistantFirstMessageMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantFirstMessageMode) Ptr() *AssistantFirstMessageMode {
	return &a
}

// These are the options for the assistant's LLM.
type AssistantModel struct {
	AnyscaleModel     *AnyscaleModel
	AnthropicModel    *AnthropicModel
	CustomLlmModel    *CustomLlmModel
	DeepInfraModel    *DeepInfraModel
	GoogleModel       *GoogleModel
	GroqModel         *GroqModel
	InflectionAiModel *InflectionAiModel
	OpenAiModel       *OpenAiModel
	OpenRouterModel   *OpenRouterModel
	PerplexityAiModel *PerplexityAiModel
	TogetherAiModel   *TogetherAiModel
	VapiModel         *VapiModel
	XaiModel          *XaiModel

	typ string
}

func (a *AssistantModel) GetAnyscaleModel() *AnyscaleModel {
	if a == nil {
		return nil
	}
	return a.AnyscaleModel
}

func (a *AssistantModel) GetAnthropicModel() *AnthropicModel {
	if a == nil {
		return nil
	}
	return a.AnthropicModel
}

func (a *AssistantModel) GetCustomLlmModel() *CustomLlmModel {
	if a == nil {
		return nil
	}
	return a.CustomLlmModel
}

func (a *AssistantModel) GetDeepInfraModel() *DeepInfraModel {
	if a == nil {
		return nil
	}
	return a.DeepInfraModel
}

func (a *AssistantModel) GetGoogleModel() *GoogleModel {
	if a == nil {
		return nil
	}
	return a.GoogleModel
}

func (a *AssistantModel) GetGroqModel() *GroqModel {
	if a == nil {
		return nil
	}
	return a.GroqModel
}

func (a *AssistantModel) GetInflectionAiModel() *InflectionAiModel {
	if a == nil {
		return nil
	}
	return a.InflectionAiModel
}

func (a *AssistantModel) GetOpenAiModel() *OpenAiModel {
	if a == nil {
		return nil
	}
	return a.OpenAiModel
}

func (a *AssistantModel) GetOpenRouterModel() *OpenRouterModel {
	if a == nil {
		return nil
	}
	return a.OpenRouterModel
}

func (a *AssistantModel) GetPerplexityAiModel() *PerplexityAiModel {
	if a == nil {
		return nil
	}
	return a.PerplexityAiModel
}

func (a *AssistantModel) GetTogetherAiModel() *TogetherAiModel {
	if a == nil {
		return nil
	}
	return a.TogetherAiModel
}

func (a *AssistantModel) GetVapiModel() *VapiModel {
	if a == nil {
		return nil
	}
	return a.VapiModel
}

func (a *AssistantModel) GetXaiModel() *XaiModel {
	if a == nil {
		return nil
	}
	return a.XaiModel
}

func (a *AssistantModel) UnmarshalJSON(data []byte) error {
	valueAnyscaleModel := new(AnyscaleModel)
	if err := json.Unmarshal(data, &valueAnyscaleModel); err == nil {
		a.typ = "AnyscaleModel"
		a.AnyscaleModel = valueAnyscaleModel
		return nil
	}
	valueAnthropicModel := new(AnthropicModel)
	if err := json.Unmarshal(data, &valueAnthropicModel); err == nil {
		a.typ = "AnthropicModel"
		a.AnthropicModel = valueAnthropicModel
		return nil
	}
	valueCustomLlmModel := new(CustomLlmModel)
	if err := json.Unmarshal(data, &valueCustomLlmModel); err == nil {
		a.typ = "CustomLlmModel"
		a.CustomLlmModel = valueCustomLlmModel
		return nil
	}
	valueDeepInfraModel := new(DeepInfraModel)
	if err := json.Unmarshal(data, &valueDeepInfraModel); err == nil {
		a.typ = "DeepInfraModel"
		a.DeepInfraModel = valueDeepInfraModel
		return nil
	}
	valueGoogleModel := new(GoogleModel)
	if err := json.Unmarshal(data, &valueGoogleModel); err == nil {
		a.typ = "GoogleModel"
		a.GoogleModel = valueGoogleModel
		return nil
	}
	valueGroqModel := new(GroqModel)
	if err := json.Unmarshal(data, &valueGroqModel); err == nil {
		a.typ = "GroqModel"
		a.GroqModel = valueGroqModel
		return nil
	}
	valueInflectionAiModel := new(InflectionAiModel)
	if err := json.Unmarshal(data, &valueInflectionAiModel); err == nil {
		a.typ = "InflectionAiModel"
		a.InflectionAiModel = valueInflectionAiModel
		return nil
	}
	valueOpenAiModel := new(OpenAiModel)
	if err := json.Unmarshal(data, &valueOpenAiModel); err == nil {
		a.typ = "OpenAiModel"
		a.OpenAiModel = valueOpenAiModel
		return nil
	}
	valueOpenRouterModel := new(OpenRouterModel)
	if err := json.Unmarshal(data, &valueOpenRouterModel); err == nil {
		a.typ = "OpenRouterModel"
		a.OpenRouterModel = valueOpenRouterModel
		return nil
	}
	valuePerplexityAiModel := new(PerplexityAiModel)
	if err := json.Unmarshal(data, &valuePerplexityAiModel); err == nil {
		a.typ = "PerplexityAiModel"
		a.PerplexityAiModel = valuePerplexityAiModel
		return nil
	}
	valueTogetherAiModel := new(TogetherAiModel)
	if err := json.Unmarshal(data, &valueTogetherAiModel); err == nil {
		a.typ = "TogetherAiModel"
		a.TogetherAiModel = valueTogetherAiModel
		return nil
	}
	valueVapiModel := new(VapiModel)
	if err := json.Unmarshal(data, &valueVapiModel); err == nil {
		a.typ = "VapiModel"
		a.VapiModel = valueVapiModel
		return nil
	}
	valueXaiModel := new(XaiModel)
	if err := json.Unmarshal(data, &valueXaiModel); err == nil {
		a.typ = "XaiModel"
		a.XaiModel = valueXaiModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantModel) MarshalJSON() ([]byte, error) {
	if a.typ == "AnyscaleModel" || a.AnyscaleModel != nil {
		return json.Marshal(a.AnyscaleModel)
	}
	if a.typ == "AnthropicModel" || a.AnthropicModel != nil {
		return json.Marshal(a.AnthropicModel)
	}
	if a.typ == "CustomLlmModel" || a.CustomLlmModel != nil {
		return json.Marshal(a.CustomLlmModel)
	}
	if a.typ == "DeepInfraModel" || a.DeepInfraModel != nil {
		return json.Marshal(a.DeepInfraModel)
	}
	if a.typ == "GoogleModel" || a.GoogleModel != nil {
		return json.Marshal(a.GoogleModel)
	}
	if a.typ == "GroqModel" || a.GroqModel != nil {
		return json.Marshal(a.GroqModel)
	}
	if a.typ == "InflectionAiModel" || a.InflectionAiModel != nil {
		return json.Marshal(a.InflectionAiModel)
	}
	if a.typ == "OpenAiModel" || a.OpenAiModel != nil {
		return json.Marshal(a.OpenAiModel)
	}
	if a.typ == "OpenRouterModel" || a.OpenRouterModel != nil {
		return json.Marshal(a.OpenRouterModel)
	}
	if a.typ == "PerplexityAiModel" || a.PerplexityAiModel != nil {
		return json.Marshal(a.PerplexityAiModel)
	}
	if a.typ == "TogetherAiModel" || a.TogetherAiModel != nil {
		return json.Marshal(a.TogetherAiModel)
	}
	if a.typ == "VapiModel" || a.VapiModel != nil {
		return json.Marshal(a.VapiModel)
	}
	if a.typ == "XaiModel" || a.XaiModel != nil {
		return json.Marshal(a.XaiModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantModelVisitor interface {
	VisitAnyscaleModel(*AnyscaleModel) error
	VisitAnthropicModel(*AnthropicModel) error
	VisitCustomLlmModel(*CustomLlmModel) error
	VisitDeepInfraModel(*DeepInfraModel) error
	VisitGoogleModel(*GoogleModel) error
	VisitGroqModel(*GroqModel) error
	VisitInflectionAiModel(*InflectionAiModel) error
	VisitOpenAiModel(*OpenAiModel) error
	VisitOpenRouterModel(*OpenRouterModel) error
	VisitPerplexityAiModel(*PerplexityAiModel) error
	VisitTogetherAiModel(*TogetherAiModel) error
	VisitVapiModel(*VapiModel) error
	VisitXaiModel(*XaiModel) error
}

func (a *AssistantModel) Accept(visitor AssistantModelVisitor) error {
	if a.typ == "AnyscaleModel" || a.AnyscaleModel != nil {
		return visitor.VisitAnyscaleModel(a.AnyscaleModel)
	}
	if a.typ == "AnthropicModel" || a.AnthropicModel != nil {
		return visitor.VisitAnthropicModel(a.AnthropicModel)
	}
	if a.typ == "CustomLlmModel" || a.CustomLlmModel != nil {
		return visitor.VisitCustomLlmModel(a.CustomLlmModel)
	}
	if a.typ == "DeepInfraModel" || a.DeepInfraModel != nil {
		return visitor.VisitDeepInfraModel(a.DeepInfraModel)
	}
	if a.typ == "GoogleModel" || a.GoogleModel != nil {
		return visitor.VisitGoogleModel(a.GoogleModel)
	}
	if a.typ == "GroqModel" || a.GroqModel != nil {
		return visitor.VisitGroqModel(a.GroqModel)
	}
	if a.typ == "InflectionAiModel" || a.InflectionAiModel != nil {
		return visitor.VisitInflectionAiModel(a.InflectionAiModel)
	}
	if a.typ == "OpenAiModel" || a.OpenAiModel != nil {
		return visitor.VisitOpenAiModel(a.OpenAiModel)
	}
	if a.typ == "OpenRouterModel" || a.OpenRouterModel != nil {
		return visitor.VisitOpenRouterModel(a.OpenRouterModel)
	}
	if a.typ == "PerplexityAiModel" || a.PerplexityAiModel != nil {
		return visitor.VisitPerplexityAiModel(a.PerplexityAiModel)
	}
	if a.typ == "TogetherAiModel" || a.TogetherAiModel != nil {
		return visitor.VisitTogetherAiModel(a.TogetherAiModel)
	}
	if a.typ == "VapiModel" || a.VapiModel != nil {
		return visitor.VisitVapiModel(a.VapiModel)
	}
	if a.typ == "XaiModel" || a.XaiModel != nil {
		return visitor.VisitXaiModel(a.XaiModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantServerMessagesItem string

const (
	AssistantServerMessagesItemConversationUpdate         AssistantServerMessagesItem = "conversation-update"
	AssistantServerMessagesItemEndOfCallReport            AssistantServerMessagesItem = "end-of-call-report"
	AssistantServerMessagesItemFunctionCall               AssistantServerMessagesItem = "function-call"
	AssistantServerMessagesItemHang                       AssistantServerMessagesItem = "hang"
	AssistantServerMessagesItemLanguageChanged            AssistantServerMessagesItem = "language-changed"
	AssistantServerMessagesItemLanguageChangeDetected     AssistantServerMessagesItem = "language-change-detected"
	AssistantServerMessagesItemModelOutput                AssistantServerMessagesItem = "model-output"
	AssistantServerMessagesItemPhoneCallControl           AssistantServerMessagesItem = "phone-call-control"
	AssistantServerMessagesItemSpeechUpdate               AssistantServerMessagesItem = "speech-update"
	AssistantServerMessagesItemStatusUpdate               AssistantServerMessagesItem = "status-update"
	AssistantServerMessagesItemTranscript                 AssistantServerMessagesItem = "transcript"
	AssistantServerMessagesItemToolCalls                  AssistantServerMessagesItem = "tool-calls"
	AssistantServerMessagesItemTransferDestinationRequest AssistantServerMessagesItem = "transfer-destination-request"
	AssistantServerMessagesItemTransferUpdate             AssistantServerMessagesItem = "transfer-update"
	AssistantServerMessagesItemUserInterrupted            AssistantServerMessagesItem = "user-interrupted"
	AssistantServerMessagesItemVoiceInput                 AssistantServerMessagesItem = "voice-input"
)

func NewAssistantServerMessagesItemFromString(s string) (AssistantServerMessagesItem, error) {
	switch s {
	case "conversation-update":
		return AssistantServerMessagesItemConversationUpdate, nil
	case "end-of-call-report":
		return AssistantServerMessagesItemEndOfCallReport, nil
	case "function-call":
		return AssistantServerMessagesItemFunctionCall, nil
	case "hang":
		return AssistantServerMessagesItemHang, nil
	case "language-changed":
		return AssistantServerMessagesItemLanguageChanged, nil
	case "language-change-detected":
		return AssistantServerMessagesItemLanguageChangeDetected, nil
	case "model-output":
		return AssistantServerMessagesItemModelOutput, nil
	case "phone-call-control":
		return AssistantServerMessagesItemPhoneCallControl, nil
	case "speech-update":
		return AssistantServerMessagesItemSpeechUpdate, nil
	case "status-update":
		return AssistantServerMessagesItemStatusUpdate, nil
	case "transcript":
		return AssistantServerMessagesItemTranscript, nil
	case "tool-calls":
		return AssistantServerMessagesItemToolCalls, nil
	case "transfer-destination-request":
		return AssistantServerMessagesItemTransferDestinationRequest, nil
	case "transfer-update":
		return AssistantServerMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return AssistantServerMessagesItemUserInterrupted, nil
	case "voice-input":
		return AssistantServerMessagesItemVoiceInput, nil
	}
	var t AssistantServerMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantServerMessagesItem) Ptr() *AssistantServerMessagesItem {
	return &a
}

// These are the options for the assistant's transcriber.
type AssistantTranscriber struct {
	AssemblyAiTranscriber  *AssemblyAiTranscriber
	CustomTranscriber      *CustomTranscriber
	DeepgramTranscriber    *DeepgramTranscriber
	GladiaTranscriber      *GladiaTranscriber
	TalkscriberTranscriber *TalkscriberTranscriber

	typ string
}

func (a *AssistantTranscriber) GetAssemblyAiTranscriber() *AssemblyAiTranscriber {
	if a == nil {
		return nil
	}
	return a.AssemblyAiTranscriber
}

func (a *AssistantTranscriber) GetCustomTranscriber() *CustomTranscriber {
	if a == nil {
		return nil
	}
	return a.CustomTranscriber
}

func (a *AssistantTranscriber) GetDeepgramTranscriber() *DeepgramTranscriber {
	if a == nil {
		return nil
	}
	return a.DeepgramTranscriber
}

func (a *AssistantTranscriber) GetGladiaTranscriber() *GladiaTranscriber {
	if a == nil {
		return nil
	}
	return a.GladiaTranscriber
}

func (a *AssistantTranscriber) GetTalkscriberTranscriber() *TalkscriberTranscriber {
	if a == nil {
		return nil
	}
	return a.TalkscriberTranscriber
}

func (a *AssistantTranscriber) UnmarshalJSON(data []byte) error {
	valueAssemblyAiTranscriber := new(AssemblyAiTranscriber)
	if err := json.Unmarshal(data, &valueAssemblyAiTranscriber); err == nil {
		a.typ = "AssemblyAiTranscriber"
		a.AssemblyAiTranscriber = valueAssemblyAiTranscriber
		return nil
	}
	valueCustomTranscriber := new(CustomTranscriber)
	if err := json.Unmarshal(data, &valueCustomTranscriber); err == nil {
		a.typ = "CustomTranscriber"
		a.CustomTranscriber = valueCustomTranscriber
		return nil
	}
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		a.typ = "DeepgramTranscriber"
		a.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		a.typ = "GladiaTranscriber"
		a.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		a.typ = "TalkscriberTranscriber"
		a.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantTranscriber) MarshalJSON() ([]byte, error) {
	if a.typ == "AssemblyAiTranscriber" || a.AssemblyAiTranscriber != nil {
		return json.Marshal(a.AssemblyAiTranscriber)
	}
	if a.typ == "CustomTranscriber" || a.CustomTranscriber != nil {
		return json.Marshal(a.CustomTranscriber)
	}
	if a.typ == "DeepgramTranscriber" || a.DeepgramTranscriber != nil {
		return json.Marshal(a.DeepgramTranscriber)
	}
	if a.typ == "GladiaTranscriber" || a.GladiaTranscriber != nil {
		return json.Marshal(a.GladiaTranscriber)
	}
	if a.typ == "TalkscriberTranscriber" || a.TalkscriberTranscriber != nil {
		return json.Marshal(a.TalkscriberTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantTranscriberVisitor interface {
	VisitAssemblyAiTranscriber(*AssemblyAiTranscriber) error
	VisitCustomTranscriber(*CustomTranscriber) error
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
}

func (a *AssistantTranscriber) Accept(visitor AssistantTranscriberVisitor) error {
	if a.typ == "AssemblyAiTranscriber" || a.AssemblyAiTranscriber != nil {
		return visitor.VisitAssemblyAiTranscriber(a.AssemblyAiTranscriber)
	}
	if a.typ == "CustomTranscriber" || a.CustomTranscriber != nil {
		return visitor.VisitCustomTranscriber(a.CustomTranscriber)
	}
	if a.typ == "DeepgramTranscriber" || a.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(a.DeepgramTranscriber)
	}
	if a.typ == "GladiaTranscriber" || a.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(a.GladiaTranscriber)
	}
	if a.typ == "TalkscriberTranscriber" || a.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(a.TalkscriberTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// These are the options for the assistant's voice.
type AssistantVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	CustomVoice     *CustomVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	LmntVoice       *LmntVoice
	NeetsVoice      *NeetsVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
	TavusVoice      *TavusVoice

	typ string
}

func (a *AssistantVoice) GetAzureVoice() *AzureVoice {
	if a == nil {
		return nil
	}
	return a.AzureVoice
}

func (a *AssistantVoice) GetCartesiaVoice() *CartesiaVoice {
	if a == nil {
		return nil
	}
	return a.CartesiaVoice
}

func (a *AssistantVoice) GetCustomVoice() *CustomVoice {
	if a == nil {
		return nil
	}
	return a.CustomVoice
}

func (a *AssistantVoice) GetDeepgramVoice() *DeepgramVoice {
	if a == nil {
		return nil
	}
	return a.DeepgramVoice
}

func (a *AssistantVoice) GetElevenLabsVoice() *ElevenLabsVoice {
	if a == nil {
		return nil
	}
	return a.ElevenLabsVoice
}

func (a *AssistantVoice) GetLmntVoice() *LmntVoice {
	if a == nil {
		return nil
	}
	return a.LmntVoice
}

func (a *AssistantVoice) GetNeetsVoice() *NeetsVoice {
	if a == nil {
		return nil
	}
	return a.NeetsVoice
}

func (a *AssistantVoice) GetOpenAiVoice() *OpenAiVoice {
	if a == nil {
		return nil
	}
	return a.OpenAiVoice
}

func (a *AssistantVoice) GetPlayHtVoice() *PlayHtVoice {
	if a == nil {
		return nil
	}
	return a.PlayHtVoice
}

func (a *AssistantVoice) GetRimeAiVoice() *RimeAiVoice {
	if a == nil {
		return nil
	}
	return a.RimeAiVoice
}

func (a *AssistantVoice) GetTavusVoice() *TavusVoice {
	if a == nil {
		return nil
	}
	return a.TavusVoice
}

func (a *AssistantVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		a.typ = "AzureVoice"
		a.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		a.typ = "CartesiaVoice"
		a.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueCustomVoice := new(CustomVoice)
	if err := json.Unmarshal(data, &valueCustomVoice); err == nil {
		a.typ = "CustomVoice"
		a.CustomVoice = valueCustomVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		a.typ = "DeepgramVoice"
		a.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		a.typ = "ElevenLabsVoice"
		a.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		a.typ = "LmntVoice"
		a.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeetsVoice := new(NeetsVoice)
	if err := json.Unmarshal(data, &valueNeetsVoice); err == nil {
		a.typ = "NeetsVoice"
		a.NeetsVoice = valueNeetsVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		a.typ = "OpenAiVoice"
		a.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		a.typ = "PlayHtVoice"
		a.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		a.typ = "RimeAiVoice"
		a.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	valueTavusVoice := new(TavusVoice)
	if err := json.Unmarshal(data, &valueTavusVoice); err == nil {
		a.typ = "TavusVoice"
		a.TavusVoice = valueTavusVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantVoice) MarshalJSON() ([]byte, error) {
	if a.typ == "AzureVoice" || a.AzureVoice != nil {
		return json.Marshal(a.AzureVoice)
	}
	if a.typ == "CartesiaVoice" || a.CartesiaVoice != nil {
		return json.Marshal(a.CartesiaVoice)
	}
	if a.typ == "CustomVoice" || a.CustomVoice != nil {
		return json.Marshal(a.CustomVoice)
	}
	if a.typ == "DeepgramVoice" || a.DeepgramVoice != nil {
		return json.Marshal(a.DeepgramVoice)
	}
	if a.typ == "ElevenLabsVoice" || a.ElevenLabsVoice != nil {
		return json.Marshal(a.ElevenLabsVoice)
	}
	if a.typ == "LmntVoice" || a.LmntVoice != nil {
		return json.Marshal(a.LmntVoice)
	}
	if a.typ == "NeetsVoice" || a.NeetsVoice != nil {
		return json.Marshal(a.NeetsVoice)
	}
	if a.typ == "OpenAiVoice" || a.OpenAiVoice != nil {
		return json.Marshal(a.OpenAiVoice)
	}
	if a.typ == "PlayHtVoice" || a.PlayHtVoice != nil {
		return json.Marshal(a.PlayHtVoice)
	}
	if a.typ == "RimeAiVoice" || a.RimeAiVoice != nil {
		return json.Marshal(a.RimeAiVoice)
	}
	if a.typ == "TavusVoice" || a.TavusVoice != nil {
		return json.Marshal(a.TavusVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitCustomVoice(*CustomVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeetsVoice(*NeetsVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
	VisitTavusVoice(*TavusVoice) error
}

func (a *AssistantVoice) Accept(visitor AssistantVoiceVisitor) error {
	if a.typ == "AzureVoice" || a.AzureVoice != nil {
		return visitor.VisitAzureVoice(a.AzureVoice)
	}
	if a.typ == "CartesiaVoice" || a.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(a.CartesiaVoice)
	}
	if a.typ == "CustomVoice" || a.CustomVoice != nil {
		return visitor.VisitCustomVoice(a.CustomVoice)
	}
	if a.typ == "DeepgramVoice" || a.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(a.DeepgramVoice)
	}
	if a.typ == "ElevenLabsVoice" || a.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(a.ElevenLabsVoice)
	}
	if a.typ == "LmntVoice" || a.LmntVoice != nil {
		return visitor.VisitLmntVoice(a.LmntVoice)
	}
	if a.typ == "NeetsVoice" || a.NeetsVoice != nil {
		return visitor.VisitNeetsVoice(a.NeetsVoice)
	}
	if a.typ == "OpenAiVoice" || a.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(a.OpenAiVoice)
	}
	if a.typ == "PlayHtVoice" || a.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(a.PlayHtVoice)
	}
	if a.typ == "RimeAiVoice" || a.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(a.RimeAiVoice)
	}
	if a.typ == "TavusVoice" || a.TavusVoice != nil {
		return visitor.VisitTavusVoice(a.TavusVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
type UpdateAssistantDtoBackgroundSound string

const (
	UpdateAssistantDtoBackgroundSoundOff    UpdateAssistantDtoBackgroundSound = "off"
	UpdateAssistantDtoBackgroundSoundOffice UpdateAssistantDtoBackgroundSound = "office"
)

func NewUpdateAssistantDtoBackgroundSoundFromString(s string) (UpdateAssistantDtoBackgroundSound, error) {
	switch s {
	case "off":
		return UpdateAssistantDtoBackgroundSoundOff, nil
	case "office":
		return UpdateAssistantDtoBackgroundSoundOffice, nil
	}
	var t UpdateAssistantDtoBackgroundSound
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAssistantDtoBackgroundSound) Ptr() *UpdateAssistantDtoBackgroundSound {
	return &u
}

type UpdateAssistantDtoClientMessagesItem string

const (
	UpdateAssistantDtoClientMessagesItemConversationUpdate UpdateAssistantDtoClientMessagesItem = "conversation-update"
	UpdateAssistantDtoClientMessagesItemFunctionCall       UpdateAssistantDtoClientMessagesItem = "function-call"
	UpdateAssistantDtoClientMessagesItemFunctionCallResult UpdateAssistantDtoClientMessagesItem = "function-call-result"
	UpdateAssistantDtoClientMessagesItemHang               UpdateAssistantDtoClientMessagesItem = "hang"
	UpdateAssistantDtoClientMessagesItemLanguageChanged    UpdateAssistantDtoClientMessagesItem = "language-changed"
	UpdateAssistantDtoClientMessagesItemMetadata           UpdateAssistantDtoClientMessagesItem = "metadata"
	UpdateAssistantDtoClientMessagesItemModelOutput        UpdateAssistantDtoClientMessagesItem = "model-output"
	UpdateAssistantDtoClientMessagesItemSpeechUpdate       UpdateAssistantDtoClientMessagesItem = "speech-update"
	UpdateAssistantDtoClientMessagesItemStatusUpdate       UpdateAssistantDtoClientMessagesItem = "status-update"
	UpdateAssistantDtoClientMessagesItemTranscript         UpdateAssistantDtoClientMessagesItem = "transcript"
	UpdateAssistantDtoClientMessagesItemToolCalls          UpdateAssistantDtoClientMessagesItem = "tool-calls"
	UpdateAssistantDtoClientMessagesItemToolCallsResult    UpdateAssistantDtoClientMessagesItem = "tool-calls-result"
	UpdateAssistantDtoClientMessagesItemTransferUpdate     UpdateAssistantDtoClientMessagesItem = "transfer-update"
	UpdateAssistantDtoClientMessagesItemUserInterrupted    UpdateAssistantDtoClientMessagesItem = "user-interrupted"
	UpdateAssistantDtoClientMessagesItemVoiceInput         UpdateAssistantDtoClientMessagesItem = "voice-input"
)

func NewUpdateAssistantDtoClientMessagesItemFromString(s string) (UpdateAssistantDtoClientMessagesItem, error) {
	switch s {
	case "conversation-update":
		return UpdateAssistantDtoClientMessagesItemConversationUpdate, nil
	case "function-call":
		return UpdateAssistantDtoClientMessagesItemFunctionCall, nil
	case "function-call-result":
		return UpdateAssistantDtoClientMessagesItemFunctionCallResult, nil
	case "hang":
		return UpdateAssistantDtoClientMessagesItemHang, nil
	case "language-changed":
		return UpdateAssistantDtoClientMessagesItemLanguageChanged, nil
	case "metadata":
		return UpdateAssistantDtoClientMessagesItemMetadata, nil
	case "model-output":
		return UpdateAssistantDtoClientMessagesItemModelOutput, nil
	case "speech-update":
		return UpdateAssistantDtoClientMessagesItemSpeechUpdate, nil
	case "status-update":
		return UpdateAssistantDtoClientMessagesItemStatusUpdate, nil
	case "transcript":
		return UpdateAssistantDtoClientMessagesItemTranscript, nil
	case "tool-calls":
		return UpdateAssistantDtoClientMessagesItemToolCalls, nil
	case "tool-calls-result":
		return UpdateAssistantDtoClientMessagesItemToolCallsResult, nil
	case "transfer-update":
		return UpdateAssistantDtoClientMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return UpdateAssistantDtoClientMessagesItemUserInterrupted, nil
	case "voice-input":
		return UpdateAssistantDtoClientMessagesItemVoiceInput, nil
	}
	var t UpdateAssistantDtoClientMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAssistantDtoClientMessagesItem) Ptr() *UpdateAssistantDtoClientMessagesItem {
	return &u
}

// This is the mode for the first message. Default is 'assistant-speaks-first'.
//
// Use:
// - 'assistant-speaks-first' to have the assistant speak first.
// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
//
// @default 'assistant-speaks-first'
type UpdateAssistantDtoFirstMessageMode string

const (
	UpdateAssistantDtoFirstMessageModeAssistantSpeaksFirst                          UpdateAssistantDtoFirstMessageMode = "assistant-speaks-first"
	UpdateAssistantDtoFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage UpdateAssistantDtoFirstMessageMode = "assistant-speaks-first-with-model-generated-message"
	UpdateAssistantDtoFirstMessageModeAssistantWaitsForUser                         UpdateAssistantDtoFirstMessageMode = "assistant-waits-for-user"
)

func NewUpdateAssistantDtoFirstMessageModeFromString(s string) (UpdateAssistantDtoFirstMessageMode, error) {
	switch s {
	case "assistant-speaks-first":
		return UpdateAssistantDtoFirstMessageModeAssistantSpeaksFirst, nil
	case "assistant-speaks-first-with-model-generated-message":
		return UpdateAssistantDtoFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage, nil
	case "assistant-waits-for-user":
		return UpdateAssistantDtoFirstMessageModeAssistantWaitsForUser, nil
	}
	var t UpdateAssistantDtoFirstMessageMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAssistantDtoFirstMessageMode) Ptr() *UpdateAssistantDtoFirstMessageMode {
	return &u
}

// These are the options for the assistant's LLM.
type UpdateAssistantDtoModel struct {
	AnyscaleModel     *AnyscaleModel
	AnthropicModel    *AnthropicModel
	CustomLlmModel    *CustomLlmModel
	DeepInfraModel    *DeepInfraModel
	GoogleModel       *GoogleModel
	GroqModel         *GroqModel
	InflectionAiModel *InflectionAiModel
	OpenAiModel       *OpenAiModel
	OpenRouterModel   *OpenRouterModel
	PerplexityAiModel *PerplexityAiModel
	TogetherAiModel   *TogetherAiModel
	VapiModel         *VapiModel
	XaiModel          *XaiModel

	typ string
}

func (u *UpdateAssistantDtoModel) GetAnyscaleModel() *AnyscaleModel {
	if u == nil {
		return nil
	}
	return u.AnyscaleModel
}

func (u *UpdateAssistantDtoModel) GetAnthropicModel() *AnthropicModel {
	if u == nil {
		return nil
	}
	return u.AnthropicModel
}

func (u *UpdateAssistantDtoModel) GetCustomLlmModel() *CustomLlmModel {
	if u == nil {
		return nil
	}
	return u.CustomLlmModel
}

func (u *UpdateAssistantDtoModel) GetDeepInfraModel() *DeepInfraModel {
	if u == nil {
		return nil
	}
	return u.DeepInfraModel
}

func (u *UpdateAssistantDtoModel) GetGoogleModel() *GoogleModel {
	if u == nil {
		return nil
	}
	return u.GoogleModel
}

func (u *UpdateAssistantDtoModel) GetGroqModel() *GroqModel {
	if u == nil {
		return nil
	}
	return u.GroqModel
}

func (u *UpdateAssistantDtoModel) GetInflectionAiModel() *InflectionAiModel {
	if u == nil {
		return nil
	}
	return u.InflectionAiModel
}

func (u *UpdateAssistantDtoModel) GetOpenAiModel() *OpenAiModel {
	if u == nil {
		return nil
	}
	return u.OpenAiModel
}

func (u *UpdateAssistantDtoModel) GetOpenRouterModel() *OpenRouterModel {
	if u == nil {
		return nil
	}
	return u.OpenRouterModel
}

func (u *UpdateAssistantDtoModel) GetPerplexityAiModel() *PerplexityAiModel {
	if u == nil {
		return nil
	}
	return u.PerplexityAiModel
}

func (u *UpdateAssistantDtoModel) GetTogetherAiModel() *TogetherAiModel {
	if u == nil {
		return nil
	}
	return u.TogetherAiModel
}

func (u *UpdateAssistantDtoModel) GetVapiModel() *VapiModel {
	if u == nil {
		return nil
	}
	return u.VapiModel
}

func (u *UpdateAssistantDtoModel) GetXaiModel() *XaiModel {
	if u == nil {
		return nil
	}
	return u.XaiModel
}

func (u *UpdateAssistantDtoModel) UnmarshalJSON(data []byte) error {
	valueAnyscaleModel := new(AnyscaleModel)
	if err := json.Unmarshal(data, &valueAnyscaleModel); err == nil {
		u.typ = "AnyscaleModel"
		u.AnyscaleModel = valueAnyscaleModel
		return nil
	}
	valueAnthropicModel := new(AnthropicModel)
	if err := json.Unmarshal(data, &valueAnthropicModel); err == nil {
		u.typ = "AnthropicModel"
		u.AnthropicModel = valueAnthropicModel
		return nil
	}
	valueCustomLlmModel := new(CustomLlmModel)
	if err := json.Unmarshal(data, &valueCustomLlmModel); err == nil {
		u.typ = "CustomLlmModel"
		u.CustomLlmModel = valueCustomLlmModel
		return nil
	}
	valueDeepInfraModel := new(DeepInfraModel)
	if err := json.Unmarshal(data, &valueDeepInfraModel); err == nil {
		u.typ = "DeepInfraModel"
		u.DeepInfraModel = valueDeepInfraModel
		return nil
	}
	valueGoogleModel := new(GoogleModel)
	if err := json.Unmarshal(data, &valueGoogleModel); err == nil {
		u.typ = "GoogleModel"
		u.GoogleModel = valueGoogleModel
		return nil
	}
	valueGroqModel := new(GroqModel)
	if err := json.Unmarshal(data, &valueGroqModel); err == nil {
		u.typ = "GroqModel"
		u.GroqModel = valueGroqModel
		return nil
	}
	valueInflectionAiModel := new(InflectionAiModel)
	if err := json.Unmarshal(data, &valueInflectionAiModel); err == nil {
		u.typ = "InflectionAiModel"
		u.InflectionAiModel = valueInflectionAiModel
		return nil
	}
	valueOpenAiModel := new(OpenAiModel)
	if err := json.Unmarshal(data, &valueOpenAiModel); err == nil {
		u.typ = "OpenAiModel"
		u.OpenAiModel = valueOpenAiModel
		return nil
	}
	valueOpenRouterModel := new(OpenRouterModel)
	if err := json.Unmarshal(data, &valueOpenRouterModel); err == nil {
		u.typ = "OpenRouterModel"
		u.OpenRouterModel = valueOpenRouterModel
		return nil
	}
	valuePerplexityAiModel := new(PerplexityAiModel)
	if err := json.Unmarshal(data, &valuePerplexityAiModel); err == nil {
		u.typ = "PerplexityAiModel"
		u.PerplexityAiModel = valuePerplexityAiModel
		return nil
	}
	valueTogetherAiModel := new(TogetherAiModel)
	if err := json.Unmarshal(data, &valueTogetherAiModel); err == nil {
		u.typ = "TogetherAiModel"
		u.TogetherAiModel = valueTogetherAiModel
		return nil
	}
	valueVapiModel := new(VapiModel)
	if err := json.Unmarshal(data, &valueVapiModel); err == nil {
		u.typ = "VapiModel"
		u.VapiModel = valueVapiModel
		return nil
	}
	valueXaiModel := new(XaiModel)
	if err := json.Unmarshal(data, &valueXaiModel); err == nil {
		u.typ = "XaiModel"
		u.XaiModel = valueXaiModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateAssistantDtoModel) MarshalJSON() ([]byte, error) {
	if u.typ == "AnyscaleModel" || u.AnyscaleModel != nil {
		return json.Marshal(u.AnyscaleModel)
	}
	if u.typ == "AnthropicModel" || u.AnthropicModel != nil {
		return json.Marshal(u.AnthropicModel)
	}
	if u.typ == "CustomLlmModel" || u.CustomLlmModel != nil {
		return json.Marshal(u.CustomLlmModel)
	}
	if u.typ == "DeepInfraModel" || u.DeepInfraModel != nil {
		return json.Marshal(u.DeepInfraModel)
	}
	if u.typ == "GoogleModel" || u.GoogleModel != nil {
		return json.Marshal(u.GoogleModel)
	}
	if u.typ == "GroqModel" || u.GroqModel != nil {
		return json.Marshal(u.GroqModel)
	}
	if u.typ == "InflectionAiModel" || u.InflectionAiModel != nil {
		return json.Marshal(u.InflectionAiModel)
	}
	if u.typ == "OpenAiModel" || u.OpenAiModel != nil {
		return json.Marshal(u.OpenAiModel)
	}
	if u.typ == "OpenRouterModel" || u.OpenRouterModel != nil {
		return json.Marshal(u.OpenRouterModel)
	}
	if u.typ == "PerplexityAiModel" || u.PerplexityAiModel != nil {
		return json.Marshal(u.PerplexityAiModel)
	}
	if u.typ == "TogetherAiModel" || u.TogetherAiModel != nil {
		return json.Marshal(u.TogetherAiModel)
	}
	if u.typ == "VapiModel" || u.VapiModel != nil {
		return json.Marshal(u.VapiModel)
	}
	if u.typ == "XaiModel" || u.XaiModel != nil {
		return json.Marshal(u.XaiModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateAssistantDtoModelVisitor interface {
	VisitAnyscaleModel(*AnyscaleModel) error
	VisitAnthropicModel(*AnthropicModel) error
	VisitCustomLlmModel(*CustomLlmModel) error
	VisitDeepInfraModel(*DeepInfraModel) error
	VisitGoogleModel(*GoogleModel) error
	VisitGroqModel(*GroqModel) error
	VisitInflectionAiModel(*InflectionAiModel) error
	VisitOpenAiModel(*OpenAiModel) error
	VisitOpenRouterModel(*OpenRouterModel) error
	VisitPerplexityAiModel(*PerplexityAiModel) error
	VisitTogetherAiModel(*TogetherAiModel) error
	VisitVapiModel(*VapiModel) error
	VisitXaiModel(*XaiModel) error
}

func (u *UpdateAssistantDtoModel) Accept(visitor UpdateAssistantDtoModelVisitor) error {
	if u.typ == "AnyscaleModel" || u.AnyscaleModel != nil {
		return visitor.VisitAnyscaleModel(u.AnyscaleModel)
	}
	if u.typ == "AnthropicModel" || u.AnthropicModel != nil {
		return visitor.VisitAnthropicModel(u.AnthropicModel)
	}
	if u.typ == "CustomLlmModel" || u.CustomLlmModel != nil {
		return visitor.VisitCustomLlmModel(u.CustomLlmModel)
	}
	if u.typ == "DeepInfraModel" || u.DeepInfraModel != nil {
		return visitor.VisitDeepInfraModel(u.DeepInfraModel)
	}
	if u.typ == "GoogleModel" || u.GoogleModel != nil {
		return visitor.VisitGoogleModel(u.GoogleModel)
	}
	if u.typ == "GroqModel" || u.GroqModel != nil {
		return visitor.VisitGroqModel(u.GroqModel)
	}
	if u.typ == "InflectionAiModel" || u.InflectionAiModel != nil {
		return visitor.VisitInflectionAiModel(u.InflectionAiModel)
	}
	if u.typ == "OpenAiModel" || u.OpenAiModel != nil {
		return visitor.VisitOpenAiModel(u.OpenAiModel)
	}
	if u.typ == "OpenRouterModel" || u.OpenRouterModel != nil {
		return visitor.VisitOpenRouterModel(u.OpenRouterModel)
	}
	if u.typ == "PerplexityAiModel" || u.PerplexityAiModel != nil {
		return visitor.VisitPerplexityAiModel(u.PerplexityAiModel)
	}
	if u.typ == "TogetherAiModel" || u.TogetherAiModel != nil {
		return visitor.VisitTogetherAiModel(u.TogetherAiModel)
	}
	if u.typ == "VapiModel" || u.VapiModel != nil {
		return visitor.VisitVapiModel(u.VapiModel)
	}
	if u.typ == "XaiModel" || u.XaiModel != nil {
		return visitor.VisitXaiModel(u.XaiModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateAssistantDtoServerMessagesItem string

const (
	UpdateAssistantDtoServerMessagesItemConversationUpdate         UpdateAssistantDtoServerMessagesItem = "conversation-update"
	UpdateAssistantDtoServerMessagesItemEndOfCallReport            UpdateAssistantDtoServerMessagesItem = "end-of-call-report"
	UpdateAssistantDtoServerMessagesItemFunctionCall               UpdateAssistantDtoServerMessagesItem = "function-call"
	UpdateAssistantDtoServerMessagesItemHang                       UpdateAssistantDtoServerMessagesItem = "hang"
	UpdateAssistantDtoServerMessagesItemLanguageChanged            UpdateAssistantDtoServerMessagesItem = "language-changed"
	UpdateAssistantDtoServerMessagesItemLanguageChangeDetected     UpdateAssistantDtoServerMessagesItem = "language-change-detected"
	UpdateAssistantDtoServerMessagesItemModelOutput                UpdateAssistantDtoServerMessagesItem = "model-output"
	UpdateAssistantDtoServerMessagesItemPhoneCallControl           UpdateAssistantDtoServerMessagesItem = "phone-call-control"
	UpdateAssistantDtoServerMessagesItemSpeechUpdate               UpdateAssistantDtoServerMessagesItem = "speech-update"
	UpdateAssistantDtoServerMessagesItemStatusUpdate               UpdateAssistantDtoServerMessagesItem = "status-update"
	UpdateAssistantDtoServerMessagesItemTranscript                 UpdateAssistantDtoServerMessagesItem = "transcript"
	UpdateAssistantDtoServerMessagesItemToolCalls                  UpdateAssistantDtoServerMessagesItem = "tool-calls"
	UpdateAssistantDtoServerMessagesItemTransferDestinationRequest UpdateAssistantDtoServerMessagesItem = "transfer-destination-request"
	UpdateAssistantDtoServerMessagesItemTransferUpdate             UpdateAssistantDtoServerMessagesItem = "transfer-update"
	UpdateAssistantDtoServerMessagesItemUserInterrupted            UpdateAssistantDtoServerMessagesItem = "user-interrupted"
	UpdateAssistantDtoServerMessagesItemVoiceInput                 UpdateAssistantDtoServerMessagesItem = "voice-input"
)

func NewUpdateAssistantDtoServerMessagesItemFromString(s string) (UpdateAssistantDtoServerMessagesItem, error) {
	switch s {
	case "conversation-update":
		return UpdateAssistantDtoServerMessagesItemConversationUpdate, nil
	case "end-of-call-report":
		return UpdateAssistantDtoServerMessagesItemEndOfCallReport, nil
	case "function-call":
		return UpdateAssistantDtoServerMessagesItemFunctionCall, nil
	case "hang":
		return UpdateAssistantDtoServerMessagesItemHang, nil
	case "language-changed":
		return UpdateAssistantDtoServerMessagesItemLanguageChanged, nil
	case "language-change-detected":
		return UpdateAssistantDtoServerMessagesItemLanguageChangeDetected, nil
	case "model-output":
		return UpdateAssistantDtoServerMessagesItemModelOutput, nil
	case "phone-call-control":
		return UpdateAssistantDtoServerMessagesItemPhoneCallControl, nil
	case "speech-update":
		return UpdateAssistantDtoServerMessagesItemSpeechUpdate, nil
	case "status-update":
		return UpdateAssistantDtoServerMessagesItemStatusUpdate, nil
	case "transcript":
		return UpdateAssistantDtoServerMessagesItemTranscript, nil
	case "tool-calls":
		return UpdateAssistantDtoServerMessagesItemToolCalls, nil
	case "transfer-destination-request":
		return UpdateAssistantDtoServerMessagesItemTransferDestinationRequest, nil
	case "transfer-update":
		return UpdateAssistantDtoServerMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return UpdateAssistantDtoServerMessagesItemUserInterrupted, nil
	case "voice-input":
		return UpdateAssistantDtoServerMessagesItemVoiceInput, nil
	}
	var t UpdateAssistantDtoServerMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAssistantDtoServerMessagesItem) Ptr() *UpdateAssistantDtoServerMessagesItem {
	return &u
}

// These are the options for the assistant's transcriber.
type UpdateAssistantDtoTranscriber struct {
	AssemblyAiTranscriber  *AssemblyAiTranscriber
	CustomTranscriber      *CustomTranscriber
	DeepgramTranscriber    *DeepgramTranscriber
	GladiaTranscriber      *GladiaTranscriber
	TalkscriberTranscriber *TalkscriberTranscriber

	typ string
}

func (u *UpdateAssistantDtoTranscriber) GetAssemblyAiTranscriber() *AssemblyAiTranscriber {
	if u == nil {
		return nil
	}
	return u.AssemblyAiTranscriber
}

func (u *UpdateAssistantDtoTranscriber) GetCustomTranscriber() *CustomTranscriber {
	if u == nil {
		return nil
	}
	return u.CustomTranscriber
}

func (u *UpdateAssistantDtoTranscriber) GetDeepgramTranscriber() *DeepgramTranscriber {
	if u == nil {
		return nil
	}
	return u.DeepgramTranscriber
}

func (u *UpdateAssistantDtoTranscriber) GetGladiaTranscriber() *GladiaTranscriber {
	if u == nil {
		return nil
	}
	return u.GladiaTranscriber
}

func (u *UpdateAssistantDtoTranscriber) GetTalkscriberTranscriber() *TalkscriberTranscriber {
	if u == nil {
		return nil
	}
	return u.TalkscriberTranscriber
}

func (u *UpdateAssistantDtoTranscriber) UnmarshalJSON(data []byte) error {
	valueAssemblyAiTranscriber := new(AssemblyAiTranscriber)
	if err := json.Unmarshal(data, &valueAssemblyAiTranscriber); err == nil {
		u.typ = "AssemblyAiTranscriber"
		u.AssemblyAiTranscriber = valueAssemblyAiTranscriber
		return nil
	}
	valueCustomTranscriber := new(CustomTranscriber)
	if err := json.Unmarshal(data, &valueCustomTranscriber); err == nil {
		u.typ = "CustomTranscriber"
		u.CustomTranscriber = valueCustomTranscriber
		return nil
	}
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		u.typ = "DeepgramTranscriber"
		u.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		u.typ = "GladiaTranscriber"
		u.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		u.typ = "TalkscriberTranscriber"
		u.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateAssistantDtoTranscriber) MarshalJSON() ([]byte, error) {
	if u.typ == "AssemblyAiTranscriber" || u.AssemblyAiTranscriber != nil {
		return json.Marshal(u.AssemblyAiTranscriber)
	}
	if u.typ == "CustomTranscriber" || u.CustomTranscriber != nil {
		return json.Marshal(u.CustomTranscriber)
	}
	if u.typ == "DeepgramTranscriber" || u.DeepgramTranscriber != nil {
		return json.Marshal(u.DeepgramTranscriber)
	}
	if u.typ == "GladiaTranscriber" || u.GladiaTranscriber != nil {
		return json.Marshal(u.GladiaTranscriber)
	}
	if u.typ == "TalkscriberTranscriber" || u.TalkscriberTranscriber != nil {
		return json.Marshal(u.TalkscriberTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateAssistantDtoTranscriberVisitor interface {
	VisitAssemblyAiTranscriber(*AssemblyAiTranscriber) error
	VisitCustomTranscriber(*CustomTranscriber) error
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
}

func (u *UpdateAssistantDtoTranscriber) Accept(visitor UpdateAssistantDtoTranscriberVisitor) error {
	if u.typ == "AssemblyAiTranscriber" || u.AssemblyAiTranscriber != nil {
		return visitor.VisitAssemblyAiTranscriber(u.AssemblyAiTranscriber)
	}
	if u.typ == "CustomTranscriber" || u.CustomTranscriber != nil {
		return visitor.VisitCustomTranscriber(u.CustomTranscriber)
	}
	if u.typ == "DeepgramTranscriber" || u.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(u.DeepgramTranscriber)
	}
	if u.typ == "GladiaTranscriber" || u.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(u.GladiaTranscriber)
	}
	if u.typ == "TalkscriberTranscriber" || u.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(u.TalkscriberTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// These are the options for the assistant's voice.
type UpdateAssistantDtoVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	CustomVoice     *CustomVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	LmntVoice       *LmntVoice
	NeetsVoice      *NeetsVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
	TavusVoice      *TavusVoice

	typ string
}

func (u *UpdateAssistantDtoVoice) GetAzureVoice() *AzureVoice {
	if u == nil {
		return nil
	}
	return u.AzureVoice
}

func (u *UpdateAssistantDtoVoice) GetCartesiaVoice() *CartesiaVoice {
	if u == nil {
		return nil
	}
	return u.CartesiaVoice
}

func (u *UpdateAssistantDtoVoice) GetCustomVoice() *CustomVoice {
	if u == nil {
		return nil
	}
	return u.CustomVoice
}

func (u *UpdateAssistantDtoVoice) GetDeepgramVoice() *DeepgramVoice {
	if u == nil {
		return nil
	}
	return u.DeepgramVoice
}

func (u *UpdateAssistantDtoVoice) GetElevenLabsVoice() *ElevenLabsVoice {
	if u == nil {
		return nil
	}
	return u.ElevenLabsVoice
}

func (u *UpdateAssistantDtoVoice) GetLmntVoice() *LmntVoice {
	if u == nil {
		return nil
	}
	return u.LmntVoice
}

func (u *UpdateAssistantDtoVoice) GetNeetsVoice() *NeetsVoice {
	if u == nil {
		return nil
	}
	return u.NeetsVoice
}

func (u *UpdateAssistantDtoVoice) GetOpenAiVoice() *OpenAiVoice {
	if u == nil {
		return nil
	}
	return u.OpenAiVoice
}

func (u *UpdateAssistantDtoVoice) GetPlayHtVoice() *PlayHtVoice {
	if u == nil {
		return nil
	}
	return u.PlayHtVoice
}

func (u *UpdateAssistantDtoVoice) GetRimeAiVoice() *RimeAiVoice {
	if u == nil {
		return nil
	}
	return u.RimeAiVoice
}

func (u *UpdateAssistantDtoVoice) GetTavusVoice() *TavusVoice {
	if u == nil {
		return nil
	}
	return u.TavusVoice
}

func (u *UpdateAssistantDtoVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		u.typ = "AzureVoice"
		u.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		u.typ = "CartesiaVoice"
		u.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueCustomVoice := new(CustomVoice)
	if err := json.Unmarshal(data, &valueCustomVoice); err == nil {
		u.typ = "CustomVoice"
		u.CustomVoice = valueCustomVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		u.typ = "DeepgramVoice"
		u.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		u.typ = "ElevenLabsVoice"
		u.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		u.typ = "LmntVoice"
		u.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeetsVoice := new(NeetsVoice)
	if err := json.Unmarshal(data, &valueNeetsVoice); err == nil {
		u.typ = "NeetsVoice"
		u.NeetsVoice = valueNeetsVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		u.typ = "OpenAiVoice"
		u.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		u.typ = "PlayHtVoice"
		u.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		u.typ = "RimeAiVoice"
		u.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	valueTavusVoice := new(TavusVoice)
	if err := json.Unmarshal(data, &valueTavusVoice); err == nil {
		u.typ = "TavusVoice"
		u.TavusVoice = valueTavusVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateAssistantDtoVoice) MarshalJSON() ([]byte, error) {
	if u.typ == "AzureVoice" || u.AzureVoice != nil {
		return json.Marshal(u.AzureVoice)
	}
	if u.typ == "CartesiaVoice" || u.CartesiaVoice != nil {
		return json.Marshal(u.CartesiaVoice)
	}
	if u.typ == "CustomVoice" || u.CustomVoice != nil {
		return json.Marshal(u.CustomVoice)
	}
	if u.typ == "DeepgramVoice" || u.DeepgramVoice != nil {
		return json.Marshal(u.DeepgramVoice)
	}
	if u.typ == "ElevenLabsVoice" || u.ElevenLabsVoice != nil {
		return json.Marshal(u.ElevenLabsVoice)
	}
	if u.typ == "LmntVoice" || u.LmntVoice != nil {
		return json.Marshal(u.LmntVoice)
	}
	if u.typ == "NeetsVoice" || u.NeetsVoice != nil {
		return json.Marshal(u.NeetsVoice)
	}
	if u.typ == "OpenAiVoice" || u.OpenAiVoice != nil {
		return json.Marshal(u.OpenAiVoice)
	}
	if u.typ == "PlayHtVoice" || u.PlayHtVoice != nil {
		return json.Marshal(u.PlayHtVoice)
	}
	if u.typ == "RimeAiVoice" || u.RimeAiVoice != nil {
		return json.Marshal(u.RimeAiVoice)
	}
	if u.typ == "TavusVoice" || u.TavusVoice != nil {
		return json.Marshal(u.TavusVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateAssistantDtoVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitCustomVoice(*CustomVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeetsVoice(*NeetsVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
	VisitTavusVoice(*TavusVoice) error
}

func (u *UpdateAssistantDtoVoice) Accept(visitor UpdateAssistantDtoVoiceVisitor) error {
	if u.typ == "AzureVoice" || u.AzureVoice != nil {
		return visitor.VisitAzureVoice(u.AzureVoice)
	}
	if u.typ == "CartesiaVoice" || u.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(u.CartesiaVoice)
	}
	if u.typ == "CustomVoice" || u.CustomVoice != nil {
		return visitor.VisitCustomVoice(u.CustomVoice)
	}
	if u.typ == "DeepgramVoice" || u.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(u.DeepgramVoice)
	}
	if u.typ == "ElevenLabsVoice" || u.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(u.ElevenLabsVoice)
	}
	if u.typ == "LmntVoice" || u.LmntVoice != nil {
		return visitor.VisitLmntVoice(u.LmntVoice)
	}
	if u.typ == "NeetsVoice" || u.NeetsVoice != nil {
		return visitor.VisitNeetsVoice(u.NeetsVoice)
	}
	if u.typ == "OpenAiVoice" || u.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(u.OpenAiVoice)
	}
	if u.typ == "PlayHtVoice" || u.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(u.PlayHtVoice)
	}
	if u.typ == "RimeAiVoice" || u.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(u.RimeAiVoice)
	}
	if u.typ == "TavusVoice" || u.TavusVoice != nil {
		return visitor.VisitTavusVoice(u.TavusVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateAssistantDto struct {
	// These are the options for the assistant's transcriber.
	Transcriber *UpdateAssistantDtoTranscriber `json:"transcriber,omitempty" url:"-"`
	// These are the options for the assistant's LLM.
	Model *UpdateAssistantDtoModel `json:"model,omitempty" url:"-"`
	// These are the options for the assistant's voice.
	Voice *UpdateAssistantDtoVoice `json:"voice,omitempty" url:"-"`
	// This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
	//
	// If unspecified, assistant will wait for user to speak and use the model to respond once they speak.
	FirstMessage *string `json:"firstMessage,omitempty" url:"-"`
	// This is the mode for the first message. Default is 'assistant-speaks-first'.
	//
	// Use:
	// - 'assistant-speaks-first' to have the assistant speak first.
	// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
	// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
	//
	// @default 'assistant-speaks-first'
	FirstMessageMode *UpdateAssistantDtoFirstMessageMode `json:"firstMessageMode,omitempty" url:"-"`
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"-"`
	// These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input. You can check the shape of the messages in ClientMessage schema.
	ClientMessages []UpdateAssistantDtoClientMessagesItem `json:"clientMessages,omitempty" url:"-"`
	// These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
	ServerMessages []UpdateAssistantDtoServerMessagesItem `json:"serverMessages,omitempty" url:"-"`
	// How many seconds of silence to wait before ending the call. Defaults to 30.
	//
	// @default 30
	SilenceTimeoutSeconds *float64 `json:"silenceTimeoutSeconds,omitempty" url:"-"`
	// This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
	//
	// @default 600 (10 minutes)
	MaxDurationSeconds *float64 `json:"maxDurationSeconds,omitempty" url:"-"`
	// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
	BackgroundSound *UpdateAssistantDtoBackgroundSound `json:"backgroundSound,omitempty" url:"-"`
	// This enables filtering of noise and background speech while the user is talking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackgroundDenoisingEnabled *bool `json:"backgroundDenoisingEnabled,omitempty" url:"-"`
	// This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
	//
	// Default `false` while in beta.
	//
	// @default false
	ModelOutputInMessagesEnabled *bool `json:"modelOutputInMessagesEnabled,omitempty" url:"-"`
	// These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
	TransportConfigurations []*TransportConfigurationTwilio `json:"transportConfigurations,omitempty" url:"-"`
	// This is the name of the assistant.
	//
	// This is required when you want to transfer between assistants in a call.
	Name *string `json:"name,omitempty" url:"-"`
	// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
	// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
	// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
	VoicemailDetection *TwilioVoicemailDetection `json:"voicemailDetection,omitempty" url:"-"`
	// This is the message that the assistant will say if the call is forwarded to voicemail.
	//
	// If unspecified, it will hang up.
	VoicemailMessage *string `json:"voicemailMessage,omitempty" url:"-"`
	// This is the message that the assistant will say if it ends the call.
	//
	// If unspecified, it will hang up without saying anything.
	EndCallMessage *string `json:"endCallMessage,omitempty" url:"-"`
	// This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
	EndCallPhrases []string `json:"endCallPhrases,omitempty" url:"-"`
	// This is for metadata you want to store on the assistant.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
	// This is the plan for analysis of assistant's calls. Stored in `call.analysis`.
	AnalysisPlan *AnalysisPlan `json:"analysisPlan,omitempty" url:"-"`
	// This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.
	//
	// Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"-"`
	// This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.
	//
	// Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.
	MessagePlan *MessagePlan `json:"messagePlan,omitempty" url:"-"`
	// This is the plan for when the assistant should start talking.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to start talking after the customer is done speaking.
	// - The assistant is too fast to start talking after the customer is done speaking.
	// - The assistant is so fast that it's actually interrupting the customer.
	StartSpeakingPlan *StartSpeakingPlan `json:"startSpeakingPlan,omitempty" url:"-"`
	// This is the plan for when assistant should stop talking on customer interruption.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to recognize customer's interruption.
	// - The assistant is too fast to recognize customer's interruption.
	// - The assistant is getting interrupted by phrases that are just acknowledgments.
	// - The assistant is getting interrupted by background noises.
	// - The assistant is not properly stopping -- it starts talking right after getting interrupted.
	StopSpeakingPlan *StopSpeakingPlan `json:"stopSpeakingPlan,omitempty" url:"-"`
	// This is the plan for real-time monitoring of the assistant's calls.
	//
	// Usage:
	// - To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.
	// - To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.
	//
	// Note, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible
	MonitorPlan *MonitorPlan `json:"monitorPlan,omitempty" url:"-"`
	// These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
	CredentialIds []string `json:"credentialIds,omitempty" url:"-"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server.url
	// 2. phoneNumber.serverUrl
	// 3. org.serverUrl
	Server *Server `json:"server,omitempty" url:"-"`
}
