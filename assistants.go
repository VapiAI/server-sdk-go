// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"
)

type AssistantsListRequest struct {
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`
}

// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
type UpdateAssistantDtoBackgroundSound string

const (
	UpdateAssistantDtoBackgroundSoundOff    UpdateAssistantDtoBackgroundSound = "off"
	UpdateAssistantDtoBackgroundSoundOffice UpdateAssistantDtoBackgroundSound = "office"
)

func NewUpdateAssistantDtoBackgroundSoundFromString(s string) (UpdateAssistantDtoBackgroundSound, error) {
	switch s {
	case "off":
		return UpdateAssistantDtoBackgroundSoundOff, nil
	case "office":
		return UpdateAssistantDtoBackgroundSoundOffice, nil
	}
	var t UpdateAssistantDtoBackgroundSound
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAssistantDtoBackgroundSound) Ptr() *UpdateAssistantDtoBackgroundSound {
	return &u
}

type UpdateAssistantDtoClientMessagesItem string

const (
	UpdateAssistantDtoClientMessagesItemConversationUpdate UpdateAssistantDtoClientMessagesItem = "conversation-update"
	UpdateAssistantDtoClientMessagesItemFunctionCall       UpdateAssistantDtoClientMessagesItem = "function-call"
	UpdateAssistantDtoClientMessagesItemFunctionCallResult UpdateAssistantDtoClientMessagesItem = "function-call-result"
	UpdateAssistantDtoClientMessagesItemHang               UpdateAssistantDtoClientMessagesItem = "hang"
	UpdateAssistantDtoClientMessagesItemLanguageChanged    UpdateAssistantDtoClientMessagesItem = "language-changed"
	UpdateAssistantDtoClientMessagesItemMetadata           UpdateAssistantDtoClientMessagesItem = "metadata"
	UpdateAssistantDtoClientMessagesItemModelOutput        UpdateAssistantDtoClientMessagesItem = "model-output"
	UpdateAssistantDtoClientMessagesItemSpeechUpdate       UpdateAssistantDtoClientMessagesItem = "speech-update"
	UpdateAssistantDtoClientMessagesItemStatusUpdate       UpdateAssistantDtoClientMessagesItem = "status-update"
	UpdateAssistantDtoClientMessagesItemTranscript         UpdateAssistantDtoClientMessagesItem = "transcript"
	UpdateAssistantDtoClientMessagesItemToolCalls          UpdateAssistantDtoClientMessagesItem = "tool-calls"
	UpdateAssistantDtoClientMessagesItemToolCallsResult    UpdateAssistantDtoClientMessagesItem = "tool-calls-result"
	UpdateAssistantDtoClientMessagesItemUserInterrupted    UpdateAssistantDtoClientMessagesItem = "user-interrupted"
	UpdateAssistantDtoClientMessagesItemVoiceInput         UpdateAssistantDtoClientMessagesItem = "voice-input"
)

func NewUpdateAssistantDtoClientMessagesItemFromString(s string) (UpdateAssistantDtoClientMessagesItem, error) {
	switch s {
	case "conversation-update":
		return UpdateAssistantDtoClientMessagesItemConversationUpdate, nil
	case "function-call":
		return UpdateAssistantDtoClientMessagesItemFunctionCall, nil
	case "function-call-result":
		return UpdateAssistantDtoClientMessagesItemFunctionCallResult, nil
	case "hang":
		return UpdateAssistantDtoClientMessagesItemHang, nil
	case "language-changed":
		return UpdateAssistantDtoClientMessagesItemLanguageChanged, nil
	case "metadata":
		return UpdateAssistantDtoClientMessagesItemMetadata, nil
	case "model-output":
		return UpdateAssistantDtoClientMessagesItemModelOutput, nil
	case "speech-update":
		return UpdateAssistantDtoClientMessagesItemSpeechUpdate, nil
	case "status-update":
		return UpdateAssistantDtoClientMessagesItemStatusUpdate, nil
	case "transcript":
		return UpdateAssistantDtoClientMessagesItemTranscript, nil
	case "tool-calls":
		return UpdateAssistantDtoClientMessagesItemToolCalls, nil
	case "tool-calls-result":
		return UpdateAssistantDtoClientMessagesItemToolCallsResult, nil
	case "user-interrupted":
		return UpdateAssistantDtoClientMessagesItemUserInterrupted, nil
	case "voice-input":
		return UpdateAssistantDtoClientMessagesItemVoiceInput, nil
	}
	var t UpdateAssistantDtoClientMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAssistantDtoClientMessagesItem) Ptr() *UpdateAssistantDtoClientMessagesItem {
	return &u
}

// This is the mode for the first message. Default is 'assistant-speaks-first'.
//
// Use:
//
// - 'assistant-speaks-first' to have the assistant speak first.
// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
//
// @default 'assistant-speaks-first'
type UpdateAssistantDtoFirstMessageMode string

const (
	UpdateAssistantDtoFirstMessageModeAssistantSpeaksFirst                          UpdateAssistantDtoFirstMessageMode = "assistant-speaks-first"
	UpdateAssistantDtoFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage UpdateAssistantDtoFirstMessageMode = "assistant-speaks-first-with-model-generated-message"
	UpdateAssistantDtoFirstMessageModeAssistantWaitsForUser                         UpdateAssistantDtoFirstMessageMode = "assistant-waits-for-user"
)

func NewUpdateAssistantDtoFirstMessageModeFromString(s string) (UpdateAssistantDtoFirstMessageMode, error) {
	switch s {
	case "assistant-speaks-first":
		return UpdateAssistantDtoFirstMessageModeAssistantSpeaksFirst, nil
	case "assistant-speaks-first-with-model-generated-message":
		return UpdateAssistantDtoFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage, nil
	case "assistant-waits-for-user":
		return UpdateAssistantDtoFirstMessageModeAssistantWaitsForUser, nil
	}
	var t UpdateAssistantDtoFirstMessageMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAssistantDtoFirstMessageMode) Ptr() *UpdateAssistantDtoFirstMessageMode {
	return &u
}

// These are the options for the assistant's LLM.
type UpdateAssistantDtoModel struct {
	AnyscaleModel     *AnyscaleModel
	AnthropicModel    *AnthropicModel
	CustomLlmModel    *CustomLlmModel
	DeepInfraModel    *DeepInfraModel
	GroqModel         *GroqModel
	OpenAiModel       *OpenAiModel
	OpenRouterModel   *OpenRouterModel
	PerplexityAiModel *PerplexityAiModel
	TogetherAiModel   *TogetherAiModel
	VapiModel         *VapiModel
}

func (u *UpdateAssistantDtoModel) UnmarshalJSON(data []byte) error {
	valueAnyscaleModel := new(AnyscaleModel)
	if err := json.Unmarshal(data, &valueAnyscaleModel); err == nil {
		u.AnyscaleModel = valueAnyscaleModel
		return nil
	}
	valueAnthropicModel := new(AnthropicModel)
	if err := json.Unmarshal(data, &valueAnthropicModel); err == nil {
		u.AnthropicModel = valueAnthropicModel
		return nil
	}
	valueCustomLlmModel := new(CustomLlmModel)
	if err := json.Unmarshal(data, &valueCustomLlmModel); err == nil {
		u.CustomLlmModel = valueCustomLlmModel
		return nil
	}
	valueDeepInfraModel := new(DeepInfraModel)
	if err := json.Unmarshal(data, &valueDeepInfraModel); err == nil {
		u.DeepInfraModel = valueDeepInfraModel
		return nil
	}
	valueGroqModel := new(GroqModel)
	if err := json.Unmarshal(data, &valueGroqModel); err == nil {
		u.GroqModel = valueGroqModel
		return nil
	}
	valueOpenAiModel := new(OpenAiModel)
	if err := json.Unmarshal(data, &valueOpenAiModel); err == nil {
		u.OpenAiModel = valueOpenAiModel
		return nil
	}
	valueOpenRouterModel := new(OpenRouterModel)
	if err := json.Unmarshal(data, &valueOpenRouterModel); err == nil {
		u.OpenRouterModel = valueOpenRouterModel
		return nil
	}
	valuePerplexityAiModel := new(PerplexityAiModel)
	if err := json.Unmarshal(data, &valuePerplexityAiModel); err == nil {
		u.PerplexityAiModel = valuePerplexityAiModel
		return nil
	}
	valueTogetherAiModel := new(TogetherAiModel)
	if err := json.Unmarshal(data, &valueTogetherAiModel); err == nil {
		u.TogetherAiModel = valueTogetherAiModel
		return nil
	}
	valueVapiModel := new(VapiModel)
	if err := json.Unmarshal(data, &valueVapiModel); err == nil {
		u.VapiModel = valueVapiModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateAssistantDtoModel) MarshalJSON() ([]byte, error) {
	if u.AnyscaleModel != nil {
		return json.Marshal(u.AnyscaleModel)
	}
	if u.AnthropicModel != nil {
		return json.Marshal(u.AnthropicModel)
	}
	if u.CustomLlmModel != nil {
		return json.Marshal(u.CustomLlmModel)
	}
	if u.DeepInfraModel != nil {
		return json.Marshal(u.DeepInfraModel)
	}
	if u.GroqModel != nil {
		return json.Marshal(u.GroqModel)
	}
	if u.OpenAiModel != nil {
		return json.Marshal(u.OpenAiModel)
	}
	if u.OpenRouterModel != nil {
		return json.Marshal(u.OpenRouterModel)
	}
	if u.PerplexityAiModel != nil {
		return json.Marshal(u.PerplexityAiModel)
	}
	if u.TogetherAiModel != nil {
		return json.Marshal(u.TogetherAiModel)
	}
	if u.VapiModel != nil {
		return json.Marshal(u.VapiModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateAssistantDtoModelVisitor interface {
	VisitAnyscaleModel(*AnyscaleModel) error
	VisitAnthropicModel(*AnthropicModel) error
	VisitCustomLlmModel(*CustomLlmModel) error
	VisitDeepInfraModel(*DeepInfraModel) error
	VisitGroqModel(*GroqModel) error
	VisitOpenAiModel(*OpenAiModel) error
	VisitOpenRouterModel(*OpenRouterModel) error
	VisitPerplexityAiModel(*PerplexityAiModel) error
	VisitTogetherAiModel(*TogetherAiModel) error
	VisitVapiModel(*VapiModel) error
}

func (u *UpdateAssistantDtoModel) Accept(visitor UpdateAssistantDtoModelVisitor) error {
	if u.AnyscaleModel != nil {
		return visitor.VisitAnyscaleModel(u.AnyscaleModel)
	}
	if u.AnthropicModel != nil {
		return visitor.VisitAnthropicModel(u.AnthropicModel)
	}
	if u.CustomLlmModel != nil {
		return visitor.VisitCustomLlmModel(u.CustomLlmModel)
	}
	if u.DeepInfraModel != nil {
		return visitor.VisitDeepInfraModel(u.DeepInfraModel)
	}
	if u.GroqModel != nil {
		return visitor.VisitGroqModel(u.GroqModel)
	}
	if u.OpenAiModel != nil {
		return visitor.VisitOpenAiModel(u.OpenAiModel)
	}
	if u.OpenRouterModel != nil {
		return visitor.VisitOpenRouterModel(u.OpenRouterModel)
	}
	if u.PerplexityAiModel != nil {
		return visitor.VisitPerplexityAiModel(u.PerplexityAiModel)
	}
	if u.TogetherAiModel != nil {
		return visitor.VisitTogetherAiModel(u.TogetherAiModel)
	}
	if u.VapiModel != nil {
		return visitor.VisitVapiModel(u.VapiModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateAssistantDtoServerMessagesItem string

const (
	UpdateAssistantDtoServerMessagesItemConversationUpdate         UpdateAssistantDtoServerMessagesItem = "conversation-update"
	UpdateAssistantDtoServerMessagesItemEndOfCallReport            UpdateAssistantDtoServerMessagesItem = "end-of-call-report"
	UpdateAssistantDtoServerMessagesItemFunctionCall               UpdateAssistantDtoServerMessagesItem = "function-call"
	UpdateAssistantDtoServerMessagesItemHang                       UpdateAssistantDtoServerMessagesItem = "hang"
	UpdateAssistantDtoServerMessagesItemLanguageChanged            UpdateAssistantDtoServerMessagesItem = "language-changed"
	UpdateAssistantDtoServerMessagesItemModelOutput                UpdateAssistantDtoServerMessagesItem = "model-output"
	UpdateAssistantDtoServerMessagesItemPhoneCallControl           UpdateAssistantDtoServerMessagesItem = "phone-call-control"
	UpdateAssistantDtoServerMessagesItemSpeechUpdate               UpdateAssistantDtoServerMessagesItem = "speech-update"
	UpdateAssistantDtoServerMessagesItemStatusUpdate               UpdateAssistantDtoServerMessagesItem = "status-update"
	UpdateAssistantDtoServerMessagesItemTranscript                 UpdateAssistantDtoServerMessagesItem = "transcript"
	UpdateAssistantDtoServerMessagesItemToolCalls                  UpdateAssistantDtoServerMessagesItem = "tool-calls"
	UpdateAssistantDtoServerMessagesItemTransferDestinationRequest UpdateAssistantDtoServerMessagesItem = "transfer-destination-request"
	UpdateAssistantDtoServerMessagesItemTransferUpdate             UpdateAssistantDtoServerMessagesItem = "transfer-update"
	UpdateAssistantDtoServerMessagesItemUserInterrupted            UpdateAssistantDtoServerMessagesItem = "user-interrupted"
	UpdateAssistantDtoServerMessagesItemVoiceInput                 UpdateAssistantDtoServerMessagesItem = "voice-input"
)

func NewUpdateAssistantDtoServerMessagesItemFromString(s string) (UpdateAssistantDtoServerMessagesItem, error) {
	switch s {
	case "conversation-update":
		return UpdateAssistantDtoServerMessagesItemConversationUpdate, nil
	case "end-of-call-report":
		return UpdateAssistantDtoServerMessagesItemEndOfCallReport, nil
	case "function-call":
		return UpdateAssistantDtoServerMessagesItemFunctionCall, nil
	case "hang":
		return UpdateAssistantDtoServerMessagesItemHang, nil
	case "language-changed":
		return UpdateAssistantDtoServerMessagesItemLanguageChanged, nil
	case "model-output":
		return UpdateAssistantDtoServerMessagesItemModelOutput, nil
	case "phone-call-control":
		return UpdateAssistantDtoServerMessagesItemPhoneCallControl, nil
	case "speech-update":
		return UpdateAssistantDtoServerMessagesItemSpeechUpdate, nil
	case "status-update":
		return UpdateAssistantDtoServerMessagesItemStatusUpdate, nil
	case "transcript":
		return UpdateAssistantDtoServerMessagesItemTranscript, nil
	case "tool-calls":
		return UpdateAssistantDtoServerMessagesItemToolCalls, nil
	case "transfer-destination-request":
		return UpdateAssistantDtoServerMessagesItemTransferDestinationRequest, nil
	case "transfer-update":
		return UpdateAssistantDtoServerMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return UpdateAssistantDtoServerMessagesItemUserInterrupted, nil
	case "voice-input":
		return UpdateAssistantDtoServerMessagesItemVoiceInput, nil
	}
	var t UpdateAssistantDtoServerMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAssistantDtoServerMessagesItem) Ptr() *UpdateAssistantDtoServerMessagesItem {
	return &u
}

// These are the options for the assistant's transcriber.
type UpdateAssistantDtoTranscriber struct {
	DeepgramTranscriber    *DeepgramTranscriber
	GladiaTranscriber      *GladiaTranscriber
	TalkscriberTranscriber *TalkscriberTranscriber
}

func (u *UpdateAssistantDtoTranscriber) UnmarshalJSON(data []byte) error {
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		u.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		u.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		u.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateAssistantDtoTranscriber) MarshalJSON() ([]byte, error) {
	if u.DeepgramTranscriber != nil {
		return json.Marshal(u.DeepgramTranscriber)
	}
	if u.GladiaTranscriber != nil {
		return json.Marshal(u.GladiaTranscriber)
	}
	if u.TalkscriberTranscriber != nil {
		return json.Marshal(u.TalkscriberTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateAssistantDtoTranscriberVisitor interface {
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
}

func (u *UpdateAssistantDtoTranscriber) Accept(visitor UpdateAssistantDtoTranscriberVisitor) error {
	if u.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(u.DeepgramTranscriber)
	}
	if u.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(u.GladiaTranscriber)
	}
	if u.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(u.TalkscriberTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// These are the options for the assistant's voice.
type UpdateAssistantDtoVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	LmntVoice       *LmntVoice
	NeetsVoice      *NeetsVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
}

func (u *UpdateAssistantDtoVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		u.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		u.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		u.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		u.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		u.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeetsVoice := new(NeetsVoice)
	if err := json.Unmarshal(data, &valueNeetsVoice); err == nil {
		u.NeetsVoice = valueNeetsVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		u.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		u.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		u.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateAssistantDtoVoice) MarshalJSON() ([]byte, error) {
	if u.AzureVoice != nil {
		return json.Marshal(u.AzureVoice)
	}
	if u.CartesiaVoice != nil {
		return json.Marshal(u.CartesiaVoice)
	}
	if u.DeepgramVoice != nil {
		return json.Marshal(u.DeepgramVoice)
	}
	if u.ElevenLabsVoice != nil {
		return json.Marshal(u.ElevenLabsVoice)
	}
	if u.LmntVoice != nil {
		return json.Marshal(u.LmntVoice)
	}
	if u.NeetsVoice != nil {
		return json.Marshal(u.NeetsVoice)
	}
	if u.OpenAiVoice != nil {
		return json.Marshal(u.OpenAiVoice)
	}
	if u.PlayHtVoice != nil {
		return json.Marshal(u.PlayHtVoice)
	}
	if u.RimeAiVoice != nil {
		return json.Marshal(u.RimeAiVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateAssistantDtoVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeetsVoice(*NeetsVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
}

func (u *UpdateAssistantDtoVoice) Accept(visitor UpdateAssistantDtoVoiceVisitor) error {
	if u.AzureVoice != nil {
		return visitor.VisitAzureVoice(u.AzureVoice)
	}
	if u.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(u.CartesiaVoice)
	}
	if u.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(u.DeepgramVoice)
	}
	if u.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(u.ElevenLabsVoice)
	}
	if u.LmntVoice != nil {
		return visitor.VisitLmntVoice(u.LmntVoice)
	}
	if u.NeetsVoice != nil {
		return visitor.VisitNeetsVoice(u.NeetsVoice)
	}
	if u.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(u.OpenAiVoice)
	}
	if u.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(u.PlayHtVoice)
	}
	if u.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(u.RimeAiVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateAssistantDto struct {
	// These are the options for the assistant's transcriber.
	Transcriber *UpdateAssistantDtoTranscriber `json:"transcriber,omitempty" url:"-"`
	// These are the options for the assistant's LLM.
	Model *UpdateAssistantDtoModel `json:"model,omitempty" url:"-"`
	// These are the options for the assistant's voice.
	Voice *UpdateAssistantDtoVoice `json:"voice,omitempty" url:"-"`
	// This is the mode for the first message. Default is 'assistant-speaks-first'.
	//
	// Use:
	// - 'assistant-speaks-first' to have the assistant speak first.
	// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
	// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
	//
	// @default 'assistant-speaks-first'
	FirstMessageMode *UpdateAssistantDtoFirstMessageMode `json:"firstMessageMode,omitempty" url:"-"`
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"-"`
	// These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transcript,tool-calls,user-interrupted,voice-input. You can check the shape of the messages in ClientMessage schema.
	ClientMessages []UpdateAssistantDtoClientMessagesItem `json:"clientMessages,omitempty" url:"-"`
	// These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
	ServerMessages []UpdateAssistantDtoServerMessagesItem `json:"serverMessages,omitempty" url:"-"`
	// How many seconds of silence to wait before ending the call. Defaults to 30.
	//
	// @default 30
	SilenceTimeoutSeconds *float64 `json:"silenceTimeoutSeconds,omitempty" url:"-"`
	// This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
	//
	// @default 600 (10 minutes)
	MaxDurationSeconds *float64 `json:"maxDurationSeconds,omitempty" url:"-"`
	// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
	BackgroundSound *UpdateAssistantDtoBackgroundSound `json:"backgroundSound,omitempty" url:"-"`
	// This determines whether the model says 'mhmm', 'ahem' etc. while user is speaking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackchannelingEnabled *bool `json:"backchannelingEnabled,omitempty" url:"-"`
	// This enables filtering of noise and background speech while the user is talking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackgroundDenoisingEnabled *bool `json:"backgroundDenoisingEnabled,omitempty" url:"-"`
	// This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
	//
	// Default `false` while in beta.
	//
	// @default false
	ModelOutputInMessagesEnabled *bool `json:"modelOutputInMessagesEnabled,omitempty" url:"-"`
	// These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
	TransportConfigurations []*TransportConfigurationTwilio `json:"transportConfigurations,omitempty" url:"-"`
	// This is the name of the assistant.
	//
	// This is required when you want to transfer between assistants in a call.
	Name *string `json:"name,omitempty" url:"-"`
	// This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
	//
	// If unspecified, assistant will wait for user to speak and use the model to respond once they speak.
	FirstMessage *string `json:"firstMessage,omitempty" url:"-"`
	// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
	// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
	// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
	VoicemailDetection *TwilioVoicemailDetection `json:"voicemailDetection,omitempty" url:"-"`
	// This is the message that the assistant will say if the call is forwarded to voicemail.
	//
	// If unspecified, it will hang up.
	VoicemailMessage *string `json:"voicemailMessage,omitempty" url:"-"`
	// This is the message that the assistant will say if it ends the call.
	//
	// If unspecified, it will hang up without saying anything.
	EndCallMessage *string `json:"endCallMessage,omitempty" url:"-"`
	// This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
	EndCallPhrases []string `json:"endCallPhrases,omitempty" url:"-"`
	// This is for metadata you want to store on the assistant.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
	// This is the URL Vapi will communicate with via HTTP GET and POST Requests. This is used for retrieving context, function calling, and end-of-call reports.
	//
	// All requests will be sent with the call object among other things relevant to that message. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl
	ServerUrl *string `json:"serverUrl,omitempty" url:"-"`
	// This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"-"`
	// This is the plan for analysis of assistant's calls. Stored in `call.analysis`.
	AnalysisPlan *AnalysisPlan `json:"analysisPlan,omitempty" url:"-"`
	// This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.
	//
	// Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"-"`
	// This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.
	//
	// Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.
	MessagePlan *MessagePlan `json:"messagePlan,omitempty" url:"-"`
	// This is the plan for when the assistant should start talking.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to start talking after the customer is done speaking.
	// - The assistant is too fast to start talking after the customer is done speaking.
	// - The assistant is so fast that it's actually interrupting the customer.
	StartSpeakingPlan *StartSpeakingPlan `json:"startSpeakingPlan,omitempty" url:"-"`
	// This is the plan for when assistant should stop talking on customer interruption.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to recognize customer's interruption.
	// - The assistant is too fast to recognize customer's interruption.
	// - The assistant is getting interrupted by phrases that are just acknowledgments.
	// - The assistant is getting interrupted by background noises.
	// - The assistant is not properly stopping -- it starts talking right after getting interrupted.
	StopSpeakingPlan *StopSpeakingPlan `json:"stopSpeakingPlan,omitempty" url:"-"`
	// This is the plan for real-time monitoring of the assistant's calls.
	//
	// Usage:
	// - To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.
	// - To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.
	//
	// Note, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible
	MonitorPlan *MonitorPlan `json:"monitorPlan,omitempty" url:"-"`
	// These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
	CredentialIds []string `json:"credentialIds,omitempty" url:"-"`
}
