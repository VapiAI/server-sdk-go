// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/VapiAI/server-sdk-go/internal"
	time "time"
)

type CreateSessionDto struct {
	// This is a user-defined name for the session. Maximum length is 40 characters.
	Name *string `json:"name,omitempty" url:"-"`
	// This is the current status of the session. Can be either 'active' or 'completed'.
	Status *CreateSessionDtoStatus `json:"status,omitempty" url:"-"`
	// Session expiration time in seconds. Defaults to 24 hours (86400 seconds) if not set.
	ExpirationSeconds *float64 `json:"expirationSeconds,omitempty" url:"-"`
	// This is the ID of the assistant associated with this session. Use this when referencing an existing assistant.
	AssistantId *string `json:"assistantId,omitempty" url:"-"`
	// This is the assistant configuration for this session. Use this when creating a new assistant configuration.
	// If assistantId is provided, this will be ignored.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"-"`
	// This is an array of chat messages in the session.
	Messages []*CreateSessionDtoMessagesItem `json:"messages,omitempty" url:"-"`
	// This is the customer information associated with this session.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"-"`
	// This is the ID of the phone number associated with this session.
	PhoneNumberId *string `json:"phoneNumberId,omitempty" url:"-"`
	// This is the phone number configuration for this session.
	PhoneNumber *ImportTwilioPhoneNumberDto `json:"phoneNumber,omitempty" url:"-"`
}

type SessionsListRequest struct {
	// This is the name of the session to filter by.
	Name *string `json:"-" url:"name,omitempty"`
	// This is the ID of the assistant to filter sessions by.
	AssistantId *string `json:"-" url:"assistantId,omitempty"`
	// This is the ID of the workflow to filter sessions by.
	WorkflowId *string `json:"-" url:"workflowId,omitempty"`
	// This is the page number to return. Defaults to 1.
	Page *float64 `json:"-" url:"page,omitempty"`
	// This is the sort order for pagination. Defaults to 'DESC'.
	SortOrder *SessionsListRequestSortOrder `json:"-" url:"sortOrder,omitempty"`
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`
}

type Session struct {
	// This is the unique identifier for the session.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that owns this session.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 timestamp indicating when the session was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 timestamp indicating when the session was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is a user-defined name for the session. Maximum length is 40 characters.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the current status of the session. Can be either 'active' or 'completed'.
	Status *SessionStatus `json:"status,omitempty" url:"status,omitempty"`
	// Session expiration time in seconds. Defaults to 24 hours (86400 seconds) if not set.
	ExpirationSeconds *float64 `json:"expirationSeconds,omitempty" url:"expirationSeconds,omitempty"`
	// This is the ID of the assistant associated with this session. Use this when referencing an existing assistant.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant configuration for this session. Use this when creating a new assistant configuration.
	// If assistantId is provided, this will be ignored.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is an array of chat messages in the session.
	Messages []*SessionMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the customer information associated with this session.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the ID of the phone number associated with this session.
	PhoneNumberId *string `json:"phoneNumberId,omitempty" url:"phoneNumberId,omitempty"`
	// This is the phone number configuration for this session.
	PhoneNumber *ImportTwilioPhoneNumberDto `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Session) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *Session) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *Session) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *Session) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *Session) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *Session) GetStatus() *SessionStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *Session) GetExpirationSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.ExpirationSeconds
}

func (s *Session) GetAssistantId() *string {
	if s == nil {
		return nil
	}
	return s.AssistantId
}

func (s *Session) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *Session) GetMessages() []*SessionMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *Session) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *Session) GetPhoneNumberId() *string {
	if s == nil {
		return nil
	}
	return s.PhoneNumberId
}

func (s *Session) GetPhoneNumber() *ImportTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *Session) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Session) UnmarshalJSON(data []byte) error {
	type embed Session
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Session(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Session) MarshalJSON() ([]byte, error) {
	type embed Session
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Session) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SessionMessagesItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (s *SessionMessagesItem) GetSystemMessage() *SystemMessage {
	if s == nil {
		return nil
	}
	return s.SystemMessage
}

func (s *SessionMessagesItem) GetUserMessage() *UserMessage {
	if s == nil {
		return nil
	}
	return s.UserMessage
}

func (s *SessionMessagesItem) GetAssistantMessage() *AssistantMessage {
	if s == nil {
		return nil
	}
	return s.AssistantMessage
}

func (s *SessionMessagesItem) GetToolMessage() *ToolMessage {
	if s == nil {
		return nil
	}
	return s.ToolMessage
}

func (s *SessionMessagesItem) GetDeveloperMessage() *DeveloperMessage {
	if s == nil {
		return nil
	}
	return s.DeveloperMessage
}

func (s *SessionMessagesItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		s.typ = "SystemMessage"
		s.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		s.typ = "UserMessage"
		s.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		s.typ = "AssistantMessage"
		s.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		s.typ = "ToolMessage"
		s.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		s.typ = "DeveloperMessage"
		s.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SessionMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return json.Marshal(s.SystemMessage)
	}
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return json.Marshal(s.UserMessage)
	}
	if s.typ == "AssistantMessage" || s.AssistantMessage != nil {
		return json.Marshal(s.AssistantMessage)
	}
	if s.typ == "ToolMessage" || s.ToolMessage != nil {
		return json.Marshal(s.ToolMessage)
	}
	if s.typ == "DeveloperMessage" || s.DeveloperMessage != nil {
		return json.Marshal(s.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SessionMessagesItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (s *SessionMessagesItem) Accept(visitor SessionMessagesItemVisitor) error {
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return visitor.VisitSystemMessage(s.SystemMessage)
	}
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return visitor.VisitUserMessage(s.UserMessage)
	}
	if s.typ == "AssistantMessage" || s.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(s.AssistantMessage)
	}
	if s.typ == "ToolMessage" || s.ToolMessage != nil {
		return visitor.VisitToolMessage(s.ToolMessage)
	}
	if s.typ == "DeveloperMessage" || s.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(s.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SessionPaginatedResponse struct {
	Results  []*Session      `json:"results,omitempty" url:"results,omitempty"`
	Metadata *PaginationMeta `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SessionPaginatedResponse) GetResults() []*Session {
	if s == nil {
		return nil
	}
	return s.Results
}

func (s *SessionPaginatedResponse) GetMetadata() *PaginationMeta {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *SessionPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SessionPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SessionPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SessionPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SessionPaginatedResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the current status of the session. Can be either 'active' or 'completed'.
type SessionStatus string

const (
	SessionStatusActive    SessionStatus = "active"
	SessionStatusCompleted SessionStatus = "completed"
)

func NewSessionStatusFromString(s string) (SessionStatus, error) {
	switch s {
	case "active":
		return SessionStatusActive, nil
	case "completed":
		return SessionStatusCompleted, nil
	}
	var t SessionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SessionStatus) Ptr() *SessionStatus {
	return &s
}

type CreateSessionDtoMessagesItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (c *CreateSessionDtoMessagesItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *CreateSessionDtoMessagesItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *CreateSessionDtoMessagesItem) GetAssistantMessage() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.AssistantMessage
}

func (c *CreateSessionDtoMessagesItem) GetToolMessage() *ToolMessage {
	if c == nil {
		return nil
	}
	return c.ToolMessage
}

func (c *CreateSessionDtoMessagesItem) GetDeveloperMessage() *DeveloperMessage {
	if c == nil {
		return nil
	}
	return c.DeveloperMessage
}

func (c *CreateSessionDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		c.typ = "AssistantMessage"
		c.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		c.typ = "ToolMessage"
		c.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		c.typ = "DeveloperMessage"
		c.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateSessionDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return json.Marshal(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return json.Marshal(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return json.Marshal(c.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateSessionDtoMessagesItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (c *CreateSessionDtoMessagesItem) Accept(visitor CreateSessionDtoMessagesItemVisitor) error {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return visitor.VisitToolMessage(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(c.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the current status of the session. Can be either 'active' or 'completed'.
type CreateSessionDtoStatus string

const (
	CreateSessionDtoStatusActive    CreateSessionDtoStatus = "active"
	CreateSessionDtoStatusCompleted CreateSessionDtoStatus = "completed"
)

func NewCreateSessionDtoStatusFromString(s string) (CreateSessionDtoStatus, error) {
	switch s {
	case "active":
		return CreateSessionDtoStatusActive, nil
	case "completed":
		return CreateSessionDtoStatusCompleted, nil
	}
	var t CreateSessionDtoStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateSessionDtoStatus) Ptr() *CreateSessionDtoStatus {
	return &c
}

type SessionsListRequestSortOrder string

const (
	SessionsListRequestSortOrderAsc  SessionsListRequestSortOrder = "ASC"
	SessionsListRequestSortOrderDesc SessionsListRequestSortOrder = "DESC"
)

func NewSessionsListRequestSortOrderFromString(s string) (SessionsListRequestSortOrder, error) {
	switch s {
	case "ASC":
		return SessionsListRequestSortOrderAsc, nil
	case "DESC":
		return SessionsListRequestSortOrderDesc, nil
	}
	var t SessionsListRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SessionsListRequestSortOrder) Ptr() *SessionsListRequestSortOrder {
	return &s
}

type UpdateSessionDtoMessagesItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (u *UpdateSessionDtoMessagesItem) GetSystemMessage() *SystemMessage {
	if u == nil {
		return nil
	}
	return u.SystemMessage
}

func (u *UpdateSessionDtoMessagesItem) GetUserMessage() *UserMessage {
	if u == nil {
		return nil
	}
	return u.UserMessage
}

func (u *UpdateSessionDtoMessagesItem) GetAssistantMessage() *AssistantMessage {
	if u == nil {
		return nil
	}
	return u.AssistantMessage
}

func (u *UpdateSessionDtoMessagesItem) GetToolMessage() *ToolMessage {
	if u == nil {
		return nil
	}
	return u.ToolMessage
}

func (u *UpdateSessionDtoMessagesItem) GetDeveloperMessage() *DeveloperMessage {
	if u == nil {
		return nil
	}
	return u.DeveloperMessage
}

func (u *UpdateSessionDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		u.typ = "SystemMessage"
		u.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		u.typ = "UserMessage"
		u.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		u.typ = "AssistantMessage"
		u.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		u.typ = "ToolMessage"
		u.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		u.typ = "DeveloperMessage"
		u.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateSessionDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "SystemMessage" || u.SystemMessage != nil {
		return json.Marshal(u.SystemMessage)
	}
	if u.typ == "UserMessage" || u.UserMessage != nil {
		return json.Marshal(u.UserMessage)
	}
	if u.typ == "AssistantMessage" || u.AssistantMessage != nil {
		return json.Marshal(u.AssistantMessage)
	}
	if u.typ == "ToolMessage" || u.ToolMessage != nil {
		return json.Marshal(u.ToolMessage)
	}
	if u.typ == "DeveloperMessage" || u.DeveloperMessage != nil {
		return json.Marshal(u.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateSessionDtoMessagesItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (u *UpdateSessionDtoMessagesItem) Accept(visitor UpdateSessionDtoMessagesItemVisitor) error {
	if u.typ == "SystemMessage" || u.SystemMessage != nil {
		return visitor.VisitSystemMessage(u.SystemMessage)
	}
	if u.typ == "UserMessage" || u.UserMessage != nil {
		return visitor.VisitUserMessage(u.UserMessage)
	}
	if u.typ == "AssistantMessage" || u.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(u.AssistantMessage)
	}
	if u.typ == "ToolMessage" || u.ToolMessage != nil {
		return visitor.VisitToolMessage(u.ToolMessage)
	}
	if u.typ == "DeveloperMessage" || u.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(u.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// This is the new status for the session.
type UpdateSessionDtoStatus string

const (
	UpdateSessionDtoStatusActive    UpdateSessionDtoStatus = "active"
	UpdateSessionDtoStatusCompleted UpdateSessionDtoStatus = "completed"
)

func NewUpdateSessionDtoStatusFromString(s string) (UpdateSessionDtoStatus, error) {
	switch s {
	case "active":
		return UpdateSessionDtoStatusActive, nil
	case "completed":
		return UpdateSessionDtoStatusCompleted, nil
	}
	var t UpdateSessionDtoStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateSessionDtoStatus) Ptr() *UpdateSessionDtoStatus {
	return &u
}

type UpdateSessionDto struct {
	// This is the new name for the session. Maximum length is 40 characters.
	Name *string `json:"name,omitempty" url:"-"`
	// This is the new status for the session.
	Status *UpdateSessionDtoStatus `json:"status,omitempty" url:"-"`
	// Session expiration time in seconds. Defaults to 24 hours (86400 seconds) if not set.
	ExpirationSeconds *float64 `json:"expirationSeconds,omitempty" url:"-"`
	// This is the updated array of chat messages.
	Messages []*UpdateSessionDtoMessagesItem `json:"messages,omitempty" url:"-"`
}
