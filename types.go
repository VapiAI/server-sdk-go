// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/fern-demo/vapi-go-sdk/core"
	time "time"
)

type AddVoiceToProviderDto struct {
	// This is the owner_id of your shared voice which you want to add to your provider Account from Provider Voice Library
	OwnerId string `json:"ownerId" url:"ownerId"`
	// This is the voice_id of the shared voice which you want to add to your provider Account from Provider Voice Library
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the new name of the voice which you want to have once you have added voice to your provider Account from Provider Voice Library
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AddVoiceToProviderDto) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddVoiceToProviderDto) UnmarshalJSON(data []byte) error {
	type unmarshaler AddVoiceToProviderDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddVoiceToProviderDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddVoiceToProviderDto) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Analysis struct {
	// This is the summary of the call. Customize by setting `assistant.analysisPlan.summaryPrompt`.
	Summary *string `json:"summary,omitempty" url:"summary,omitempty"`
	// This is the structured data extracted from the call. Customize by setting `assistant.analysisPlan.structuredDataPrompt` and/or `assistant.analysisPlan.structuredDataSchema`.
	StructuredData map[string]interface{} `json:"structuredData,omitempty" url:"structuredData,omitempty"`
	// This is the evaluation of the call. Customize by setting `assistant.analysisPlan.successEvaluationPrompt` and/or `assistant.analysisPlan.successEvaluationRubric`.
	SuccessEvaluation *string `json:"successEvaluation,omitempty" url:"successEvaluation,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Analysis) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Analysis) UnmarshalJSON(data []byte) error {
	type unmarshaler Analysis
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Analysis(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Analysis) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnalysisCost struct {
	// This is the type of cost, always 'analysis' for this class.
	// This is the type of analysis performed.
	AnalysisType AnalysisCostAnalysisType `json:"analysisType" url:"analysisType"`
	// This is the model that was used to perform the analysis.
	Model map[string]interface{} `json:"model,omitempty" url:"model,omitempty"`
	// This is the number of prompt tokens used in the analysis.
	PromptTokens float64 `json:"promptTokens" url:"promptTokens"`
	// This is the number of completion tokens generated in the analysis.
	CompletionTokens float64 `json:"completionTokens" url:"completionTokens"`
	// This is the cost of the component in USD.
	Cost  float64 `json:"cost" url:"cost"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AnalysisCost) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalysisCost) Type() string {
	return a.type_
}

func (a *AnalysisCost) UnmarshalJSON(data []byte) error {
	type embed AnalysisCost
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnalysisCost(unmarshaler.embed)
	if unmarshaler.Type != "analysis" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "analysis", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalysisCost) MarshalJSON() ([]byte, error) {
	type embed AnalysisCost
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "analysis",
	}
	return json.Marshal(marshaler)
}

func (a *AnalysisCost) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the type of analysis performed.
type AnalysisCostAnalysisType string

const (
	AnalysisCostAnalysisTypeSummary           AnalysisCostAnalysisType = "summary"
	AnalysisCostAnalysisTypeStructuredData    AnalysisCostAnalysisType = "structuredData"
	AnalysisCostAnalysisTypeSuccessEvaluation AnalysisCostAnalysisType = "successEvaluation"
)

func NewAnalysisCostAnalysisTypeFromString(s string) (AnalysisCostAnalysisType, error) {
	switch s {
	case "summary":
		return AnalysisCostAnalysisTypeSummary, nil
	case "structuredData":
		return AnalysisCostAnalysisTypeStructuredData, nil
	case "successEvaluation":
		return AnalysisCostAnalysisTypeSuccessEvaluation, nil
	}
	var t AnalysisCostAnalysisType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalysisCostAnalysisType) Ptr() *AnalysisCostAnalysisType {
	return &a
}

type AnalysisCostBreakdown struct {
	// This is the cost to summarize the call.
	Summary *float64 `json:"summary,omitempty" url:"summary,omitempty"`
	// This is the number of prompt tokens used to summarize the call.
	SummaryPromptTokens *float64 `json:"summaryPromptTokens,omitempty" url:"summaryPromptTokens,omitempty"`
	// This is the number of completion tokens used to summarize the call.
	SummaryCompletionTokens *float64 `json:"summaryCompletionTokens,omitempty" url:"summaryCompletionTokens,omitempty"`
	// This is the cost to extract structured data from the call.
	StructuredData *float64 `json:"structuredData,omitempty" url:"structuredData,omitempty"`
	// This is the number of prompt tokens used to extract structured data from the call.
	StructuredDataPromptTokens *float64 `json:"structuredDataPromptTokens,omitempty" url:"structuredDataPromptTokens,omitempty"`
	// This is the number of completion tokens used to extract structured data from the call.
	StructuredDataCompletionTokens *float64 `json:"structuredDataCompletionTokens,omitempty" url:"structuredDataCompletionTokens,omitempty"`
	// This is the cost to evaluate if the call was successful.
	SuccessEvaluation *float64 `json:"successEvaluation,omitempty" url:"successEvaluation,omitempty"`
	// This is the number of prompt tokens used to evaluate if the call was successful.
	SuccessEvaluationPromptTokens *float64 `json:"successEvaluationPromptTokens,omitempty" url:"successEvaluationPromptTokens,omitempty"`
	// This is the number of completion tokens used to evaluate if the call was successful.
	SuccessEvaluationCompletionTokens *float64 `json:"successEvaluationCompletionTokens,omitempty" url:"successEvaluationCompletionTokens,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AnalysisCostBreakdown) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalysisCostBreakdown) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalysisCostBreakdown
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalysisCostBreakdown(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalysisCostBreakdown) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnalysisPlan struct {
	// This is the plan for generating the summary of the call. This outputs to `call.analysis.summary`.
	SummaryPlan *SummaryPlan `json:"summaryPlan,omitempty" url:"summaryPlan,omitempty"`
	// This is the plan for generating the structured data from the call. This outputs to `call.analysis.structuredData`.
	StructuredDataPlan *StructuredDataPlan `json:"structuredDataPlan,omitempty" url:"structuredDataPlan,omitempty"`
	// This is the plan for generating the success evaluation of the call. This outputs to `call.analysis.successEvaluation`.
	SuccessEvaluationPlan *SuccessEvaluationPlan `json:"successEvaluationPlan,omitempty" url:"successEvaluationPlan,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AnalysisPlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalysisPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalysisPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalysisPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalysisPlan) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnalyticsOperation struct {
	// This is the aggregation operation you want to perform.
	Operation AnalyticsOperationOperation `json:"operation" url:"operation"`
	// This is the columns you want to perform the aggregation operation on.
	Column AnalyticsOperationColumn `json:"column" url:"column"`
	// This is the alias for column name returned. Defaults to `${operation}${column}`.
	Alias *string `json:"alias,omitempty" url:"alias,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AnalyticsOperation) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalyticsOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalyticsOperation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsOperation) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the columns you want to perform the aggregation operation on.
type AnalyticsOperationColumn string

const (
	AnalyticsOperationColumnId                               AnalyticsOperationColumn = "id"
	AnalyticsOperationColumnCost                             AnalyticsOperationColumn = "cost"
	AnalyticsOperationColumnCostBreakdownLlm                 AnalyticsOperationColumn = "costBreakdown.llm"
	AnalyticsOperationColumnCostBreakdownStt                 AnalyticsOperationColumn = "costBreakdown.stt"
	AnalyticsOperationColumnCostBreakdownTts                 AnalyticsOperationColumn = "costBreakdown.tts"
	AnalyticsOperationColumnCostBreakdownVapi                AnalyticsOperationColumn = "costBreakdown.vapi"
	AnalyticsOperationColumnCostBreakdownTtsCharacters       AnalyticsOperationColumn = "costBreakdown.ttsCharacters"
	AnalyticsOperationColumnCostBreakdownLlmPromptTokens     AnalyticsOperationColumn = "costBreakdown.llmPromptTokens"
	AnalyticsOperationColumnCostBreakdownLlmCompletionTokens AnalyticsOperationColumn = "costBreakdown.llmCompletionTokens"
	AnalyticsOperationColumnDuration                         AnalyticsOperationColumn = "duration"
)

func NewAnalyticsOperationColumnFromString(s string) (AnalyticsOperationColumn, error) {
	switch s {
	case "id":
		return AnalyticsOperationColumnId, nil
	case "cost":
		return AnalyticsOperationColumnCost, nil
	case "costBreakdown.llm":
		return AnalyticsOperationColumnCostBreakdownLlm, nil
	case "costBreakdown.stt":
		return AnalyticsOperationColumnCostBreakdownStt, nil
	case "costBreakdown.tts":
		return AnalyticsOperationColumnCostBreakdownTts, nil
	case "costBreakdown.vapi":
		return AnalyticsOperationColumnCostBreakdownVapi, nil
	case "costBreakdown.ttsCharacters":
		return AnalyticsOperationColumnCostBreakdownTtsCharacters, nil
	case "costBreakdown.llmPromptTokens":
		return AnalyticsOperationColumnCostBreakdownLlmPromptTokens, nil
	case "costBreakdown.llmCompletionTokens":
		return AnalyticsOperationColumnCostBreakdownLlmCompletionTokens, nil
	case "duration":
		return AnalyticsOperationColumnDuration, nil
	}
	var t AnalyticsOperationColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalyticsOperationColumn) Ptr() *AnalyticsOperationColumn {
	return &a
}

// This is the aggregation operation you want to perform.
type AnalyticsOperationOperation string

const (
	AnalyticsOperationOperationSum   AnalyticsOperationOperation = "sum"
	AnalyticsOperationOperationAvg   AnalyticsOperationOperation = "avg"
	AnalyticsOperationOperationCount AnalyticsOperationOperation = "count"
	AnalyticsOperationOperationMin   AnalyticsOperationOperation = "min"
	AnalyticsOperationOperationMax   AnalyticsOperationOperation = "max"
)

func NewAnalyticsOperationOperationFromString(s string) (AnalyticsOperationOperation, error) {
	switch s {
	case "sum":
		return AnalyticsOperationOperationSum, nil
	case "avg":
		return AnalyticsOperationOperationAvg, nil
	case "count":
		return AnalyticsOperationOperationCount, nil
	case "min":
		return AnalyticsOperationOperationMin, nil
	case "max":
		return AnalyticsOperationOperationMax, nil
	}
	var t AnalyticsOperationOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalyticsOperationOperation) Ptr() *AnalyticsOperationOperation {
	return &a
}

type AnalyticsQuery struct {
	// This is the table you want to query.
	// This is the list of columns you want to group by.
	GroupBy []AnalyticsQueryGroupByItem `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// This is the name of the query. This will be used to identify the query in the response.
	Name string `json:"name" url:"name"`
	// This is the time range for the query.
	TimeRange *TimeRange `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the list of operations you want to perform.
	Operations []*AnalyticsOperation `json:"operations,omitempty" url:"operations,omitempty"`
	table      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AnalyticsQuery) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsQuery) Table() string {
	return a.table
}

func (a *AnalyticsQuery) UnmarshalJSON(data []byte) error {
	type embed AnalyticsQuery
	var unmarshaler = struct {
		embed
		Table string `json:"table"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnalyticsQuery(unmarshaler.embed)
	if unmarshaler.Table != "call" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "call", unmarshaler.Table)
	}
	a.table = unmarshaler.Table

	extraProperties, err := core.ExtractExtraProperties(data, *a, "table")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsQuery) MarshalJSON() ([]byte, error) {
	type embed AnalyticsQuery
	var marshaler = struct {
		embed
		Table string `json:"table"`
	}{
		embed: embed(*a),
		Table: "call",
	}
	return json.Marshal(marshaler)
}

func (a *AnalyticsQuery) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnalyticsQueryGroupByItem string

const (
	AnalyticsQueryGroupByItemType                      AnalyticsQueryGroupByItem = "type"
	AnalyticsQueryGroupByItemAssistantId               AnalyticsQueryGroupByItem = "assistantId"
	AnalyticsQueryGroupByItemEndedReason               AnalyticsQueryGroupByItem = "endedReason"
	AnalyticsQueryGroupByItemAnalysisSuccessEvaluation AnalyticsQueryGroupByItem = "analysis.successEvaluation"
	AnalyticsQueryGroupByItemStatus                    AnalyticsQueryGroupByItem = "status"
)

func NewAnalyticsQueryGroupByItemFromString(s string) (AnalyticsQueryGroupByItem, error) {
	switch s {
	case "type":
		return AnalyticsQueryGroupByItemType, nil
	case "assistantId":
		return AnalyticsQueryGroupByItemAssistantId, nil
	case "endedReason":
		return AnalyticsQueryGroupByItemEndedReason, nil
	case "analysis.successEvaluation":
		return AnalyticsQueryGroupByItemAnalysisSuccessEvaluation, nil
	case "status":
		return AnalyticsQueryGroupByItemStatus, nil
	}
	var t AnalyticsQueryGroupByItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalyticsQueryGroupByItem) Ptr() *AnalyticsQueryGroupByItem {
	return &a
}

type AnalyticsQueryResult struct {
	// This is the unique key for the query.
	Name string `json:"name" url:"name"`
	// This is the time range for the query.
	TimeRange *TimeRange `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the result of the query, a list of unique groups with result of their aggregations.
	//
	// Example:
	// "result": [
	// { "date": "2023-01-01", "assistantId": "123", "endedReason": "customer-ended-call", "sumDuration": 120, "avgCost": 10.5 },
	// { "date": "2023-01-02", "assistantId": "123", "endedReason": "customer-did-not-give-microphone-permission", "sumDuration": 0, "avgCost": 0 },
	// // Additional results
	// ]
	Result []map[string]interface{} `json:"result,omitempty" url:"result,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AnalyticsQueryResult) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsQueryResult) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalyticsQueryResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalyticsQueryResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsQueryResult) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnthropicCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AnthropicCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnthropicCredential) Provider() string {
	return a.provider
}

func (a *AnthropicCredential) UnmarshalJSON(data []byte) error {
	type embed AnthropicCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnthropicCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anthropic", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnthropicCredential) MarshalJSON() ([]byte, error) {
	type embed AnthropicCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
		Provider:  "anthropic",
	}
	return json.Marshal(marshaler)
}

func (a *AnthropicCredential) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnthropicModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*AnthropicModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// This is the Anthropic/Claude models that will be used.
	Model AnthropicModelModel `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *KnowledgeBase `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AnthropicModel) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnthropicModel) Provider() string {
	return a.provider
}

func (a *AnthropicModel) UnmarshalJSON(data []byte) error {
	type embed AnthropicModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnthropicModel(unmarshaler.embed)
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anthropic", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnthropicModel) MarshalJSON() ([]byte, error) {
	type embed AnthropicModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "anthropic",
	}
	return json.Marshal(marshaler)
}

func (a *AnthropicModel) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the Anthropic/Claude models that will be used.
type AnthropicModelModel string

const (
	AnthropicModelModelClaude3Opus20240229    AnthropicModelModel = "claude-3-opus-20240229"
	AnthropicModelModelClaude3Sonnet20240229  AnthropicModelModel = "claude-3-sonnet-20240229"
	AnthropicModelModelClaude3Haiku20240307   AnthropicModelModel = "claude-3-haiku-20240307"
	AnthropicModelModelClaude35Sonnet20240620 AnthropicModelModel = "claude-3-5-sonnet-20240620"
)

func NewAnthropicModelModelFromString(s string) (AnthropicModelModel, error) {
	switch s {
	case "claude-3-opus-20240229":
		return AnthropicModelModelClaude3Opus20240229, nil
	case "claude-3-sonnet-20240229":
		return AnthropicModelModelClaude3Sonnet20240229, nil
	case "claude-3-haiku-20240307":
		return AnthropicModelModelClaude3Haiku20240307, nil
	case "claude-3-5-sonnet-20240620":
		return AnthropicModelModelClaude35Sonnet20240620, nil
	}
	var t AnthropicModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnthropicModelModel) Ptr() *AnthropicModelModel {
	return &a
}

type AnthropicModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (a *AnthropicModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		a.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		a.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		a.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		a.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		a.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		a.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		a.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AnthropicModelToolsItem) MarshalJSON() ([]byte, error) {
	if a.CreateDtmfToolDto != nil {
		return json.Marshal(a.CreateDtmfToolDto)
	}
	if a.CreateEndCallToolDto != nil {
		return json.Marshal(a.CreateEndCallToolDto)
	}
	if a.CreateVoicemailToolDto != nil {
		return json.Marshal(a.CreateVoicemailToolDto)
	}
	if a.CreateFunctionToolDto != nil {
		return json.Marshal(a.CreateFunctionToolDto)
	}
	if a.CreateGhlToolDto != nil {
		return json.Marshal(a.CreateGhlToolDto)
	}
	if a.CreateMakeToolDto != nil {
		return json.Marshal(a.CreateMakeToolDto)
	}
	if a.CreateTransferCallToolDto != nil {
		return json.Marshal(a.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AnthropicModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (a *AnthropicModelToolsItem) Accept(visitor AnthropicModelToolsItemVisitor) error {
	if a.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(a.CreateDtmfToolDto)
	}
	if a.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(a.CreateEndCallToolDto)
	}
	if a.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(a.CreateVoicemailToolDto)
	}
	if a.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(a.CreateFunctionToolDto)
	}
	if a.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(a.CreateGhlToolDto)
	}
	if a.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(a.CreateMakeToolDto)
	}
	if a.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(a.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AnyscaleCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AnyscaleCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnyscaleCredential) Provider() string {
	return a.provider
}

func (a *AnyscaleCredential) UnmarshalJSON(data []byte) error {
	type embed AnyscaleCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnyscaleCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "anyscale" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anyscale", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnyscaleCredential) MarshalJSON() ([]byte, error) {
	type embed AnyscaleCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
		Provider:  "anyscale",
	}
	return json.Marshal(marshaler)
}

func (a *AnyscaleCredential) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnyscaleModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*AnyscaleModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *KnowledgeBase `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AnyscaleModel) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnyscaleModel) Provider() string {
	return a.provider
}

func (a *AnyscaleModel) UnmarshalJSON(data []byte) error {
	type embed AnyscaleModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnyscaleModel(unmarshaler.embed)
	if unmarshaler.Provider != "anyscale" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anyscale", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnyscaleModel) MarshalJSON() ([]byte, error) {
	type embed AnyscaleModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "anyscale",
	}
	return json.Marshal(marshaler)
}

func (a *AnyscaleModel) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnyscaleModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (a *AnyscaleModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		a.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		a.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		a.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		a.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		a.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		a.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		a.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AnyscaleModelToolsItem) MarshalJSON() ([]byte, error) {
	if a.CreateDtmfToolDto != nil {
		return json.Marshal(a.CreateDtmfToolDto)
	}
	if a.CreateEndCallToolDto != nil {
		return json.Marshal(a.CreateEndCallToolDto)
	}
	if a.CreateVoicemailToolDto != nil {
		return json.Marshal(a.CreateVoicemailToolDto)
	}
	if a.CreateFunctionToolDto != nil {
		return json.Marshal(a.CreateFunctionToolDto)
	}
	if a.CreateGhlToolDto != nil {
		return json.Marshal(a.CreateGhlToolDto)
	}
	if a.CreateMakeToolDto != nil {
		return json.Marshal(a.CreateMakeToolDto)
	}
	if a.CreateTransferCallToolDto != nil {
		return json.Marshal(a.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AnyscaleModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (a *AnyscaleModelToolsItem) Accept(visitor AnyscaleModelToolsItemVisitor) error {
	if a.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(a.CreateDtmfToolDto)
	}
	if a.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(a.CreateEndCallToolDto)
	}
	if a.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(a.CreateVoicemailToolDto)
	}
	if a.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(a.CreateFunctionToolDto)
	}
	if a.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(a.CreateGhlToolDto)
	}
	if a.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(a.CreateMakeToolDto)
	}
	if a.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(a.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type Artifact struct {
	// These are the messages that were spoken during the call.
	Messages []*ArtifactMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the messages that were spoken during the call, formatted for OpenAI.
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.
	RecordingUrl *string `json:"recordingUrl,omitempty" url:"recordingUrl,omitempty"`
	// This is the stereo recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.
	StereoRecordingUrl *string `json:"stereoRecordingUrl,omitempty" url:"stereoRecordingUrl,omitempty"`
	// This is video recording url for the call. To enable, set `assistant.artifactPlan.videoRecordingEnabled`.
	VideoRecordingUrl *string `json:"videoRecordingUrl,omitempty" url:"videoRecordingUrl,omitempty"`
	// This is video recording start delay in ms. To enable, set `assistant.artifactPlan.videoRecordingEnabled`. This can be used to align the playback of the recording with artifact.messages timestamps.
	VideoRecordingStartDelaySeconds *float64 `json:"videoRecordingStartDelaySeconds,omitempty" url:"videoRecordingStartDelaySeconds,omitempty"`
	// This is the transcript of the call. This is derived from `artifact.messages` but provided for convenience.
	Transcript *string `json:"transcript,omitempty" url:"transcript,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Artifact) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Artifact) UnmarshalJSON(data []byte) error {
	type unmarshaler Artifact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Artifact(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Artifact) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ArtifactMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage
}

func (a *ArtifactMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		a.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		a.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		a.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		a.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		a.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ArtifactMessagesItem) MarshalJSON() ([]byte, error) {
	if a.UserMessage != nil {
		return json.Marshal(a.UserMessage)
	}
	if a.SystemMessage != nil {
		return json.Marshal(a.SystemMessage)
	}
	if a.BotMessage != nil {
		return json.Marshal(a.BotMessage)
	}
	if a.ToolCallMessage != nil {
		return json.Marshal(a.ToolCallMessage)
	}
	if a.ToolCallResultMessage != nil {
		return json.Marshal(a.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ArtifactMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (a *ArtifactMessagesItem) Accept(visitor ArtifactMessagesItemVisitor) error {
	if a.UserMessage != nil {
		return visitor.VisitUserMessage(a.UserMessage)
	}
	if a.SystemMessage != nil {
		return visitor.VisitSystemMessage(a.SystemMessage)
	}
	if a.BotMessage != nil {
		return visitor.VisitBotMessage(a.BotMessage)
	}
	if a.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(a.ToolCallMessage)
	}
	if a.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(a.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ArtifactPlan struct {
	// This determines whether assistant's calls are recorded. Defaults to true.
	//
	// Usage:
	//
	// - If you don't want to record the calls, set this to false.
	// - If you want to record the calls when `assistant.hipaaEnabled`, explicity set this to true and make sure to provide S3 or GCP credentials on the Provider Credentials page in the Dashboard.
	//
	// You can find the recording at `call.artifact.recordingUrl` and `call.artifact.stereoRecordingUrl` after the call is ended.
	//
	// @default true
	RecordingEnabled *bool `json:"recordingEnabled,omitempty" url:"recordingEnabled,omitempty"`
	// This determines whether the video is recorded during the call. Defaults to false. Only relevant for `webCall` type.
	//
	// You can find the video recording at `call.artifact.videoRecordingUrl` after the call is ended.
	//
	// @default false
	VideoRecordingEnabled *bool `json:"videoRecordingEnabled,omitempty" url:"videoRecordingEnabled,omitempty"`
	// This is the plan for `call.artifact.transcript`. To disable, set `transcriptPlan.enabled` to false.
	TranscriptPlan *TranscriptPlan `json:"transcriptPlan,omitempty" url:"transcriptPlan,omitempty"`
	// This is the path where the recording will be uploaded. This is only used if you have provided S3 or GCP credentials on the Provider Credentials page in the Dashboard.
	//
	// If credential.s3PathPrefix or credential.bucketPlan.path is set, this will append to it.
	//
	// Usage:
	//
	// - If you want to upload the recording to a specific path, set this to the path. Example: `/my-assistant-recordings`.
	// - If you want to upload the recording to the root of the bucket, set this to `/`.
	//
	// @default '/'
	RecordingPath *string `json:"recordingPath,omitempty" url:"recordingPath,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ArtifactPlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ArtifactPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler ArtifactPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ArtifactPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ArtifactPlan) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignmentMutation struct {
	// This is an optional array of conditions that must be met for this mutation to be triggered.
	Conditions []*AssignmentMutationConditionsItem `json:"conditions,omitempty" url:"conditions,omitempty"`
	// This mutation assigns a new value to an existing or new variable.
	// This is the variable to assign a new value to.
	//
	// You can reference any variable in the context of the current block execution (step):
	//
	// - "output.your-property-name" for current step's output
	// - "your-step-name.output.your-property-name" for another step's output (in the same workflow; read caveat #1)
	// - "your-block-name.output.your-property-name" for another block's output (in the same workflow; read caveat #2)
	// - "global.your-property-name" for the global context
	//
	// This needs to be the key path of the variable. If you use {{}}, it'll dereference that to the value of the variable before assignment. This can be useful if the path is dynamic. Example:
	//
	// - "global.{{my-tool-call-step.output.my-key-name}}"
	//
	// You can also string interpolate multiple variables to get the key name:
	//
	// - "global.{{my-tool-call-step.output.my-key-name-suffix}}-{{my-tool-call-step.output.my-key-name}}"
	//
	// The path to the new variable is created if it doesn't exist. Example:
	//
	// - "global.this-does-not-exist.neither-does-this" will create `this-does-not-exist` object with `neither-does-this` as a key
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow.
	Variable string `json:"variable" url:"variable"`
	// The value to assign to the variable.
	//
	// You can reference any variable in the context of the current block execution (step):
	//
	// - "{{output.your-property-name}}" for current step's output
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{global.your-property-name}}" for the global context
	//
	// Or, you can use a constant:
	//
	// - "1"
	// - "text"
	// - "true"
	// - "false"
	//
	// Or, you can mix and match with string interpolation:
	//
	// - "{{your-property-name}}-{{input.your-property-name-2}}-1"
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow.
	Value string `json:"value" url:"value"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssignmentMutation) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssignmentMutation) Type() string {
	return a.type_
}

func (a *AssignmentMutation) UnmarshalJSON(data []byte) error {
	type embed AssignmentMutation
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssignmentMutation(unmarshaler.embed)
	if unmarshaler.Type != "assignment" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assignment", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignmentMutation) MarshalJSON() ([]byte, error) {
	type embed AssignmentMutation
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "assignment",
	}
	return json.Marshal(marshaler)
}

func (a *AssignmentMutation) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignmentMutationConditionsItem struct {
	ModelBasedCondition *ModelBasedCondition
	RuleBasedCondition  *RuleBasedCondition
}

func (a *AssignmentMutationConditionsItem) UnmarshalJSON(data []byte) error {
	valueModelBasedCondition := new(ModelBasedCondition)
	if err := json.Unmarshal(data, &valueModelBasedCondition); err == nil {
		a.ModelBasedCondition = valueModelBasedCondition
		return nil
	}
	valueRuleBasedCondition := new(RuleBasedCondition)
	if err := json.Unmarshal(data, &valueRuleBasedCondition); err == nil {
		a.RuleBasedCondition = valueRuleBasedCondition
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssignmentMutationConditionsItem) MarshalJSON() ([]byte, error) {
	if a.ModelBasedCondition != nil {
		return json.Marshal(a.ModelBasedCondition)
	}
	if a.RuleBasedCondition != nil {
		return json.Marshal(a.RuleBasedCondition)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssignmentMutationConditionsItemVisitor interface {
	VisitModelBasedCondition(*ModelBasedCondition) error
	VisitRuleBasedCondition(*RuleBasedCondition) error
}

func (a *AssignmentMutationConditionsItem) Accept(visitor AssignmentMutationConditionsItemVisitor) error {
	if a.ModelBasedCondition != nil {
		return visitor.VisitModelBasedCondition(a.ModelBasedCondition)
	}
	if a.RuleBasedCondition != nil {
		return visitor.VisitRuleBasedCondition(a.RuleBasedCondition)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type Assistant struct {
	// These are the options for the assistant's transcriber.
	Transcriber *AssistantTranscriber `json:"transcriber,omitempty" url:"transcriber,omitempty"`
	// These are the options for the assistant's LLM.
	Model *AssistantModel `json:"model,omitempty" url:"model,omitempty"`
	// These are the options for the assistant's voice.
	Voice *AssistantVoice `json:"voice,omitempty" url:"voice,omitempty"`
	// This is the mode for the first message. Default is 'assistant-speaks-first'.
	//
	// Use:
	//
	// - 'assistant-speaks-first' to have the assistant speak first.
	// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
	// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
	//
	// @default 'assistant-speaks-first'
	FirstMessageMode *AssistantFirstMessageMode `json:"firstMessageMode,omitempty" url:"firstMessageMode,omitempty"`
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transcript,tool-calls,user-interrupted,voice-input. You can check the shape of the messages in ClientMessage schema.
	ClientMessages []AssistantClientMessagesItem `json:"clientMessages,omitempty" url:"clientMessages,omitempty"`
	// These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
	ServerMessages []AssistantServerMessagesItem `json:"serverMessages,omitempty" url:"serverMessages,omitempty"`
	// How many seconds of silence to wait before ending the call. Defaults to 30.
	//
	// @default 30
	SilenceTimeoutSeconds *float64 `json:"silenceTimeoutSeconds,omitempty" url:"silenceTimeoutSeconds,omitempty"`
	// This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
	//
	// @default 600 (10 minutes)
	MaxDurationSeconds *float64 `json:"maxDurationSeconds,omitempty" url:"maxDurationSeconds,omitempty"`
	// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
	BackgroundSound *AssistantBackgroundSound `json:"backgroundSound,omitempty" url:"backgroundSound,omitempty"`
	// This determines whether the model says 'mhmm', 'ahem' etc. while user is speaking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackchannelingEnabled *bool `json:"backchannelingEnabled,omitempty" url:"backchannelingEnabled,omitempty"`
	// This enables filtering of noise and background speech while the user is talking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackgroundDenoisingEnabled *bool `json:"backgroundDenoisingEnabled,omitempty" url:"backgroundDenoisingEnabled,omitempty"`
	// This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
	//
	// Default `false` while in beta.
	//
	// @default false
	ModelOutputInMessagesEnabled *bool `json:"modelOutputInMessagesEnabled,omitempty" url:"modelOutputInMessagesEnabled,omitempty"`
	// These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
	TransportConfigurations []*TransportConfigurationTwilio `json:"transportConfigurations,omitempty" url:"transportConfigurations,omitempty"`
	// This is the name of the assistant.
	//
	// This is required when you want to transfer between assistants in a call.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
	//
	// If unspecified, assistant will wait for user to speak and use the model to respond once they speak.
	FirstMessage *string `json:"firstMessage,omitempty" url:"firstMessage,omitempty"`
	// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
	// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
	// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
	VoicemailDetection *TwilioVoicemailDetection `json:"voicemailDetection,omitempty" url:"voicemailDetection,omitempty"`
	// This is the message that the assistant will say if the call is forwarded to voicemail.
	//
	// If unspecified, it will hang up.
	VoicemailMessage *string `json:"voicemailMessage,omitempty" url:"voicemailMessage,omitempty"`
	// This is the message that the assistant will say if it ends the call.
	//
	// If unspecified, it will hang up without saying anything.
	EndCallMessage *string `json:"endCallMessage,omitempty" url:"endCallMessage,omitempty"`
	// This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
	EndCallPhrases []string `json:"endCallPhrases,omitempty" url:"endCallPhrases,omitempty"`
	// This is for metadata you want to store on the assistant.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the URL Vapi will communicate with via HTTP GET and POST Requests. This is used for retrieving context, function calling, and end-of-call reports.
	//
	// All requests will be sent with the call object among other things relevant to that message. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	// This is the plan for analysis of assistant's calls. Stored in `call.analysis`.
	AnalysisPlan *AnalysisPlan `json:"analysisPlan,omitempty" url:"analysisPlan,omitempty"`
	// This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.
	//
	// Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"artifactPlan,omitempty"`
	// This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.
	//
	// Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.
	MessagePlan *MessagePlan `json:"messagePlan,omitempty" url:"messagePlan,omitempty"`
	// This is the plan for when the assistant should start talking.
	//
	// You should configure this if you're running into these issues:
	//
	// - The assistant is too slow to start talking after the customer is done speaking.
	// - The assistant is too fast to start talking after the customer is done speaking.
	// - The assistant is so fast that it's actually interrupting the customer.
	StartSpeakingPlan *StartSpeakingPlan `json:"startSpeakingPlan,omitempty" url:"startSpeakingPlan,omitempty"`
	// This is the plan for when assistant should stop talking on customer interruption.
	//
	// You should configure this if you're running into these issues:
	//
	// - The assistant is too slow to recognize customer's interruption.
	// - The assistant is too fast to recognize customer's interruption.
	// - The assistant is getting interrupted by phrases that are just acknowledgments.
	// - The assistant is getting interrupted by background noises.
	// - The assistant is not properly stopping -- it starts talking right after getting interrupted.
	StopSpeakingPlan *StopSpeakingPlan `json:"stopSpeakingPlan,omitempty" url:"stopSpeakingPlan,omitempty"`
	// This is the plan for real-time monitoring of the assistant's calls.
	//
	// Usage:
	//
	// - To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.
	// - To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.
	//
	// Note, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible
	MonitorPlan *MonitorPlan `json:"monitorPlan,omitempty" url:"monitorPlan,omitempty"`
	// These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
	CredentialIds []string `json:"credentialIds,omitempty" url:"credentialIds,omitempty"`
	// This is the unique identifier for the assistant.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this assistant belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the assistant was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Assistant) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Assistant) UnmarshalJSON(data []byte) error {
	type embed Assistant
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Assistant(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Assistant) MarshalJSON() ([]byte, error) {
	type embed Assistant
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Assistant) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
type AssistantBackgroundSound string

const (
	AssistantBackgroundSoundOff    AssistantBackgroundSound = "off"
	AssistantBackgroundSoundOffice AssistantBackgroundSound = "office"
)

func NewAssistantBackgroundSoundFromString(s string) (AssistantBackgroundSound, error) {
	switch s {
	case "off":
		return AssistantBackgroundSoundOff, nil
	case "office":
		return AssistantBackgroundSoundOffice, nil
	}
	var t AssistantBackgroundSound
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantBackgroundSound) Ptr() *AssistantBackgroundSound {
	return &a
}

type AssistantClientMessagesItem string

const (
	AssistantClientMessagesItemConversationUpdate AssistantClientMessagesItem = "conversation-update"
	AssistantClientMessagesItemFunctionCall       AssistantClientMessagesItem = "function-call"
	AssistantClientMessagesItemFunctionCallResult AssistantClientMessagesItem = "function-call-result"
	AssistantClientMessagesItemHang               AssistantClientMessagesItem = "hang"
	AssistantClientMessagesItemLanguageChanged    AssistantClientMessagesItem = "language-changed"
	AssistantClientMessagesItemMetadata           AssistantClientMessagesItem = "metadata"
	AssistantClientMessagesItemModelOutput        AssistantClientMessagesItem = "model-output"
	AssistantClientMessagesItemSpeechUpdate       AssistantClientMessagesItem = "speech-update"
	AssistantClientMessagesItemStatusUpdate       AssistantClientMessagesItem = "status-update"
	AssistantClientMessagesItemTranscript         AssistantClientMessagesItem = "transcript"
	AssistantClientMessagesItemToolCalls          AssistantClientMessagesItem = "tool-calls"
	AssistantClientMessagesItemToolCallsResult    AssistantClientMessagesItem = "tool-calls-result"
	AssistantClientMessagesItemUserInterrupted    AssistantClientMessagesItem = "user-interrupted"
	AssistantClientMessagesItemVoiceInput         AssistantClientMessagesItem = "voice-input"
)

func NewAssistantClientMessagesItemFromString(s string) (AssistantClientMessagesItem, error) {
	switch s {
	case "conversation-update":
		return AssistantClientMessagesItemConversationUpdate, nil
	case "function-call":
		return AssistantClientMessagesItemFunctionCall, nil
	case "function-call-result":
		return AssistantClientMessagesItemFunctionCallResult, nil
	case "hang":
		return AssistantClientMessagesItemHang, nil
	case "language-changed":
		return AssistantClientMessagesItemLanguageChanged, nil
	case "metadata":
		return AssistantClientMessagesItemMetadata, nil
	case "model-output":
		return AssistantClientMessagesItemModelOutput, nil
	case "speech-update":
		return AssistantClientMessagesItemSpeechUpdate, nil
	case "status-update":
		return AssistantClientMessagesItemStatusUpdate, nil
	case "transcript":
		return AssistantClientMessagesItemTranscript, nil
	case "tool-calls":
		return AssistantClientMessagesItemToolCalls, nil
	case "tool-calls-result":
		return AssistantClientMessagesItemToolCallsResult, nil
	case "user-interrupted":
		return AssistantClientMessagesItemUserInterrupted, nil
	case "voice-input":
		return AssistantClientMessagesItemVoiceInput, nil
	}
	var t AssistantClientMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantClientMessagesItem) Ptr() *AssistantClientMessagesItem {
	return &a
}

// This is the mode for the first message. Default is 'assistant-speaks-first'.
//
// Use:
//
// - 'assistant-speaks-first' to have the assistant speak first.
// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
//
// @default 'assistant-speaks-first'
type AssistantFirstMessageMode string

const (
	AssistantFirstMessageModeAssistantSpeaksFirst                          AssistantFirstMessageMode = "assistant-speaks-first"
	AssistantFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage AssistantFirstMessageMode = "assistant-speaks-first-with-model-generated-message"
	AssistantFirstMessageModeAssistantWaitsForUser                         AssistantFirstMessageMode = "assistant-waits-for-user"
)

func NewAssistantFirstMessageModeFromString(s string) (AssistantFirstMessageMode, error) {
	switch s {
	case "assistant-speaks-first":
		return AssistantFirstMessageModeAssistantSpeaksFirst, nil
	case "assistant-speaks-first-with-model-generated-message":
		return AssistantFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage, nil
	case "assistant-waits-for-user":
		return AssistantFirstMessageModeAssistantWaitsForUser, nil
	}
	var t AssistantFirstMessageMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantFirstMessageMode) Ptr() *AssistantFirstMessageMode {
	return &a
}

// These are the options for the assistant's LLM.
type AssistantModel struct {
	AnyscaleModel     *AnyscaleModel
	AnthropicModel    *AnthropicModel
	CustomLlmModel    *CustomLlmModel
	DeepInfraModel    *DeepInfraModel
	GroqModel         *GroqModel
	OpenAiModel       *OpenAiModel
	OpenRouterModel   *OpenRouterModel
	PerplexityAiModel *PerplexityAiModel
	TogetherAiModel   *TogetherAiModel
	VapiModel         *VapiModel
}

func (a *AssistantModel) UnmarshalJSON(data []byte) error {
	valueAnyscaleModel := new(AnyscaleModel)
	if err := json.Unmarshal(data, &valueAnyscaleModel); err == nil {
		a.AnyscaleModel = valueAnyscaleModel
		return nil
	}
	valueAnthropicModel := new(AnthropicModel)
	if err := json.Unmarshal(data, &valueAnthropicModel); err == nil {
		a.AnthropicModel = valueAnthropicModel
		return nil
	}
	valueCustomLlmModel := new(CustomLlmModel)
	if err := json.Unmarshal(data, &valueCustomLlmModel); err == nil {
		a.CustomLlmModel = valueCustomLlmModel
		return nil
	}
	valueDeepInfraModel := new(DeepInfraModel)
	if err := json.Unmarshal(data, &valueDeepInfraModel); err == nil {
		a.DeepInfraModel = valueDeepInfraModel
		return nil
	}
	valueGroqModel := new(GroqModel)
	if err := json.Unmarshal(data, &valueGroqModel); err == nil {
		a.GroqModel = valueGroqModel
		return nil
	}
	valueOpenAiModel := new(OpenAiModel)
	if err := json.Unmarshal(data, &valueOpenAiModel); err == nil {
		a.OpenAiModel = valueOpenAiModel
		return nil
	}
	valueOpenRouterModel := new(OpenRouterModel)
	if err := json.Unmarshal(data, &valueOpenRouterModel); err == nil {
		a.OpenRouterModel = valueOpenRouterModel
		return nil
	}
	valuePerplexityAiModel := new(PerplexityAiModel)
	if err := json.Unmarshal(data, &valuePerplexityAiModel); err == nil {
		a.PerplexityAiModel = valuePerplexityAiModel
		return nil
	}
	valueTogetherAiModel := new(TogetherAiModel)
	if err := json.Unmarshal(data, &valueTogetherAiModel); err == nil {
		a.TogetherAiModel = valueTogetherAiModel
		return nil
	}
	valueVapiModel := new(VapiModel)
	if err := json.Unmarshal(data, &valueVapiModel); err == nil {
		a.VapiModel = valueVapiModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantModel) MarshalJSON() ([]byte, error) {
	if a.AnyscaleModel != nil {
		return json.Marshal(a.AnyscaleModel)
	}
	if a.AnthropicModel != nil {
		return json.Marshal(a.AnthropicModel)
	}
	if a.CustomLlmModel != nil {
		return json.Marshal(a.CustomLlmModel)
	}
	if a.DeepInfraModel != nil {
		return json.Marshal(a.DeepInfraModel)
	}
	if a.GroqModel != nil {
		return json.Marshal(a.GroqModel)
	}
	if a.OpenAiModel != nil {
		return json.Marshal(a.OpenAiModel)
	}
	if a.OpenRouterModel != nil {
		return json.Marshal(a.OpenRouterModel)
	}
	if a.PerplexityAiModel != nil {
		return json.Marshal(a.PerplexityAiModel)
	}
	if a.TogetherAiModel != nil {
		return json.Marshal(a.TogetherAiModel)
	}
	if a.VapiModel != nil {
		return json.Marshal(a.VapiModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantModelVisitor interface {
	VisitAnyscaleModel(*AnyscaleModel) error
	VisitAnthropicModel(*AnthropicModel) error
	VisitCustomLlmModel(*CustomLlmModel) error
	VisitDeepInfraModel(*DeepInfraModel) error
	VisitGroqModel(*GroqModel) error
	VisitOpenAiModel(*OpenAiModel) error
	VisitOpenRouterModel(*OpenRouterModel) error
	VisitPerplexityAiModel(*PerplexityAiModel) error
	VisitTogetherAiModel(*TogetherAiModel) error
	VisitVapiModel(*VapiModel) error
}

func (a *AssistantModel) Accept(visitor AssistantModelVisitor) error {
	if a.AnyscaleModel != nil {
		return visitor.VisitAnyscaleModel(a.AnyscaleModel)
	}
	if a.AnthropicModel != nil {
		return visitor.VisitAnthropicModel(a.AnthropicModel)
	}
	if a.CustomLlmModel != nil {
		return visitor.VisitCustomLlmModel(a.CustomLlmModel)
	}
	if a.DeepInfraModel != nil {
		return visitor.VisitDeepInfraModel(a.DeepInfraModel)
	}
	if a.GroqModel != nil {
		return visitor.VisitGroqModel(a.GroqModel)
	}
	if a.OpenAiModel != nil {
		return visitor.VisitOpenAiModel(a.OpenAiModel)
	}
	if a.OpenRouterModel != nil {
		return visitor.VisitOpenRouterModel(a.OpenRouterModel)
	}
	if a.PerplexityAiModel != nil {
		return visitor.VisitPerplexityAiModel(a.PerplexityAiModel)
	}
	if a.TogetherAiModel != nil {
		return visitor.VisitTogetherAiModel(a.TogetherAiModel)
	}
	if a.VapiModel != nil {
		return visitor.VisitVapiModel(a.VapiModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverrides struct {
	// These are the options for the assistant's transcriber.
	Transcriber *AssistantOverridesTranscriber `json:"transcriber,omitempty" url:"transcriber,omitempty"`
	// These are the options for the assistant's LLM.
	Model *AssistantOverridesModel `json:"model,omitempty" url:"model,omitempty"`
	// These are the options for the assistant's voice.
	Voice *AssistantOverridesVoice `json:"voice,omitempty" url:"voice,omitempty"`
	// This is the mode for the first message. Default is 'assistant-speaks-first'.
	//
	// Use:
	//
	// - 'assistant-speaks-first' to have the assistant speak first.
	// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
	// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
	//
	// @default 'assistant-speaks-first'
	FirstMessageMode *AssistantOverridesFirstMessageMode `json:"firstMessageMode,omitempty" url:"firstMessageMode,omitempty"`
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transcript,tool-calls,user-interrupted,voice-input. You can check the shape of the messages in ClientMessage schema.
	ClientMessages []AssistantOverridesClientMessagesItem `json:"clientMessages,omitempty" url:"clientMessages,omitempty"`
	// These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
	ServerMessages []AssistantOverridesServerMessagesItem `json:"serverMessages,omitempty" url:"serverMessages,omitempty"`
	// How many seconds of silence to wait before ending the call. Defaults to 30.
	//
	// @default 30
	SilenceTimeoutSeconds *float64 `json:"silenceTimeoutSeconds,omitempty" url:"silenceTimeoutSeconds,omitempty"`
	// This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
	//
	// @default 600 (10 minutes)
	MaxDurationSeconds *float64 `json:"maxDurationSeconds,omitempty" url:"maxDurationSeconds,omitempty"`
	// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
	BackgroundSound *AssistantOverridesBackgroundSound `json:"backgroundSound,omitempty" url:"backgroundSound,omitempty"`
	// This determines whether the model says 'mhmm', 'ahem' etc. while user is speaking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackchannelingEnabled *bool `json:"backchannelingEnabled,omitempty" url:"backchannelingEnabled,omitempty"`
	// This enables filtering of noise and background speech while the user is talking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackgroundDenoisingEnabled *bool `json:"backgroundDenoisingEnabled,omitempty" url:"backgroundDenoisingEnabled,omitempty"`
	// This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
	//
	// Default `false` while in beta.
	//
	// @default false
	ModelOutputInMessagesEnabled *bool `json:"modelOutputInMessagesEnabled,omitempty" url:"modelOutputInMessagesEnabled,omitempty"`
	// These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
	TransportConfigurations []*TransportConfigurationTwilio `json:"transportConfigurations,omitempty" url:"transportConfigurations,omitempty"`
	// These are values that will be used to replace the template variables in the assistant messages and other text-based fields.
	VariableValues map[string]interface{} `json:"variableValues,omitempty" url:"variableValues,omitempty"`
	// This is the name of the assistant.
	//
	// This is required when you want to transfer between assistants in a call.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
	//
	// If unspecified, assistant will wait for user to speak and use the model to respond once they speak.
	FirstMessage *string `json:"firstMessage,omitempty" url:"firstMessage,omitempty"`
	// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
	// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
	// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
	VoicemailDetection *TwilioVoicemailDetection `json:"voicemailDetection,omitempty" url:"voicemailDetection,omitempty"`
	// This is the message that the assistant will say if the call is forwarded to voicemail.
	//
	// If unspecified, it will hang up.
	VoicemailMessage *string `json:"voicemailMessage,omitempty" url:"voicemailMessage,omitempty"`
	// This is the message that the assistant will say if it ends the call.
	//
	// If unspecified, it will hang up without saying anything.
	EndCallMessage *string `json:"endCallMessage,omitempty" url:"endCallMessage,omitempty"`
	// This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
	EndCallPhrases []string `json:"endCallPhrases,omitempty" url:"endCallPhrases,omitempty"`
	// This is for metadata you want to store on the assistant.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the URL Vapi will communicate with via HTTP GET and POST Requests. This is used for retrieving context, function calling, and end-of-call reports.
	//
	// All requests will be sent with the call object among other things relevant to that message. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	// This is the plan for analysis of assistant's calls. Stored in `call.analysis`.
	AnalysisPlan *AnalysisPlan `json:"analysisPlan,omitempty" url:"analysisPlan,omitempty"`
	// This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.
	//
	// Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"artifactPlan,omitempty"`
	// This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.
	//
	// Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.
	MessagePlan *MessagePlan `json:"messagePlan,omitempty" url:"messagePlan,omitempty"`
	// This is the plan for when the assistant should start talking.
	//
	// You should configure this if you're running into these issues:
	//
	// - The assistant is too slow to start talking after the customer is done speaking.
	// - The assistant is too fast to start talking after the customer is done speaking.
	// - The assistant is so fast that it's actually interrupting the customer.
	StartSpeakingPlan *StartSpeakingPlan `json:"startSpeakingPlan,omitempty" url:"startSpeakingPlan,omitempty"`
	// This is the plan for when assistant should stop talking on customer interruption.
	//
	// You should configure this if you're running into these issues:
	//
	// - The assistant is too slow to recognize customer's interruption.
	// - The assistant is too fast to recognize customer's interruption.
	// - The assistant is getting interrupted by phrases that are just acknowledgments.
	// - The assistant is getting interrupted by background noises.
	// - The assistant is not properly stopping -- it starts talking right after getting interrupted.
	StopSpeakingPlan *StopSpeakingPlan `json:"stopSpeakingPlan,omitempty" url:"stopSpeakingPlan,omitempty"`
	// This is the plan for real-time monitoring of the assistant's calls.
	//
	// Usage:
	//
	// - To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.
	// - To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.
	//
	// Note, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible
	MonitorPlan *MonitorPlan `json:"monitorPlan,omitempty" url:"monitorPlan,omitempty"`
	// These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
	CredentialIds []string `json:"credentialIds,omitempty" url:"credentialIds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssistantOverrides) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantOverrides) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantOverrides
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantOverrides(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantOverrides) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
type AssistantOverridesBackgroundSound string

const (
	AssistantOverridesBackgroundSoundOff    AssistantOverridesBackgroundSound = "off"
	AssistantOverridesBackgroundSoundOffice AssistantOverridesBackgroundSound = "office"
)

func NewAssistantOverridesBackgroundSoundFromString(s string) (AssistantOverridesBackgroundSound, error) {
	switch s {
	case "off":
		return AssistantOverridesBackgroundSoundOff, nil
	case "office":
		return AssistantOverridesBackgroundSoundOffice, nil
	}
	var t AssistantOverridesBackgroundSound
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesBackgroundSound) Ptr() *AssistantOverridesBackgroundSound {
	return &a
}

type AssistantOverridesClientMessagesItem string

const (
	AssistantOverridesClientMessagesItemConversationUpdate AssistantOverridesClientMessagesItem = "conversation-update"
	AssistantOverridesClientMessagesItemFunctionCall       AssistantOverridesClientMessagesItem = "function-call"
	AssistantOverridesClientMessagesItemFunctionCallResult AssistantOverridesClientMessagesItem = "function-call-result"
	AssistantOverridesClientMessagesItemHang               AssistantOverridesClientMessagesItem = "hang"
	AssistantOverridesClientMessagesItemLanguageChanged    AssistantOverridesClientMessagesItem = "language-changed"
	AssistantOverridesClientMessagesItemMetadata           AssistantOverridesClientMessagesItem = "metadata"
	AssistantOverridesClientMessagesItemModelOutput        AssistantOverridesClientMessagesItem = "model-output"
	AssistantOverridesClientMessagesItemSpeechUpdate       AssistantOverridesClientMessagesItem = "speech-update"
	AssistantOverridesClientMessagesItemStatusUpdate       AssistantOverridesClientMessagesItem = "status-update"
	AssistantOverridesClientMessagesItemTranscript         AssistantOverridesClientMessagesItem = "transcript"
	AssistantOverridesClientMessagesItemToolCalls          AssistantOverridesClientMessagesItem = "tool-calls"
	AssistantOverridesClientMessagesItemToolCallsResult    AssistantOverridesClientMessagesItem = "tool-calls-result"
	AssistantOverridesClientMessagesItemUserInterrupted    AssistantOverridesClientMessagesItem = "user-interrupted"
	AssistantOverridesClientMessagesItemVoiceInput         AssistantOverridesClientMessagesItem = "voice-input"
)

func NewAssistantOverridesClientMessagesItemFromString(s string) (AssistantOverridesClientMessagesItem, error) {
	switch s {
	case "conversation-update":
		return AssistantOverridesClientMessagesItemConversationUpdate, nil
	case "function-call":
		return AssistantOverridesClientMessagesItemFunctionCall, nil
	case "function-call-result":
		return AssistantOverridesClientMessagesItemFunctionCallResult, nil
	case "hang":
		return AssistantOverridesClientMessagesItemHang, nil
	case "language-changed":
		return AssistantOverridesClientMessagesItemLanguageChanged, nil
	case "metadata":
		return AssistantOverridesClientMessagesItemMetadata, nil
	case "model-output":
		return AssistantOverridesClientMessagesItemModelOutput, nil
	case "speech-update":
		return AssistantOverridesClientMessagesItemSpeechUpdate, nil
	case "status-update":
		return AssistantOverridesClientMessagesItemStatusUpdate, nil
	case "transcript":
		return AssistantOverridesClientMessagesItemTranscript, nil
	case "tool-calls":
		return AssistantOverridesClientMessagesItemToolCalls, nil
	case "tool-calls-result":
		return AssistantOverridesClientMessagesItemToolCallsResult, nil
	case "user-interrupted":
		return AssistantOverridesClientMessagesItemUserInterrupted, nil
	case "voice-input":
		return AssistantOverridesClientMessagesItemVoiceInput, nil
	}
	var t AssistantOverridesClientMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesClientMessagesItem) Ptr() *AssistantOverridesClientMessagesItem {
	return &a
}

// This is the mode for the first message. Default is 'assistant-speaks-first'.
//
// Use:
//
// - 'assistant-speaks-first' to have the assistant speak first.
// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
//
// @default 'assistant-speaks-first'
type AssistantOverridesFirstMessageMode string

const (
	AssistantOverridesFirstMessageModeAssistantSpeaksFirst                          AssistantOverridesFirstMessageMode = "assistant-speaks-first"
	AssistantOverridesFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage AssistantOverridesFirstMessageMode = "assistant-speaks-first-with-model-generated-message"
	AssistantOverridesFirstMessageModeAssistantWaitsForUser                         AssistantOverridesFirstMessageMode = "assistant-waits-for-user"
)

func NewAssistantOverridesFirstMessageModeFromString(s string) (AssistantOverridesFirstMessageMode, error) {
	switch s {
	case "assistant-speaks-first":
		return AssistantOverridesFirstMessageModeAssistantSpeaksFirst, nil
	case "assistant-speaks-first-with-model-generated-message":
		return AssistantOverridesFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage, nil
	case "assistant-waits-for-user":
		return AssistantOverridesFirstMessageModeAssistantWaitsForUser, nil
	}
	var t AssistantOverridesFirstMessageMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesFirstMessageMode) Ptr() *AssistantOverridesFirstMessageMode {
	return &a
}

// These are the options for the assistant's LLM.
type AssistantOverridesModel struct {
	AnyscaleModel     *AnyscaleModel
	AnthropicModel    *AnthropicModel
	CustomLlmModel    *CustomLlmModel
	DeepInfraModel    *DeepInfraModel
	GroqModel         *GroqModel
	OpenAiModel       *OpenAiModel
	OpenRouterModel   *OpenRouterModel
	PerplexityAiModel *PerplexityAiModel
	TogetherAiModel   *TogetherAiModel
	VapiModel         *VapiModel
}

func (a *AssistantOverridesModel) UnmarshalJSON(data []byte) error {
	valueAnyscaleModel := new(AnyscaleModel)
	if err := json.Unmarshal(data, &valueAnyscaleModel); err == nil {
		a.AnyscaleModel = valueAnyscaleModel
		return nil
	}
	valueAnthropicModel := new(AnthropicModel)
	if err := json.Unmarshal(data, &valueAnthropicModel); err == nil {
		a.AnthropicModel = valueAnthropicModel
		return nil
	}
	valueCustomLlmModel := new(CustomLlmModel)
	if err := json.Unmarshal(data, &valueCustomLlmModel); err == nil {
		a.CustomLlmModel = valueCustomLlmModel
		return nil
	}
	valueDeepInfraModel := new(DeepInfraModel)
	if err := json.Unmarshal(data, &valueDeepInfraModel); err == nil {
		a.DeepInfraModel = valueDeepInfraModel
		return nil
	}
	valueGroqModel := new(GroqModel)
	if err := json.Unmarshal(data, &valueGroqModel); err == nil {
		a.GroqModel = valueGroqModel
		return nil
	}
	valueOpenAiModel := new(OpenAiModel)
	if err := json.Unmarshal(data, &valueOpenAiModel); err == nil {
		a.OpenAiModel = valueOpenAiModel
		return nil
	}
	valueOpenRouterModel := new(OpenRouterModel)
	if err := json.Unmarshal(data, &valueOpenRouterModel); err == nil {
		a.OpenRouterModel = valueOpenRouterModel
		return nil
	}
	valuePerplexityAiModel := new(PerplexityAiModel)
	if err := json.Unmarshal(data, &valuePerplexityAiModel); err == nil {
		a.PerplexityAiModel = valuePerplexityAiModel
		return nil
	}
	valueTogetherAiModel := new(TogetherAiModel)
	if err := json.Unmarshal(data, &valueTogetherAiModel); err == nil {
		a.TogetherAiModel = valueTogetherAiModel
		return nil
	}
	valueVapiModel := new(VapiModel)
	if err := json.Unmarshal(data, &valueVapiModel); err == nil {
		a.VapiModel = valueVapiModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesModel) MarshalJSON() ([]byte, error) {
	if a.AnyscaleModel != nil {
		return json.Marshal(a.AnyscaleModel)
	}
	if a.AnthropicModel != nil {
		return json.Marshal(a.AnthropicModel)
	}
	if a.CustomLlmModel != nil {
		return json.Marshal(a.CustomLlmModel)
	}
	if a.DeepInfraModel != nil {
		return json.Marshal(a.DeepInfraModel)
	}
	if a.GroqModel != nil {
		return json.Marshal(a.GroqModel)
	}
	if a.OpenAiModel != nil {
		return json.Marshal(a.OpenAiModel)
	}
	if a.OpenRouterModel != nil {
		return json.Marshal(a.OpenRouterModel)
	}
	if a.PerplexityAiModel != nil {
		return json.Marshal(a.PerplexityAiModel)
	}
	if a.TogetherAiModel != nil {
		return json.Marshal(a.TogetherAiModel)
	}
	if a.VapiModel != nil {
		return json.Marshal(a.VapiModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesModelVisitor interface {
	VisitAnyscaleModel(*AnyscaleModel) error
	VisitAnthropicModel(*AnthropicModel) error
	VisitCustomLlmModel(*CustomLlmModel) error
	VisitDeepInfraModel(*DeepInfraModel) error
	VisitGroqModel(*GroqModel) error
	VisitOpenAiModel(*OpenAiModel) error
	VisitOpenRouterModel(*OpenRouterModel) error
	VisitPerplexityAiModel(*PerplexityAiModel) error
	VisitTogetherAiModel(*TogetherAiModel) error
	VisitVapiModel(*VapiModel) error
}

func (a *AssistantOverridesModel) Accept(visitor AssistantOverridesModelVisitor) error {
	if a.AnyscaleModel != nil {
		return visitor.VisitAnyscaleModel(a.AnyscaleModel)
	}
	if a.AnthropicModel != nil {
		return visitor.VisitAnthropicModel(a.AnthropicModel)
	}
	if a.CustomLlmModel != nil {
		return visitor.VisitCustomLlmModel(a.CustomLlmModel)
	}
	if a.DeepInfraModel != nil {
		return visitor.VisitDeepInfraModel(a.DeepInfraModel)
	}
	if a.GroqModel != nil {
		return visitor.VisitGroqModel(a.GroqModel)
	}
	if a.OpenAiModel != nil {
		return visitor.VisitOpenAiModel(a.OpenAiModel)
	}
	if a.OpenRouterModel != nil {
		return visitor.VisitOpenRouterModel(a.OpenRouterModel)
	}
	if a.PerplexityAiModel != nil {
		return visitor.VisitPerplexityAiModel(a.PerplexityAiModel)
	}
	if a.TogetherAiModel != nil {
		return visitor.VisitTogetherAiModel(a.TogetherAiModel)
	}
	if a.VapiModel != nil {
		return visitor.VisitVapiModel(a.VapiModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesServerMessagesItem string

const (
	AssistantOverridesServerMessagesItemConversationUpdate         AssistantOverridesServerMessagesItem = "conversation-update"
	AssistantOverridesServerMessagesItemEndOfCallReport            AssistantOverridesServerMessagesItem = "end-of-call-report"
	AssistantOverridesServerMessagesItemFunctionCall               AssistantOverridesServerMessagesItem = "function-call"
	AssistantOverridesServerMessagesItemHang                       AssistantOverridesServerMessagesItem = "hang"
	AssistantOverridesServerMessagesItemLanguageChanged            AssistantOverridesServerMessagesItem = "language-changed"
	AssistantOverridesServerMessagesItemModelOutput                AssistantOverridesServerMessagesItem = "model-output"
	AssistantOverridesServerMessagesItemPhoneCallControl           AssistantOverridesServerMessagesItem = "phone-call-control"
	AssistantOverridesServerMessagesItemSpeechUpdate               AssistantOverridesServerMessagesItem = "speech-update"
	AssistantOverridesServerMessagesItemStatusUpdate               AssistantOverridesServerMessagesItem = "status-update"
	AssistantOverridesServerMessagesItemTranscript                 AssistantOverridesServerMessagesItem = "transcript"
	AssistantOverridesServerMessagesItemToolCalls                  AssistantOverridesServerMessagesItem = "tool-calls"
	AssistantOverridesServerMessagesItemTransferDestinationRequest AssistantOverridesServerMessagesItem = "transfer-destination-request"
	AssistantOverridesServerMessagesItemTransferUpdate             AssistantOverridesServerMessagesItem = "transfer-update"
	AssistantOverridesServerMessagesItemUserInterrupted            AssistantOverridesServerMessagesItem = "user-interrupted"
	AssistantOverridesServerMessagesItemVoiceInput                 AssistantOverridesServerMessagesItem = "voice-input"
)

func NewAssistantOverridesServerMessagesItemFromString(s string) (AssistantOverridesServerMessagesItem, error) {
	switch s {
	case "conversation-update":
		return AssistantOverridesServerMessagesItemConversationUpdate, nil
	case "end-of-call-report":
		return AssistantOverridesServerMessagesItemEndOfCallReport, nil
	case "function-call":
		return AssistantOverridesServerMessagesItemFunctionCall, nil
	case "hang":
		return AssistantOverridesServerMessagesItemHang, nil
	case "language-changed":
		return AssistantOverridesServerMessagesItemLanguageChanged, nil
	case "model-output":
		return AssistantOverridesServerMessagesItemModelOutput, nil
	case "phone-call-control":
		return AssistantOverridesServerMessagesItemPhoneCallControl, nil
	case "speech-update":
		return AssistantOverridesServerMessagesItemSpeechUpdate, nil
	case "status-update":
		return AssistantOverridesServerMessagesItemStatusUpdate, nil
	case "transcript":
		return AssistantOverridesServerMessagesItemTranscript, nil
	case "tool-calls":
		return AssistantOverridesServerMessagesItemToolCalls, nil
	case "transfer-destination-request":
		return AssistantOverridesServerMessagesItemTransferDestinationRequest, nil
	case "transfer-update":
		return AssistantOverridesServerMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return AssistantOverridesServerMessagesItemUserInterrupted, nil
	case "voice-input":
		return AssistantOverridesServerMessagesItemVoiceInput, nil
	}
	var t AssistantOverridesServerMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesServerMessagesItem) Ptr() *AssistantOverridesServerMessagesItem {
	return &a
}

// These are the options for the assistant's transcriber.
type AssistantOverridesTranscriber struct {
	DeepgramTranscriber    *DeepgramTranscriber
	GladiaTranscriber      *GladiaTranscriber
	TalkscriberTranscriber *TalkscriberTranscriber
}

func (a *AssistantOverridesTranscriber) UnmarshalJSON(data []byte) error {
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		a.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		a.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		a.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesTranscriber) MarshalJSON() ([]byte, error) {
	if a.DeepgramTranscriber != nil {
		return json.Marshal(a.DeepgramTranscriber)
	}
	if a.GladiaTranscriber != nil {
		return json.Marshal(a.GladiaTranscriber)
	}
	if a.TalkscriberTranscriber != nil {
		return json.Marshal(a.TalkscriberTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesTranscriberVisitor interface {
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
}

func (a *AssistantOverridesTranscriber) Accept(visitor AssistantOverridesTranscriberVisitor) error {
	if a.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(a.DeepgramTranscriber)
	}
	if a.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(a.GladiaTranscriber)
	}
	if a.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(a.TalkscriberTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// These are the options for the assistant's voice.
type AssistantOverridesVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	LmntVoice       *LmntVoice
	NeetsVoice      *NeetsVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
}

func (a *AssistantOverridesVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		a.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		a.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		a.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		a.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		a.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeetsVoice := new(NeetsVoice)
	if err := json.Unmarshal(data, &valueNeetsVoice); err == nil {
		a.NeetsVoice = valueNeetsVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		a.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		a.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		a.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesVoice) MarshalJSON() ([]byte, error) {
	if a.AzureVoice != nil {
		return json.Marshal(a.AzureVoice)
	}
	if a.CartesiaVoice != nil {
		return json.Marshal(a.CartesiaVoice)
	}
	if a.DeepgramVoice != nil {
		return json.Marshal(a.DeepgramVoice)
	}
	if a.ElevenLabsVoice != nil {
		return json.Marshal(a.ElevenLabsVoice)
	}
	if a.LmntVoice != nil {
		return json.Marshal(a.LmntVoice)
	}
	if a.NeetsVoice != nil {
		return json.Marshal(a.NeetsVoice)
	}
	if a.OpenAiVoice != nil {
		return json.Marshal(a.OpenAiVoice)
	}
	if a.PlayHtVoice != nil {
		return json.Marshal(a.PlayHtVoice)
	}
	if a.RimeAiVoice != nil {
		return json.Marshal(a.RimeAiVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeetsVoice(*NeetsVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
}

func (a *AssistantOverridesVoice) Accept(visitor AssistantOverridesVoiceVisitor) error {
	if a.AzureVoice != nil {
		return visitor.VisitAzureVoice(a.AzureVoice)
	}
	if a.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(a.CartesiaVoice)
	}
	if a.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(a.DeepgramVoice)
	}
	if a.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(a.ElevenLabsVoice)
	}
	if a.LmntVoice != nil {
		return visitor.VisitLmntVoice(a.LmntVoice)
	}
	if a.NeetsVoice != nil {
		return visitor.VisitNeetsVoice(a.NeetsVoice)
	}
	if a.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(a.OpenAiVoice)
	}
	if a.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(a.PlayHtVoice)
	}
	if a.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(a.RimeAiVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantServerMessagesItem string

const (
	AssistantServerMessagesItemConversationUpdate         AssistantServerMessagesItem = "conversation-update"
	AssistantServerMessagesItemEndOfCallReport            AssistantServerMessagesItem = "end-of-call-report"
	AssistantServerMessagesItemFunctionCall               AssistantServerMessagesItem = "function-call"
	AssistantServerMessagesItemHang                       AssistantServerMessagesItem = "hang"
	AssistantServerMessagesItemLanguageChanged            AssistantServerMessagesItem = "language-changed"
	AssistantServerMessagesItemModelOutput                AssistantServerMessagesItem = "model-output"
	AssistantServerMessagesItemPhoneCallControl           AssistantServerMessagesItem = "phone-call-control"
	AssistantServerMessagesItemSpeechUpdate               AssistantServerMessagesItem = "speech-update"
	AssistantServerMessagesItemStatusUpdate               AssistantServerMessagesItem = "status-update"
	AssistantServerMessagesItemTranscript                 AssistantServerMessagesItem = "transcript"
	AssistantServerMessagesItemToolCalls                  AssistantServerMessagesItem = "tool-calls"
	AssistantServerMessagesItemTransferDestinationRequest AssistantServerMessagesItem = "transfer-destination-request"
	AssistantServerMessagesItemTransferUpdate             AssistantServerMessagesItem = "transfer-update"
	AssistantServerMessagesItemUserInterrupted            AssistantServerMessagesItem = "user-interrupted"
	AssistantServerMessagesItemVoiceInput                 AssistantServerMessagesItem = "voice-input"
)

func NewAssistantServerMessagesItemFromString(s string) (AssistantServerMessagesItem, error) {
	switch s {
	case "conversation-update":
		return AssistantServerMessagesItemConversationUpdate, nil
	case "end-of-call-report":
		return AssistantServerMessagesItemEndOfCallReport, nil
	case "function-call":
		return AssistantServerMessagesItemFunctionCall, nil
	case "hang":
		return AssistantServerMessagesItemHang, nil
	case "language-changed":
		return AssistantServerMessagesItemLanguageChanged, nil
	case "model-output":
		return AssistantServerMessagesItemModelOutput, nil
	case "phone-call-control":
		return AssistantServerMessagesItemPhoneCallControl, nil
	case "speech-update":
		return AssistantServerMessagesItemSpeechUpdate, nil
	case "status-update":
		return AssistantServerMessagesItemStatusUpdate, nil
	case "transcript":
		return AssistantServerMessagesItemTranscript, nil
	case "tool-calls":
		return AssistantServerMessagesItemToolCalls, nil
	case "transfer-destination-request":
		return AssistantServerMessagesItemTransferDestinationRequest, nil
	case "transfer-update":
		return AssistantServerMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return AssistantServerMessagesItemUserInterrupted, nil
	case "voice-input":
		return AssistantServerMessagesItemVoiceInput, nil
	}
	var t AssistantServerMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantServerMessagesItem) Ptr() *AssistantServerMessagesItem {
	return &a
}

// These are the options for the assistant's transcriber.
type AssistantTranscriber struct {
	DeepgramTranscriber    *DeepgramTranscriber
	GladiaTranscriber      *GladiaTranscriber
	TalkscriberTranscriber *TalkscriberTranscriber
}

func (a *AssistantTranscriber) UnmarshalJSON(data []byte) error {
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		a.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		a.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		a.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantTranscriber) MarshalJSON() ([]byte, error) {
	if a.DeepgramTranscriber != nil {
		return json.Marshal(a.DeepgramTranscriber)
	}
	if a.GladiaTranscriber != nil {
		return json.Marshal(a.GladiaTranscriber)
	}
	if a.TalkscriberTranscriber != nil {
		return json.Marshal(a.TalkscriberTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantTranscriberVisitor interface {
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
}

func (a *AssistantTranscriber) Accept(visitor AssistantTranscriberVisitor) error {
	if a.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(a.DeepgramTranscriber)
	}
	if a.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(a.GladiaTranscriber)
	}
	if a.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(a.TalkscriberTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// These are the options for the assistant's voice.
type AssistantVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	LmntVoice       *LmntVoice
	NeetsVoice      *NeetsVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
}

func (a *AssistantVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		a.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		a.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		a.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		a.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		a.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeetsVoice := new(NeetsVoice)
	if err := json.Unmarshal(data, &valueNeetsVoice); err == nil {
		a.NeetsVoice = valueNeetsVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		a.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		a.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		a.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantVoice) MarshalJSON() ([]byte, error) {
	if a.AzureVoice != nil {
		return json.Marshal(a.AzureVoice)
	}
	if a.CartesiaVoice != nil {
		return json.Marshal(a.CartesiaVoice)
	}
	if a.DeepgramVoice != nil {
		return json.Marshal(a.DeepgramVoice)
	}
	if a.ElevenLabsVoice != nil {
		return json.Marshal(a.ElevenLabsVoice)
	}
	if a.LmntVoice != nil {
		return json.Marshal(a.LmntVoice)
	}
	if a.NeetsVoice != nil {
		return json.Marshal(a.NeetsVoice)
	}
	if a.OpenAiVoice != nil {
		return json.Marshal(a.OpenAiVoice)
	}
	if a.PlayHtVoice != nil {
		return json.Marshal(a.PlayHtVoice)
	}
	if a.RimeAiVoice != nil {
		return json.Marshal(a.RimeAiVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeetsVoice(*NeetsVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
}

func (a *AssistantVoice) Accept(visitor AssistantVoiceVisitor) error {
	if a.AzureVoice != nil {
		return visitor.VisitAzureVoice(a.AzureVoice)
	}
	if a.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(a.CartesiaVoice)
	}
	if a.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(a.DeepgramVoice)
	}
	if a.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(a.ElevenLabsVoice)
	}
	if a.LmntVoice != nil {
		return visitor.VisitLmntVoice(a.LmntVoice)
	}
	if a.NeetsVoice != nil {
		return visitor.VisitNeetsVoice(a.NeetsVoice)
	}
	if a.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(a.OpenAiVoice)
	}
	if a.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(a.PlayHtVoice)
	}
	if a.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(a.RimeAiVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AzureOpenAiCredential struct {
	Region AzureOpenAiCredentialRegion       `json:"region" url:"region"`
	Models []AzureOpenAiCredentialModelsItem `json:"models,omitempty" url:"models,omitempty"`
	// This is not returned in the API.
	OpenAiKey string `json:"openAIKey" url:"openAIKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt      time.Time `json:"updatedAt" url:"updatedAt"`
	OpenAiEndpoint string    `json:"openAIEndpoint" url:"openAIEndpoint"`
	provider       string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AzureOpenAiCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureOpenAiCredential) Provider() string {
	return a.provider
}

func (a *AzureOpenAiCredential) UnmarshalJSON(data []byte) error {
	type embed AzureOpenAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AzureOpenAiCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "azure-openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "azure-openai", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureOpenAiCredential) MarshalJSON() ([]byte, error) {
	type embed AzureOpenAiCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
		Provider:  "azure-openai",
	}
	return json.Marshal(marshaler)
}

func (a *AzureOpenAiCredential) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AzureOpenAiCredentialModelsItem string

const (
	AzureOpenAiCredentialModelsItemGpt4OMini20240718 AzureOpenAiCredentialModelsItem = "gpt-4o-mini-2024-07-18"
	AzureOpenAiCredentialModelsItemGpt4O20240513     AzureOpenAiCredentialModelsItem = "gpt-4o-2024-05-13"
	AzureOpenAiCredentialModelsItemGpt4Turbo20240409 AzureOpenAiCredentialModelsItem = "gpt-4-turbo-2024-04-09"
	AzureOpenAiCredentialModelsItemGpt40125Preview   AzureOpenAiCredentialModelsItem = "gpt-4-0125-preview"
	AzureOpenAiCredentialModelsItemGpt41106Preview   AzureOpenAiCredentialModelsItem = "gpt-4-1106-preview"
	AzureOpenAiCredentialModelsItemGpt40613          AzureOpenAiCredentialModelsItem = "gpt-4-0613"
	AzureOpenAiCredentialModelsItemGpt35Turbo0125    AzureOpenAiCredentialModelsItem = "gpt-35-turbo-0125"
	AzureOpenAiCredentialModelsItemGpt35Turbo1106    AzureOpenAiCredentialModelsItem = "gpt-35-turbo-1106"
)

func NewAzureOpenAiCredentialModelsItemFromString(s string) (AzureOpenAiCredentialModelsItem, error) {
	switch s {
	case "gpt-4o-mini-2024-07-18":
		return AzureOpenAiCredentialModelsItemGpt4OMini20240718, nil
	case "gpt-4o-2024-05-13":
		return AzureOpenAiCredentialModelsItemGpt4O20240513, nil
	case "gpt-4-turbo-2024-04-09":
		return AzureOpenAiCredentialModelsItemGpt4Turbo20240409, nil
	case "gpt-4-0125-preview":
		return AzureOpenAiCredentialModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return AzureOpenAiCredentialModelsItemGpt41106Preview, nil
	case "gpt-4-0613":
		return AzureOpenAiCredentialModelsItemGpt40613, nil
	case "gpt-35-turbo-0125":
		return AzureOpenAiCredentialModelsItemGpt35Turbo0125, nil
	case "gpt-35-turbo-1106":
		return AzureOpenAiCredentialModelsItemGpt35Turbo1106, nil
	}
	var t AzureOpenAiCredentialModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureOpenAiCredentialModelsItem) Ptr() *AzureOpenAiCredentialModelsItem {
	return &a
}

type AzureOpenAiCredentialRegion string

const (
	AzureOpenAiCredentialRegionAustralia      AzureOpenAiCredentialRegion = "australia"
	AzureOpenAiCredentialRegionCanada         AzureOpenAiCredentialRegion = "canada"
	AzureOpenAiCredentialRegionEastus2        AzureOpenAiCredentialRegion = "eastus2"
	AzureOpenAiCredentialRegionEastus         AzureOpenAiCredentialRegion = "eastus"
	AzureOpenAiCredentialRegionFrance         AzureOpenAiCredentialRegion = "france"
	AzureOpenAiCredentialRegionIndia          AzureOpenAiCredentialRegion = "india"
	AzureOpenAiCredentialRegionJapan          AzureOpenAiCredentialRegion = "japan"
	AzureOpenAiCredentialRegionNorthcentralus AzureOpenAiCredentialRegion = "northcentralus"
	AzureOpenAiCredentialRegionNorway         AzureOpenAiCredentialRegion = "norway"
	AzureOpenAiCredentialRegionSouthcentralus AzureOpenAiCredentialRegion = "southcentralus"
	AzureOpenAiCredentialRegionSweden         AzureOpenAiCredentialRegion = "sweden"
	AzureOpenAiCredentialRegionSwitzerland    AzureOpenAiCredentialRegion = "switzerland"
	AzureOpenAiCredentialRegionUk             AzureOpenAiCredentialRegion = "uk"
	AzureOpenAiCredentialRegionWestus         AzureOpenAiCredentialRegion = "westus"
	AzureOpenAiCredentialRegionWestus3        AzureOpenAiCredentialRegion = "westus3"
)

func NewAzureOpenAiCredentialRegionFromString(s string) (AzureOpenAiCredentialRegion, error) {
	switch s {
	case "australia":
		return AzureOpenAiCredentialRegionAustralia, nil
	case "canada":
		return AzureOpenAiCredentialRegionCanada, nil
	case "eastus2":
		return AzureOpenAiCredentialRegionEastus2, nil
	case "eastus":
		return AzureOpenAiCredentialRegionEastus, nil
	case "france":
		return AzureOpenAiCredentialRegionFrance, nil
	case "india":
		return AzureOpenAiCredentialRegionIndia, nil
	case "japan":
		return AzureOpenAiCredentialRegionJapan, nil
	case "northcentralus":
		return AzureOpenAiCredentialRegionNorthcentralus, nil
	case "norway":
		return AzureOpenAiCredentialRegionNorway, nil
	case "southcentralus":
		return AzureOpenAiCredentialRegionSouthcentralus, nil
	case "sweden":
		return AzureOpenAiCredentialRegionSweden, nil
	case "switzerland":
		return AzureOpenAiCredentialRegionSwitzerland, nil
	case "uk":
		return AzureOpenAiCredentialRegionUk, nil
	case "westus":
		return AzureOpenAiCredentialRegionWestus, nil
	case "westus3":
		return AzureOpenAiCredentialRegionWestus3, nil
	}
	var t AzureOpenAiCredentialRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureOpenAiCredentialRegion) Ptr() *AzureOpenAiCredentialRegion {
	return &a
}

type AzureVoice struct {
	// This determines whether fillers are injected into the model output before inputting it into the voice provider.
	//
	// Default `false` because you can achieve better results with prompting the model.
	FillerInjectionEnabled *bool `json:"fillerInjectionEnabled,omitempty" url:"fillerInjectionEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *AzureVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AzureVoice) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureVoice) Provider() string {
	return a.provider
}

func (a *AzureVoice) UnmarshalJSON(data []byte) error {
	type embed AzureVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AzureVoice(unmarshaler.embed)
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "azure", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureVoice) MarshalJSON() ([]byte, error) {
	type embed AzureVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "azure",
	}
	return json.Marshal(marshaler)
}

func (a *AzureVoice) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the provider-specific ID that will be used.
type AzureVoiceVoiceId struct {
	andrewStringLiteral string
	brianStringLiteral  string
	emmaStringLiteral   string
	String              string
}

func NewAzureVoiceVoiceIdWithAndrewStringLiteral() *AzureVoiceVoiceId {
	return &AzureVoiceVoiceId{andrewStringLiteral: "andrew"}
}

func NewAzureVoiceVoiceIdWithBrianStringLiteral() *AzureVoiceVoiceId {
	return &AzureVoiceVoiceId{brianStringLiteral: "brian"}
}

func NewAzureVoiceVoiceIdWithEmmaStringLiteral() *AzureVoiceVoiceId {
	return &AzureVoiceVoiceId{emmaStringLiteral: "emma"}
}

func (a *AzureVoiceVoiceId) AndrewStringLiteral() string {
	return a.andrewStringLiteral
}

func (a *AzureVoiceVoiceId) BrianStringLiteral() string {
	return a.brianStringLiteral
}

func (a *AzureVoiceVoiceId) EmmaStringLiteral() string {
	return a.emmaStringLiteral
}

func (a *AzureVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueAndrewStringLiteral string
	if err := json.Unmarshal(data, &valueAndrewStringLiteral); err == nil {
		a.andrewStringLiteral = valueAndrewStringLiteral
		if a.andrewStringLiteral != "andrew" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "andrew", valueAndrewStringLiteral)
		}
		return nil
	}
	var valueBrianStringLiteral string
	if err := json.Unmarshal(data, &valueBrianStringLiteral); err == nil {
		a.brianStringLiteral = valueBrianStringLiteral
		if a.brianStringLiteral != "brian" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "brian", valueBrianStringLiteral)
		}
		return nil
	}
	var valueEmmaStringLiteral string
	if err := json.Unmarshal(data, &valueEmmaStringLiteral); err == nil {
		a.emmaStringLiteral = valueEmmaStringLiteral
		if a.emmaStringLiteral != "emma" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "emma", valueEmmaStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AzureVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if a.andrewStringLiteral != "" {
		return json.Marshal("andrew")
	}
	if a.brianStringLiteral != "" {
		return json.Marshal("brian")
	}
	if a.emmaStringLiteral != "" {
		return json.Marshal("emma")
	}
	if a.String != "" {
		return json.Marshal(a.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AzureVoiceVoiceIdVisitor interface {
	VisitAndrewStringLiteral(string) error
	VisitBrianStringLiteral(string) error
	VisitEmmaStringLiteral(string) error
	VisitString(string) error
}

func (a *AzureVoiceVoiceId) Accept(visitor AzureVoiceVoiceIdVisitor) error {
	if a.andrewStringLiteral != "" {
		return visitor.VisitAndrewStringLiteral(a.andrewStringLiteral)
	}
	if a.brianStringLiteral != "" {
		return visitor.VisitBrianStringLiteral(a.brianStringLiteral)
	}
	if a.emmaStringLiteral != "" {
		return visitor.VisitEmmaStringLiteral(a.emmaStringLiteral)
	}
	if a.String != "" {
		return visitor.VisitString(a.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type BlockCompleteMessage struct {
	// This is an optional array of conditions that must be met for this message to be triggered.
	Conditions []*BlockCompleteMessageConditionsItem `json:"conditions,omitempty" url:"conditions,omitempty"`
	// This is the message type that is triggered when the block completes.
	// This is the content that the assistant will say when this message is triggered.
	Content string `json:"content" url:"content"`
	type_   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BlockCompleteMessage) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BlockCompleteMessage) Type() string {
	return b.type_
}

func (b *BlockCompleteMessage) UnmarshalJSON(data []byte) error {
	type embed BlockCompleteMessage
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BlockCompleteMessage(unmarshaler.embed)
	if unmarshaler.Type != "block-complete" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "block-complete", unmarshaler.Type)
	}
	b.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *b, "type")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BlockCompleteMessage) MarshalJSON() ([]byte, error) {
	type embed BlockCompleteMessage
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
		Type:  "block-complete",
	}
	return json.Marshal(marshaler)
}

func (b *BlockCompleteMessage) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BlockCompleteMessageConditionsItem struct {
	ModelBasedCondition *ModelBasedCondition
	RuleBasedCondition  *RuleBasedCondition
}

func (b *BlockCompleteMessageConditionsItem) UnmarshalJSON(data []byte) error {
	valueModelBasedCondition := new(ModelBasedCondition)
	if err := json.Unmarshal(data, &valueModelBasedCondition); err == nil {
		b.ModelBasedCondition = valueModelBasedCondition
		return nil
	}
	valueRuleBasedCondition := new(RuleBasedCondition)
	if err := json.Unmarshal(data, &valueRuleBasedCondition); err == nil {
		b.RuleBasedCondition = valueRuleBasedCondition
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BlockCompleteMessageConditionsItem) MarshalJSON() ([]byte, error) {
	if b.ModelBasedCondition != nil {
		return json.Marshal(b.ModelBasedCondition)
	}
	if b.RuleBasedCondition != nil {
		return json.Marshal(b.RuleBasedCondition)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BlockCompleteMessageConditionsItemVisitor interface {
	VisitModelBasedCondition(*ModelBasedCondition) error
	VisitRuleBasedCondition(*RuleBasedCondition) error
}

func (b *BlockCompleteMessageConditionsItem) Accept(visitor BlockCompleteMessageConditionsItemVisitor) error {
	if b.ModelBasedCondition != nil {
		return visitor.VisitModelBasedCondition(b.ModelBasedCondition)
	}
	if b.RuleBasedCondition != nil {
		return visitor.VisitRuleBasedCondition(b.RuleBasedCondition)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BlockStartMessage struct {
	// This is an optional array of conditions that must be met for this message to be triggered.
	Conditions []*BlockStartMessageConditionsItem `json:"conditions,omitempty" url:"conditions,omitempty"`
	// This is the message type that is triggered when the block starts.
	// This is the content that the assistant will say when this message is triggered.
	Content string `json:"content" url:"content"`
	type_   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BlockStartMessage) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BlockStartMessage) Type() string {
	return b.type_
}

func (b *BlockStartMessage) UnmarshalJSON(data []byte) error {
	type embed BlockStartMessage
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BlockStartMessage(unmarshaler.embed)
	if unmarshaler.Type != "block-start" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "block-start", unmarshaler.Type)
	}
	b.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *b, "type")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BlockStartMessage) MarshalJSON() ([]byte, error) {
	type embed BlockStartMessage
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
		Type:  "block-start",
	}
	return json.Marshal(marshaler)
}

func (b *BlockStartMessage) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BlockStartMessageConditionsItem struct {
	ModelBasedCondition *ModelBasedCondition
	RuleBasedCondition  *RuleBasedCondition
}

func (b *BlockStartMessageConditionsItem) UnmarshalJSON(data []byte) error {
	valueModelBasedCondition := new(ModelBasedCondition)
	if err := json.Unmarshal(data, &valueModelBasedCondition); err == nil {
		b.ModelBasedCondition = valueModelBasedCondition
		return nil
	}
	valueRuleBasedCondition := new(RuleBasedCondition)
	if err := json.Unmarshal(data, &valueRuleBasedCondition); err == nil {
		b.RuleBasedCondition = valueRuleBasedCondition
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BlockStartMessageConditionsItem) MarshalJSON() ([]byte, error) {
	if b.ModelBasedCondition != nil {
		return json.Marshal(b.ModelBasedCondition)
	}
	if b.RuleBasedCondition != nil {
		return json.Marshal(b.RuleBasedCondition)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BlockStartMessageConditionsItemVisitor interface {
	VisitModelBasedCondition(*ModelBasedCondition) error
	VisitRuleBasedCondition(*RuleBasedCondition) error
}

func (b *BlockStartMessageConditionsItem) Accept(visitor BlockStartMessageConditionsItemVisitor) error {
	if b.ModelBasedCondition != nil {
		return visitor.VisitModelBasedCondition(b.ModelBasedCondition)
	}
	if b.RuleBasedCondition != nil {
		return visitor.VisitRuleBasedCondition(b.RuleBasedCondition)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BotMessage struct {
	// The role of the bot in the conversation.
	Role string `json:"role" url:"role"`
	// The message content from the bot.
	Message string `json:"message" url:"message"`
	// The timestamp when the message was sent.
	Time float64 `json:"time" url:"time"`
	// The timestamp when the message ended.
	EndTime float64 `json:"endTime" url:"endTime"`
	// The number of seconds from the start of the conversation.
	SecondsFromStart float64 `json:"secondsFromStart" url:"secondsFromStart"`
	// The source of the message.
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The duration of the message in seconds.
	Duration *float64 `json:"duration,omitempty" url:"duration,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BotMessage) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler BotMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotMessage) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BucketPlan struct {
	// This is the name of the bucket.
	Name string `json:"name" url:"name"`
	// This is the region of the bucket.
	//
	// Usage:
	//
	// - If `credential.type` is `aws`, then this is required.
	// - If `credential.type` is `gcp`, then this is optional since GCP allows buckets to be accessed without a region but region is required for data residency requirements. Read here: https://cloud.google.com/storage/docs/request-endpoints
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// This is the path where call artifacts will be stored.
	//
	// Usage:
	//
	// - To store call artifacts in a specific folder, set this to the full path. Eg. "/folder-name1/folder-name2".
	// - To store call artifacts in the root of the bucket, leave this blank.
	//
	// @default "/"
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// This is the HMAC access key offered by GCP for interoperability with S3 clients. Here is the guide on how to create: https://cloud.google.com/storage/docs/authentication/managing-hmackeys#console
	//
	// Usage:
	//
	// - If `credential.type` is `gcp`, then this is required.
	// - If `credential.type` is `aws`, then this is not required since credential.awsAccessKeyId is used instead.
	HmacAccessKey *string `json:"hmacAccessKey,omitempty" url:"hmacAccessKey,omitempty"`
	// This is the secret for the HMAC access key. Here is the guide on how to create: https://cloud.google.com/storage/docs/authentication/managing-hmackeys#console
	//
	// Usage:
	//
	// - If `credential.type` is `gcp`, then this is required.
	// - If `credential.type` is `aws`, then this is not required since credential.awsSecretAccessKey is used instead.
	//
	// Note: This is not returned in the API.
	HmacSecret *string `json:"hmacSecret,omitempty" url:"hmacSecret,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BucketPlan) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BucketPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler BucketPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BucketPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BucketPlan) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BuyPhoneNumberDto struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *BuyPhoneNumberDtoFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// This is the area code of the phone number to purchase.
	AreaCode string `json:"areaCode" url:"areaCode"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BuyPhoneNumberDto) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BuyPhoneNumberDto) UnmarshalJSON(data []byte) error {
	type unmarshaler BuyPhoneNumberDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BuyPhoneNumberDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BuyPhoneNumberDto) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type BuyPhoneNumberDtoFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (b *BuyPhoneNumberDtoFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		b.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		b.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BuyPhoneNumberDtoFallbackDestination) MarshalJSON() ([]byte, error) {
	if b.TransferDestinationNumber != nil {
		return json.Marshal(b.TransferDestinationNumber)
	}
	if b.TransferDestinationSip != nil {
		return json.Marshal(b.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BuyPhoneNumberDtoFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (b *BuyPhoneNumberDtoFallbackDestination) Accept(visitor BuyPhoneNumberDtoFallbackDestinationVisitor) error {
	if b.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(b.TransferDestinationNumber)
	}
	if b.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(b.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

type ByoPhoneNumber struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *ByoPhoneNumberFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.
	//
	// Use cases:
	//
	// - `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.
	// - `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.
	//
	// If `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\+?[a-zA-Z0-9]+$/`).
	//
	// @default true (E164 check is enabled)
	NumberE164CheckEnabled *bool `json:"numberE164CheckEnabled,omitempty" url:"numberE164CheckEnabled,omitempty"`
	// This is the unique identifier for the phone number.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this phone number belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the phone number was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the phone number was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	// This is the number of the customer.
	Number *string `json:"number,omitempty" url:"number,omitempty"`
	// This is the credential of your own SIP trunk or Carrier (type `byo-sip-trunk`) which can be used to make calls to this phone number.
	//
	// You can add the SIP trunk or Carrier credential in the Provider Credentials page on the Dashboard to get the credentialId.
	CredentialId string `json:"credentialId" url:"credentialId"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *ByoPhoneNumber) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *ByoPhoneNumber) Provider() string {
	return b.provider
}

func (b *ByoPhoneNumber) UnmarshalJSON(data []byte) error {
	type embed ByoPhoneNumber
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = ByoPhoneNumber(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "byo-phone-number" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "byo-phone-number", unmarshaler.Provider)
	}
	b.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *b, "provider")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *ByoPhoneNumber) MarshalJSON() ([]byte, error) {
	type embed ByoPhoneNumber
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
		Provider:  "byo-phone-number",
	}
	return json.Marshal(marshaler)
}

func (b *ByoPhoneNumber) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type ByoPhoneNumberFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (b *ByoPhoneNumberFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		b.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		b.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b ByoPhoneNumberFallbackDestination) MarshalJSON() ([]byte, error) {
	if b.TransferDestinationNumber != nil {
		return json.Marshal(b.TransferDestinationNumber)
	}
	if b.TransferDestinationSip != nil {
		return json.Marshal(b.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type ByoPhoneNumberFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (b *ByoPhoneNumberFallbackDestination) Accept(visitor ByoPhoneNumberFallbackDestinationVisitor) error {
	if b.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(b.TransferDestinationNumber)
	}
	if b.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(b.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

type ByoSipTrunkCredential struct {
	// This can be used to bring your own SIP trunks or to connect to a Carrier.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the list of SIP trunk's gateways.
	Gateways []*SipTrunkGateway `json:"gateways,omitempty" url:"gateways,omitempty"`
	// This is the name of the SIP trunk. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This can be used to configure the outbound authentication if required by the SIP trunk.
	OutboundAuthenticationPlan *SipTrunkOutboundAuthenticationPlan `json:"outboundAuthenticationPlan,omitempty" url:"outboundAuthenticationPlan,omitempty"`
	// This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.
	//
	// Usage:
	//
	// - Vonage/Twilio requires leading plus for all outbound calls. Set this to true.
	//
	// @default false
	OutboundLeadingPlusEnabled *bool `json:"outboundLeadingPlusEnabled,omitempty" url:"outboundLeadingPlusEnabled,omitempty"`
	// This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.
	SbcConfiguration *SbcConfiguration `json:"sbcConfiguration,omitempty" url:"sbcConfiguration,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *ByoSipTrunkCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *ByoSipTrunkCredential) UnmarshalJSON(data []byte) error {
	type embed ByoSipTrunkCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = ByoSipTrunkCredential(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *ByoSipTrunkCredential) MarshalJSON() ([]byte, error) {
	type embed ByoSipTrunkCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *ByoSipTrunkCredential) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Call struct {
	// This is the type of call.
	Type *CallType `json:"type,omitempty" url:"type,omitempty"`
	// These are the costs of individual components of the call in USD.
	Costs    []*CallCostsItem    `json:"costs,omitempty" url:"costs,omitempty"`
	Messages []*CallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the provider of the call.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneCallProvider *CallPhoneCallProvider `json:"phoneCallProvider,omitempty" url:"phoneCallProvider,omitempty"`
	// This is the transport of the phone call.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneCallTransport *CallPhoneCallTransport `json:"phoneCallTransport,omitempty" url:"phoneCallTransport,omitempty"`
	// This is the status of the call.
	Status *CallStatus `json:"status,omitempty" url:"status,omitempty"`
	// This is the explanation for how the call ended.
	EndedReason *CallEndedReason `json:"endedReason,omitempty" url:"endedReason,omitempty"`
	// This is the destination where the call ended up being transferred to. If the call was not transferred, this will be empty.
	Destination *CallDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the unique identifier for the call.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this call belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the call was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the call was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the ISO 8601 date-time string of when the call was started.
	StartedAt *time.Time `json:"startedAt,omitempty" url:"startedAt,omitempty"`
	// This is the ISO 8601 date-time string of when the call was ended.
	EndedAt *time.Time `json:"endedAt,omitempty" url:"endedAt,omitempty"`
	// This is the cost of the call in USD.
	Cost *float64 `json:"cost,omitempty" url:"cost,omitempty"`
	// This is the cost of the call in USD.
	CostBreakdown *CostBreakdown `json:"costBreakdown,omitempty" url:"costBreakdown,omitempty"`
	// This is a copy of assistant artifact plan. This isn't actually stored on the call but rather just returned in POST /call/web to enable artifact creation client side.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"artifactPlan,omitempty"`
	// This is the analysis of the call. Configure in `assistant.analysisPlan`.
	Analysis *Analysis `json:"analysis,omitempty" url:"analysis,omitempty"`
	// This is to real-time monitor the call. Configure in `assistant.monitorPlan`.
	Monitor *Monitor `json:"monitor,omitempty" url:"monitor,omitempty"`
	// These are the artifacts created from the call. Configure in `assistant.artifactPlan`.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// The ID of the call as provided by the phone number service. callSid in Twilio. conversationUuid in Vonage.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneCallProviderId *string `json:"phoneCallProviderId,omitempty" url:"phoneCallProviderId,omitempty"`
	// This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the overrides for the `assistant` or `assistantId`'s settings and template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the call. To use a transient squad, use `squad` instead.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// This is the phone number that will be used for the call. To use a transient number, use `phoneNumber` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneNumberId *string `json:"phoneNumberId,omitempty" url:"phoneNumberId,omitempty"`
	// This is the phone number that will be used for the call. To use an existing number, use `phoneNumberId` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneNumber *ImportTwilioPhoneNumberDto `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the customer that will be called. To call a transient customer , use `customer` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	CustomerId *string `json:"customerId,omitempty" url:"customerId,omitempty"`
	// This is the customer that will be called. To call an existing customer, use `customerId` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the name of the call. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Call) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Call) UnmarshalJSON(data []byte) error {
	type embed Call
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		StartedAt *core.DateTime `json:"startedAt,omitempty"`
		EndedAt   *core.DateTime `json:"endedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Call(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	c.StartedAt = unmarshaler.StartedAt.TimePtr()
	c.EndedAt = unmarshaler.EndedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Call) MarshalJSON() ([]byte, error) {
	type embed Call
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		StartedAt *core.DateTime `json:"startedAt,omitempty"`
		EndedAt   *core.DateTime `json:"endedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		StartedAt: core.NewOptionalDateTime(c.StartedAt),
		EndedAt:   core.NewOptionalDateTime(c.EndedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Call) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CallCostsItem struct {
	TransportCost   *TransportCost
	TranscriberCost *TranscriberCost
	ModelCost       *ModelCost
	VoiceCost       *VoiceCost
	VapiCost        *VapiCost
	AnalysisCost    *AnalysisCost
}

func (c *CallCostsItem) UnmarshalJSON(data []byte) error {
	valueTransportCost := new(TransportCost)
	if err := json.Unmarshal(data, &valueTransportCost); err == nil {
		c.TransportCost = valueTransportCost
		return nil
	}
	valueTranscriberCost := new(TranscriberCost)
	if err := json.Unmarshal(data, &valueTranscriberCost); err == nil {
		c.TranscriberCost = valueTranscriberCost
		return nil
	}
	valueModelCost := new(ModelCost)
	if err := json.Unmarshal(data, &valueModelCost); err == nil {
		c.ModelCost = valueModelCost
		return nil
	}
	valueVoiceCost := new(VoiceCost)
	if err := json.Unmarshal(data, &valueVoiceCost); err == nil {
		c.VoiceCost = valueVoiceCost
		return nil
	}
	valueVapiCost := new(VapiCost)
	if err := json.Unmarshal(data, &valueVapiCost); err == nil {
		c.VapiCost = valueVapiCost
		return nil
	}
	valueAnalysisCost := new(AnalysisCost)
	if err := json.Unmarshal(data, &valueAnalysisCost); err == nil {
		c.AnalysisCost = valueAnalysisCost
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CallCostsItem) MarshalJSON() ([]byte, error) {
	if c.TransportCost != nil {
		return json.Marshal(c.TransportCost)
	}
	if c.TranscriberCost != nil {
		return json.Marshal(c.TranscriberCost)
	}
	if c.ModelCost != nil {
		return json.Marshal(c.ModelCost)
	}
	if c.VoiceCost != nil {
		return json.Marshal(c.VoiceCost)
	}
	if c.VapiCost != nil {
		return json.Marshal(c.VapiCost)
	}
	if c.AnalysisCost != nil {
		return json.Marshal(c.AnalysisCost)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CallCostsItemVisitor interface {
	VisitTransportCost(*TransportCost) error
	VisitTranscriberCost(*TranscriberCost) error
	VisitModelCost(*ModelCost) error
	VisitVoiceCost(*VoiceCost) error
	VisitVapiCost(*VapiCost) error
	VisitAnalysisCost(*AnalysisCost) error
}

func (c *CallCostsItem) Accept(visitor CallCostsItemVisitor) error {
	if c.TransportCost != nil {
		return visitor.VisitTransportCost(c.TransportCost)
	}
	if c.TranscriberCost != nil {
		return visitor.VisitTranscriberCost(c.TranscriberCost)
	}
	if c.ModelCost != nil {
		return visitor.VisitModelCost(c.ModelCost)
	}
	if c.VoiceCost != nil {
		return visitor.VisitVoiceCost(c.VoiceCost)
	}
	if c.VapiCost != nil {
		return visitor.VisitVapiCost(c.VapiCost)
	}
	if c.AnalysisCost != nil {
		return visitor.VisitAnalysisCost(c.AnalysisCost)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the destination where the call ended up being transferred to. If the call was not transferred, this will be empty.
type CallDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (c *CallDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CallDestination) MarshalJSON() ([]byte, error) {
	if c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CallDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *CallDestination) Accept(visitor CallDestinationVisitor) error {
	if c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the explanation for how the call ended.
type CallEndedReason string

const (
	CallEndedReasonAssistantError                                                          CallEndedReason = "assistant-error"
	CallEndedReasonAssistantNotFound                                                       CallEndedReason = "assistant-not-found"
	CallEndedReasonDbError                                                                 CallEndedReason = "db-error"
	CallEndedReasonNoServerAvailable                                                       CallEndedReason = "no-server-available"
	CallEndedReasonLicenseCheckFailed                                                      CallEndedReason = "license-check-failed"
	CallEndedReasonPipelineErrorOpenaiLlmFailed                                            CallEndedReason = "pipeline-error-openai-llm-failed"
	CallEndedReasonPipelineErrorAzureOpenaiLlmFailed                                       CallEndedReason = "pipeline-error-azure-openai-llm-failed"
	CallEndedReasonPipelineErrorGroqLlmFailed                                              CallEndedReason = "pipeline-error-groq-llm-failed"
	CallEndedReasonPipelineErrorAnthropicLlmFailed                                         CallEndedReason = "pipeline-error-anthropic-llm-failed"
	CallEndedReasonPipelineErrorVapiLlmFailed                                              CallEndedReason = "pipeline-error-vapi-llm-failed"
	CallEndedReasonPipelineErrorVapi400BadRequestValidationFailed                          CallEndedReason = "pipeline-error-vapi-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorVapi401Unauthorized                                        CallEndedReason = "pipeline-error-vapi-401-unauthorized"
	CallEndedReasonPipelineErrorVapi403ModelAccessDenied                                   CallEndedReason = "pipeline-error-vapi-403-model-access-denied"
	CallEndedReasonPipelineErrorVapi429ExceededQuota                                       CallEndedReason = "pipeline-error-vapi-429-exceeded-quota"
	CallEndedReasonPipelineErrorVapi500ServerError                                         CallEndedReason = "pipeline-error-vapi-500-server-error"
	CallEndedReasonPipelineErrorOpenaiVoiceFailed                                          CallEndedReason = "pipeline-error-openai-voice-failed"
	CallEndedReasonPipelineErrorCartesiaVoiceFailed                                        CallEndedReason = "pipeline-error-cartesia-voice-failed"
	CallEndedReasonPipelineErrorDeepgramTranscriberFailed                                  CallEndedReason = "pipeline-error-deepgram-transcriber-failed"
	CallEndedReasonPipelineErrorDeepgramVoiceFailed                                        CallEndedReason = "pipeline-error-deepgram-voice-failed"
	CallEndedReasonPipelineErrorGladiaTranscriberFailed                                    CallEndedReason = "pipeline-error-gladia-transcriber-failed"
	CallEndedReasonPipelineErrorElevenLabsVoiceFailed                                      CallEndedReason = "pipeline-error-eleven-labs-voice-failed"
	CallEndedReasonPipelineErrorPlayhtVoiceFailed                                          CallEndedReason = "pipeline-error-playht-voice-failed"
	CallEndedReasonPipelineErrorLmntVoiceFailed                                            CallEndedReason = "pipeline-error-lmnt-voice-failed"
	CallEndedReasonPipelineErrorAzureVoiceFailed                                           CallEndedReason = "pipeline-error-azure-voice-failed"
	CallEndedReasonPipelineErrorRimeAiVoiceFailed                                          CallEndedReason = "pipeline-error-rime-ai-voice-failed"
	CallEndedReasonPipelineErrorNeetsVoiceFailed                                           CallEndedReason = "pipeline-error-neets-voice-failed"
	CallEndedReasonPipelineNoAvailableModel                                                CallEndedReason = "pipeline-no-available-model"
	CallEndedReasonWorkerShutdown                                                          CallEndedReason = "worker-shutdown"
	CallEndedReasonUnknownError                                                            CallEndedReason = "unknown-error"
	CallEndedReasonVonageDisconnected                                                      CallEndedReason = "vonage-disconnected"
	CallEndedReasonVonageFailedToConnectCall                                               CallEndedReason = "vonage-failed-to-connect-call"
	CallEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived                         CallEndedReason = "phone-call-provider-bypass-enabled-but-no-call-received"
	CallEndedReasonVapifaultPhoneCallWorkerSetupSocketError                                CallEndedReason = "vapifault-phone-call-worker-setup-socket-error"
	CallEndedReasonVapifaultPhoneCallWorkerWorkerSetupSocketTimeout                        CallEndedReason = "vapifault-phone-call-worker-worker-setup-socket-timeout"
	CallEndedReasonVapifaultPhoneCallWorkerCouldNotFindCall                                CallEndedReason = "vapifault-phone-call-worker-could-not-find-call"
	CallEndedReasonVapifaultTransportNeverConnected                                        CallEndedReason = "vapifault-transport-never-connected"
	CallEndedReasonVapifaultWebCallWorkerSetupFailed                                       CallEndedReason = "vapifault-web-call-worker-setup-failed"
	CallEndedReasonVapifaultTransportConnectedButCallNotActive                             CallEndedReason = "vapifault-transport-connected-but-call-not-active"
	CallEndedReasonAssistantNotInvalid                                                     CallEndedReason = "assistant-not-invalid"
	CallEndedReasonAssistantNotProvided                                                    CallEndedReason = "assistant-not-provided"
	CallEndedReasonCallStartErrorNeitherAssistantNorServerSet                              CallEndedReason = "call-start-error-neither-assistant-nor-server-set"
	CallEndedReasonAssistantRequestFailed                                                  CallEndedReason = "assistant-request-failed"
	CallEndedReasonAssistantRequestReturnedError                                           CallEndedReason = "assistant-request-returned-error"
	CallEndedReasonAssistantRequestReturnedUnspeakableError                                CallEndedReason = "assistant-request-returned-unspeakable-error"
	CallEndedReasonAssistantRequestReturnedInvalidAssistant                                CallEndedReason = "assistant-request-returned-invalid-assistant"
	CallEndedReasonAssistantRequestReturnedNoAssistant                                     CallEndedReason = "assistant-request-returned-no-assistant"
	CallEndedReasonAssistantRequestReturnedForwardingPhoneNumber                           CallEndedReason = "assistant-request-returned-forwarding-phone-number"
	CallEndedReasonAssistantEndedCall                                                      CallEndedReason = "assistant-ended-call"
	CallEndedReasonAssistantSaidEndCallPhrase                                              CallEndedReason = "assistant-said-end-call-phrase"
	CallEndedReasonAssistantForwardedCall                                                  CallEndedReason = "assistant-forwarded-call"
	CallEndedReasonAssistantJoinTimedOut                                                   CallEndedReason = "assistant-join-timed-out"
	CallEndedReasonCustomerBusy                                                            CallEndedReason = "customer-busy"
	CallEndedReasonCustomerEndedCall                                                       CallEndedReason = "customer-ended-call"
	CallEndedReasonCustomerDidNotAnswer                                                    CallEndedReason = "customer-did-not-answer"
	CallEndedReasonCustomerDidNotGiveMicrophonePermission                                  CallEndedReason = "customer-did-not-give-microphone-permission"
	CallEndedReasonAssistantSaidMessageWithEndCallEnabled                                  CallEndedReason = "assistant-said-message-with-end-call-enabled"
	CallEndedReasonExceededMaxDuration                                                     CallEndedReason = "exceeded-max-duration"
	CallEndedReasonManuallyCanceled                                                        CallEndedReason = "manually-canceled"
	CallEndedReasonPhoneCallProviderClosedWebsocket                                        CallEndedReason = "phone-call-provider-closed-websocket"
	CallEndedReasonPipelineErrorOpenai400BadRequestValidationFailed                        CallEndedReason = "pipeline-error-openai-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorOpenai401Unauthorized                                      CallEndedReason = "pipeline-error-openai-401-unauthorized"
	CallEndedReasonPipelineErrorOpenai403ModelAccessDenied                                 CallEndedReason = "pipeline-error-openai-403-model-access-denied"
	CallEndedReasonPipelineErrorOpenai429ExceededQuota                                     CallEndedReason = "pipeline-error-openai-429-exceeded-quota"
	CallEndedReasonPipelineErrorOpenai500ServerError                                       CallEndedReason = "pipeline-error-openai-500-server-error"
	CallEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed                   CallEndedReason = "pipeline-error-azure-openai-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorAzureOpenai401Unauthorized                                 CallEndedReason = "pipeline-error-azure-openai-401-unauthorized"
	CallEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied                            CallEndedReason = "pipeline-error-azure-openai-403-model-access-denied"
	CallEndedReasonPipelineErrorAzureOpenai429ExceededQuota                                CallEndedReason = "pipeline-error-azure-openai-429-exceeded-quota"
	CallEndedReasonPipelineErrorAzureOpenai500ServerError                                  CallEndedReason = "pipeline-error-azure-openai-500-server-error"
	CallEndedReasonPipelineErrorGroq400BadRequestValidationFailed                          CallEndedReason = "pipeline-error-groq-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorGroq401Unauthorized                                        CallEndedReason = "pipeline-error-groq-401-unauthorized"
	CallEndedReasonPipelineErrorGroq403ModelAccessDenied                                   CallEndedReason = "pipeline-error-groq-403-model-access-denied"
	CallEndedReasonPipelineErrorGroq429ExceededQuota                                       CallEndedReason = "pipeline-error-groq-429-exceeded-quota"
	CallEndedReasonPipelineErrorGroq500ServerError                                         CallEndedReason = "pipeline-error-groq-500-server-error"
	CallEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed                     CallEndedReason = "pipeline-error-anthropic-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorAnthropic401Unauthorized                                   CallEndedReason = "pipeline-error-anthropic-401-unauthorized"
	CallEndedReasonPipelineErrorAnthropic403ModelAccessDenied                              CallEndedReason = "pipeline-error-anthropic-403-model-access-denied"
	CallEndedReasonPipelineErrorAnthropic429ExceededQuota                                  CallEndedReason = "pipeline-error-anthropic-429-exceeded-quota"
	CallEndedReasonPipelineErrorAnthropic500ServerError                                    CallEndedReason = "pipeline-error-anthropic-500-server-error"
	CallEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed                    CallEndedReason = "pipeline-error-together-ai-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorTogetherAi401Unauthorized                                  CallEndedReason = "pipeline-error-together-ai-401-unauthorized"
	CallEndedReasonPipelineErrorTogetherAi403ModelAccessDenied                             CallEndedReason = "pipeline-error-together-ai-403-model-access-denied"
	CallEndedReasonPipelineErrorTogetherAi429ExceededQuota                                 CallEndedReason = "pipeline-error-together-ai-429-exceeded-quota"
	CallEndedReasonPipelineErrorTogetherAi500ServerError                                   CallEndedReason = "pipeline-error-together-ai-500-server-error"
	CallEndedReasonPipelineErrorTogetherAiLlmFailed                                        CallEndedReason = "pipeline-error-together-ai-llm-failed"
	CallEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed                      CallEndedReason = "pipeline-error-anyscale-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorAnyscale401Unauthorized                                    CallEndedReason = "pipeline-error-anyscale-401-unauthorized"
	CallEndedReasonPipelineErrorAnyscale403ModelAccessDenied                               CallEndedReason = "pipeline-error-anyscale-403-model-access-denied"
	CallEndedReasonPipelineErrorAnyscale429ExceededQuota                                   CallEndedReason = "pipeline-error-anyscale-429-exceeded-quota"
	CallEndedReasonPipelineErrorAnyscale500ServerError                                     CallEndedReason = "pipeline-error-anyscale-500-server-error"
	CallEndedReasonPipelineErrorAnyscaleLlmFailed                                          CallEndedReason = "pipeline-error-anyscale-llm-failed"
	CallEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed                    CallEndedReason = "pipeline-error-openrouter-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorOpenrouter401Unauthorized                                  CallEndedReason = "pipeline-error-openrouter-401-unauthorized"
	CallEndedReasonPipelineErrorOpenrouter403ModelAccessDenied                             CallEndedReason = "pipeline-error-openrouter-403-model-access-denied"
	CallEndedReasonPipelineErrorOpenrouter429ExceededQuota                                 CallEndedReason = "pipeline-error-openrouter-429-exceeded-quota"
	CallEndedReasonPipelineErrorOpenrouter500ServerError                                   CallEndedReason = "pipeline-error-openrouter-500-server-error"
	CallEndedReasonPipelineErrorOpenrouterLlmFailed                                        CallEndedReason = "pipeline-error-openrouter-llm-failed"
	CallEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed                  CallEndedReason = "pipeline-error-perplexity-ai-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorPerplexityAi401Unauthorized                                CallEndedReason = "pipeline-error-perplexity-ai-401-unauthorized"
	CallEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied                           CallEndedReason = "pipeline-error-perplexity-ai-403-model-access-denied"
	CallEndedReasonPipelineErrorPerplexityAi429ExceededQuota                               CallEndedReason = "pipeline-error-perplexity-ai-429-exceeded-quota"
	CallEndedReasonPipelineErrorPerplexityAi500ServerError                                 CallEndedReason = "pipeline-error-perplexity-ai-500-server-error"
	CallEndedReasonPipelineErrorPerplexityAiLlmFailed                                      CallEndedReason = "pipeline-error-perplexity-ai-llm-failed"
	CallEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed                     CallEndedReason = "pipeline-error-deepinfra-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorDeepinfra401Unauthorized                                   CallEndedReason = "pipeline-error-deepinfra-401-unauthorized"
	CallEndedReasonPipelineErrorDeepinfra403ModelAccessDenied                              CallEndedReason = "pipeline-error-deepinfra-403-model-access-denied"
	CallEndedReasonPipelineErrorDeepinfra429ExceededQuota                                  CallEndedReason = "pipeline-error-deepinfra-429-exceeded-quota"
	CallEndedReasonPipelineErrorDeepinfra500ServerError                                    CallEndedReason = "pipeline-error-deepinfra-500-server-error"
	CallEndedReasonPipelineErrorDeepinfraLlmFailed                                         CallEndedReason = "pipeline-error-deepinfra-llm-failed"
	CallEndedReasonPipelineErrorRunpod400BadRequestValidationFailed                        CallEndedReason = "pipeline-error-runpod-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorRunpod401Unauthorized                                      CallEndedReason = "pipeline-error-runpod-401-unauthorized"
	CallEndedReasonPipelineErrorRunpod403ModelAccessDenied                                 CallEndedReason = "pipeline-error-runpod-403-model-access-denied"
	CallEndedReasonPipelineErrorRunpod429ExceededQuota                                     CallEndedReason = "pipeline-error-runpod-429-exceeded-quota"
	CallEndedReasonPipelineErrorRunpod500ServerError                                       CallEndedReason = "pipeline-error-runpod-500-server-error"
	CallEndedReasonPipelineErrorRunpodLlmFailed                                            CallEndedReason = "pipeline-error-runpod-llm-failed"
	CallEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed                     CallEndedReason = "pipeline-error-custom-llm-400-bad-request-validation-failed"
	CallEndedReasonPipelineErrorCustomLlm401Unauthorized                                   CallEndedReason = "pipeline-error-custom-llm-401-unauthorized"
	CallEndedReasonPipelineErrorCustomLlm403ModelAccessDenied                              CallEndedReason = "pipeline-error-custom-llm-403-model-access-denied"
	CallEndedReasonPipelineErrorCustomLlm429ExceededQuota                                  CallEndedReason = "pipeline-error-custom-llm-429-exceeded-quota"
	CallEndedReasonPipelineErrorCustomLlm500ServerError                                    CallEndedReason = "pipeline-error-custom-llm-500-server-error"
	CallEndedReasonPipelineErrorCustomLlmLlmFailed                                         CallEndedReason = "pipeline-error-custom-llm-llm-failed"
	CallEndedReasonPipelineErrorCartesiaSocketHangUp                                       CallEndedReason = "pipeline-error-cartesia-socket-hang-up"
	CallEndedReasonPipelineErrorCartesiaRequestedPayment                                   CallEndedReason = "pipeline-error-cartesia-requested-payment"
	CallEndedReasonPipelineErrorCartesia500ServerError                                     CallEndedReason = "pipeline-error-cartesia-500-server-error"
	CallEndedReasonPipelineErrorCartesia503ServerError                                     CallEndedReason = "pipeline-error-cartesia-503-server-error"
	CallEndedReasonPipelineErrorCartesia522ServerError                                     CallEndedReason = "pipeline-error-cartesia-522-server-error"
	CallEndedReasonPipelineErrorCustomVoiceFailed                                          CallEndedReason = "pipeline-error-custom-voice-failed"
	CallEndedReasonPipelineErrorElevenLabsVoiceNotFound                                    CallEndedReason = "pipeline-error-eleven-labs-voice-not-found"
	CallEndedReasonPipelineErrorElevenLabsQuotaExceeded                                    CallEndedReason = "pipeline-error-eleven-labs-quota-exceeded"
	CallEndedReasonPipelineErrorElevenLabsUnauthorizedAccess                               CallEndedReason = "pipeline-error-eleven-labs-unauthorized-access"
	CallEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel                        CallEndedReason = "pipeline-error-eleven-labs-unauthorized-to-access-model"
	CallEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus             CallEndedReason = "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus"
	CallEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade               CallEndedReason = "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade"
	CallEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade     CallEndedReason = "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade"
	CallEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade CallEndedReason = "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade"
	CallEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade                    CallEndedReason = "pipeline-error-eleven-labs-system-busy-and-requested-upgrade"
	CallEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned                                CallEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned"
	CallEndedReasonPipelineErrorElevenLabsInvalidApiKey                                    CallEndedReason = "pipeline-error-eleven-labs-invalid-api-key"
	CallEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples                              CallEndedReason = "pipeline-error-eleven-labs-invalid-voice-samples"
	CallEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner                             CallEndedReason = "pipeline-error-eleven-labs-voice-disabled-by-owner"
	CallEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation                        CallEndedReason = "pipeline-error-eleven-labs-blocked-account-in-probation"
	CallEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy                 CallEndedReason = "pipeline-error-eleven-labs-blocked-content-against-their-policy"
	CallEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone                      CallEndedReason = "pipeline-error-eleven-labs-missing-samples-for-voice-clone"
	CallEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed                 CallEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used"
	CallEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers                      CallEndedReason = "pipeline-error-eleven-labs-voice-not-allowed-for-free-users"
	CallEndedReasonPipelineErrorElevenLabs500ServerError                                   CallEndedReason = "pipeline-error-eleven-labs-500-server-error"
	CallEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded                        CallEndedReason = "pipeline-error-eleven-labs-max-character-limit-exceeded"
	CallEndedReasonPipelineErrorPlayhtRequestTimedOut                                      CallEndedReason = "pipeline-error-playht-request-timed-out"
	CallEndedReasonPipelineErrorPlayhtInvalidVoice                                         CallEndedReason = "pipeline-error-playht-invalid-voice"
	CallEndedReasonPipelineErrorPlayhtUnexpectedError                                      CallEndedReason = "pipeline-error-playht-unexpected-error"
	CallEndedReasonPipelineErrorPlayhtOutOfCredits                                         CallEndedReason = "pipeline-error-playht-out-of-credits"
	CallEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri                    CallEndedReason = "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri"
	CallEndedReasonPipelineErrorPlayht401Unauthorized                                      CallEndedReason = "pipeline-error-playht-401-unauthorized"
	CallEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters                          CallEndedReason = "pipeline-error-playht-403-forbidden-out-of-characters"
	CallEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable                    CallEndedReason = "pipeline-error-playht-403-forbidden-api-access-not-available"
	CallEndedReasonPipelineErrorPlayht429ExceededQuota                                     CallEndedReason = "pipeline-error-playht-429-exceeded-quota"
	CallEndedReasonPipelineErrorPlayht502GatewayError                                      CallEndedReason = "pipeline-error-playht-502-gateway-error"
	CallEndedReasonPipelineErrorPlayht504GatewayError                                      CallEndedReason = "pipeline-error-playht-504-gateway-error"
	CallEndedReasonPipelineErrorDeepgram403ModelAccessDenied                               CallEndedReason = "pipeline-error-deepgram-403-model-access-denied"
	CallEndedReasonPipelineErrorDeepgram404NotFound                                        CallEndedReason = "pipeline-error-deepgram-404-not-found"
	CallEndedReasonPipelineErrorDeepgram400NoSuchModelLanguageTierCombination              CallEndedReason = "pipeline-error-deepgram-400-no-such-model-language-tier-combination"
	CallEndedReasonPipelineErrorDeepgram500ReturningInvalidJson                            CallEndedReason = "pipeline-error-deepgram-500-returning-invalid-json"
	CallEndedReasonSipGatewayFailedToConnectCall                                           CallEndedReason = "sip-gateway-failed-to-connect-call"
	CallEndedReasonSilenceTimedOut                                                         CallEndedReason = "silence-timed-out"
	CallEndedReasonTwilioFailedToConnectCall                                               CallEndedReason = "twilio-failed-to-connect-call"
	CallEndedReasonTwilioReportedCustomerMisdialed                                         CallEndedReason = "twilio-reported-customer-misdialed"
	CallEndedReasonVoicemail                                                               CallEndedReason = "voicemail"
	CallEndedReasonVonageRejected                                                          CallEndedReason = "vonage-rejected"
)

func NewCallEndedReasonFromString(s string) (CallEndedReason, error) {
	switch s {
	case "assistant-error":
		return CallEndedReasonAssistantError, nil
	case "assistant-not-found":
		return CallEndedReasonAssistantNotFound, nil
	case "db-error":
		return CallEndedReasonDbError, nil
	case "no-server-available":
		return CallEndedReasonNoServerAvailable, nil
	case "license-check-failed":
		return CallEndedReasonLicenseCheckFailed, nil
	case "pipeline-error-openai-llm-failed":
		return CallEndedReasonPipelineErrorOpenaiLlmFailed, nil
	case "pipeline-error-azure-openai-llm-failed":
		return CallEndedReasonPipelineErrorAzureOpenaiLlmFailed, nil
	case "pipeline-error-groq-llm-failed":
		return CallEndedReasonPipelineErrorGroqLlmFailed, nil
	case "pipeline-error-anthropic-llm-failed":
		return CallEndedReasonPipelineErrorAnthropicLlmFailed, nil
	case "pipeline-error-vapi-llm-failed":
		return CallEndedReasonPipelineErrorVapiLlmFailed, nil
	case "pipeline-error-vapi-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorVapi400BadRequestValidationFailed, nil
	case "pipeline-error-vapi-401-unauthorized":
		return CallEndedReasonPipelineErrorVapi401Unauthorized, nil
	case "pipeline-error-vapi-403-model-access-denied":
		return CallEndedReasonPipelineErrorVapi403ModelAccessDenied, nil
	case "pipeline-error-vapi-429-exceeded-quota":
		return CallEndedReasonPipelineErrorVapi429ExceededQuota, nil
	case "pipeline-error-vapi-500-server-error":
		return CallEndedReasonPipelineErrorVapi500ServerError, nil
	case "pipeline-error-openai-voice-failed":
		return CallEndedReasonPipelineErrorOpenaiVoiceFailed, nil
	case "pipeline-error-cartesia-voice-failed":
		return CallEndedReasonPipelineErrorCartesiaVoiceFailed, nil
	case "pipeline-error-deepgram-transcriber-failed":
		return CallEndedReasonPipelineErrorDeepgramTranscriberFailed, nil
	case "pipeline-error-deepgram-voice-failed":
		return CallEndedReasonPipelineErrorDeepgramVoiceFailed, nil
	case "pipeline-error-gladia-transcriber-failed":
		return CallEndedReasonPipelineErrorGladiaTranscriberFailed, nil
	case "pipeline-error-eleven-labs-voice-failed":
		return CallEndedReasonPipelineErrorElevenLabsVoiceFailed, nil
	case "pipeline-error-playht-voice-failed":
		return CallEndedReasonPipelineErrorPlayhtVoiceFailed, nil
	case "pipeline-error-lmnt-voice-failed":
		return CallEndedReasonPipelineErrorLmntVoiceFailed, nil
	case "pipeline-error-azure-voice-failed":
		return CallEndedReasonPipelineErrorAzureVoiceFailed, nil
	case "pipeline-error-rime-ai-voice-failed":
		return CallEndedReasonPipelineErrorRimeAiVoiceFailed, nil
	case "pipeline-error-neets-voice-failed":
		return CallEndedReasonPipelineErrorNeetsVoiceFailed, nil
	case "pipeline-no-available-model":
		return CallEndedReasonPipelineNoAvailableModel, nil
	case "worker-shutdown":
		return CallEndedReasonWorkerShutdown, nil
	case "unknown-error":
		return CallEndedReasonUnknownError, nil
	case "vonage-disconnected":
		return CallEndedReasonVonageDisconnected, nil
	case "vonage-failed-to-connect-call":
		return CallEndedReasonVonageFailedToConnectCall, nil
	case "phone-call-provider-bypass-enabled-but-no-call-received":
		return CallEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived, nil
	case "vapifault-phone-call-worker-setup-socket-error":
		return CallEndedReasonVapifaultPhoneCallWorkerSetupSocketError, nil
	case "vapifault-phone-call-worker-worker-setup-socket-timeout":
		return CallEndedReasonVapifaultPhoneCallWorkerWorkerSetupSocketTimeout, nil
	case "vapifault-phone-call-worker-could-not-find-call":
		return CallEndedReasonVapifaultPhoneCallWorkerCouldNotFindCall, nil
	case "vapifault-transport-never-connected":
		return CallEndedReasonVapifaultTransportNeverConnected, nil
	case "vapifault-web-call-worker-setup-failed":
		return CallEndedReasonVapifaultWebCallWorkerSetupFailed, nil
	case "vapifault-transport-connected-but-call-not-active":
		return CallEndedReasonVapifaultTransportConnectedButCallNotActive, nil
	case "assistant-not-invalid":
		return CallEndedReasonAssistantNotInvalid, nil
	case "assistant-not-provided":
		return CallEndedReasonAssistantNotProvided, nil
	case "call-start-error-neither-assistant-nor-server-set":
		return CallEndedReasonCallStartErrorNeitherAssistantNorServerSet, nil
	case "assistant-request-failed":
		return CallEndedReasonAssistantRequestFailed, nil
	case "assistant-request-returned-error":
		return CallEndedReasonAssistantRequestReturnedError, nil
	case "assistant-request-returned-unspeakable-error":
		return CallEndedReasonAssistantRequestReturnedUnspeakableError, nil
	case "assistant-request-returned-invalid-assistant":
		return CallEndedReasonAssistantRequestReturnedInvalidAssistant, nil
	case "assistant-request-returned-no-assistant":
		return CallEndedReasonAssistantRequestReturnedNoAssistant, nil
	case "assistant-request-returned-forwarding-phone-number":
		return CallEndedReasonAssistantRequestReturnedForwardingPhoneNumber, nil
	case "assistant-ended-call":
		return CallEndedReasonAssistantEndedCall, nil
	case "assistant-said-end-call-phrase":
		return CallEndedReasonAssistantSaidEndCallPhrase, nil
	case "assistant-forwarded-call":
		return CallEndedReasonAssistantForwardedCall, nil
	case "assistant-join-timed-out":
		return CallEndedReasonAssistantJoinTimedOut, nil
	case "customer-busy":
		return CallEndedReasonCustomerBusy, nil
	case "customer-ended-call":
		return CallEndedReasonCustomerEndedCall, nil
	case "customer-did-not-answer":
		return CallEndedReasonCustomerDidNotAnswer, nil
	case "customer-did-not-give-microphone-permission":
		return CallEndedReasonCustomerDidNotGiveMicrophonePermission, nil
	case "assistant-said-message-with-end-call-enabled":
		return CallEndedReasonAssistantSaidMessageWithEndCallEnabled, nil
	case "exceeded-max-duration":
		return CallEndedReasonExceededMaxDuration, nil
	case "manually-canceled":
		return CallEndedReasonManuallyCanceled, nil
	case "phone-call-provider-closed-websocket":
		return CallEndedReasonPhoneCallProviderClosedWebsocket, nil
	case "pipeline-error-openai-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-openai-401-unauthorized":
		return CallEndedReasonPipelineErrorOpenai401Unauthorized, nil
	case "pipeline-error-openai-403-model-access-denied":
		return CallEndedReasonPipelineErrorOpenai403ModelAccessDenied, nil
	case "pipeline-error-openai-429-exceeded-quota":
		return CallEndedReasonPipelineErrorOpenai429ExceededQuota, nil
	case "pipeline-error-openai-500-server-error":
		return CallEndedReasonPipelineErrorOpenai500ServerError, nil
	case "pipeline-error-azure-openai-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-azure-openai-401-unauthorized":
		return CallEndedReasonPipelineErrorAzureOpenai401Unauthorized, nil
	case "pipeline-error-azure-openai-403-model-access-denied":
		return CallEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied, nil
	case "pipeline-error-azure-openai-429-exceeded-quota":
		return CallEndedReasonPipelineErrorAzureOpenai429ExceededQuota, nil
	case "pipeline-error-azure-openai-500-server-error":
		return CallEndedReasonPipelineErrorAzureOpenai500ServerError, nil
	case "pipeline-error-groq-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorGroq400BadRequestValidationFailed, nil
	case "pipeline-error-groq-401-unauthorized":
		return CallEndedReasonPipelineErrorGroq401Unauthorized, nil
	case "pipeline-error-groq-403-model-access-denied":
		return CallEndedReasonPipelineErrorGroq403ModelAccessDenied, nil
	case "pipeline-error-groq-429-exceeded-quota":
		return CallEndedReasonPipelineErrorGroq429ExceededQuota, nil
	case "pipeline-error-groq-500-server-error":
		return CallEndedReasonPipelineErrorGroq500ServerError, nil
	case "pipeline-error-anthropic-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-401-unauthorized":
		return CallEndedReasonPipelineErrorAnthropic401Unauthorized, nil
	case "pipeline-error-anthropic-403-model-access-denied":
		return CallEndedReasonPipelineErrorAnthropic403ModelAccessDenied, nil
	case "pipeline-error-anthropic-429-exceeded-quota":
		return CallEndedReasonPipelineErrorAnthropic429ExceededQuota, nil
	case "pipeline-error-anthropic-500-server-error":
		return CallEndedReasonPipelineErrorAnthropic500ServerError, nil
	case "pipeline-error-together-ai-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed, nil
	case "pipeline-error-together-ai-401-unauthorized":
		return CallEndedReasonPipelineErrorTogetherAi401Unauthorized, nil
	case "pipeline-error-together-ai-403-model-access-denied":
		return CallEndedReasonPipelineErrorTogetherAi403ModelAccessDenied, nil
	case "pipeline-error-together-ai-429-exceeded-quota":
		return CallEndedReasonPipelineErrorTogetherAi429ExceededQuota, nil
	case "pipeline-error-together-ai-500-server-error":
		return CallEndedReasonPipelineErrorTogetherAi500ServerError, nil
	case "pipeline-error-together-ai-llm-failed":
		return CallEndedReasonPipelineErrorTogetherAiLlmFailed, nil
	case "pipeline-error-anyscale-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed, nil
	case "pipeline-error-anyscale-401-unauthorized":
		return CallEndedReasonPipelineErrorAnyscale401Unauthorized, nil
	case "pipeline-error-anyscale-403-model-access-denied":
		return CallEndedReasonPipelineErrorAnyscale403ModelAccessDenied, nil
	case "pipeline-error-anyscale-429-exceeded-quota":
		return CallEndedReasonPipelineErrorAnyscale429ExceededQuota, nil
	case "pipeline-error-anyscale-500-server-error":
		return CallEndedReasonPipelineErrorAnyscale500ServerError, nil
	case "pipeline-error-anyscale-llm-failed":
		return CallEndedReasonPipelineErrorAnyscaleLlmFailed, nil
	case "pipeline-error-openrouter-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed, nil
	case "pipeline-error-openrouter-401-unauthorized":
		return CallEndedReasonPipelineErrorOpenrouter401Unauthorized, nil
	case "pipeline-error-openrouter-403-model-access-denied":
		return CallEndedReasonPipelineErrorOpenrouter403ModelAccessDenied, nil
	case "pipeline-error-openrouter-429-exceeded-quota":
		return CallEndedReasonPipelineErrorOpenrouter429ExceededQuota, nil
	case "pipeline-error-openrouter-500-server-error":
		return CallEndedReasonPipelineErrorOpenrouter500ServerError, nil
	case "pipeline-error-openrouter-llm-failed":
		return CallEndedReasonPipelineErrorOpenrouterLlmFailed, nil
	case "pipeline-error-perplexity-ai-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed, nil
	case "pipeline-error-perplexity-ai-401-unauthorized":
		return CallEndedReasonPipelineErrorPerplexityAi401Unauthorized, nil
	case "pipeline-error-perplexity-ai-403-model-access-denied":
		return CallEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied, nil
	case "pipeline-error-perplexity-ai-429-exceeded-quota":
		return CallEndedReasonPipelineErrorPerplexityAi429ExceededQuota, nil
	case "pipeline-error-perplexity-ai-500-server-error":
		return CallEndedReasonPipelineErrorPerplexityAi500ServerError, nil
	case "pipeline-error-perplexity-ai-llm-failed":
		return CallEndedReasonPipelineErrorPerplexityAiLlmFailed, nil
	case "pipeline-error-deepinfra-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed, nil
	case "pipeline-error-deepinfra-401-unauthorized":
		return CallEndedReasonPipelineErrorDeepinfra401Unauthorized, nil
	case "pipeline-error-deepinfra-403-model-access-denied":
		return CallEndedReasonPipelineErrorDeepinfra403ModelAccessDenied, nil
	case "pipeline-error-deepinfra-429-exceeded-quota":
		return CallEndedReasonPipelineErrorDeepinfra429ExceededQuota, nil
	case "pipeline-error-deepinfra-500-server-error":
		return CallEndedReasonPipelineErrorDeepinfra500ServerError, nil
	case "pipeline-error-deepinfra-llm-failed":
		return CallEndedReasonPipelineErrorDeepinfraLlmFailed, nil
	case "pipeline-error-runpod-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorRunpod400BadRequestValidationFailed, nil
	case "pipeline-error-runpod-401-unauthorized":
		return CallEndedReasonPipelineErrorRunpod401Unauthorized, nil
	case "pipeline-error-runpod-403-model-access-denied":
		return CallEndedReasonPipelineErrorRunpod403ModelAccessDenied, nil
	case "pipeline-error-runpod-429-exceeded-quota":
		return CallEndedReasonPipelineErrorRunpod429ExceededQuota, nil
	case "pipeline-error-runpod-500-server-error":
		return CallEndedReasonPipelineErrorRunpod500ServerError, nil
	case "pipeline-error-runpod-llm-failed":
		return CallEndedReasonPipelineErrorRunpodLlmFailed, nil
	case "pipeline-error-custom-llm-400-bad-request-validation-failed":
		return CallEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed, nil
	case "pipeline-error-custom-llm-401-unauthorized":
		return CallEndedReasonPipelineErrorCustomLlm401Unauthorized, nil
	case "pipeline-error-custom-llm-403-model-access-denied":
		return CallEndedReasonPipelineErrorCustomLlm403ModelAccessDenied, nil
	case "pipeline-error-custom-llm-429-exceeded-quota":
		return CallEndedReasonPipelineErrorCustomLlm429ExceededQuota, nil
	case "pipeline-error-custom-llm-500-server-error":
		return CallEndedReasonPipelineErrorCustomLlm500ServerError, nil
	case "pipeline-error-custom-llm-llm-failed":
		return CallEndedReasonPipelineErrorCustomLlmLlmFailed, nil
	case "pipeline-error-cartesia-socket-hang-up":
		return CallEndedReasonPipelineErrorCartesiaSocketHangUp, nil
	case "pipeline-error-cartesia-requested-payment":
		return CallEndedReasonPipelineErrorCartesiaRequestedPayment, nil
	case "pipeline-error-cartesia-500-server-error":
		return CallEndedReasonPipelineErrorCartesia500ServerError, nil
	case "pipeline-error-cartesia-503-server-error":
		return CallEndedReasonPipelineErrorCartesia503ServerError, nil
	case "pipeline-error-cartesia-522-server-error":
		return CallEndedReasonPipelineErrorCartesia522ServerError, nil
	case "pipeline-error-custom-voice-failed":
		return CallEndedReasonPipelineErrorCustomVoiceFailed, nil
	case "pipeline-error-eleven-labs-voice-not-found":
		return CallEndedReasonPipelineErrorElevenLabsVoiceNotFound, nil
	case "pipeline-error-eleven-labs-quota-exceeded":
		return CallEndedReasonPipelineErrorElevenLabsQuotaExceeded, nil
	case "pipeline-error-eleven-labs-unauthorized-access":
		return CallEndedReasonPipelineErrorElevenLabsUnauthorizedAccess, nil
	case "pipeline-error-eleven-labs-unauthorized-to-access-model":
		return CallEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel, nil
	case "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus":
		return CallEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus, nil
	case "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade":
		return CallEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade":
		return CallEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade":
		return CallEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-system-busy-and-requested-upgrade":
		return CallEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned":
		return CallEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned, nil
	case "pipeline-error-eleven-labs-invalid-api-key":
		return CallEndedReasonPipelineErrorElevenLabsInvalidApiKey, nil
	case "pipeline-error-eleven-labs-invalid-voice-samples":
		return CallEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples, nil
	case "pipeline-error-eleven-labs-voice-disabled-by-owner":
		return CallEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner, nil
	case "pipeline-error-eleven-labs-blocked-account-in-probation":
		return CallEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation, nil
	case "pipeline-error-eleven-labs-blocked-content-against-their-policy":
		return CallEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy, nil
	case "pipeline-error-eleven-labs-missing-samples-for-voice-clone":
		return CallEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used":
		return CallEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed, nil
	case "pipeline-error-eleven-labs-voice-not-allowed-for-free-users":
		return CallEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers, nil
	case "pipeline-error-eleven-labs-500-server-error":
		return CallEndedReasonPipelineErrorElevenLabs500ServerError, nil
	case "pipeline-error-eleven-labs-max-character-limit-exceeded":
		return CallEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded, nil
	case "pipeline-error-playht-request-timed-out":
		return CallEndedReasonPipelineErrorPlayhtRequestTimedOut, nil
	case "pipeline-error-playht-invalid-voice":
		return CallEndedReasonPipelineErrorPlayhtInvalidVoice, nil
	case "pipeline-error-playht-unexpected-error":
		return CallEndedReasonPipelineErrorPlayhtUnexpectedError, nil
	case "pipeline-error-playht-out-of-credits":
		return CallEndedReasonPipelineErrorPlayhtOutOfCredits, nil
	case "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri":
		return CallEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri, nil
	case "pipeline-error-playht-401-unauthorized":
		return CallEndedReasonPipelineErrorPlayht401Unauthorized, nil
	case "pipeline-error-playht-403-forbidden-out-of-characters":
		return CallEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters, nil
	case "pipeline-error-playht-403-forbidden-api-access-not-available":
		return CallEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable, nil
	case "pipeline-error-playht-429-exceeded-quota":
		return CallEndedReasonPipelineErrorPlayht429ExceededQuota, nil
	case "pipeline-error-playht-502-gateway-error":
		return CallEndedReasonPipelineErrorPlayht502GatewayError, nil
	case "pipeline-error-playht-504-gateway-error":
		return CallEndedReasonPipelineErrorPlayht504GatewayError, nil
	case "pipeline-error-deepgram-403-model-access-denied":
		return CallEndedReasonPipelineErrorDeepgram403ModelAccessDenied, nil
	case "pipeline-error-deepgram-404-not-found":
		return CallEndedReasonPipelineErrorDeepgram404NotFound, nil
	case "pipeline-error-deepgram-400-no-such-model-language-tier-combination":
		return CallEndedReasonPipelineErrorDeepgram400NoSuchModelLanguageTierCombination, nil
	case "pipeline-error-deepgram-500-returning-invalid-json":
		return CallEndedReasonPipelineErrorDeepgram500ReturningInvalidJson, nil
	case "sip-gateway-failed-to-connect-call":
		return CallEndedReasonSipGatewayFailedToConnectCall, nil
	case "silence-timed-out":
		return CallEndedReasonSilenceTimedOut, nil
	case "twilio-failed-to-connect-call":
		return CallEndedReasonTwilioFailedToConnectCall, nil
	case "twilio-reported-customer-misdialed":
		return CallEndedReasonTwilioReportedCustomerMisdialed, nil
	case "voicemail":
		return CallEndedReasonVoicemail, nil
	case "vonage-rejected":
		return CallEndedReasonVonageRejected, nil
	}
	var t CallEndedReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CallEndedReason) Ptr() *CallEndedReason {
	return &c
}

type CallMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage
}

func (c *CallMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		c.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		c.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		c.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CallMessagesItem) MarshalJSON() ([]byte, error) {
	if c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.BotMessage != nil {
		return json.Marshal(c.BotMessage)
	}
	if c.ToolCallMessage != nil {
		return json.Marshal(c.ToolCallMessage)
	}
	if c.ToolCallResultMessage != nil {
		return json.Marshal(c.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CallMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (c *CallMessagesItem) Accept(visitor CallMessagesItemVisitor) error {
	if c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.BotMessage != nil {
		return visitor.VisitBotMessage(c.BotMessage)
	}
	if c.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(c.ToolCallMessage)
	}
	if c.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(c.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CallPaginatedResponse struct {
	Results  []*Call         `json:"results,omitempty" url:"results,omitempty"`
	Metadata *PaginationMeta `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CallPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CallPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CallPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CallPaginatedResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallPaginatedResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the provider of the call.
//
// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
type CallPhoneCallProvider string

const (
	CallPhoneCallProviderTwilio CallPhoneCallProvider = "twilio"
	CallPhoneCallProviderVonage CallPhoneCallProvider = "vonage"
	CallPhoneCallProviderVapi   CallPhoneCallProvider = "vapi"
)

func NewCallPhoneCallProviderFromString(s string) (CallPhoneCallProvider, error) {
	switch s {
	case "twilio":
		return CallPhoneCallProviderTwilio, nil
	case "vonage":
		return CallPhoneCallProviderVonage, nil
	case "vapi":
		return CallPhoneCallProviderVapi, nil
	}
	var t CallPhoneCallProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CallPhoneCallProvider) Ptr() *CallPhoneCallProvider {
	return &c
}

// This is the transport of the phone call.
//
// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
type CallPhoneCallTransport string

const (
	CallPhoneCallTransportSip  CallPhoneCallTransport = "sip"
	CallPhoneCallTransportPstn CallPhoneCallTransport = "pstn"
)

func NewCallPhoneCallTransportFromString(s string) (CallPhoneCallTransport, error) {
	switch s {
	case "sip":
		return CallPhoneCallTransportSip, nil
	case "pstn":
		return CallPhoneCallTransportPstn, nil
	}
	var t CallPhoneCallTransport
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CallPhoneCallTransport) Ptr() *CallPhoneCallTransport {
	return &c
}

// This is the status of the call.
type CallStatus string

const (
	CallStatusQueued     CallStatus = "queued"
	CallStatusRinging    CallStatus = "ringing"
	CallStatusInProgress CallStatus = "in-progress"
	CallStatusForwarding CallStatus = "forwarding"
	CallStatusEnded      CallStatus = "ended"
)

func NewCallStatusFromString(s string) (CallStatus, error) {
	switch s {
	case "queued":
		return CallStatusQueued, nil
	case "ringing":
		return CallStatusRinging, nil
	case "in-progress":
		return CallStatusInProgress, nil
	case "forwarding":
		return CallStatusForwarding, nil
	case "ended":
		return CallStatusEnded, nil
	}
	var t CallStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CallStatus) Ptr() *CallStatus {
	return &c
}

// This is the type of call.
type CallType string

const (
	CallTypeInboundPhoneCall  CallType = "inboundPhoneCall"
	CallTypeOutboundPhoneCall CallType = "outboundPhoneCall"
	CallTypeWebCall           CallType = "webCall"
)

func NewCallTypeFromString(s string) (CallType, error) {
	switch s {
	case "inboundPhoneCall":
		return CallTypeInboundPhoneCall, nil
	case "outboundPhoneCall":
		return CallTypeOutboundPhoneCall, nil
	case "webCall":
		return CallTypeWebCall, nil
	}
	var t CallType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CallType) Ptr() *CallType {
	return &c
}

type CallbackStep struct {
	// This is the block to use. To use an existing block, use `blockId`.
	Block *CallbackStepBlock `json:"block,omitempty" url:"block,omitempty"`
	// This is a step that calls back to the previous step after it's done. This effectively means we're spawning a new conversation thread. The previous conversation thread will resume where it left off once this step is done.
	//
	// Use case:
	//
	// - You are collecting a customer's order and while they were on one item, they start a new item or try to modify a previous one. You would make a OrderUpdate block which calls the same block repeatedly when a new update starts.
	// This is the mutations to apply to the context after the step is done.
	Mutations []*AssignmentMutation `json:"mutations,omitempty" url:"mutations,omitempty"`
	// This is the name of the step.
	Name string `json:"name" url:"name"`
	// This is the id of the block to use. To use a transient block, use `block`.
	BlockId *string `json:"blockId,omitempty" url:"blockId,omitempty"`
	// This is the input to the block. You can use any key-value map as input to the block.
	//
	// Example:
	// {
	// "name": "John Doe",
	// "age": 20
	// }
	//
	// You can reference any variable in the context of the current block:
	//
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// Example:
	// {
	// "name": "{{my-tool-call-step.output.name}}",
	// "age": "{{my-tool-call-step.input.age}}",
	// "date": "{{workflow.input.date}}"
	// }
	//
	// You can dynamically change the key name.
	//
	// Example:
	// {
	// "{{my-tool-call-step.output.key-name-for-name}}": "{{name}}",
	// "{{my-tool-call-step.input.key-name-for-age}}": "{{age}}",
	// "{{workflow.input.key-name-for-date}}": "{{date}}"
	// }
	//
	// You can represent the value as a string, number, boolean, array, or object.
	//
	// Example:
	// {
	// "name": "john",
	// "age": 20,
	// "date": "2021-01-01",
	// "metadata": {
	// "unique-key": "{{my-tool-call-step.output.unique-key}}"
	// },
	// "array": ["A", "B", "C"],
	// }
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow.
	Input map[string]interface{} `json:"input,omitempty" url:"input,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CallbackStep) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CallbackStep) Type() string {
	return c.type_
}

func (c *CallbackStep) UnmarshalJSON(data []byte) error {
	type embed CallbackStep
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CallbackStep(unmarshaler.embed)
	if unmarshaler.Type != "callback" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "callback", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallbackStep) MarshalJSON() ([]byte, error) {
	type embed CallbackStep
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "callback",
	}
	return json.Marshal(marshaler)
}

func (c *CallbackStep) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the block to use. To use an existing block, use `blockId`.
type CallbackStepBlock struct {
	CreateConversationBlockDto *CreateConversationBlockDto
	CreateToolCallBlockDto     *CreateToolCallBlockDto
	// This is the CreateWorkflowBlockDTO object but Swagger does not display nested schemas correctly.
	CreateWorkflowBlockDto *CreateWorkflowBlockDto
}

func (c *CallbackStepBlock) UnmarshalJSON(data []byte) error {
	valueCreateConversationBlockDto := new(CreateConversationBlockDto)
	if err := json.Unmarshal(data, &valueCreateConversationBlockDto); err == nil {
		c.CreateConversationBlockDto = valueCreateConversationBlockDto
		return nil
	}
	valueCreateToolCallBlockDto := new(CreateToolCallBlockDto)
	if err := json.Unmarshal(data, &valueCreateToolCallBlockDto); err == nil {
		c.CreateToolCallBlockDto = valueCreateToolCallBlockDto
		return nil
	}
	valueCreateWorkflowBlockDto := new(CreateWorkflowBlockDto)
	if err := json.Unmarshal(data, &valueCreateWorkflowBlockDto); err == nil {
		c.CreateWorkflowBlockDto = valueCreateWorkflowBlockDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CallbackStepBlock) MarshalJSON() ([]byte, error) {
	if c.CreateConversationBlockDto != nil {
		return json.Marshal(c.CreateConversationBlockDto)
	}
	if c.CreateToolCallBlockDto != nil {
		return json.Marshal(c.CreateToolCallBlockDto)
	}
	if c.CreateWorkflowBlockDto != nil {
		return json.Marshal(c.CreateWorkflowBlockDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CallbackStepBlockVisitor interface {
	VisitCreateConversationBlockDto(*CreateConversationBlockDto) error
	VisitCreateToolCallBlockDto(*CreateToolCallBlockDto) error
	VisitCreateWorkflowBlockDto(*CreateWorkflowBlockDto) error
}

func (c *CallbackStepBlock) Accept(visitor CallbackStepBlockVisitor) error {
	if c.CreateConversationBlockDto != nil {
		return visitor.VisitCreateConversationBlockDto(c.CreateConversationBlockDto)
	}
	if c.CreateToolCallBlockDto != nil {
		return visitor.VisitCreateToolCallBlockDto(c.CreateToolCallBlockDto)
	}
	if c.CreateWorkflowBlockDto != nil {
		return visitor.VisitCreateWorkflowBlockDto(c.CreateWorkflowBlockDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CartesiaCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CartesiaCredential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CartesiaCredential) Provider() string {
	return c.provider
}

func (c *CartesiaCredential) UnmarshalJSON(data []byte) error {
	type embed CartesiaCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CartesiaCredential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cartesia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CartesiaCredential) MarshalJSON() ([]byte, error) {
	type embed CartesiaCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		Provider:  "cartesia",
	}
	return json.Marshal(marshaler)
}

func (c *CartesiaCredential) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CartesiaVoice struct {
	// This determines whether fillers are injected into the model output before inputting it into the voice provider.
	//
	// Default `false` because you can achieve better results with prompting the model.
	FillerInjectionEnabled *bool `json:"fillerInjectionEnabled,omitempty" url:"fillerInjectionEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the model that will be used. This is optional and will default to the correct model for the voiceId.
	Model *CartesiaVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be used. This is optional and will default to the correct language for the voiceId.
	Language *CartesiaVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the provider-specific ID that will be used.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CartesiaVoice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CartesiaVoice) Provider() string {
	return c.provider
}

func (c *CartesiaVoice) UnmarshalJSON(data []byte) error {
	type embed CartesiaVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CartesiaVoice(unmarshaler.embed)
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cartesia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CartesiaVoice) MarshalJSON() ([]byte, error) {
	type embed CartesiaVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cartesia",
	}
	return json.Marshal(marshaler)
}

func (c *CartesiaVoice) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the language that will be used. This is optional and will default to the correct language for the voiceId.
type CartesiaVoiceLanguage string

const (
	CartesiaVoiceLanguageDe CartesiaVoiceLanguage = "de"
	CartesiaVoiceLanguageEn CartesiaVoiceLanguage = "en"
	CartesiaVoiceLanguageEs CartesiaVoiceLanguage = "es"
	CartesiaVoiceLanguageFr CartesiaVoiceLanguage = "fr"
	CartesiaVoiceLanguageJa CartesiaVoiceLanguage = "ja"
	CartesiaVoiceLanguagePt CartesiaVoiceLanguage = "pt"
	CartesiaVoiceLanguageZh CartesiaVoiceLanguage = "zh"
)

func NewCartesiaVoiceLanguageFromString(s string) (CartesiaVoiceLanguage, error) {
	switch s {
	case "de":
		return CartesiaVoiceLanguageDe, nil
	case "en":
		return CartesiaVoiceLanguageEn, nil
	case "es":
		return CartesiaVoiceLanguageEs, nil
	case "fr":
		return CartesiaVoiceLanguageFr, nil
	case "ja":
		return CartesiaVoiceLanguageJa, nil
	case "pt":
		return CartesiaVoiceLanguagePt, nil
	case "zh":
		return CartesiaVoiceLanguageZh, nil
	}
	var t CartesiaVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CartesiaVoiceLanguage) Ptr() *CartesiaVoiceLanguage {
	return &c
}

// This is the model that will be used. This is optional and will default to the correct model for the voiceId.
type CartesiaVoiceModel string

const (
	CartesiaVoiceModelSonicEnglish      CartesiaVoiceModel = "sonic-english"
	CartesiaVoiceModelSonicMultilingual CartesiaVoiceModel = "sonic-multilingual"
)

func NewCartesiaVoiceModelFromString(s string) (CartesiaVoiceModel, error) {
	switch s {
	case "sonic-english":
		return CartesiaVoiceModelSonicEnglish, nil
	case "sonic-multilingual":
		return CartesiaVoiceModelSonicMultilingual, nil
	}
	var t CartesiaVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CartesiaVoiceModel) Ptr() *CartesiaVoiceModel {
	return &c
}

type ChunkPlan struct {
	// This determines whether the model output is chunked before being sent to the voice provider. Default `true`.
	//
	// Usage:
	//
	// - To rely on the voice provider's audio generation logic, set this to `false`.
	// - If seeing issues with quality, set this to `true`.
	//
	// If disabled, Vapi-provided audio control tokens like <flush /> will not work.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the minimum number of characters in a chunk.
	//
	// Usage:
	//
	// - To increase quality, set this to a higher value.
	// - To decrease latency, set this to a lower value.
	//
	// @default 30
	MinCharacters *float64 `json:"minCharacters,omitempty" url:"minCharacters,omitempty"`
	// These are the punctuations that are considered valid boundaries for a chunk to be created.
	//
	// Usage:
	//
	// - To increase quality, constrain to fewer boundaries.
	// - To decrease latency, enable all.
	//
	// Default is automatically set to balance the trade-off between quality and latency based on the provider.
	PunctuationBoundaries []PunctuationBoundary `json:"punctuationBoundaries,omitempty" url:"punctuationBoundaries,omitempty"`
	// This is the plan for formatting the chunk before it is sent to the voice provider.
	FormatPlan *FormatPlan `json:"formatPlan,omitempty" url:"formatPlan,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChunkPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChunkPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler ChunkPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChunkPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChunkPlan) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessage struct {
	// These are the messages that can be sent from client-side SDKs to control the call.
	Message *ClientInboundMessageMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientInboundMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientInboundMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientInboundMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessageAddMessage struct {
	// This is the type of the message. Send "add-message" message to add a message to the conversation history.
	// This is the message to add to the conversation.
	Message *OpenAiMessage `json:"message,omitempty" url:"message,omitempty"`
	type_   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientInboundMessageAddMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageAddMessage) Type() string {
	return c.type_
}

func (c *ClientInboundMessageAddMessage) UnmarshalJSON(data []byte) error {
	type embed ClientInboundMessageAddMessage
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientInboundMessageAddMessage(unmarshaler.embed)
	if unmarshaler.Type != "add-message" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "add-message", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageAddMessage) MarshalJSON() ([]byte, error) {
	type embed ClientInboundMessageAddMessage
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "add-message",
	}
	return json.Marshal(marshaler)
}

func (c *ClientInboundMessageAddMessage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessageControl struct {
	// This is the type of the message. Send "control" message to control the assistant. `control` options are:
	//
	// - "mute-assistant" - mute the assistant
	// - "unmute-assistant" - unmute the assistant
	// - "say-first-message" - say the first message (this is used when video recording is enabled and the conversation is only started once the client side kicks off the recording)
	// This is the control action
	Control ClientInboundMessageControlControl `json:"control" url:"control"`
	type_   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientInboundMessageControl) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageControl) Type() string {
	return c.type_
}

func (c *ClientInboundMessageControl) UnmarshalJSON(data []byte) error {
	type embed ClientInboundMessageControl
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientInboundMessageControl(unmarshaler.embed)
	if unmarshaler.Type != "control" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "control", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageControl) MarshalJSON() ([]byte, error) {
	type embed ClientInboundMessageControl
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "control",
	}
	return json.Marshal(marshaler)
}

func (c *ClientInboundMessageControl) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the control action
type ClientInboundMessageControlControl string

const (
	ClientInboundMessageControlControlMuteAssistant   ClientInboundMessageControlControl = "mute-assistant"
	ClientInboundMessageControlControlUnmuteAssistant ClientInboundMessageControlControl = "unmute-assistant"
	ClientInboundMessageControlControlSayFirstMessage ClientInboundMessageControlControl = "say-first-message"
)

func NewClientInboundMessageControlControlFromString(s string) (ClientInboundMessageControlControl, error) {
	switch s {
	case "mute-assistant":
		return ClientInboundMessageControlControlMuteAssistant, nil
	case "unmute-assistant":
		return ClientInboundMessageControlControlUnmuteAssistant, nil
	case "say-first-message":
		return ClientInboundMessageControlControlSayFirstMessage, nil
	}
	var t ClientInboundMessageControlControl
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientInboundMessageControlControl) Ptr() *ClientInboundMessageControlControl {
	return &c
}

// These are the messages that can be sent from client-side SDKs to control the call.
type ClientInboundMessageMessage struct {
	ClientInboundMessageAddMessage *ClientInboundMessageAddMessage
	ClientInboundMessageControl    *ClientInboundMessageControl
	ClientInboundMessageSay        *ClientInboundMessageSay
}

func (c *ClientInboundMessageMessage) UnmarshalJSON(data []byte) error {
	valueClientInboundMessageAddMessage := new(ClientInboundMessageAddMessage)
	if err := json.Unmarshal(data, &valueClientInboundMessageAddMessage); err == nil {
		c.ClientInboundMessageAddMessage = valueClientInboundMessageAddMessage
		return nil
	}
	valueClientInboundMessageControl := new(ClientInboundMessageControl)
	if err := json.Unmarshal(data, &valueClientInboundMessageControl); err == nil {
		c.ClientInboundMessageControl = valueClientInboundMessageControl
		return nil
	}
	valueClientInboundMessageSay := new(ClientInboundMessageSay)
	if err := json.Unmarshal(data, &valueClientInboundMessageSay); err == nil {
		c.ClientInboundMessageSay = valueClientInboundMessageSay
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientInboundMessageMessage) MarshalJSON() ([]byte, error) {
	if c.ClientInboundMessageAddMessage != nil {
		return json.Marshal(c.ClientInboundMessageAddMessage)
	}
	if c.ClientInboundMessageControl != nil {
		return json.Marshal(c.ClientInboundMessageControl)
	}
	if c.ClientInboundMessageSay != nil {
		return json.Marshal(c.ClientInboundMessageSay)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientInboundMessageMessageVisitor interface {
	VisitClientInboundMessageAddMessage(*ClientInboundMessageAddMessage) error
	VisitClientInboundMessageControl(*ClientInboundMessageControl) error
	VisitClientInboundMessageSay(*ClientInboundMessageSay) error
}

func (c *ClientInboundMessageMessage) Accept(visitor ClientInboundMessageMessageVisitor) error {
	if c.ClientInboundMessageAddMessage != nil {
		return visitor.VisitClientInboundMessageAddMessage(c.ClientInboundMessageAddMessage)
	}
	if c.ClientInboundMessageControl != nil {
		return visitor.VisitClientInboundMessageControl(c.ClientInboundMessageControl)
	}
	if c.ClientInboundMessageSay != nil {
		return visitor.VisitClientInboundMessageSay(c.ClientInboundMessageSay)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientInboundMessageSay struct {
	// This is the type of the message. Send "say" message to make the assistant say something.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// This is the content to say.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is the flag to end call after content is spoken.
	EndCallAfterSpoken *bool `json:"endCallAfterSpoken,omitempty" url:"endCallAfterSpoken,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientInboundMessageSay) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageSay) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientInboundMessageSay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientInboundMessageSay(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageSay) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessage struct {
	// These are all the messages that can be sent to the client-side SDKs during the call. Configure the messages you'd like to receive in `assistant.clientMessages`.
	Message *ClientMessageMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageConversationUpdate struct {
	// This is the type of the message. "conversation-update" is sent when an update is committed to the conversation history.
	// This is the most up-to-date conversation history at the time the message is sent.
	Messages []*ClientMessageConversationUpdateMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the most up-to-date conversation history at the time the message is sent, formatted for OpenAI.
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	type_                   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageConversationUpdate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageConversationUpdate) Type() string {
	return c.type_
}

func (c *ClientMessageConversationUpdate) UnmarshalJSON(data []byte) error {
	type embed ClientMessageConversationUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageConversationUpdate(unmarshaler.embed)
	if unmarshaler.Type != "conversation-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "conversation-update", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageConversationUpdate) MarshalJSON() ([]byte, error) {
	type embed ClientMessageConversationUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "conversation-update",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageConversationUpdate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageConversationUpdateMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		c.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		c.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		c.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageConversationUpdateMessagesItem) MarshalJSON() ([]byte, error) {
	if c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.BotMessage != nil {
		return json.Marshal(c.BotMessage)
	}
	if c.ToolCallMessage != nil {
		return json.Marshal(c.ToolCallMessage)
	}
	if c.ToolCallResultMessage != nil {
		return json.Marshal(c.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageConversationUpdateMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (c *ClientMessageConversationUpdateMessagesItem) Accept(visitor ClientMessageConversationUpdateMessagesItemVisitor) error {
	if c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.BotMessage != nil {
		return visitor.VisitBotMessage(c.BotMessage)
	}
	if c.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(c.ToolCallMessage)
	}
	if c.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(c.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageHang struct {
	// This is the type of the message. "hang" is sent when the assistant is hanging due to a delay. The delay can be caused by many factors, such as:
	//
	// - the model is too slow to respond
	// - the voice is too slow to respond
	// - the tool call is still waiting for a response from your server
	// - etc.
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageHang) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageHang) Type() string {
	return c.type_
}

func (c *ClientMessageHang) UnmarshalJSON(data []byte) error {
	type embed ClientMessageHang
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageHang(unmarshaler.embed)
	if unmarshaler.Type != "hang" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "hang", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageHang) MarshalJSON() ([]byte, error) {
	type embed ClientMessageHang
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "hang",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageHang) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageLanguageChanged struct {
	// This is the type of the message. "language-switched" is sent when the transcriber is automatically switched based on the detected language.
	// This is the language the transcriber is switched to.
	Language string `json:"language" url:"language"`
	type_    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageLanguageChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageLanguageChanged) Type() string {
	return c.type_
}

func (c *ClientMessageLanguageChanged) UnmarshalJSON(data []byte) error {
	type embed ClientMessageLanguageChanged
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageLanguageChanged(unmarshaler.embed)
	if unmarshaler.Type != "language-changed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "language-changed", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageLanguageChanged) MarshalJSON() ([]byte, error) {
	type embed ClientMessageLanguageChanged
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "language-changed",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageLanguageChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// These are all the messages that can be sent to the client-side SDKs during the call. Configure the messages you'd like to receive in `assistant.clientMessages`.
type ClientMessageMessage struct {
	ClientMessageConversationUpdate *ClientMessageConversationUpdate
	ClientMessageHang               *ClientMessageHang
	ClientMessageMetadata           *ClientMessageMetadata
	ClientMessageModelOutput        *ClientMessageModelOutput
	ClientMessageSpeechUpdate       *ClientMessageSpeechUpdate
	ClientMessageTranscript         *ClientMessageTranscript
	ClientMessageToolCalls          *ClientMessageToolCalls
	ClientMessageToolCallsResult    *ClientMessageToolCallsResult
	ClientMessageUserInterrupted    *ClientMessageUserInterrupted
	ClientMessageLanguageChanged    *ClientMessageLanguageChanged
	ClientMessageVoiceInput         *ClientMessageVoiceInput
}

func (c *ClientMessageMessage) UnmarshalJSON(data []byte) error {
	valueClientMessageConversationUpdate := new(ClientMessageConversationUpdate)
	if err := json.Unmarshal(data, &valueClientMessageConversationUpdate); err == nil {
		c.ClientMessageConversationUpdate = valueClientMessageConversationUpdate
		return nil
	}
	valueClientMessageHang := new(ClientMessageHang)
	if err := json.Unmarshal(data, &valueClientMessageHang); err == nil {
		c.ClientMessageHang = valueClientMessageHang
		return nil
	}
	valueClientMessageMetadata := new(ClientMessageMetadata)
	if err := json.Unmarshal(data, &valueClientMessageMetadata); err == nil {
		c.ClientMessageMetadata = valueClientMessageMetadata
		return nil
	}
	valueClientMessageModelOutput := new(ClientMessageModelOutput)
	if err := json.Unmarshal(data, &valueClientMessageModelOutput); err == nil {
		c.ClientMessageModelOutput = valueClientMessageModelOutput
		return nil
	}
	valueClientMessageSpeechUpdate := new(ClientMessageSpeechUpdate)
	if err := json.Unmarshal(data, &valueClientMessageSpeechUpdate); err == nil {
		c.ClientMessageSpeechUpdate = valueClientMessageSpeechUpdate
		return nil
	}
	valueClientMessageTranscript := new(ClientMessageTranscript)
	if err := json.Unmarshal(data, &valueClientMessageTranscript); err == nil {
		c.ClientMessageTranscript = valueClientMessageTranscript
		return nil
	}
	valueClientMessageToolCalls := new(ClientMessageToolCalls)
	if err := json.Unmarshal(data, &valueClientMessageToolCalls); err == nil {
		c.ClientMessageToolCalls = valueClientMessageToolCalls
		return nil
	}
	valueClientMessageToolCallsResult := new(ClientMessageToolCallsResult)
	if err := json.Unmarshal(data, &valueClientMessageToolCallsResult); err == nil {
		c.ClientMessageToolCallsResult = valueClientMessageToolCallsResult
		return nil
	}
	valueClientMessageUserInterrupted := new(ClientMessageUserInterrupted)
	if err := json.Unmarshal(data, &valueClientMessageUserInterrupted); err == nil {
		c.ClientMessageUserInterrupted = valueClientMessageUserInterrupted
		return nil
	}
	valueClientMessageLanguageChanged := new(ClientMessageLanguageChanged)
	if err := json.Unmarshal(data, &valueClientMessageLanguageChanged); err == nil {
		c.ClientMessageLanguageChanged = valueClientMessageLanguageChanged
		return nil
	}
	valueClientMessageVoiceInput := new(ClientMessageVoiceInput)
	if err := json.Unmarshal(data, &valueClientMessageVoiceInput); err == nil {
		c.ClientMessageVoiceInput = valueClientMessageVoiceInput
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageMessage) MarshalJSON() ([]byte, error) {
	if c.ClientMessageConversationUpdate != nil {
		return json.Marshal(c.ClientMessageConversationUpdate)
	}
	if c.ClientMessageHang != nil {
		return json.Marshal(c.ClientMessageHang)
	}
	if c.ClientMessageMetadata != nil {
		return json.Marshal(c.ClientMessageMetadata)
	}
	if c.ClientMessageModelOutput != nil {
		return json.Marshal(c.ClientMessageModelOutput)
	}
	if c.ClientMessageSpeechUpdate != nil {
		return json.Marshal(c.ClientMessageSpeechUpdate)
	}
	if c.ClientMessageTranscript != nil {
		return json.Marshal(c.ClientMessageTranscript)
	}
	if c.ClientMessageToolCalls != nil {
		return json.Marshal(c.ClientMessageToolCalls)
	}
	if c.ClientMessageToolCallsResult != nil {
		return json.Marshal(c.ClientMessageToolCallsResult)
	}
	if c.ClientMessageUserInterrupted != nil {
		return json.Marshal(c.ClientMessageUserInterrupted)
	}
	if c.ClientMessageLanguageChanged != nil {
		return json.Marshal(c.ClientMessageLanguageChanged)
	}
	if c.ClientMessageVoiceInput != nil {
		return json.Marshal(c.ClientMessageVoiceInput)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageMessageVisitor interface {
	VisitClientMessageConversationUpdate(*ClientMessageConversationUpdate) error
	VisitClientMessageHang(*ClientMessageHang) error
	VisitClientMessageMetadata(*ClientMessageMetadata) error
	VisitClientMessageModelOutput(*ClientMessageModelOutput) error
	VisitClientMessageSpeechUpdate(*ClientMessageSpeechUpdate) error
	VisitClientMessageTranscript(*ClientMessageTranscript) error
	VisitClientMessageToolCalls(*ClientMessageToolCalls) error
	VisitClientMessageToolCallsResult(*ClientMessageToolCallsResult) error
	VisitClientMessageUserInterrupted(*ClientMessageUserInterrupted) error
	VisitClientMessageLanguageChanged(*ClientMessageLanguageChanged) error
	VisitClientMessageVoiceInput(*ClientMessageVoiceInput) error
}

func (c *ClientMessageMessage) Accept(visitor ClientMessageMessageVisitor) error {
	if c.ClientMessageConversationUpdate != nil {
		return visitor.VisitClientMessageConversationUpdate(c.ClientMessageConversationUpdate)
	}
	if c.ClientMessageHang != nil {
		return visitor.VisitClientMessageHang(c.ClientMessageHang)
	}
	if c.ClientMessageMetadata != nil {
		return visitor.VisitClientMessageMetadata(c.ClientMessageMetadata)
	}
	if c.ClientMessageModelOutput != nil {
		return visitor.VisitClientMessageModelOutput(c.ClientMessageModelOutput)
	}
	if c.ClientMessageSpeechUpdate != nil {
		return visitor.VisitClientMessageSpeechUpdate(c.ClientMessageSpeechUpdate)
	}
	if c.ClientMessageTranscript != nil {
		return visitor.VisitClientMessageTranscript(c.ClientMessageTranscript)
	}
	if c.ClientMessageToolCalls != nil {
		return visitor.VisitClientMessageToolCalls(c.ClientMessageToolCalls)
	}
	if c.ClientMessageToolCallsResult != nil {
		return visitor.VisitClientMessageToolCallsResult(c.ClientMessageToolCallsResult)
	}
	if c.ClientMessageUserInterrupted != nil {
		return visitor.VisitClientMessageUserInterrupted(c.ClientMessageUserInterrupted)
	}
	if c.ClientMessageLanguageChanged != nil {
		return visitor.VisitClientMessageLanguageChanged(c.ClientMessageLanguageChanged)
	}
	if c.ClientMessageVoiceInput != nil {
		return visitor.VisitClientMessageVoiceInput(c.ClientMessageVoiceInput)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageMetadata struct {
	// This is the type of the message. "metadata" is sent to forward metadata to the client.
	// This is the metadata content
	Metadata string `json:"metadata" url:"metadata"`
	type_    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageMetadata) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageMetadata) Type() string {
	return c.type_
}

func (c *ClientMessageMetadata) UnmarshalJSON(data []byte) error {
	type embed ClientMessageMetadata
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageMetadata(unmarshaler.embed)
	if unmarshaler.Type != "metadata" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "metadata", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageMetadata) MarshalJSON() ([]byte, error) {
	type embed ClientMessageMetadata
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "metadata",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageMetadata) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageModelOutput struct {
	// This is the type of the message. "model-output" is sent as the model outputs tokens.
	// This is the output of the model. It can be a token or tool call.
	Output map[string]interface{} `json:"output,omitempty" url:"output,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageModelOutput) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageModelOutput) Type() string {
	return c.type_
}

func (c *ClientMessageModelOutput) UnmarshalJSON(data []byte) error {
	type embed ClientMessageModelOutput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageModelOutput(unmarshaler.embed)
	if unmarshaler.Type != "model-output" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "model-output", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageModelOutput) MarshalJSON() ([]byte, error) {
	type embed ClientMessageModelOutput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "model-output",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageModelOutput) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageSpeechUpdate struct {
	// This is the type of the message. "speech-update" is sent whenever assistant or user start or stop speaking.
	// This is the status of the speech update.
	Status ClientMessageSpeechUpdateStatus `json:"status" url:"status"`
	// This is the role which the speech update is for.
	Role  ClientMessageSpeechUpdateRole `json:"role" url:"role"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageSpeechUpdate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageSpeechUpdate) Type() string {
	return c.type_
}

func (c *ClientMessageSpeechUpdate) UnmarshalJSON(data []byte) error {
	type embed ClientMessageSpeechUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageSpeechUpdate(unmarshaler.embed)
	if unmarshaler.Type != "speech-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "speech-update", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageSpeechUpdate) MarshalJSON() ([]byte, error) {
	type embed ClientMessageSpeechUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "speech-update",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageSpeechUpdate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the role which the speech update is for.
type ClientMessageSpeechUpdateRole string

const (
	ClientMessageSpeechUpdateRoleAssistant ClientMessageSpeechUpdateRole = "assistant"
	ClientMessageSpeechUpdateRoleUser      ClientMessageSpeechUpdateRole = "user"
)

func NewClientMessageSpeechUpdateRoleFromString(s string) (ClientMessageSpeechUpdateRole, error) {
	switch s {
	case "assistant":
		return ClientMessageSpeechUpdateRoleAssistant, nil
	case "user":
		return ClientMessageSpeechUpdateRoleUser, nil
	}
	var t ClientMessageSpeechUpdateRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageSpeechUpdateRole) Ptr() *ClientMessageSpeechUpdateRole {
	return &c
}

// This is the status of the speech update.
type ClientMessageSpeechUpdateStatus string

const (
	ClientMessageSpeechUpdateStatusStarted ClientMessageSpeechUpdateStatus = "started"
	ClientMessageSpeechUpdateStatusStopped ClientMessageSpeechUpdateStatus = "stopped"
)

func NewClientMessageSpeechUpdateStatusFromString(s string) (ClientMessageSpeechUpdateStatus, error) {
	switch s {
	case "started":
		return ClientMessageSpeechUpdateStatusStarted, nil
	case "stopped":
		return ClientMessageSpeechUpdateStatusStopped, nil
	}
	var t ClientMessageSpeechUpdateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageSpeechUpdateStatus) Ptr() *ClientMessageSpeechUpdateStatus {
	return &c
}

type ClientMessageToolCalls struct {
	// This is the type of the message. "tool-calls" is sent to call a tool.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// This is the list of tools calls that the model is requesting along with the original tool configuration.
	ToolWithToolCallList []*ClientMessageToolCallsToolWithToolCallListItem `json:"toolWithToolCallList,omitempty" url:"toolWithToolCallList,omitempty"`
	// This is the list of tool calls that the model is requesting.
	ToolCallList []*ToolCall `json:"toolCallList,omitempty" url:"toolCallList,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageToolCalls) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientMessageToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientMessageToolCalls(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageToolCalls) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageToolCallsResult struct {
	// This is the type of the message. "tool-calls-result" is sent to forward the result of a tool call to the client.
	// This is the result of the tool call.
	ToolCallResult map[string]interface{} `json:"toolCallResult,omitempty" url:"toolCallResult,omitempty"`
	type_          string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageToolCallsResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageToolCallsResult) Type() string {
	return c.type_
}

func (c *ClientMessageToolCallsResult) UnmarshalJSON(data []byte) error {
	type embed ClientMessageToolCallsResult
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageToolCallsResult(unmarshaler.embed)
	if unmarshaler.Type != "tool-calls-result" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tool-calls-result", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageToolCallsResult) MarshalJSON() ([]byte, error) {
	type embed ClientMessageToolCallsResult
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "tool-calls-result",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageToolCallsResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageToolCallsToolWithToolCallListItem struct {
	FunctionToolWithToolCall *FunctionToolWithToolCall
	GhlToolWithToolCall      *GhlToolWithToolCall
	MakeToolWithToolCall     *MakeToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) UnmarshalJSON(data []byte) error {
	valueFunctionToolWithToolCall := new(FunctionToolWithToolCall)
	if err := json.Unmarshal(data, &valueFunctionToolWithToolCall); err == nil {
		c.FunctionToolWithToolCall = valueFunctionToolWithToolCall
		return nil
	}
	valueGhlToolWithToolCall := new(GhlToolWithToolCall)
	if err := json.Unmarshal(data, &valueGhlToolWithToolCall); err == nil {
		c.GhlToolWithToolCall = valueGhlToolWithToolCall
		return nil
	}
	valueMakeToolWithToolCall := new(MakeToolWithToolCall)
	if err := json.Unmarshal(data, &valueMakeToolWithToolCall); err == nil {
		c.MakeToolWithToolCall = valueMakeToolWithToolCall
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageToolCallsToolWithToolCallListItem) MarshalJSON() ([]byte, error) {
	if c.FunctionToolWithToolCall != nil {
		return json.Marshal(c.FunctionToolWithToolCall)
	}
	if c.GhlToolWithToolCall != nil {
		return json.Marshal(c.GhlToolWithToolCall)
	}
	if c.MakeToolWithToolCall != nil {
		return json.Marshal(c.MakeToolWithToolCall)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageToolCallsToolWithToolCallListItemVisitor interface {
	VisitFunctionToolWithToolCall(*FunctionToolWithToolCall) error
	VisitGhlToolWithToolCall(*GhlToolWithToolCall) error
	VisitMakeToolWithToolCall(*MakeToolWithToolCall) error
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) Accept(visitor ClientMessageToolCallsToolWithToolCallListItemVisitor) error {
	if c.FunctionToolWithToolCall != nil {
		return visitor.VisitFunctionToolWithToolCall(c.FunctionToolWithToolCall)
	}
	if c.GhlToolWithToolCall != nil {
		return visitor.VisitGhlToolWithToolCall(c.GhlToolWithToolCall)
	}
	if c.MakeToolWithToolCall != nil {
		return visitor.VisitMakeToolWithToolCall(c.MakeToolWithToolCall)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageTranscript struct {
	// This is the type of the message. "transcript" is sent as transcriber outputs partial or final transcript.
	// This is the role for which the transcript is for.
	Role ClientMessageTranscriptRole `json:"role" url:"role"`
	// This is the type of the transcript.
	TranscriptType ClientMessageTranscriptTranscriptType `json:"transcriptType" url:"transcriptType"`
	// This is the transcript content.
	Transcript string `json:"transcript" url:"transcript"`
	type_      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageTranscript) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageTranscript) Type() string {
	return c.type_
}

func (c *ClientMessageTranscript) UnmarshalJSON(data []byte) error {
	type embed ClientMessageTranscript
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageTranscript(unmarshaler.embed)
	if unmarshaler.Type != "transcript" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "transcript", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageTranscript) MarshalJSON() ([]byte, error) {
	type embed ClientMessageTranscript
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "transcript",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageTranscript) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the role for which the transcript is for.
type ClientMessageTranscriptRole string

const (
	ClientMessageTranscriptRoleAssistant ClientMessageTranscriptRole = "assistant"
	ClientMessageTranscriptRoleUser      ClientMessageTranscriptRole = "user"
)

func NewClientMessageTranscriptRoleFromString(s string) (ClientMessageTranscriptRole, error) {
	switch s {
	case "assistant":
		return ClientMessageTranscriptRoleAssistant, nil
	case "user":
		return ClientMessageTranscriptRoleUser, nil
	}
	var t ClientMessageTranscriptRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageTranscriptRole) Ptr() *ClientMessageTranscriptRole {
	return &c
}

// This is the type of the transcript.
type ClientMessageTranscriptTranscriptType string

const (
	ClientMessageTranscriptTranscriptTypePartial ClientMessageTranscriptTranscriptType = "partial"
	ClientMessageTranscriptTranscriptTypeFinal   ClientMessageTranscriptTranscriptType = "final"
)

func NewClientMessageTranscriptTranscriptTypeFromString(s string) (ClientMessageTranscriptTranscriptType, error) {
	switch s {
	case "partial":
		return ClientMessageTranscriptTranscriptTypePartial, nil
	case "final":
		return ClientMessageTranscriptTranscriptTypeFinal, nil
	}
	var t ClientMessageTranscriptTranscriptType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageTranscriptTranscriptType) Ptr() *ClientMessageTranscriptTranscriptType {
	return &c
}

type ClientMessageUserInterrupted struct {
	// This is the type of the message. "user-interrupted" is sent when the user interrupts the assistant.
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageUserInterrupted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageUserInterrupted) Type() string {
	return c.type_
}

func (c *ClientMessageUserInterrupted) UnmarshalJSON(data []byte) error {
	type embed ClientMessageUserInterrupted
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageUserInterrupted(unmarshaler.embed)
	if unmarshaler.Type != "user-interrupted" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "user-interrupted", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageUserInterrupted) MarshalJSON() ([]byte, error) {
	type embed ClientMessageUserInterrupted
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "user-interrupted",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageUserInterrupted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageVoiceInput struct {
	// This is the type of the message. "voice-input" is sent when a generation is requested from voice provider.
	// This is the voice input content
	Input string `json:"input" url:"input"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientMessageVoiceInput) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageVoiceInput) Type() string {
	return c.type_
}

func (c *ClientMessageVoiceInput) UnmarshalJSON(data []byte) error {
	type embed ClientMessageVoiceInput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageVoiceInput(unmarshaler.embed)
	if unmarshaler.Type != "voice-input" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "voice-input", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageVoiceInput) MarshalJSON() ([]byte, error) {
	type embed ClientMessageVoiceInput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "voice-input",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageVoiceInput) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CloneVoiceDto struct {
	// This is the name of the cloned voice in the provider account.
	Name string `json:"name" url:"name"`
	// This is the description of your cloned voice.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Serialized labels dictionary for the voice.
	Labels *string `json:"labels,omitempty" url:"labels,omitempty"`
	// These are the files you want to use to clone your voice. Only Audio files are supported.
	Files []string `json:"files,omitempty" url:"files,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CloneVoiceDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloneVoiceDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CloneVoiceDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CloneVoiceDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CloneVoiceDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Condition struct {
	// This is the value you want to compare against the parameter.
	Value string `json:"value" url:"value"`
	// This is the operator you want to use to compare the parameter and value.
	Operator ConditionOperator `json:"operator" url:"operator"`
	// This is the name of the parameter that you want to check.
	Param string `json:"param" url:"param"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Condition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Condition) UnmarshalJSON(data []byte) error {
	type unmarshaler Condition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Condition(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Condition) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the operator you want to use to compare the parameter and value.
type ConditionOperator string

const (
	ConditionOperatorEq  ConditionOperator = "eq"
	ConditionOperatorNeq ConditionOperator = "neq"
	ConditionOperatorGt  ConditionOperator = "gt"
	ConditionOperatorGte ConditionOperator = "gte"
	ConditionOperatorLt  ConditionOperator = "lt"
	ConditionOperatorLte ConditionOperator = "lte"
)

func NewConditionOperatorFromString(s string) (ConditionOperator, error) {
	switch s {
	case "eq":
		return ConditionOperatorEq, nil
	case "neq":
		return ConditionOperatorNeq, nil
	case "gt":
		return ConditionOperatorGt, nil
	case "gte":
		return ConditionOperatorGte, nil
	case "lt":
		return ConditionOperatorLt, nil
	case "lte":
		return ConditionOperatorLte, nil
	}
	var t ConditionOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConditionOperator) Ptr() *ConditionOperator {
	return &c
}

type ConversationBlock struct {
	// These are the pre-configured messages that will be spoken to the user while the block is running.
	Messages []*ConversationBlockMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the input schema for the block. This is the input the block needs to run. It's given to the block as `steps[0].input`
	//
	// These are accessible as variables:
	//
	// - ({{input.propertyName}}) in context of the block execution (step)
	// - ({{stepName.input.propertyName}}) in context of the workflow
	InputSchema *JsonSchema `json:"inputSchema,omitempty" url:"inputSchema,omitempty"`
	// This is the output schema for the block. This is the output the block will return to the workflow (`{{stepName.output}}`).
	//
	// These are accessible as variables:
	//
	// - ({{output.propertyName}}) in context of the block execution (step)
	// - ({{stepName.output.propertyName}}) in context of the workflow (read caveat #1)
	// - ({{blockName.output.propertyName}}) in context of the workflow (read caveat #2)
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	OutputSchema *JsonSchema `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	// This is the unique identifier for the block.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this block belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the block was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the block was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of the block. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the instruction to the model.
	//
	// You can reference any variable in the context of the current block execution (step):
	//
	// - "{{input.your-property-name}}" for the current step's input
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// This can be as simple or as complex as you want it to be.
	//
	// - "say hello and ask the user about their day!"
	// - "collect the user's first and last name"
	// - "user is {{input.firstName}} {{input.lastName}}. their age is {{input.age}}. ask them about their salary and if they might be interested in buying a house. we offer {{input.offer}}"
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output/input.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output/input.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	Instruction string `json:"instruction" url:"instruction"`
	type_       string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ConversationBlock) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationBlock) Type() string {
	return c.type_
}

func (c *ConversationBlock) UnmarshalJSON(data []byte) error {
	type embed ConversationBlock
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationBlock(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "conversation" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "conversation", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationBlock) MarshalJSON() ([]byte, error) {
	type embed ConversationBlock
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		Type:      "conversation",
	}
	return json.Marshal(marshaler)
}

func (c *ConversationBlock) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConversationBlockMessagesItem struct {
	BlockStartMessage    *BlockStartMessage
	BlockCompleteMessage *BlockCompleteMessage
}

func (c *ConversationBlockMessagesItem) UnmarshalJSON(data []byte) error {
	valueBlockStartMessage := new(BlockStartMessage)
	if err := json.Unmarshal(data, &valueBlockStartMessage); err == nil {
		c.BlockStartMessage = valueBlockStartMessage
		return nil
	}
	valueBlockCompleteMessage := new(BlockCompleteMessage)
	if err := json.Unmarshal(data, &valueBlockCompleteMessage); err == nil {
		c.BlockCompleteMessage = valueBlockCompleteMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConversationBlockMessagesItem) MarshalJSON() ([]byte, error) {
	if c.BlockStartMessage != nil {
		return json.Marshal(c.BlockStartMessage)
	}
	if c.BlockCompleteMessage != nil {
		return json.Marshal(c.BlockCompleteMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ConversationBlockMessagesItemVisitor interface {
	VisitBlockStartMessage(*BlockStartMessage) error
	VisitBlockCompleteMessage(*BlockCompleteMessage) error
}

func (c *ConversationBlockMessagesItem) Accept(visitor ConversationBlockMessagesItemVisitor) error {
	if c.BlockStartMessage != nil {
		return visitor.VisitBlockStartMessage(c.BlockStartMessage)
	}
	if c.BlockCompleteMessage != nil {
		return visitor.VisitBlockCompleteMessage(c.BlockCompleteMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CostBreakdown struct {
	// This is the cost of the transport provider, like Twilio or Vonage.
	Transport *float64 `json:"transport,omitempty" url:"transport,omitempty"`
	// This is the cost of the speech-to-text service.
	Stt *float64 `json:"stt,omitempty" url:"stt,omitempty"`
	// This is the cost of the language model.
	Llm *float64 `json:"llm,omitempty" url:"llm,omitempty"`
	// This is the cost of the text-to-speech service.
	Tts *float64 `json:"tts,omitempty" url:"tts,omitempty"`
	// This is the cost of Vapi.
	Vapi *float64 `json:"vapi,omitempty" url:"vapi,omitempty"`
	// This is the total cost of the call.
	Total *float64 `json:"total,omitempty" url:"total,omitempty"`
	// This is the LLM prompt tokens used for the call.
	LlmPromptTokens *float64 `json:"llmPromptTokens,omitempty" url:"llmPromptTokens,omitempty"`
	// This is the LLM completion tokens used for the call.
	LlmCompletionTokens *float64 `json:"llmCompletionTokens,omitempty" url:"llmCompletionTokens,omitempty"`
	// This is the TTS characters used for the call.
	TtsCharacters *float64 `json:"ttsCharacters,omitempty" url:"ttsCharacters,omitempty"`
	// This is the cost of the analysis.
	AnalysisCostBreakdown *AnalysisCostBreakdown `json:"analysisCostBreakdown,omitempty" url:"analysisCostBreakdown,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CostBreakdown) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CostBreakdown) UnmarshalJSON(data []byte) error {
	type unmarshaler CostBreakdown
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CostBreakdown(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CostBreakdown) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAnthropicCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateAnthropicCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAnthropicCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAnthropicCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAnthropicCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAnthropicCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "anthropic", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAnthropicCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAnthropicCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "anthropic",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAnthropicCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAnyscaleCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateAnyscaleCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAnyscaleCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAnyscaleCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAnyscaleCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAnyscaleCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "anyscale" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "anyscale", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAnyscaleCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAnyscaleCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "anyscale",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAnyscaleCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAssistantDto struct {
	// These are the options for the assistant's transcriber.
	Transcriber *CreateAssistantDtoTranscriber `json:"transcriber,omitempty" url:"transcriber,omitempty"`
	// These are the options for the assistant's LLM.
	Model *CreateAssistantDtoModel `json:"model,omitempty" url:"model,omitempty"`
	// These are the options for the assistant's voice.
	Voice *CreateAssistantDtoVoice `json:"voice,omitempty" url:"voice,omitempty"`
	// This is the mode for the first message. Default is 'assistant-speaks-first'.
	//
	// Use:
	//
	// - 'assistant-speaks-first' to have the assistant speak first.
	// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
	// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
	//
	// @default 'assistant-speaks-first'
	FirstMessageMode *CreateAssistantDtoFirstMessageMode `json:"firstMessageMode,omitempty" url:"firstMessageMode,omitempty"`
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transcript,tool-calls,user-interrupted,voice-input. You can check the shape of the messages in ClientMessage schema.
	ClientMessages []CreateAssistantDtoClientMessagesItem `json:"clientMessages,omitempty" url:"clientMessages,omitempty"`
	// These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
	ServerMessages []CreateAssistantDtoServerMessagesItem `json:"serverMessages,omitempty" url:"serverMessages,omitempty"`
	// How many seconds of silence to wait before ending the call. Defaults to 30.
	//
	// @default 30
	SilenceTimeoutSeconds *float64 `json:"silenceTimeoutSeconds,omitempty" url:"silenceTimeoutSeconds,omitempty"`
	// This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
	//
	// @default 600 (10 minutes)
	MaxDurationSeconds *float64 `json:"maxDurationSeconds,omitempty" url:"maxDurationSeconds,omitempty"`
	// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
	BackgroundSound *CreateAssistantDtoBackgroundSound `json:"backgroundSound,omitempty" url:"backgroundSound,omitempty"`
	// This determines whether the model says 'mhmm', 'ahem' etc. while user is speaking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackchannelingEnabled *bool `json:"backchannelingEnabled,omitempty" url:"backchannelingEnabled,omitempty"`
	// This enables filtering of noise and background speech while the user is talking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackgroundDenoisingEnabled *bool `json:"backgroundDenoisingEnabled,omitempty" url:"backgroundDenoisingEnabled,omitempty"`
	// This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
	//
	// Default `false` while in beta.
	//
	// @default false
	ModelOutputInMessagesEnabled *bool `json:"modelOutputInMessagesEnabled,omitempty" url:"modelOutputInMessagesEnabled,omitempty"`
	// These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
	TransportConfigurations []*TransportConfigurationTwilio `json:"transportConfigurations,omitempty" url:"transportConfigurations,omitempty"`
	// This is the name of the assistant.
	//
	// This is required when you want to transfer between assistants in a call.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
	//
	// If unspecified, assistant will wait for user to speak and use the model to respond once they speak.
	FirstMessage *string `json:"firstMessage,omitempty" url:"firstMessage,omitempty"`
	// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
	// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
	// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
	VoicemailDetection *TwilioVoicemailDetection `json:"voicemailDetection,omitempty" url:"voicemailDetection,omitempty"`
	// This is the message that the assistant will say if the call is forwarded to voicemail.
	//
	// If unspecified, it will hang up.
	VoicemailMessage *string `json:"voicemailMessage,omitempty" url:"voicemailMessage,omitempty"`
	// This is the message that the assistant will say if it ends the call.
	//
	// If unspecified, it will hang up without saying anything.
	EndCallMessage *string `json:"endCallMessage,omitempty" url:"endCallMessage,omitempty"`
	// This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
	EndCallPhrases []string `json:"endCallPhrases,omitempty" url:"endCallPhrases,omitempty"`
	// This is for metadata you want to store on the assistant.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the URL Vapi will communicate with via HTTP GET and POST Requests. This is used for retrieving context, function calling, and end-of-call reports.
	//
	// All requests will be sent with the call object among other things relevant to that message. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	// This is the plan for analysis of assistant's calls. Stored in `call.analysis`.
	AnalysisPlan *AnalysisPlan `json:"analysisPlan,omitempty" url:"analysisPlan,omitempty"`
	// This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.
	//
	// Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"artifactPlan,omitempty"`
	// This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.
	//
	// Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.
	MessagePlan *MessagePlan `json:"messagePlan,omitempty" url:"messagePlan,omitempty"`
	// This is the plan for when the assistant should start talking.
	//
	// You should configure this if you're running into these issues:
	//
	// - The assistant is too slow to start talking after the customer is done speaking.
	// - The assistant is too fast to start talking after the customer is done speaking.
	// - The assistant is so fast that it's actually interrupting the customer.
	StartSpeakingPlan *StartSpeakingPlan `json:"startSpeakingPlan,omitempty" url:"startSpeakingPlan,omitempty"`
	// This is the plan for when assistant should stop talking on customer interruption.
	//
	// You should configure this if you're running into these issues:
	//
	// - The assistant is too slow to recognize customer's interruption.
	// - The assistant is too fast to recognize customer's interruption.
	// - The assistant is getting interrupted by phrases that are just acknowledgments.
	// - The assistant is getting interrupted by background noises.
	// - The assistant is not properly stopping -- it starts talking right after getting interrupted.
	StopSpeakingPlan *StopSpeakingPlan `json:"stopSpeakingPlan,omitempty" url:"stopSpeakingPlan,omitempty"`
	// This is the plan for real-time monitoring of the assistant's calls.
	//
	// Usage:
	//
	// - To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.
	// - To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.
	//
	// Note, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible
	MonitorPlan *MonitorPlan `json:"monitorPlan,omitempty" url:"monitorPlan,omitempty"`
	// These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
	CredentialIds []string `json:"credentialIds,omitempty" url:"credentialIds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateAssistantDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAssistantDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateAssistantDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateAssistantDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAssistantDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
type CreateAssistantDtoBackgroundSound string

const (
	CreateAssistantDtoBackgroundSoundOff    CreateAssistantDtoBackgroundSound = "off"
	CreateAssistantDtoBackgroundSoundOffice CreateAssistantDtoBackgroundSound = "office"
)

func NewCreateAssistantDtoBackgroundSoundFromString(s string) (CreateAssistantDtoBackgroundSound, error) {
	switch s {
	case "off":
		return CreateAssistantDtoBackgroundSoundOff, nil
	case "office":
		return CreateAssistantDtoBackgroundSoundOffice, nil
	}
	var t CreateAssistantDtoBackgroundSound
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoBackgroundSound) Ptr() *CreateAssistantDtoBackgroundSound {
	return &c
}

type CreateAssistantDtoClientMessagesItem string

const (
	CreateAssistantDtoClientMessagesItemConversationUpdate CreateAssistantDtoClientMessagesItem = "conversation-update"
	CreateAssistantDtoClientMessagesItemFunctionCall       CreateAssistantDtoClientMessagesItem = "function-call"
	CreateAssistantDtoClientMessagesItemFunctionCallResult CreateAssistantDtoClientMessagesItem = "function-call-result"
	CreateAssistantDtoClientMessagesItemHang               CreateAssistantDtoClientMessagesItem = "hang"
	CreateAssistantDtoClientMessagesItemLanguageChanged    CreateAssistantDtoClientMessagesItem = "language-changed"
	CreateAssistantDtoClientMessagesItemMetadata           CreateAssistantDtoClientMessagesItem = "metadata"
	CreateAssistantDtoClientMessagesItemModelOutput        CreateAssistantDtoClientMessagesItem = "model-output"
	CreateAssistantDtoClientMessagesItemSpeechUpdate       CreateAssistantDtoClientMessagesItem = "speech-update"
	CreateAssistantDtoClientMessagesItemStatusUpdate       CreateAssistantDtoClientMessagesItem = "status-update"
	CreateAssistantDtoClientMessagesItemTranscript         CreateAssistantDtoClientMessagesItem = "transcript"
	CreateAssistantDtoClientMessagesItemToolCalls          CreateAssistantDtoClientMessagesItem = "tool-calls"
	CreateAssistantDtoClientMessagesItemToolCallsResult    CreateAssistantDtoClientMessagesItem = "tool-calls-result"
	CreateAssistantDtoClientMessagesItemUserInterrupted    CreateAssistantDtoClientMessagesItem = "user-interrupted"
	CreateAssistantDtoClientMessagesItemVoiceInput         CreateAssistantDtoClientMessagesItem = "voice-input"
)

func NewCreateAssistantDtoClientMessagesItemFromString(s string) (CreateAssistantDtoClientMessagesItem, error) {
	switch s {
	case "conversation-update":
		return CreateAssistantDtoClientMessagesItemConversationUpdate, nil
	case "function-call":
		return CreateAssistantDtoClientMessagesItemFunctionCall, nil
	case "function-call-result":
		return CreateAssistantDtoClientMessagesItemFunctionCallResult, nil
	case "hang":
		return CreateAssistantDtoClientMessagesItemHang, nil
	case "language-changed":
		return CreateAssistantDtoClientMessagesItemLanguageChanged, nil
	case "metadata":
		return CreateAssistantDtoClientMessagesItemMetadata, nil
	case "model-output":
		return CreateAssistantDtoClientMessagesItemModelOutput, nil
	case "speech-update":
		return CreateAssistantDtoClientMessagesItemSpeechUpdate, nil
	case "status-update":
		return CreateAssistantDtoClientMessagesItemStatusUpdate, nil
	case "transcript":
		return CreateAssistantDtoClientMessagesItemTranscript, nil
	case "tool-calls":
		return CreateAssistantDtoClientMessagesItemToolCalls, nil
	case "tool-calls-result":
		return CreateAssistantDtoClientMessagesItemToolCallsResult, nil
	case "user-interrupted":
		return CreateAssistantDtoClientMessagesItemUserInterrupted, nil
	case "voice-input":
		return CreateAssistantDtoClientMessagesItemVoiceInput, nil
	}
	var t CreateAssistantDtoClientMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoClientMessagesItem) Ptr() *CreateAssistantDtoClientMessagesItem {
	return &c
}

// This is the mode for the first message. Default is 'assistant-speaks-first'.
//
// Use:
//
// - 'assistant-speaks-first' to have the assistant speak first.
// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
//
// @default 'assistant-speaks-first'
type CreateAssistantDtoFirstMessageMode string

const (
	CreateAssistantDtoFirstMessageModeAssistantSpeaksFirst                          CreateAssistantDtoFirstMessageMode = "assistant-speaks-first"
	CreateAssistantDtoFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage CreateAssistantDtoFirstMessageMode = "assistant-speaks-first-with-model-generated-message"
	CreateAssistantDtoFirstMessageModeAssistantWaitsForUser                         CreateAssistantDtoFirstMessageMode = "assistant-waits-for-user"
)

func NewCreateAssistantDtoFirstMessageModeFromString(s string) (CreateAssistantDtoFirstMessageMode, error) {
	switch s {
	case "assistant-speaks-first":
		return CreateAssistantDtoFirstMessageModeAssistantSpeaksFirst, nil
	case "assistant-speaks-first-with-model-generated-message":
		return CreateAssistantDtoFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage, nil
	case "assistant-waits-for-user":
		return CreateAssistantDtoFirstMessageModeAssistantWaitsForUser, nil
	}
	var t CreateAssistantDtoFirstMessageMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoFirstMessageMode) Ptr() *CreateAssistantDtoFirstMessageMode {
	return &c
}

// These are the options for the assistant's LLM.
type CreateAssistantDtoModel struct {
	AnyscaleModel     *AnyscaleModel
	AnthropicModel    *AnthropicModel
	CustomLlmModel    *CustomLlmModel
	DeepInfraModel    *DeepInfraModel
	GroqModel         *GroqModel
	OpenAiModel       *OpenAiModel
	OpenRouterModel   *OpenRouterModel
	PerplexityAiModel *PerplexityAiModel
	TogetherAiModel   *TogetherAiModel
	VapiModel         *VapiModel
}

func (c *CreateAssistantDtoModel) UnmarshalJSON(data []byte) error {
	valueAnyscaleModel := new(AnyscaleModel)
	if err := json.Unmarshal(data, &valueAnyscaleModel); err == nil {
		c.AnyscaleModel = valueAnyscaleModel
		return nil
	}
	valueAnthropicModel := new(AnthropicModel)
	if err := json.Unmarshal(data, &valueAnthropicModel); err == nil {
		c.AnthropicModel = valueAnthropicModel
		return nil
	}
	valueCustomLlmModel := new(CustomLlmModel)
	if err := json.Unmarshal(data, &valueCustomLlmModel); err == nil {
		c.CustomLlmModel = valueCustomLlmModel
		return nil
	}
	valueDeepInfraModel := new(DeepInfraModel)
	if err := json.Unmarshal(data, &valueDeepInfraModel); err == nil {
		c.DeepInfraModel = valueDeepInfraModel
		return nil
	}
	valueGroqModel := new(GroqModel)
	if err := json.Unmarshal(data, &valueGroqModel); err == nil {
		c.GroqModel = valueGroqModel
		return nil
	}
	valueOpenAiModel := new(OpenAiModel)
	if err := json.Unmarshal(data, &valueOpenAiModel); err == nil {
		c.OpenAiModel = valueOpenAiModel
		return nil
	}
	valueOpenRouterModel := new(OpenRouterModel)
	if err := json.Unmarshal(data, &valueOpenRouterModel); err == nil {
		c.OpenRouterModel = valueOpenRouterModel
		return nil
	}
	valuePerplexityAiModel := new(PerplexityAiModel)
	if err := json.Unmarshal(data, &valuePerplexityAiModel); err == nil {
		c.PerplexityAiModel = valuePerplexityAiModel
		return nil
	}
	valueTogetherAiModel := new(TogetherAiModel)
	if err := json.Unmarshal(data, &valueTogetherAiModel); err == nil {
		c.TogetherAiModel = valueTogetherAiModel
		return nil
	}
	valueVapiModel := new(VapiModel)
	if err := json.Unmarshal(data, &valueVapiModel); err == nil {
		c.VapiModel = valueVapiModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoModel) MarshalJSON() ([]byte, error) {
	if c.AnyscaleModel != nil {
		return json.Marshal(c.AnyscaleModel)
	}
	if c.AnthropicModel != nil {
		return json.Marshal(c.AnthropicModel)
	}
	if c.CustomLlmModel != nil {
		return json.Marshal(c.CustomLlmModel)
	}
	if c.DeepInfraModel != nil {
		return json.Marshal(c.DeepInfraModel)
	}
	if c.GroqModel != nil {
		return json.Marshal(c.GroqModel)
	}
	if c.OpenAiModel != nil {
		return json.Marshal(c.OpenAiModel)
	}
	if c.OpenRouterModel != nil {
		return json.Marshal(c.OpenRouterModel)
	}
	if c.PerplexityAiModel != nil {
		return json.Marshal(c.PerplexityAiModel)
	}
	if c.TogetherAiModel != nil {
		return json.Marshal(c.TogetherAiModel)
	}
	if c.VapiModel != nil {
		return json.Marshal(c.VapiModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoModelVisitor interface {
	VisitAnyscaleModel(*AnyscaleModel) error
	VisitAnthropicModel(*AnthropicModel) error
	VisitCustomLlmModel(*CustomLlmModel) error
	VisitDeepInfraModel(*DeepInfraModel) error
	VisitGroqModel(*GroqModel) error
	VisitOpenAiModel(*OpenAiModel) error
	VisitOpenRouterModel(*OpenRouterModel) error
	VisitPerplexityAiModel(*PerplexityAiModel) error
	VisitTogetherAiModel(*TogetherAiModel) error
	VisitVapiModel(*VapiModel) error
}

func (c *CreateAssistantDtoModel) Accept(visitor CreateAssistantDtoModelVisitor) error {
	if c.AnyscaleModel != nil {
		return visitor.VisitAnyscaleModel(c.AnyscaleModel)
	}
	if c.AnthropicModel != nil {
		return visitor.VisitAnthropicModel(c.AnthropicModel)
	}
	if c.CustomLlmModel != nil {
		return visitor.VisitCustomLlmModel(c.CustomLlmModel)
	}
	if c.DeepInfraModel != nil {
		return visitor.VisitDeepInfraModel(c.DeepInfraModel)
	}
	if c.GroqModel != nil {
		return visitor.VisitGroqModel(c.GroqModel)
	}
	if c.OpenAiModel != nil {
		return visitor.VisitOpenAiModel(c.OpenAiModel)
	}
	if c.OpenRouterModel != nil {
		return visitor.VisitOpenRouterModel(c.OpenRouterModel)
	}
	if c.PerplexityAiModel != nil {
		return visitor.VisitPerplexityAiModel(c.PerplexityAiModel)
	}
	if c.TogetherAiModel != nil {
		return visitor.VisitTogetherAiModel(c.TogetherAiModel)
	}
	if c.VapiModel != nil {
		return visitor.VisitVapiModel(c.VapiModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoServerMessagesItem string

const (
	CreateAssistantDtoServerMessagesItemConversationUpdate         CreateAssistantDtoServerMessagesItem = "conversation-update"
	CreateAssistantDtoServerMessagesItemEndOfCallReport            CreateAssistantDtoServerMessagesItem = "end-of-call-report"
	CreateAssistantDtoServerMessagesItemFunctionCall               CreateAssistantDtoServerMessagesItem = "function-call"
	CreateAssistantDtoServerMessagesItemHang                       CreateAssistantDtoServerMessagesItem = "hang"
	CreateAssistantDtoServerMessagesItemLanguageChanged            CreateAssistantDtoServerMessagesItem = "language-changed"
	CreateAssistantDtoServerMessagesItemModelOutput                CreateAssistantDtoServerMessagesItem = "model-output"
	CreateAssistantDtoServerMessagesItemPhoneCallControl           CreateAssistantDtoServerMessagesItem = "phone-call-control"
	CreateAssistantDtoServerMessagesItemSpeechUpdate               CreateAssistantDtoServerMessagesItem = "speech-update"
	CreateAssistantDtoServerMessagesItemStatusUpdate               CreateAssistantDtoServerMessagesItem = "status-update"
	CreateAssistantDtoServerMessagesItemTranscript                 CreateAssistantDtoServerMessagesItem = "transcript"
	CreateAssistantDtoServerMessagesItemToolCalls                  CreateAssistantDtoServerMessagesItem = "tool-calls"
	CreateAssistantDtoServerMessagesItemTransferDestinationRequest CreateAssistantDtoServerMessagesItem = "transfer-destination-request"
	CreateAssistantDtoServerMessagesItemTransferUpdate             CreateAssistantDtoServerMessagesItem = "transfer-update"
	CreateAssistantDtoServerMessagesItemUserInterrupted            CreateAssistantDtoServerMessagesItem = "user-interrupted"
	CreateAssistantDtoServerMessagesItemVoiceInput                 CreateAssistantDtoServerMessagesItem = "voice-input"
)

func NewCreateAssistantDtoServerMessagesItemFromString(s string) (CreateAssistantDtoServerMessagesItem, error) {
	switch s {
	case "conversation-update":
		return CreateAssistantDtoServerMessagesItemConversationUpdate, nil
	case "end-of-call-report":
		return CreateAssistantDtoServerMessagesItemEndOfCallReport, nil
	case "function-call":
		return CreateAssistantDtoServerMessagesItemFunctionCall, nil
	case "hang":
		return CreateAssistantDtoServerMessagesItemHang, nil
	case "language-changed":
		return CreateAssistantDtoServerMessagesItemLanguageChanged, nil
	case "model-output":
		return CreateAssistantDtoServerMessagesItemModelOutput, nil
	case "phone-call-control":
		return CreateAssistantDtoServerMessagesItemPhoneCallControl, nil
	case "speech-update":
		return CreateAssistantDtoServerMessagesItemSpeechUpdate, nil
	case "status-update":
		return CreateAssistantDtoServerMessagesItemStatusUpdate, nil
	case "transcript":
		return CreateAssistantDtoServerMessagesItemTranscript, nil
	case "tool-calls":
		return CreateAssistantDtoServerMessagesItemToolCalls, nil
	case "transfer-destination-request":
		return CreateAssistantDtoServerMessagesItemTransferDestinationRequest, nil
	case "transfer-update":
		return CreateAssistantDtoServerMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return CreateAssistantDtoServerMessagesItemUserInterrupted, nil
	case "voice-input":
		return CreateAssistantDtoServerMessagesItemVoiceInput, nil
	}
	var t CreateAssistantDtoServerMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoServerMessagesItem) Ptr() *CreateAssistantDtoServerMessagesItem {
	return &c
}

// These are the options for the assistant's transcriber.
type CreateAssistantDtoTranscriber struct {
	DeepgramTranscriber    *DeepgramTranscriber
	GladiaTranscriber      *GladiaTranscriber
	TalkscriberTranscriber *TalkscriberTranscriber
}

func (c *CreateAssistantDtoTranscriber) UnmarshalJSON(data []byte) error {
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		c.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		c.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		c.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoTranscriber) MarshalJSON() ([]byte, error) {
	if c.DeepgramTranscriber != nil {
		return json.Marshal(c.DeepgramTranscriber)
	}
	if c.GladiaTranscriber != nil {
		return json.Marshal(c.GladiaTranscriber)
	}
	if c.TalkscriberTranscriber != nil {
		return json.Marshal(c.TalkscriberTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoTranscriberVisitor interface {
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
}

func (c *CreateAssistantDtoTranscriber) Accept(visitor CreateAssistantDtoTranscriberVisitor) error {
	if c.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(c.DeepgramTranscriber)
	}
	if c.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(c.GladiaTranscriber)
	}
	if c.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(c.TalkscriberTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// These are the options for the assistant's voice.
type CreateAssistantDtoVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	LmntVoice       *LmntVoice
	NeetsVoice      *NeetsVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
}

func (c *CreateAssistantDtoVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		c.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		c.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		c.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		c.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		c.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeetsVoice := new(NeetsVoice)
	if err := json.Unmarshal(data, &valueNeetsVoice); err == nil {
		c.NeetsVoice = valueNeetsVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		c.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		c.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		c.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoVoice) MarshalJSON() ([]byte, error) {
	if c.AzureVoice != nil {
		return json.Marshal(c.AzureVoice)
	}
	if c.CartesiaVoice != nil {
		return json.Marshal(c.CartesiaVoice)
	}
	if c.DeepgramVoice != nil {
		return json.Marshal(c.DeepgramVoice)
	}
	if c.ElevenLabsVoice != nil {
		return json.Marshal(c.ElevenLabsVoice)
	}
	if c.LmntVoice != nil {
		return json.Marshal(c.LmntVoice)
	}
	if c.NeetsVoice != nil {
		return json.Marshal(c.NeetsVoice)
	}
	if c.OpenAiVoice != nil {
		return json.Marshal(c.OpenAiVoice)
	}
	if c.PlayHtVoice != nil {
		return json.Marshal(c.PlayHtVoice)
	}
	if c.RimeAiVoice != nil {
		return json.Marshal(c.RimeAiVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeetsVoice(*NeetsVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
}

func (c *CreateAssistantDtoVoice) Accept(visitor CreateAssistantDtoVoiceVisitor) error {
	if c.AzureVoice != nil {
		return visitor.VisitAzureVoice(c.AzureVoice)
	}
	if c.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(c.CartesiaVoice)
	}
	if c.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(c.DeepgramVoice)
	}
	if c.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(c.ElevenLabsVoice)
	}
	if c.LmntVoice != nil {
		return visitor.VisitLmntVoice(c.LmntVoice)
	}
	if c.NeetsVoice != nil {
		return visitor.VisitNeetsVoice(c.NeetsVoice)
	}
	if c.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(c.OpenAiVoice)
	}
	if c.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(c.PlayHtVoice)
	}
	if c.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(c.RimeAiVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAzureOpenAiCredentialDto struct {
	Region CreateAzureOpenAiCredentialDtoRegion       `json:"region" url:"region"`
	Models []CreateAzureOpenAiCredentialDtoModelsItem `json:"models,omitempty" url:"models,omitempty"`
	// This is not returned in the API.
	OpenAiKey      string `json:"openAIKey" url:"openAIKey"`
	OpenAiEndpoint string `json:"openAIEndpoint" url:"openAIEndpoint"`
	provider       string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateAzureOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAzureOpenAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAzureOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAzureOpenAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAzureOpenAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "azure-openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "azure-openai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAzureOpenAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAzureOpenAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "azure-openai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAzureOpenAiCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAzureOpenAiCredentialDtoModelsItem string

const (
	CreateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718 CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-mini-2024-07-18"
	CreateAzureOpenAiCredentialDtoModelsItemGpt4O20240513     CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-05-13"
	CreateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409 CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-turbo-2024-04-09"
	CreateAzureOpenAiCredentialDtoModelsItemGpt40125Preview   CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0125-preview"
	CreateAzureOpenAiCredentialDtoModelsItemGpt41106Preview   CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-1106-preview"
	CreateAzureOpenAiCredentialDtoModelsItemGpt40613          CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0613"
	CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125    CreateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-0125"
	CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106    CreateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-1106"
)

func NewCreateAzureOpenAiCredentialDtoModelsItemFromString(s string) (CreateAzureOpenAiCredentialDtoModelsItem, error) {
	switch s {
	case "gpt-4o-mini-2024-07-18":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718, nil
	case "gpt-4o-2024-05-13":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4O20240513, nil
	case "gpt-4-turbo-2024-04-09":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409, nil
	case "gpt-4-0125-preview":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt41106Preview, nil
	case "gpt-4-0613":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt40613, nil
	case "gpt-35-turbo-0125":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125, nil
	case "gpt-35-turbo-1106":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106, nil
	}
	var t CreateAzureOpenAiCredentialDtoModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAzureOpenAiCredentialDtoModelsItem) Ptr() *CreateAzureOpenAiCredentialDtoModelsItem {
	return &c
}

type CreateAzureOpenAiCredentialDtoRegion string

const (
	CreateAzureOpenAiCredentialDtoRegionAustralia      CreateAzureOpenAiCredentialDtoRegion = "australia"
	CreateAzureOpenAiCredentialDtoRegionCanada         CreateAzureOpenAiCredentialDtoRegion = "canada"
	CreateAzureOpenAiCredentialDtoRegionEastus2        CreateAzureOpenAiCredentialDtoRegion = "eastus2"
	CreateAzureOpenAiCredentialDtoRegionEastus         CreateAzureOpenAiCredentialDtoRegion = "eastus"
	CreateAzureOpenAiCredentialDtoRegionFrance         CreateAzureOpenAiCredentialDtoRegion = "france"
	CreateAzureOpenAiCredentialDtoRegionIndia          CreateAzureOpenAiCredentialDtoRegion = "india"
	CreateAzureOpenAiCredentialDtoRegionJapan          CreateAzureOpenAiCredentialDtoRegion = "japan"
	CreateAzureOpenAiCredentialDtoRegionNorthcentralus CreateAzureOpenAiCredentialDtoRegion = "northcentralus"
	CreateAzureOpenAiCredentialDtoRegionNorway         CreateAzureOpenAiCredentialDtoRegion = "norway"
	CreateAzureOpenAiCredentialDtoRegionSouthcentralus CreateAzureOpenAiCredentialDtoRegion = "southcentralus"
	CreateAzureOpenAiCredentialDtoRegionSweden         CreateAzureOpenAiCredentialDtoRegion = "sweden"
	CreateAzureOpenAiCredentialDtoRegionSwitzerland    CreateAzureOpenAiCredentialDtoRegion = "switzerland"
	CreateAzureOpenAiCredentialDtoRegionUk             CreateAzureOpenAiCredentialDtoRegion = "uk"
	CreateAzureOpenAiCredentialDtoRegionWestus         CreateAzureOpenAiCredentialDtoRegion = "westus"
	CreateAzureOpenAiCredentialDtoRegionWestus3        CreateAzureOpenAiCredentialDtoRegion = "westus3"
)

func NewCreateAzureOpenAiCredentialDtoRegionFromString(s string) (CreateAzureOpenAiCredentialDtoRegion, error) {
	switch s {
	case "australia":
		return CreateAzureOpenAiCredentialDtoRegionAustralia, nil
	case "canada":
		return CreateAzureOpenAiCredentialDtoRegionCanada, nil
	case "eastus2":
		return CreateAzureOpenAiCredentialDtoRegionEastus2, nil
	case "eastus":
		return CreateAzureOpenAiCredentialDtoRegionEastus, nil
	case "france":
		return CreateAzureOpenAiCredentialDtoRegionFrance, nil
	case "india":
		return CreateAzureOpenAiCredentialDtoRegionIndia, nil
	case "japan":
		return CreateAzureOpenAiCredentialDtoRegionJapan, nil
	case "northcentralus":
		return CreateAzureOpenAiCredentialDtoRegionNorthcentralus, nil
	case "norway":
		return CreateAzureOpenAiCredentialDtoRegionNorway, nil
	case "southcentralus":
		return CreateAzureOpenAiCredentialDtoRegionSouthcentralus, nil
	case "sweden":
		return CreateAzureOpenAiCredentialDtoRegionSweden, nil
	case "switzerland":
		return CreateAzureOpenAiCredentialDtoRegionSwitzerland, nil
	case "uk":
		return CreateAzureOpenAiCredentialDtoRegionUk, nil
	case "westus":
		return CreateAzureOpenAiCredentialDtoRegionWestus, nil
	case "westus3":
		return CreateAzureOpenAiCredentialDtoRegionWestus3, nil
	}
	var t CreateAzureOpenAiCredentialDtoRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAzureOpenAiCredentialDtoRegion) Ptr() *CreateAzureOpenAiCredentialDtoRegion {
	return &c
}

type CreateByoPhoneNumberDto struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *CreateByoPhoneNumberDtoFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.
	//
	// Use cases:
	//
	// - `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.
	// - `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.
	//
	// If `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\+?[a-zA-Z0-9]+$/`).
	//
	// @default true (E164 check is enabled)
	NumberE164CheckEnabled *bool `json:"numberE164CheckEnabled,omitempty" url:"numberE164CheckEnabled,omitempty"`
	// This is the number of the customer.
	Number *string `json:"number,omitempty" url:"number,omitempty"`
	// This is the credential of your own SIP trunk or Carrier (type `byo-sip-trunk`) which can be used to make calls to this phone number.
	//
	// You can add the SIP trunk or Carrier credential in the Provider Credentials page on the Dashboard to get the credentialId.
	CredentialId string `json:"credentialId" url:"credentialId"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	provider        string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateByoPhoneNumberDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateByoPhoneNumberDto) Provider() string {
	return c.provider
}

func (c *CreateByoPhoneNumberDto) UnmarshalJSON(data []byte) error {
	type embed CreateByoPhoneNumberDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateByoPhoneNumberDto(unmarshaler.embed)
	if unmarshaler.Provider != "byo-phone-number" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "byo-phone-number", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateByoPhoneNumberDto) MarshalJSON() ([]byte, error) {
	type embed CreateByoPhoneNumberDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "byo-phone-number",
	}
	return json.Marshal(marshaler)
}

func (c *CreateByoPhoneNumberDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type CreateByoPhoneNumberDtoFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (c *CreateByoPhoneNumberDtoFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateByoPhoneNumberDtoFallbackDestination) MarshalJSON() ([]byte, error) {
	if c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateByoPhoneNumberDtoFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *CreateByoPhoneNumberDtoFallbackDestination) Accept(visitor CreateByoPhoneNumberDtoFallbackDestinationVisitor) error {
	if c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateByoSipTrunkCredentialDto struct {
	// This can be used to bring your own SIP trunks or to connect to a Carrier.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// This is the list of SIP trunk's gateways.
	Gateways []*SipTrunkGateway `json:"gateways,omitempty" url:"gateways,omitempty"`
	// This is the name of the SIP trunk. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This can be used to configure the outbound authentication if required by the SIP trunk.
	OutboundAuthenticationPlan *SipTrunkOutboundAuthenticationPlan `json:"outboundAuthenticationPlan,omitempty" url:"outboundAuthenticationPlan,omitempty"`
	// This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.
	//
	// Usage:
	//
	// - Vonage/Twilio requires leading plus for all outbound calls. Set this to true.
	//
	// @default false
	OutboundLeadingPlusEnabled *bool `json:"outboundLeadingPlusEnabled,omitempty" url:"outboundLeadingPlusEnabled,omitempty"`
	// This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.
	SbcConfiguration *SbcConfiguration `json:"sbcConfiguration,omitempty" url:"sbcConfiguration,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateByoSipTrunkCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateByoSipTrunkCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateByoSipTrunkCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateByoSipTrunkCredentialDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateByoSipTrunkCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCartesiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCartesiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCartesiaCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateCartesiaCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateCartesiaCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCartesiaCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cartesia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCartesiaCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateCartesiaCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cartesia",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCartesiaCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConversationBlockDto struct {
	// These are the pre-configured messages that will be spoken to the user while the block is running.
	Messages []*CreateConversationBlockDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the input schema for the block. This is the input the block needs to run. It's given to the block as `steps[0].input`
	//
	// These are accessible as variables:
	//
	// - ({{input.propertyName}}) in context of the block execution (step)
	// - ({{stepName.input.propertyName}}) in context of the workflow
	InputSchema *JsonSchema `json:"inputSchema,omitempty" url:"inputSchema,omitempty"`
	// This is the output schema for the block. This is the output the block will return to the workflow (`{{stepName.output}}`).
	//
	// These are accessible as variables:
	//
	// - ({{output.propertyName}}) in context of the block execution (step)
	// - ({{stepName.output.propertyName}}) in context of the workflow (read caveat #1)
	// - ({{blockName.output.propertyName}}) in context of the workflow (read caveat #2)
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	OutputSchema *JsonSchema `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	// This is the instruction to the model.
	//
	// You can reference any variable in the context of the current block execution (step):
	//
	// - "{{input.your-property-name}}" for the current step's input
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// This can be as simple or as complex as you want it to be.
	//
	// - "say hello and ask the user about their day!"
	// - "collect the user's first and last name"
	// - "user is {{input.firstName}} {{input.lastName}}. their age is {{input.age}}. ask them about their salary and if they might be interested in buying a house. we offer {{input.offer}}"
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output/input.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output/input.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	Instruction string `json:"instruction" url:"instruction"`
	// This is the name of the block. This is just for your reference.
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateConversationBlockDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateConversationBlockDto) Type() string {
	return c.type_
}

func (c *CreateConversationBlockDto) UnmarshalJSON(data []byte) error {
	type embed CreateConversationBlockDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateConversationBlockDto(unmarshaler.embed)
	if unmarshaler.Type != "conversation" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "conversation", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConversationBlockDto) MarshalJSON() ([]byte, error) {
	type embed CreateConversationBlockDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "conversation",
	}
	return json.Marshal(marshaler)
}

func (c *CreateConversationBlockDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConversationBlockDtoMessagesItem struct {
	BlockStartMessage    *BlockStartMessage
	BlockCompleteMessage *BlockCompleteMessage
}

func (c *CreateConversationBlockDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueBlockStartMessage := new(BlockStartMessage)
	if err := json.Unmarshal(data, &valueBlockStartMessage); err == nil {
		c.BlockStartMessage = valueBlockStartMessage
		return nil
	}
	valueBlockCompleteMessage := new(BlockCompleteMessage)
	if err := json.Unmarshal(data, &valueBlockCompleteMessage); err == nil {
		c.BlockCompleteMessage = valueBlockCompleteMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateConversationBlockDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.BlockStartMessage != nil {
		return json.Marshal(c.BlockStartMessage)
	}
	if c.BlockCompleteMessage != nil {
		return json.Marshal(c.BlockCompleteMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateConversationBlockDtoMessagesItemVisitor interface {
	VisitBlockStartMessage(*BlockStartMessage) error
	VisitBlockCompleteMessage(*BlockCompleteMessage) error
}

func (c *CreateConversationBlockDtoMessagesItem) Accept(visitor CreateConversationBlockDtoMessagesItemVisitor) error {
	if c.BlockStartMessage != nil {
		return visitor.VisitBlockStartMessage(c.BlockStartMessage)
	}
	if c.BlockCompleteMessage != nil {
		return visitor.VisitBlockCompleteMessage(c.BlockCompleteMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateCustomLlmCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCustomLlmCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomLlmCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateCustomLlmCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateCustomLlmCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCustomLlmCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-llm", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomLlmCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateCustomLlmCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-llm",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCustomLlmCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCustomerDto struct {
	// This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.
	//
	// Use cases:
	//
	// - `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.
	// - `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.
	//
	// If `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\+?[a-zA-Z0-9]+$/`).
	//
	// @default true (E164 check is enabled)
	NumberE164CheckEnabled *bool `json:"numberE164CheckEnabled,omitempty" url:"numberE164CheckEnabled,omitempty"`
	// This is the extension that will be dialed after the call is answered.
	Extension *string `json:"extension,omitempty" url:"extension,omitempty"`
	// This is the number of the customer.
	Number *string `json:"number,omitempty" url:"number,omitempty"`
	// This is the SIP URI of the customer.
	SipUri *string `json:"sipUri,omitempty" url:"sipUri,omitempty"`
	// This is the name of the customer. This is just for your own reference.
	//
	// For SIP inbound calls, this is extracted from the `From` SIP header with format `"Display Name" <sip:username@domain>`.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCustomerDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomerDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCustomerDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCustomerDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomerDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeepInfraCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateDeepInfraCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeepInfraCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateDeepInfraCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateDeepInfraCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDeepInfraCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "deepinfra" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "deepinfra", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeepInfraCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateDeepInfraCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "deepinfra",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDeepInfraCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeepgramCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com.
	ApiUrl   *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateDeepgramCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeepgramCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateDeepgramCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateDeepgramCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDeepgramCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "deepgram", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeepgramCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateDeepgramCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDeepgramCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDtmfToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateDtmfToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateDtmfToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDtmfToolDto) Type() string {
	return c.type_
}

func (c *CreateDtmfToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateDtmfToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDtmfToolDto(unmarshaler.embed)
	if unmarshaler.Type != "dtmf" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "dtmf", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDtmfToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateDtmfToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "dtmf",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDtmfToolDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDtmfToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (c *CreateDtmfToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateDtmfToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateDtmfToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateDtmfToolDtoMessagesItem) Accept(visitor CreateDtmfToolDtoMessagesItemVisitor) error {
	if c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateElevenLabsCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateElevenLabsCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateElevenLabsCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateElevenLabsCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateElevenLabsCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateElevenLabsCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "11labs", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateElevenLabsCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateElevenLabsCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (c *CreateElevenLabsCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEndCallToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateEndCallToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateEndCallToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateEndCallToolDto) Type() string {
	return c.type_
}

func (c *CreateEndCallToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateEndCallToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateEndCallToolDto(unmarshaler.embed)
	if unmarshaler.Type != "endCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "endCall", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEndCallToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateEndCallToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "endCall",
	}
	return json.Marshal(marshaler)
}

func (c *CreateEndCallToolDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEndCallToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (c *CreateEndCallToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEndCallToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateEndCallToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateEndCallToolDtoMessagesItem) Accept(visitor CreateEndCallToolDtoMessagesItemVisitor) error {
	if c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateFunctionToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateFunctionToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateFunctionToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateFunctionToolDto) Type() string {
	return c.type_
}

func (c *CreateFunctionToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateFunctionToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateFunctionToolDto(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "function", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateFunctionToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateFunctionToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (c *CreateFunctionToolDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateFunctionToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (c *CreateFunctionToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateFunctionToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateFunctionToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateFunctionToolDtoMessagesItem) Accept(visitor CreateFunctionToolDtoMessagesItemVisitor) error {
	if c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGcpCredentialDto struct {
	// This is the name of the GCP credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.
	//
	// The schema is identical to the JSON that GCP outputs.
	GcpKey *GcpKey `json:"gcpKey,omitempty" url:"gcpKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in GCP.
	BucketPlan *BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateGcpCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGcpCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGcpCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGcpCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGcpCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gcp" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gcp", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGcpCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGcpCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "gcp",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGcpCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGhlToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateGhlToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata *GhlToolMetadata                `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateGhlToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGhlToolDto) Type() string {
	return c.type_
}

func (c *CreateGhlToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateGhlToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGhlToolDto(unmarshaler.embed)
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "ghl", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGhlToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateGhlToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "ghl",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGhlToolDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGhlToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (c *CreateGhlToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateGhlToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGhlToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateGhlToolDtoMessagesItem) Accept(visitor CreateGhlToolDtoMessagesItemVisitor) error {
	if c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGladiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateGladiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGladiaCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGladiaCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGladiaCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGladiaCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gladia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGladiaCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGladiaCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "gladia",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGladiaCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoHighLevelCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateGoHighLevelCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoHighLevelCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGoHighLevelCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoHighLevelCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoHighLevelCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gohighlevel" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gohighlevel", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoHighLevelCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoHighLevelCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "gohighlevel",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoHighLevelCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGroqCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateGroqCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGroqCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGroqCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGroqCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGroqCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "groq" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "groq", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGroqCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGroqCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "groq",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGroqCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLmntCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateLmntCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLmntCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateLmntCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateLmntCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateLmntCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "lmnt", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLmntCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateLmntCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "lmnt",
	}
	return json.Marshal(marshaler)
}

func (c *CreateLmntCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateMakeCredentialDto struct {
	// Team ID
	TeamId string `json:"teamId" url:"teamId"`
	// Region of your application. For example: eu1, eu2, us1, us2
	Region string `json:"region" url:"region"`
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateMakeCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMakeCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateMakeCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateMakeCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateMakeCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "make", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMakeCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateMakeCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "make",
	}
	return json.Marshal(marshaler)
}

func (c *CreateMakeCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateMakeToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateMakeToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata *MakeToolMetadata                `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateMakeToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMakeToolDto) Type() string {
	return c.type_
}

func (c *CreateMakeToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateMakeToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateMakeToolDto(unmarshaler.embed)
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "make", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMakeToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateMakeToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "make",
	}
	return json.Marshal(marshaler)
}

func (c *CreateMakeToolDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateMakeToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (c *CreateMakeToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateMakeToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateMakeToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateMakeToolDtoMessagesItem) Accept(visitor CreateMakeToolDtoMessagesItemVisitor) error {
	if c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateOpenAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOpenAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateOpenAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateOpenAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "openai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOpenAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateOpenAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateOpenAiCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOpenRouterCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOpenRouterCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOpenRouterCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateOpenRouterCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateOpenRouterCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateOpenRouterCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "openrouter" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "openrouter", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOpenRouterCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateOpenRouterCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "openrouter",
	}
	return json.Marshal(marshaler)
}

func (c *CreateOpenRouterCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOrgDto struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	// When HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.
	// This is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// This is the name of the org. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.
	BillingLimit *float64 `json:"billingLimit,omitempty" url:"billingLimit,omitempty"`
	// This is the URL Vapi will communicate with via HTTP GET and POST Requests. This is used for retrieving context, function calling, and end-of-call reports.
	//
	// All requests will be sent with the call object among other things relevant to that message. You can find more details in the Server URL documentation.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	// This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.
	ConcurrencyLimit *float64 `json:"concurrencyLimit,omitempty" url:"concurrencyLimit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOrgDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrgDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrgDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrgDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrgDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOutboundCallDto struct {
	// This is the name of the call. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the overrides for the `assistant` or `assistantId`'s settings and template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the call. To use a transient squad, use `squad` instead.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// This is the phone number that will be used for the call. To use a transient number, use `phoneNumber` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneNumberId *string `json:"phoneNumberId,omitempty" url:"phoneNumberId,omitempty"`
	// This is the phone number that will be used for the call. To use an existing number, use `phoneNumberId` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneNumber *ImportTwilioPhoneNumberDto `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the customer that will be called. To call a transient customer , use `customer` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	CustomerId *string `json:"customerId,omitempty" url:"customerId,omitempty"`
	// This is the customer that will be called. To call an existing customer, use `customerId` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOutboundCallDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOutboundCallDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOutboundCallDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOutboundCallDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOutboundCallDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOutputToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateOutputToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOutputToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOutputToolDto) Type() string {
	return c.type_
}

func (c *CreateOutputToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateOutputToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateOutputToolDto(unmarshaler.embed)
	if unmarshaler.Type != "output" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "output", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOutputToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateOutputToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "output",
	}
	return json.Marshal(marshaler)
}

func (c *CreateOutputToolDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOutputToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (c *CreateOutputToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateOutputToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateOutputToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateOutputToolDtoMessagesItem) Accept(visitor CreateOutputToolDtoMessagesItemVisitor) error {
	if c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreatePerplexityAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreatePerplexityAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePerplexityAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreatePerplexityAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreatePerplexityAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreatePerplexityAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "perplexity-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "perplexity-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePerplexityAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreatePerplexityAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "perplexity-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreatePerplexityAiCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreatePlayHtCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	UserId   string `json:"userId" url:"userId"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreatePlayHtCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePlayHtCredentialDto) Provider() string {
	return c.provider
}

func (c *CreatePlayHtCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreatePlayHtCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreatePlayHtCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "playht", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePlayHtCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreatePlayHtCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "playht",
	}
	return json.Marshal(marshaler)
}

func (c *CreatePlayHtCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateRimeAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateRimeAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateRimeAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateRimeAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateRimeAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateRimeAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "rime-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateRimeAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateRimeAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateRimeAiCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateRunpodCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateRunpodCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateRunpodCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateRunpodCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateRunpodCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateRunpodCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "runpod" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "runpod", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateRunpodCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateRunpodCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "runpod",
	}
	return json.Marshal(marshaler)
}

func (c *CreateRunpodCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateS3CredentialDto struct {
	// Credential provider. Only allowed value is s3
	// AWS access key ID.
	AwsAccessKeyId string `json:"awsAccessKeyId" url:"awsAccessKeyId"`
	// AWS access key secret. This is not returned in the API.
	AwsSecretAccessKey string `json:"awsSecretAccessKey" url:"awsSecretAccessKey"`
	// AWS region in which the S3 bucket is located.
	Region string `json:"region" url:"region"`
	// AWS S3 bucket name.
	S3BucketName string `json:"s3BucketName" url:"s3BucketName"`
	// The path prefix for the uploaded recording. Ex. "recordings/"
	S3PathPrefix string `json:"s3PathPrefix" url:"s3PathPrefix"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateS3CredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateS3CredentialDto) Provider() string {
	return c.provider
}

func (c *CreateS3CredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateS3CredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateS3CredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "s3" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "s3", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateS3CredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateS3CredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "s3",
	}
	return json.Marshal(marshaler)
}

func (c *CreateS3CredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSquadDto struct {
	// This is the name of the squad.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the list of assistants that make up the squad.
	//
	// The call will start with the first assistant in the list.
	Members []*SquadMemberDto `json:"members,omitempty" url:"members,omitempty"`
	// This can be used to override all the assistants' settings and provide values for their template variables.
	//
	// Both `membersOverrides` and `members[n].assistantOverrides` can be used together. First, `members[n].assistantOverrides` is applied. Then, `membersOverrides` is applied as a global override.
	MembersOverrides *AssistantOverrides `json:"membersOverrides,omitempty" url:"membersOverrides,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateSquadDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSquadDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateSquadDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateSquadDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSquadDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTogetherAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTogetherAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTogetherAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateTogetherAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateTogetherAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTogetherAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "together-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "together-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTogetherAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateTogetherAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "together-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTogetherAiCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTokenDto struct {
	// This is the tag for the token. It represents its scope.
	Tag *CreateTokenDtoTag `json:"tag,omitempty" url:"tag,omitempty"`
	// This is the name of the token. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This are the restrictions for the token.
	Restrictions *TokenRestrictions `json:"restrictions,omitempty" url:"restrictions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTokenDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTokenDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTokenDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTokenDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTokenDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the tag for the token. It represents its scope.
type CreateTokenDtoTag string

const (
	CreateTokenDtoTagPrivate CreateTokenDtoTag = "private"
	CreateTokenDtoTagPublic  CreateTokenDtoTag = "public"
)

func NewCreateTokenDtoTagFromString(s string) (CreateTokenDtoTag, error) {
	switch s {
	case "private":
		return CreateTokenDtoTagPrivate, nil
	case "public":
		return CreateTokenDtoTagPublic, nil
	}
	var t CreateTokenDtoTag
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateTokenDtoTag) Ptr() *CreateTokenDtoTag {
	return &c
}

type CreateToolCallBlockDto struct {
	// These are the pre-configured messages that will be spoken to the user while the block is running.
	Messages []*CreateToolCallBlockDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the input schema for the block. This is the input the block needs to run. It's given to the block as `steps[0].input`
	//
	// These are accessible as variables:
	//
	// - ({{input.propertyName}}) in context of the block execution (step)
	// - ({{stepName.input.propertyName}}) in context of the workflow
	InputSchema *JsonSchema `json:"inputSchema,omitempty" url:"inputSchema,omitempty"`
	// This is the output schema for the block. This is the output the block will return to the workflow (`{{stepName.output}}`).
	//
	// These are accessible as variables:
	//
	// - ({{output.propertyName}}) in context of the block execution (step)
	// - ({{stepName.output.propertyName}}) in context of the workflow (read caveat #1)
	// - ({{blockName.output.propertyName}}) in context of the workflow (read caveat #2)
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	OutputSchema *JsonSchema `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	// This is the tool that the block will call. To use an existing tool, use `toolId`.
	Tool *CreateToolCallBlockDtoTool `json:"tool,omitempty" url:"tool,omitempty"`
	// This is the id of the tool that the block will call. To use a transient tool, use `tool`.
	ToolId *string `json:"toolId,omitempty" url:"toolId,omitempty"`
	// This is the name of the block. This is just for your reference.
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateToolCallBlockDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateToolCallBlockDto) Type() string {
	return c.type_
}

func (c *CreateToolCallBlockDto) UnmarshalJSON(data []byte) error {
	type embed CreateToolCallBlockDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateToolCallBlockDto(unmarshaler.embed)
	if unmarshaler.Type != "tool-call" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tool-call", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateToolCallBlockDto) MarshalJSON() ([]byte, error) {
	type embed CreateToolCallBlockDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "tool-call",
	}
	return json.Marshal(marshaler)
}

func (c *CreateToolCallBlockDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateToolCallBlockDtoMessagesItem struct {
	BlockStartMessage    *BlockStartMessage
	BlockCompleteMessage *BlockCompleteMessage
}

func (c *CreateToolCallBlockDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueBlockStartMessage := new(BlockStartMessage)
	if err := json.Unmarshal(data, &valueBlockStartMessage); err == nil {
		c.BlockStartMessage = valueBlockStartMessage
		return nil
	}
	valueBlockCompleteMessage := new(BlockCompleteMessage)
	if err := json.Unmarshal(data, &valueBlockCompleteMessage); err == nil {
		c.BlockCompleteMessage = valueBlockCompleteMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolCallBlockDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.BlockStartMessage != nil {
		return json.Marshal(c.BlockStartMessage)
	}
	if c.BlockCompleteMessage != nil {
		return json.Marshal(c.BlockCompleteMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolCallBlockDtoMessagesItemVisitor interface {
	VisitBlockStartMessage(*BlockStartMessage) error
	VisitBlockCompleteMessage(*BlockCompleteMessage) error
}

func (c *CreateToolCallBlockDtoMessagesItem) Accept(visitor CreateToolCallBlockDtoMessagesItemVisitor) error {
	if c.BlockStartMessage != nil {
		return visitor.VisitBlockStartMessage(c.BlockStartMessage)
	}
	if c.BlockCompleteMessage != nil {
		return visitor.VisitBlockCompleteMessage(c.BlockCompleteMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the tool that the block will call. To use an existing tool, use `toolId`.
type CreateToolCallBlockDtoTool struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (c *CreateToolCallBlockDtoTool) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		c.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		c.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		c.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		c.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		c.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		c.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		c.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolCallBlockDtoTool) MarshalJSON() ([]byte, error) {
	if c.CreateDtmfToolDto != nil {
		return json.Marshal(c.CreateDtmfToolDto)
	}
	if c.CreateEndCallToolDto != nil {
		return json.Marshal(c.CreateEndCallToolDto)
	}
	if c.CreateVoicemailToolDto != nil {
		return json.Marshal(c.CreateVoicemailToolDto)
	}
	if c.CreateFunctionToolDto != nil {
		return json.Marshal(c.CreateFunctionToolDto)
	}
	if c.CreateGhlToolDto != nil {
		return json.Marshal(c.CreateGhlToolDto)
	}
	if c.CreateMakeToolDto != nil {
		return json.Marshal(c.CreateMakeToolDto)
	}
	if c.CreateTransferCallToolDto != nil {
		return json.Marshal(c.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolCallBlockDtoToolVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (c *CreateToolCallBlockDtoTool) Accept(visitor CreateToolCallBlockDtoToolVisitor) error {
	if c.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(c.CreateDtmfToolDto)
	}
	if c.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(c.CreateEndCallToolDto)
	}
	if c.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(c.CreateVoicemailToolDto)
	}
	if c.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(c.CreateFunctionToolDto)
	}
	if c.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(c.CreateGhlToolDto)
	}
	if c.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(c.CreateMakeToolDto)
	}
	if c.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(c.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDto struct {
	Details         *CreateToolTemplateDtoDetails         `json:"details,omitempty" url:"details,omitempty"`
	ProviderDetails *CreateToolTemplateDtoProviderDetails `json:"providerDetails,omitempty" url:"providerDetails,omitempty"`
	Metadata        *ToolTemplateMetadata                 `json:"metadata,omitempty" url:"metadata,omitempty"`
	Visibility      *CreateToolTemplateDtoVisibility      `json:"visibility,omitempty" url:"visibility,omitempty"`
	// The name of the template. This is just for your own reference.
	Name     *string                        `json:"name,omitempty" url:"name,omitempty"`
	Provider *CreateToolTemplateDtoProvider `json:"provider,omitempty" url:"provider,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateToolTemplateDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateToolTemplateDto) Type() string {
	return c.type_
}

func (c *CreateToolTemplateDto) UnmarshalJSON(data []byte) error {
	type embed CreateToolTemplateDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateToolTemplateDto(unmarshaler.embed)
	if unmarshaler.Type != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tool", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateToolTemplateDto) MarshalJSON() ([]byte, error) {
	type embed CreateToolTemplateDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "tool",
	}
	return json.Marshal(marshaler)
}

func (c *CreateToolTemplateDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateToolTemplateDtoDetails struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (c *CreateToolTemplateDtoDetails) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		c.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		c.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		c.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		c.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		c.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		c.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		c.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolTemplateDtoDetails) MarshalJSON() ([]byte, error) {
	if c.CreateDtmfToolDto != nil {
		return json.Marshal(c.CreateDtmfToolDto)
	}
	if c.CreateEndCallToolDto != nil {
		return json.Marshal(c.CreateEndCallToolDto)
	}
	if c.CreateVoicemailToolDto != nil {
		return json.Marshal(c.CreateVoicemailToolDto)
	}
	if c.CreateFunctionToolDto != nil {
		return json.Marshal(c.CreateFunctionToolDto)
	}
	if c.CreateGhlToolDto != nil {
		return json.Marshal(c.CreateGhlToolDto)
	}
	if c.CreateMakeToolDto != nil {
		return json.Marshal(c.CreateMakeToolDto)
	}
	if c.CreateTransferCallToolDto != nil {
		return json.Marshal(c.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoDetailsVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (c *CreateToolTemplateDtoDetails) Accept(visitor CreateToolTemplateDtoDetailsVisitor) error {
	if c.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(c.CreateDtmfToolDto)
	}
	if c.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(c.CreateEndCallToolDto)
	}
	if c.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(c.CreateVoicemailToolDto)
	}
	if c.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(c.CreateFunctionToolDto)
	}
	if c.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(c.CreateGhlToolDto)
	}
	if c.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(c.CreateMakeToolDto)
	}
	if c.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(c.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoProvider string

const (
	CreateToolTemplateDtoProviderMake        CreateToolTemplateDtoProvider = "make"
	CreateToolTemplateDtoProviderGohighlevel CreateToolTemplateDtoProvider = "gohighlevel"
	CreateToolTemplateDtoProviderFunction    CreateToolTemplateDtoProvider = "function"
)

func NewCreateToolTemplateDtoProviderFromString(s string) (CreateToolTemplateDtoProvider, error) {
	switch s {
	case "make":
		return CreateToolTemplateDtoProviderMake, nil
	case "gohighlevel":
		return CreateToolTemplateDtoProviderGohighlevel, nil
	case "function":
		return CreateToolTemplateDtoProviderFunction, nil
	}
	var t CreateToolTemplateDtoProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateToolTemplateDtoProvider) Ptr() *CreateToolTemplateDtoProvider {
	return &c
}

type CreateToolTemplateDtoProviderDetails struct {
	MakeToolProviderDetails     *MakeToolProviderDetails
	GhlToolProviderDetails      *GhlToolProviderDetails
	FunctionToolProviderDetails *FunctionToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) UnmarshalJSON(data []byte) error {
	valueMakeToolProviderDetails := new(MakeToolProviderDetails)
	if err := json.Unmarshal(data, &valueMakeToolProviderDetails); err == nil {
		c.MakeToolProviderDetails = valueMakeToolProviderDetails
		return nil
	}
	valueGhlToolProviderDetails := new(GhlToolProviderDetails)
	if err := json.Unmarshal(data, &valueGhlToolProviderDetails); err == nil {
		c.GhlToolProviderDetails = valueGhlToolProviderDetails
		return nil
	}
	valueFunctionToolProviderDetails := new(FunctionToolProviderDetails)
	if err := json.Unmarshal(data, &valueFunctionToolProviderDetails); err == nil {
		c.FunctionToolProviderDetails = valueFunctionToolProviderDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolTemplateDtoProviderDetails) MarshalJSON() ([]byte, error) {
	if c.MakeToolProviderDetails != nil {
		return json.Marshal(c.MakeToolProviderDetails)
	}
	if c.GhlToolProviderDetails != nil {
		return json.Marshal(c.GhlToolProviderDetails)
	}
	if c.FunctionToolProviderDetails != nil {
		return json.Marshal(c.FunctionToolProviderDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoProviderDetailsVisitor interface {
	VisitMakeToolProviderDetails(*MakeToolProviderDetails) error
	VisitGhlToolProviderDetails(*GhlToolProviderDetails) error
	VisitFunctionToolProviderDetails(*FunctionToolProviderDetails) error
}

func (c *CreateToolTemplateDtoProviderDetails) Accept(visitor CreateToolTemplateDtoProviderDetailsVisitor) error {
	if c.MakeToolProviderDetails != nil {
		return visitor.VisitMakeToolProviderDetails(c.MakeToolProviderDetails)
	}
	if c.GhlToolProviderDetails != nil {
		return visitor.VisitGhlToolProviderDetails(c.GhlToolProviderDetails)
	}
	if c.FunctionToolProviderDetails != nil {
		return visitor.VisitFunctionToolProviderDetails(c.FunctionToolProviderDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoVisibility string

const (
	CreateToolTemplateDtoVisibilityPublic  CreateToolTemplateDtoVisibility = "public"
	CreateToolTemplateDtoVisibilityPrivate CreateToolTemplateDtoVisibility = "private"
)

func NewCreateToolTemplateDtoVisibilityFromString(s string) (CreateToolTemplateDtoVisibility, error) {
	switch s {
	case "public":
		return CreateToolTemplateDtoVisibilityPublic, nil
	case "private":
		return CreateToolTemplateDtoVisibilityPrivate, nil
	}
	var t CreateToolTemplateDtoVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateToolTemplateDtoVisibility) Ptr() *CreateToolTemplateDtoVisibility {
	return &c
}

type CreateTransferCallToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateTransferCallToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.
	Destinations []*CreateTransferCallToolDtoDestinationsItem `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTransferCallToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTransferCallToolDto) Type() string {
	return c.type_
}

func (c *CreateTransferCallToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateTransferCallToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTransferCallToolDto(unmarshaler.embed)
	if unmarshaler.Type != "transferCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "transferCall", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTransferCallToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateTransferCallToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "transferCall",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTransferCallToolDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTransferCallToolDtoDestinationsItem struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationStep      *TransferDestinationStep
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip
}

func (c *CreateTransferCallToolDtoDestinationsItem) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		c.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationStep := new(TransferDestinationStep)
	if err := json.Unmarshal(data, &valueTransferDestinationStep); err == nil {
		c.TransferDestinationStep = valueTransferDestinationStep
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTransferCallToolDtoDestinationsItem) MarshalJSON() ([]byte, error) {
	if c.TransferDestinationAssistant != nil {
		return json.Marshal(c.TransferDestinationAssistant)
	}
	if c.TransferDestinationStep != nil {
		return json.Marshal(c.TransferDestinationStep)
	}
	if c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTransferCallToolDtoDestinationsItemVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationStep(*TransferDestinationStep) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *CreateTransferCallToolDtoDestinationsItem) Accept(visitor CreateTransferCallToolDtoDestinationsItemVisitor) error {
	if c.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(c.TransferDestinationAssistant)
	}
	if c.TransferDestinationStep != nil {
		return visitor.VisitTransferDestinationStep(c.TransferDestinationStep)
	}
	if c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTransferCallToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (c *CreateTransferCallToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTransferCallToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTransferCallToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateTransferCallToolDtoMessagesItem) Accept(visitor CreateTransferCallToolDtoMessagesItemVisitor) error {
	if c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTwilioCredentialDto struct {
	// This is not returned in the API.
	AuthToken  string `json:"authToken" url:"authToken"`
	AccountSid string `json:"accountSid" url:"accountSid"`
	provider   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTwilioCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTwilioCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateTwilioCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateTwilioCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTwilioCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "twilio", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTwilioCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateTwilioCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTwilioCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTwilioPhoneNumberDto struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *CreateTwilioPhoneNumberDtoFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// These are the digits of the phone number you own on your Twilio.
	Number string `json:"number" url:"number"`
	// This is the Twilio Account SID for the phone number.
	TwilioAccountSid string `json:"twilioAccountSid" url:"twilioAccountSid"`
	// This is the Twilio Auth Token for the phone number.
	TwilioAuthToken string `json:"twilioAuthToken" url:"twilioAuthToken"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	provider        string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTwilioPhoneNumberDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTwilioPhoneNumberDto) Provider() string {
	return c.provider
}

func (c *CreateTwilioPhoneNumberDto) UnmarshalJSON(data []byte) error {
	type embed CreateTwilioPhoneNumberDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTwilioPhoneNumberDto(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "twilio", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTwilioPhoneNumberDto) MarshalJSON() ([]byte, error) {
	type embed CreateTwilioPhoneNumberDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTwilioPhoneNumberDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type CreateTwilioPhoneNumberDtoFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (c *CreateTwilioPhoneNumberDtoFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTwilioPhoneNumberDtoFallbackDestination) MarshalJSON() ([]byte, error) {
	if c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTwilioPhoneNumberDtoFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *CreateTwilioPhoneNumberDtoFallbackDestination) Accept(visitor CreateTwilioPhoneNumberDtoFallbackDestinationVisitor) error {
	if c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateVapiPhoneNumberDto struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *CreateVapiPhoneNumberDtoFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// This is the SIP URI of the phone number. You can SIP INVITE this. The assistant attached to this number will answer.
	//
	// This is case-insensitive.
	SipUri string `json:"sipUri" url:"sipUri"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	provider        string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateVapiPhoneNumberDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateVapiPhoneNumberDto) Provider() string {
	return c.provider
}

func (c *CreateVapiPhoneNumberDto) UnmarshalJSON(data []byte) error {
	type embed CreateVapiPhoneNumberDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateVapiPhoneNumberDto(unmarshaler.embed)
	if unmarshaler.Provider != "vapi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "vapi", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateVapiPhoneNumberDto) MarshalJSON() ([]byte, error) {
	type embed CreateVapiPhoneNumberDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "vapi",
	}
	return json.Marshal(marshaler)
}

func (c *CreateVapiPhoneNumberDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type CreateVapiPhoneNumberDtoFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (c *CreateVapiPhoneNumberDtoFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateVapiPhoneNumberDtoFallbackDestination) MarshalJSON() ([]byte, error) {
	if c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateVapiPhoneNumberDtoFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *CreateVapiPhoneNumberDtoFallbackDestination) Accept(visitor CreateVapiPhoneNumberDtoFallbackDestinationVisitor) error {
	if c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateVoicemailToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateVoicemailToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "voicemail". This uses the model itself to determine if a voicemil was reached. Can be used alternatively/alongside with TwilioVoicemailDetection
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateVoicemailToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateVoicemailToolDto) Type() string {
	return c.type_
}

func (c *CreateVoicemailToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateVoicemailToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateVoicemailToolDto(unmarshaler.embed)
	if unmarshaler.Type != "voicemail" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "voicemail", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateVoicemailToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateVoicemailToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "voicemail",
	}
	return json.Marshal(marshaler)
}

func (c *CreateVoicemailToolDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateVoicemailToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (c *CreateVoicemailToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateVoicemailToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateVoicemailToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateVoicemailToolDtoMessagesItem) Accept(visitor CreateVoicemailToolDtoMessagesItemVisitor) error {
	if c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateVonageCredentialDto struct {
	// This is not returned in the API.
	ApiSecret string `json:"apiSecret" url:"apiSecret"`
	ApiKey    string `json:"apiKey" url:"apiKey"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateVonageCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateVonageCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateVonageCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateVonageCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateVonageCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "vonage" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "vonage", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateVonageCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateVonageCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "vonage",
	}
	return json.Marshal(marshaler)
}

func (c *CreateVonageCredentialDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateVonagePhoneNumberDto struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *CreateVonagePhoneNumberDtoFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// These are the digits of the phone number you own on your Vonage.
	Number string `json:"number" url:"number"`
	// This is the credential that is used to make outgoing calls, and do operations like call transfer and hang up.
	CredentialId string `json:"credentialId" url:"credentialId"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	provider        string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateVonagePhoneNumberDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateVonagePhoneNumberDto) Provider() string {
	return c.provider
}

func (c *CreateVonagePhoneNumberDto) UnmarshalJSON(data []byte) error {
	type embed CreateVonagePhoneNumberDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateVonagePhoneNumberDto(unmarshaler.embed)
	if unmarshaler.Provider != "vonage" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "vonage", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateVonagePhoneNumberDto) MarshalJSON() ([]byte, error) {
	type embed CreateVonagePhoneNumberDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "vonage",
	}
	return json.Marshal(marshaler)
}

func (c *CreateVonagePhoneNumberDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type CreateVonagePhoneNumberDtoFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (c *CreateVonagePhoneNumberDtoFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateVonagePhoneNumberDtoFallbackDestination) MarshalJSON() ([]byte, error) {
	if c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateVonagePhoneNumberDtoFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *CreateVonagePhoneNumberDtoFallbackDestination) Accept(visitor CreateVonagePhoneNumberDtoFallbackDestinationVisitor) error {
	if c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateWebCallDto struct {
	// This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the overrides for the `assistant` or `assistantId`'s settings and template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the call. To use a transient squad, use `squad` instead.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateWebCallDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWebCallDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateWebCallDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateWebCallDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWebCallDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateWorkflowBlockDto struct {
	// These are the pre-configured messages that will be spoken to the user while the block is running.
	Messages []*CreateWorkflowBlockDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the input schema for the block. This is the input the block needs to run. It's given to the block as `steps[0].input`
	//
	// These are accessible as variables:
	//
	// - ({{input.propertyName}}) in context of the block execution (step)
	// - ({{stepName.input.propertyName}}) in context of the workflow
	InputSchema *JsonSchema `json:"inputSchema,omitempty" url:"inputSchema,omitempty"`
	// This is the output schema for the block. This is the output the block will return to the workflow (`{{stepName.output}}`).
	//
	// These are accessible as variables:
	//
	// - ({{output.propertyName}}) in context of the block execution (step)
	// - ({{stepName.output.propertyName}}) in context of the workflow (read caveat #1)
	// - ({{blockName.output.propertyName}}) in context of the workflow (read caveat #2)
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	OutputSchema *JsonSchema `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	// These are the steps in the workflow.
	Steps []*CreateWorkflowBlockDtoStepsItem `json:"steps,omitempty" url:"steps,omitempty"`
	// This is the name of the block. This is just for your reference.
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateWorkflowBlockDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWorkflowBlockDto) Type() string {
	return c.type_
}

func (c *CreateWorkflowBlockDto) UnmarshalJSON(data []byte) error {
	type embed CreateWorkflowBlockDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateWorkflowBlockDto(unmarshaler.embed)
	if unmarshaler.Type != "workflow" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "workflow", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWorkflowBlockDto) MarshalJSON() ([]byte, error) {
	type embed CreateWorkflowBlockDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "workflow",
	}
	return json.Marshal(marshaler)
}

func (c *CreateWorkflowBlockDto) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateWorkflowBlockDtoMessagesItem struct {
	BlockStartMessage    *BlockStartMessage
	BlockCompleteMessage *BlockCompleteMessage
}

func (c *CreateWorkflowBlockDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueBlockStartMessage := new(BlockStartMessage)
	if err := json.Unmarshal(data, &valueBlockStartMessage); err == nil {
		c.BlockStartMessage = valueBlockStartMessage
		return nil
	}
	valueBlockCompleteMessage := new(BlockCompleteMessage)
	if err := json.Unmarshal(data, &valueBlockCompleteMessage); err == nil {
		c.BlockCompleteMessage = valueBlockCompleteMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateWorkflowBlockDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.BlockStartMessage != nil {
		return json.Marshal(c.BlockStartMessage)
	}
	if c.BlockCompleteMessage != nil {
		return json.Marshal(c.BlockCompleteMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateWorkflowBlockDtoMessagesItemVisitor interface {
	VisitBlockStartMessage(*BlockStartMessage) error
	VisitBlockCompleteMessage(*BlockCompleteMessage) error
}

func (c *CreateWorkflowBlockDtoMessagesItem) Accept(visitor CreateWorkflowBlockDtoMessagesItemVisitor) error {
	if c.BlockStartMessage != nil {
		return visitor.VisitBlockStartMessage(c.BlockStartMessage)
	}
	if c.BlockCompleteMessage != nil {
		return visitor.VisitBlockCompleteMessage(c.BlockCompleteMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateWorkflowBlockDtoStepsItem struct {
	HandoffStep  *HandoffStep
	CallbackStep *CallbackStep
}

func (c *CreateWorkflowBlockDtoStepsItem) UnmarshalJSON(data []byte) error {
	valueHandoffStep := new(HandoffStep)
	if err := json.Unmarshal(data, &valueHandoffStep); err == nil {
		c.HandoffStep = valueHandoffStep
		return nil
	}
	valueCallbackStep := new(CallbackStep)
	if err := json.Unmarshal(data, &valueCallbackStep); err == nil {
		c.CallbackStep = valueCallbackStep
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateWorkflowBlockDtoStepsItem) MarshalJSON() ([]byte, error) {
	if c.HandoffStep != nil {
		return json.Marshal(c.HandoffStep)
	}
	if c.CallbackStep != nil {
		return json.Marshal(c.CallbackStep)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateWorkflowBlockDtoStepsItemVisitor interface {
	VisitHandoffStep(*HandoffStep) error
	VisitCallbackStep(*CallbackStep) error
}

func (c *CreateWorkflowBlockDtoStepsItem) Accept(visitor CreateWorkflowBlockDtoStepsItemVisitor) error {
	if c.HandoffStep != nil {
		return visitor.VisitHandoffStep(c.HandoffStep)
	}
	if c.CallbackStep != nil {
		return visitor.VisitCallbackStep(c.CallbackStep)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CustomLlmCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomLlmCredential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomLlmCredential) Provider() string {
	return c.provider
}

func (c *CustomLlmCredential) UnmarshalJSON(data []byte) error {
	type embed CustomLlmCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomLlmCredential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-llm", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomLlmCredential) MarshalJSON() ([]byte, error) {
	type embed CustomLlmCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		Provider:  "custom-llm",
	}
	return json.Marshal(marshaler)
}

func (c *CustomLlmCredential) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomLlmModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*CustomLlmModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// This is the provider that will be used for the model. Any service, including your own server, that is compatible with the OpenAI API can be used.
	// This determines whether metadata is sent in requests to the custom provider.
	//
	// - `off` will not send any metadata. payload will look like `{ messages }`
	// - `variable` will send `assistant.metadata` as a variable on the payload. payload will look like `{ messages, metadata }`
	// - `destructured` will send `assistant.metadata` fields directly on the payload. payload will look like `{ messages, ...metadata }`
	//
	// Further, `variable` and `destructured` will send `call`, `phoneNumber`, and `customer` objects in the payload.
	//
	// Default is `variable`.
	MetadataSendMode *CustomLlmModelMetadataSendMode `json:"metadataSendMode,omitempty" url:"metadataSendMode,omitempty"`
	// These is the URL we'll use for the OpenAI client's `baseURL`. Ex. https://openrouter.ai/api/v1
	Url string `json:"url" url:"url"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *KnowledgeBase `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomLlmModel) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomLlmModel) Provider() string {
	return c.provider
}

func (c *CustomLlmModel) UnmarshalJSON(data []byte) error {
	type embed CustomLlmModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomLlmModel(unmarshaler.embed)
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-llm", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomLlmModel) MarshalJSON() ([]byte, error) {
	type embed CustomLlmModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-llm",
	}
	return json.Marshal(marshaler)
}

func (c *CustomLlmModel) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This determines whether metadata is sent in requests to the custom provider.
//
// - `off` will not send any metadata. payload will look like `{ messages }`
// - `variable` will send `assistant.metadata` as a variable on the payload. payload will look like `{ messages, metadata }`
// - `destructured` will send `assistant.metadata` fields directly on the payload. payload will look like `{ messages, ...metadata }`
//
// Further, `variable` and `destructured` will send `call`, `phoneNumber`, and `customer` objects in the payload.
//
// Default is `variable`.
type CustomLlmModelMetadataSendMode string

const (
	CustomLlmModelMetadataSendModeOff          CustomLlmModelMetadataSendMode = "off"
	CustomLlmModelMetadataSendModeVariable     CustomLlmModelMetadataSendMode = "variable"
	CustomLlmModelMetadataSendModeDestructured CustomLlmModelMetadataSendMode = "destructured"
)

func NewCustomLlmModelMetadataSendModeFromString(s string) (CustomLlmModelMetadataSendMode, error) {
	switch s {
	case "off":
		return CustomLlmModelMetadataSendModeOff, nil
	case "variable":
		return CustomLlmModelMetadataSendModeVariable, nil
	case "destructured":
		return CustomLlmModelMetadataSendModeDestructured, nil
	}
	var t CustomLlmModelMetadataSendMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomLlmModelMetadataSendMode) Ptr() *CustomLlmModelMetadataSendMode {
	return &c
}

type CustomLlmModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (c *CustomLlmModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		c.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		c.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		c.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		c.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		c.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		c.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		c.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CustomLlmModelToolsItem) MarshalJSON() ([]byte, error) {
	if c.CreateDtmfToolDto != nil {
		return json.Marshal(c.CreateDtmfToolDto)
	}
	if c.CreateEndCallToolDto != nil {
		return json.Marshal(c.CreateEndCallToolDto)
	}
	if c.CreateVoicemailToolDto != nil {
		return json.Marshal(c.CreateVoicemailToolDto)
	}
	if c.CreateFunctionToolDto != nil {
		return json.Marshal(c.CreateFunctionToolDto)
	}
	if c.CreateGhlToolDto != nil {
		return json.Marshal(c.CreateGhlToolDto)
	}
	if c.CreateMakeToolDto != nil {
		return json.Marshal(c.CreateMakeToolDto)
	}
	if c.CreateTransferCallToolDto != nil {
		return json.Marshal(c.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CustomLlmModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (c *CustomLlmModelToolsItem) Accept(visitor CustomLlmModelToolsItemVisitor) error {
	if c.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(c.CreateDtmfToolDto)
	}
	if c.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(c.CreateEndCallToolDto)
	}
	if c.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(c.CreateVoicemailToolDto)
	}
	if c.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(c.CreateFunctionToolDto)
	}
	if c.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(c.CreateGhlToolDto)
	}
	if c.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(c.CreateMakeToolDto)
	}
	if c.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(c.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type DeepInfraCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeepInfraCredential) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepInfraCredential) Provider() string {
	return d.provider
}

func (d *DeepInfraCredential) UnmarshalJSON(data []byte) error {
	type embed DeepInfraCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepInfraCredential(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "deepinfra" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepinfra", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepInfraCredential) MarshalJSON() ([]byte, error) {
	type embed DeepInfraCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*d),
		CreatedAt: core.NewDateTime(d.CreatedAt),
		UpdatedAt: core.NewDateTime(d.UpdatedAt),
		Provider:  "deepinfra",
	}
	return json.Marshal(marshaler)
}

func (d *DeepInfraCredential) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepInfraModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*DeepInfraModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *KnowledgeBase `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeepInfraModel) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepInfraModel) Provider() string {
	return d.provider
}

func (d *DeepInfraModel) UnmarshalJSON(data []byte) error {
	type embed DeepInfraModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepInfraModel(unmarshaler.embed)
	if unmarshaler.Provider != "deepinfra" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepinfra", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepInfraModel) MarshalJSON() ([]byte, error) {
	type embed DeepInfraModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Provider: "deepinfra",
	}
	return json.Marshal(marshaler)
}

func (d *DeepInfraModel) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepInfraModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (d *DeepInfraModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		d.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		d.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		d.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		d.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		d.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		d.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		d.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeepInfraModelToolsItem) MarshalJSON() ([]byte, error) {
	if d.CreateDtmfToolDto != nil {
		return json.Marshal(d.CreateDtmfToolDto)
	}
	if d.CreateEndCallToolDto != nil {
		return json.Marshal(d.CreateEndCallToolDto)
	}
	if d.CreateVoicemailToolDto != nil {
		return json.Marshal(d.CreateVoicemailToolDto)
	}
	if d.CreateFunctionToolDto != nil {
		return json.Marshal(d.CreateFunctionToolDto)
	}
	if d.CreateGhlToolDto != nil {
		return json.Marshal(d.CreateGhlToolDto)
	}
	if d.CreateMakeToolDto != nil {
		return json.Marshal(d.CreateMakeToolDto)
	}
	if d.CreateTransferCallToolDto != nil {
		return json.Marshal(d.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepInfraModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (d *DeepInfraModelToolsItem) Accept(visitor DeepInfraModelToolsItemVisitor) error {
	if d.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(d.CreateDtmfToolDto)
	}
	if d.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(d.CreateEndCallToolDto)
	}
	if d.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(d.CreateVoicemailToolDto)
	}
	if d.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(d.CreateFunctionToolDto)
	}
	if d.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(d.CreateGhlToolDto)
	}
	if d.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(d.CreateMakeToolDto)
	}
	if d.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(d.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepgramCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com.
	ApiUrl   *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeepgramCredential) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepgramCredential) Provider() string {
	return d.provider
}

func (d *DeepgramCredential) UnmarshalJSON(data []byte) error {
	type embed DeepgramCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepgramCredential(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepgram", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepgramCredential) MarshalJSON() ([]byte, error) {
	type embed DeepgramCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*d),
		CreatedAt: core.NewDateTime(d.CreatedAt),
		UpdatedAt: core.NewDateTime(d.UpdatedAt),
		Provider:  "deepgram",
	}
	return json.Marshal(marshaler)
}

func (d *DeepgramCredential) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepgramTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the Deepgram model that will be used. A list of models can be found here: https://developers.deepgram.com/docs/models-languages-overview
	Model *DeepgramTranscriberModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be set for the transcription. The list of languages Deepgram supports can be found here: https://developers.deepgram.com/docs/models-languages-overview
	Language *DeepgramTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This will be use smart format option provided by Deepgram. It's default disabled because it can sometimes format numbers as times but it's getting better.
	SmartFormat *bool `json:"smartFormat,omitempty" url:"smartFormat,omitempty"`
	// This enables or disables language detection. If true, swaps transcribers to detected language automatically. Defaults to false.
	LanguageDetectionEnabled *bool `json:"languageDetectionEnabled,omitempty" url:"languageDetectionEnabled,omitempty"`
	// These keywords are passed to the transcription model to help it pick up use-case specific words. Anything that may not be a common word, like your company name, should be added here.
	Keywords []string `json:"keywords,omitempty" url:"keywords,omitempty"`
	// This is the timeout after which Deepgram will send transcription on user silence. You can read in-depth documentation here: https://developers.deepgram.com/docs/endpointing.
	//
	// Here are the most important bits:
	//
	// - Defaults to 10. This is recommended for most use cases to optimize for latency.
	// - 10 can cause some missing transcriptions since because of the shorter context. This mostly happens for one-word utterances. For those uses cases, it's recommended to try 300. It will add a bit of latency but the quality and reliability of the experience will be better.
	// - If neither 10 nor 300 work, contact support@vapi.ai and we'll find another solution.
	//
	// @default 10
	Endpointing *float64 `json:"endpointing,omitempty" url:"endpointing,omitempty"`
	provider    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeepgramTranscriber) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepgramTranscriber) Provider() string {
	return d.provider
}

func (d *DeepgramTranscriber) UnmarshalJSON(data []byte) error {
	type embed DeepgramTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepgramTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepgram", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepgramTranscriber) MarshalJSON() ([]byte, error) {
	type embed DeepgramTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (d *DeepgramTranscriber) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepgramTranscriberLanguage string

const (
	DeepgramTranscriberLanguageBg      DeepgramTranscriberLanguage = "bg"
	DeepgramTranscriberLanguageCa      DeepgramTranscriberLanguage = "ca"
	DeepgramTranscriberLanguageCs      DeepgramTranscriberLanguage = "cs"
	DeepgramTranscriberLanguageDa      DeepgramTranscriberLanguage = "da"
	DeepgramTranscriberLanguageDaDk    DeepgramTranscriberLanguage = "da-DK"
	DeepgramTranscriberLanguageDe      DeepgramTranscriberLanguage = "de"
	DeepgramTranscriberLanguageDeCh    DeepgramTranscriberLanguage = "de-CH"
	DeepgramTranscriberLanguageEl      DeepgramTranscriberLanguage = "el"
	DeepgramTranscriberLanguageEn      DeepgramTranscriberLanguage = "en"
	DeepgramTranscriberLanguageEnAu    DeepgramTranscriberLanguage = "en-AU"
	DeepgramTranscriberLanguageEnGb    DeepgramTranscriberLanguage = "en-GB"
	DeepgramTranscriberLanguageEnIn    DeepgramTranscriberLanguage = "en-IN"
	DeepgramTranscriberLanguageEnNz    DeepgramTranscriberLanguage = "en-NZ"
	DeepgramTranscriberLanguageEnUs    DeepgramTranscriberLanguage = "en-US"
	DeepgramTranscriberLanguageEs      DeepgramTranscriberLanguage = "es"
	DeepgramTranscriberLanguageEs419   DeepgramTranscriberLanguage = "es-419"
	DeepgramTranscriberLanguageEsLatam DeepgramTranscriberLanguage = "es-LATAM"
	DeepgramTranscriberLanguageEt      DeepgramTranscriberLanguage = "et"
	DeepgramTranscriberLanguageFi      DeepgramTranscriberLanguage = "fi"
	DeepgramTranscriberLanguageFr      DeepgramTranscriberLanguage = "fr"
	DeepgramTranscriberLanguageFrCa    DeepgramTranscriberLanguage = "fr-CA"
	DeepgramTranscriberLanguageHi      DeepgramTranscriberLanguage = "hi"
	DeepgramTranscriberLanguageHiLatn  DeepgramTranscriberLanguage = "hi-Latn"
	DeepgramTranscriberLanguageHu      DeepgramTranscriberLanguage = "hu"
	DeepgramTranscriberLanguageId      DeepgramTranscriberLanguage = "id"
	DeepgramTranscriberLanguageIt      DeepgramTranscriberLanguage = "it"
	DeepgramTranscriberLanguageJa      DeepgramTranscriberLanguage = "ja"
	DeepgramTranscriberLanguageKo      DeepgramTranscriberLanguage = "ko"
	DeepgramTranscriberLanguageKoKr    DeepgramTranscriberLanguage = "ko-KR"
	DeepgramTranscriberLanguageLt      DeepgramTranscriberLanguage = "lt"
	DeepgramTranscriberLanguageLv      DeepgramTranscriberLanguage = "lv"
	DeepgramTranscriberLanguageMs      DeepgramTranscriberLanguage = "ms"
	DeepgramTranscriberLanguageMulti   DeepgramTranscriberLanguage = "multi"
	DeepgramTranscriberLanguageNl      DeepgramTranscriberLanguage = "nl"
	DeepgramTranscriberLanguageNlBe    DeepgramTranscriberLanguage = "nl-BE"
	DeepgramTranscriberLanguageNo      DeepgramTranscriberLanguage = "no"
	DeepgramTranscriberLanguagePl      DeepgramTranscriberLanguage = "pl"
	DeepgramTranscriberLanguagePt      DeepgramTranscriberLanguage = "pt"
	DeepgramTranscriberLanguagePtBr    DeepgramTranscriberLanguage = "pt-BR"
	DeepgramTranscriberLanguageRo      DeepgramTranscriberLanguage = "ro"
	DeepgramTranscriberLanguageRu      DeepgramTranscriberLanguage = "ru"
	DeepgramTranscriberLanguageSk      DeepgramTranscriberLanguage = "sk"
	DeepgramTranscriberLanguageSv      DeepgramTranscriberLanguage = "sv"
	DeepgramTranscriberLanguageSvSe    DeepgramTranscriberLanguage = "sv-SE"
	DeepgramTranscriberLanguageTa      DeepgramTranscriberLanguage = "ta"
	DeepgramTranscriberLanguageTaq     DeepgramTranscriberLanguage = "taq"
	DeepgramTranscriberLanguageTh      DeepgramTranscriberLanguage = "th"
	DeepgramTranscriberLanguageThTh    DeepgramTranscriberLanguage = "th-TH"
	DeepgramTranscriberLanguageTr      DeepgramTranscriberLanguage = "tr"
	DeepgramTranscriberLanguageUk      DeepgramTranscriberLanguage = "uk"
	DeepgramTranscriberLanguageVi      DeepgramTranscriberLanguage = "vi"
	DeepgramTranscriberLanguageZh      DeepgramTranscriberLanguage = "zh"
	DeepgramTranscriberLanguageZhCn    DeepgramTranscriberLanguage = "zh-CN"
	DeepgramTranscriberLanguageZhHans  DeepgramTranscriberLanguage = "zh-Hans"
	DeepgramTranscriberLanguageZhHant  DeepgramTranscriberLanguage = "zh-Hant"
	DeepgramTranscriberLanguageZhTw    DeepgramTranscriberLanguage = "zh-TW"
)

func NewDeepgramTranscriberLanguageFromString(s string) (DeepgramTranscriberLanguage, error) {
	switch s {
	case "bg":
		return DeepgramTranscriberLanguageBg, nil
	case "ca":
		return DeepgramTranscriberLanguageCa, nil
	case "cs":
		return DeepgramTranscriberLanguageCs, nil
	case "da":
		return DeepgramTranscriberLanguageDa, nil
	case "da-DK":
		return DeepgramTranscriberLanguageDaDk, nil
	case "de":
		return DeepgramTranscriberLanguageDe, nil
	case "de-CH":
		return DeepgramTranscriberLanguageDeCh, nil
	case "el":
		return DeepgramTranscriberLanguageEl, nil
	case "en":
		return DeepgramTranscriberLanguageEn, nil
	case "en-AU":
		return DeepgramTranscriberLanguageEnAu, nil
	case "en-GB":
		return DeepgramTranscriberLanguageEnGb, nil
	case "en-IN":
		return DeepgramTranscriberLanguageEnIn, nil
	case "en-NZ":
		return DeepgramTranscriberLanguageEnNz, nil
	case "en-US":
		return DeepgramTranscriberLanguageEnUs, nil
	case "es":
		return DeepgramTranscriberLanguageEs, nil
	case "es-419":
		return DeepgramTranscriberLanguageEs419, nil
	case "es-LATAM":
		return DeepgramTranscriberLanguageEsLatam, nil
	case "et":
		return DeepgramTranscriberLanguageEt, nil
	case "fi":
		return DeepgramTranscriberLanguageFi, nil
	case "fr":
		return DeepgramTranscriberLanguageFr, nil
	case "fr-CA":
		return DeepgramTranscriberLanguageFrCa, nil
	case "hi":
		return DeepgramTranscriberLanguageHi, nil
	case "hi-Latn":
		return DeepgramTranscriberLanguageHiLatn, nil
	case "hu":
		return DeepgramTranscriberLanguageHu, nil
	case "id":
		return DeepgramTranscriberLanguageId, nil
	case "it":
		return DeepgramTranscriberLanguageIt, nil
	case "ja":
		return DeepgramTranscriberLanguageJa, nil
	case "ko":
		return DeepgramTranscriberLanguageKo, nil
	case "ko-KR":
		return DeepgramTranscriberLanguageKoKr, nil
	case "lt":
		return DeepgramTranscriberLanguageLt, nil
	case "lv":
		return DeepgramTranscriberLanguageLv, nil
	case "ms":
		return DeepgramTranscriberLanguageMs, nil
	case "multi":
		return DeepgramTranscriberLanguageMulti, nil
	case "nl":
		return DeepgramTranscriberLanguageNl, nil
	case "nl-BE":
		return DeepgramTranscriberLanguageNlBe, nil
	case "no":
		return DeepgramTranscriberLanguageNo, nil
	case "pl":
		return DeepgramTranscriberLanguagePl, nil
	case "pt":
		return DeepgramTranscriberLanguagePt, nil
	case "pt-BR":
		return DeepgramTranscriberLanguagePtBr, nil
	case "ro":
		return DeepgramTranscriberLanguageRo, nil
	case "ru":
		return DeepgramTranscriberLanguageRu, nil
	case "sk":
		return DeepgramTranscriberLanguageSk, nil
	case "sv":
		return DeepgramTranscriberLanguageSv, nil
	case "sv-SE":
		return DeepgramTranscriberLanguageSvSe, nil
	case "ta":
		return DeepgramTranscriberLanguageTa, nil
	case "taq":
		return DeepgramTranscriberLanguageTaq, nil
	case "th":
		return DeepgramTranscriberLanguageTh, nil
	case "th-TH":
		return DeepgramTranscriberLanguageThTh, nil
	case "tr":
		return DeepgramTranscriberLanguageTr, nil
	case "uk":
		return DeepgramTranscriberLanguageUk, nil
	case "vi":
		return DeepgramTranscriberLanguageVi, nil
	case "zh":
		return DeepgramTranscriberLanguageZh, nil
	case "zh-CN":
		return DeepgramTranscriberLanguageZhCn, nil
	case "zh-Hans":
		return DeepgramTranscriberLanguageZhHans, nil
	case "zh-Hant":
		return DeepgramTranscriberLanguageZhHant, nil
	case "zh-TW":
		return DeepgramTranscriberLanguageZhTw, nil
	}
	var t DeepgramTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeepgramTranscriberLanguage) Ptr() *DeepgramTranscriberLanguage {
	return &d
}

type DeepgramTranscriberModel string

const (
	DeepgramTranscriberModelNova2                 DeepgramTranscriberModel = "nova-2"
	DeepgramTranscriberModelNova2General          DeepgramTranscriberModel = "nova-2-general"
	DeepgramTranscriberModelNova2Meeting          DeepgramTranscriberModel = "nova-2-meeting"
	DeepgramTranscriberModelNova2Phonecall        DeepgramTranscriberModel = "nova-2-phonecall"
	DeepgramTranscriberModelNova2Finance          DeepgramTranscriberModel = "nova-2-finance"
	DeepgramTranscriberModelNova2Conversationalai DeepgramTranscriberModel = "nova-2-conversationalai"
	DeepgramTranscriberModelNova2Voicemail        DeepgramTranscriberModel = "nova-2-voicemail"
	DeepgramTranscriberModelNova2Video            DeepgramTranscriberModel = "nova-2-video"
	DeepgramTranscriberModelNova2Medical          DeepgramTranscriberModel = "nova-2-medical"
	DeepgramTranscriberModelNova2Drivethru        DeepgramTranscriberModel = "nova-2-drivethru"
	DeepgramTranscriberModelNova2Automotive       DeepgramTranscriberModel = "nova-2-automotive"
	DeepgramTranscriberModelNova                  DeepgramTranscriberModel = "nova"
	DeepgramTranscriberModelNovaGeneral           DeepgramTranscriberModel = "nova-general"
	DeepgramTranscriberModelNovaPhonecall         DeepgramTranscriberModel = "nova-phonecall"
	DeepgramTranscriberModelNovaMedical           DeepgramTranscriberModel = "nova-medical"
	DeepgramTranscriberModelEnhanced              DeepgramTranscriberModel = "enhanced"
	DeepgramTranscriberModelEnhancedGeneral       DeepgramTranscriberModel = "enhanced-general"
	DeepgramTranscriberModelEnhancedMeeting       DeepgramTranscriberModel = "enhanced-meeting"
	DeepgramTranscriberModelEnhancedPhonecall     DeepgramTranscriberModel = "enhanced-phonecall"
	DeepgramTranscriberModelEnhancedFinance       DeepgramTranscriberModel = "enhanced-finance"
	DeepgramTranscriberModelBase                  DeepgramTranscriberModel = "base"
	DeepgramTranscriberModelBaseGeneral           DeepgramTranscriberModel = "base-general"
	DeepgramTranscriberModelBaseMeeting           DeepgramTranscriberModel = "base-meeting"
	DeepgramTranscriberModelBasePhonecall         DeepgramTranscriberModel = "base-phonecall"
	DeepgramTranscriberModelBaseFinance           DeepgramTranscriberModel = "base-finance"
	DeepgramTranscriberModelBaseConversationalai  DeepgramTranscriberModel = "base-conversationalai"
	DeepgramTranscriberModelBaseVoicemail         DeepgramTranscriberModel = "base-voicemail"
	DeepgramTranscriberModelBaseVideo             DeepgramTranscriberModel = "base-video"
)

func NewDeepgramTranscriberModelFromString(s string) (DeepgramTranscriberModel, error) {
	switch s {
	case "nova-2":
		return DeepgramTranscriberModelNova2, nil
	case "nova-2-general":
		return DeepgramTranscriberModelNova2General, nil
	case "nova-2-meeting":
		return DeepgramTranscriberModelNova2Meeting, nil
	case "nova-2-phonecall":
		return DeepgramTranscriberModelNova2Phonecall, nil
	case "nova-2-finance":
		return DeepgramTranscriberModelNova2Finance, nil
	case "nova-2-conversationalai":
		return DeepgramTranscriberModelNova2Conversationalai, nil
	case "nova-2-voicemail":
		return DeepgramTranscriberModelNova2Voicemail, nil
	case "nova-2-video":
		return DeepgramTranscriberModelNova2Video, nil
	case "nova-2-medical":
		return DeepgramTranscriberModelNova2Medical, nil
	case "nova-2-drivethru":
		return DeepgramTranscriberModelNova2Drivethru, nil
	case "nova-2-automotive":
		return DeepgramTranscriberModelNova2Automotive, nil
	case "nova":
		return DeepgramTranscriberModelNova, nil
	case "nova-general":
		return DeepgramTranscriberModelNovaGeneral, nil
	case "nova-phonecall":
		return DeepgramTranscriberModelNovaPhonecall, nil
	case "nova-medical":
		return DeepgramTranscriberModelNovaMedical, nil
	case "enhanced":
		return DeepgramTranscriberModelEnhanced, nil
	case "enhanced-general":
		return DeepgramTranscriberModelEnhancedGeneral, nil
	case "enhanced-meeting":
		return DeepgramTranscriberModelEnhancedMeeting, nil
	case "enhanced-phonecall":
		return DeepgramTranscriberModelEnhancedPhonecall, nil
	case "enhanced-finance":
		return DeepgramTranscriberModelEnhancedFinance, nil
	case "base":
		return DeepgramTranscriberModelBase, nil
	case "base-general":
		return DeepgramTranscriberModelBaseGeneral, nil
	case "base-meeting":
		return DeepgramTranscriberModelBaseMeeting, nil
	case "base-phonecall":
		return DeepgramTranscriberModelBasePhonecall, nil
	case "base-finance":
		return DeepgramTranscriberModelBaseFinance, nil
	case "base-conversationalai":
		return DeepgramTranscriberModelBaseConversationalai, nil
	case "base-voicemail":
		return DeepgramTranscriberModelBaseVoicemail, nil
	case "base-video":
		return DeepgramTranscriberModelBaseVideo, nil
	}
	var t DeepgramTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeepgramTranscriberModel) Ptr() *DeepgramTranscriberModel {
	return &d
}

type DeepgramVoice struct {
	// This determines whether fillers are injected into the model output before inputting it into the voice provider.
	//
	// Default `false` because you can achieve better results with prompting the model.
	FillerInjectionEnabled *bool `json:"fillerInjectionEnabled,omitempty" url:"fillerInjectionEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *DeepgramVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeepgramVoice) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepgramVoice) Provider() string {
	return d.provider
}

func (d *DeepgramVoice) UnmarshalJSON(data []byte) error {
	type embed DeepgramVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepgramVoice(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepgram", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepgramVoice) MarshalJSON() ([]byte, error) {
	type embed DeepgramVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (d *DeepgramVoice) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// This is the provider-specific ID that will be used.
type DeepgramVoiceVoiceId struct {
	asteriaStringLiteral string
	lunaStringLiteral    string
	stellaStringLiteral  string
	athenaStringLiteral  string
	heraStringLiteral    string
	orionStringLiteral   string
	arcasStringLiteral   string
	perseusStringLiteral string
	angusStringLiteral   string
	orpheusStringLiteral string
	heliosStringLiteral  string
	zeusStringLiteral    string
	String               string
}

func NewDeepgramVoiceVoiceIdWithAsteriaStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{asteriaStringLiteral: "asteria"}
}

func NewDeepgramVoiceVoiceIdWithLunaStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{lunaStringLiteral: "luna"}
}

func NewDeepgramVoiceVoiceIdWithStellaStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{stellaStringLiteral: "stella"}
}

func NewDeepgramVoiceVoiceIdWithAthenaStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{athenaStringLiteral: "athena"}
}

func NewDeepgramVoiceVoiceIdWithHeraStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{heraStringLiteral: "hera"}
}

func NewDeepgramVoiceVoiceIdWithOrionStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{orionStringLiteral: "orion"}
}

func NewDeepgramVoiceVoiceIdWithArcasStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{arcasStringLiteral: "arcas"}
}

func NewDeepgramVoiceVoiceIdWithPerseusStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{perseusStringLiteral: "perseus"}
}

func NewDeepgramVoiceVoiceIdWithAngusStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{angusStringLiteral: "angus"}
}

func NewDeepgramVoiceVoiceIdWithOrpheusStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{orpheusStringLiteral: "orpheus"}
}

func NewDeepgramVoiceVoiceIdWithHeliosStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{heliosStringLiteral: "helios"}
}

func NewDeepgramVoiceVoiceIdWithZeusStringLiteral() *DeepgramVoiceVoiceId {
	return &DeepgramVoiceVoiceId{zeusStringLiteral: "zeus"}
}

func (d *DeepgramVoiceVoiceId) AsteriaStringLiteral() string {
	return d.asteriaStringLiteral
}

func (d *DeepgramVoiceVoiceId) LunaStringLiteral() string {
	return d.lunaStringLiteral
}

func (d *DeepgramVoiceVoiceId) StellaStringLiteral() string {
	return d.stellaStringLiteral
}

func (d *DeepgramVoiceVoiceId) AthenaStringLiteral() string {
	return d.athenaStringLiteral
}

func (d *DeepgramVoiceVoiceId) HeraStringLiteral() string {
	return d.heraStringLiteral
}

func (d *DeepgramVoiceVoiceId) OrionStringLiteral() string {
	return d.orionStringLiteral
}

func (d *DeepgramVoiceVoiceId) ArcasStringLiteral() string {
	return d.arcasStringLiteral
}

func (d *DeepgramVoiceVoiceId) PerseusStringLiteral() string {
	return d.perseusStringLiteral
}

func (d *DeepgramVoiceVoiceId) AngusStringLiteral() string {
	return d.angusStringLiteral
}

func (d *DeepgramVoiceVoiceId) OrpheusStringLiteral() string {
	return d.orpheusStringLiteral
}

func (d *DeepgramVoiceVoiceId) HeliosStringLiteral() string {
	return d.heliosStringLiteral
}

func (d *DeepgramVoiceVoiceId) ZeusStringLiteral() string {
	return d.zeusStringLiteral
}

func (d *DeepgramVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueAsteriaStringLiteral string
	if err := json.Unmarshal(data, &valueAsteriaStringLiteral); err == nil {
		d.asteriaStringLiteral = valueAsteriaStringLiteral
		if d.asteriaStringLiteral != "asteria" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "asteria", valueAsteriaStringLiteral)
		}
		return nil
	}
	var valueLunaStringLiteral string
	if err := json.Unmarshal(data, &valueLunaStringLiteral); err == nil {
		d.lunaStringLiteral = valueLunaStringLiteral
		if d.lunaStringLiteral != "luna" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "luna", valueLunaStringLiteral)
		}
		return nil
	}
	var valueStellaStringLiteral string
	if err := json.Unmarshal(data, &valueStellaStringLiteral); err == nil {
		d.stellaStringLiteral = valueStellaStringLiteral
		if d.stellaStringLiteral != "stella" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "stella", valueStellaStringLiteral)
		}
		return nil
	}
	var valueAthenaStringLiteral string
	if err := json.Unmarshal(data, &valueAthenaStringLiteral); err == nil {
		d.athenaStringLiteral = valueAthenaStringLiteral
		if d.athenaStringLiteral != "athena" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "athena", valueAthenaStringLiteral)
		}
		return nil
	}
	var valueHeraStringLiteral string
	if err := json.Unmarshal(data, &valueHeraStringLiteral); err == nil {
		d.heraStringLiteral = valueHeraStringLiteral
		if d.heraStringLiteral != "hera" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "hera", valueHeraStringLiteral)
		}
		return nil
	}
	var valueOrionStringLiteral string
	if err := json.Unmarshal(data, &valueOrionStringLiteral); err == nil {
		d.orionStringLiteral = valueOrionStringLiteral
		if d.orionStringLiteral != "orion" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "orion", valueOrionStringLiteral)
		}
		return nil
	}
	var valueArcasStringLiteral string
	if err := json.Unmarshal(data, &valueArcasStringLiteral); err == nil {
		d.arcasStringLiteral = valueArcasStringLiteral
		if d.arcasStringLiteral != "arcas" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "arcas", valueArcasStringLiteral)
		}
		return nil
	}
	var valuePerseusStringLiteral string
	if err := json.Unmarshal(data, &valuePerseusStringLiteral); err == nil {
		d.perseusStringLiteral = valuePerseusStringLiteral
		if d.perseusStringLiteral != "perseus" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "perseus", valuePerseusStringLiteral)
		}
		return nil
	}
	var valueAngusStringLiteral string
	if err := json.Unmarshal(data, &valueAngusStringLiteral); err == nil {
		d.angusStringLiteral = valueAngusStringLiteral
		if d.angusStringLiteral != "angus" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "angus", valueAngusStringLiteral)
		}
		return nil
	}
	var valueOrpheusStringLiteral string
	if err := json.Unmarshal(data, &valueOrpheusStringLiteral); err == nil {
		d.orpheusStringLiteral = valueOrpheusStringLiteral
		if d.orpheusStringLiteral != "orpheus" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "orpheus", valueOrpheusStringLiteral)
		}
		return nil
	}
	var valueHeliosStringLiteral string
	if err := json.Unmarshal(data, &valueHeliosStringLiteral); err == nil {
		d.heliosStringLiteral = valueHeliosStringLiteral
		if d.heliosStringLiteral != "helios" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "helios", valueHeliosStringLiteral)
		}
		return nil
	}
	var valueZeusStringLiteral string
	if err := json.Unmarshal(data, &valueZeusStringLiteral); err == nil {
		d.zeusStringLiteral = valueZeusStringLiteral
		if d.zeusStringLiteral != "zeus" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "zeus", valueZeusStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeepgramVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if d.asteriaStringLiteral != "" {
		return json.Marshal("asteria")
	}
	if d.lunaStringLiteral != "" {
		return json.Marshal("luna")
	}
	if d.stellaStringLiteral != "" {
		return json.Marshal("stella")
	}
	if d.athenaStringLiteral != "" {
		return json.Marshal("athena")
	}
	if d.heraStringLiteral != "" {
		return json.Marshal("hera")
	}
	if d.orionStringLiteral != "" {
		return json.Marshal("orion")
	}
	if d.arcasStringLiteral != "" {
		return json.Marshal("arcas")
	}
	if d.perseusStringLiteral != "" {
		return json.Marshal("perseus")
	}
	if d.angusStringLiteral != "" {
		return json.Marshal("angus")
	}
	if d.orpheusStringLiteral != "" {
		return json.Marshal("orpheus")
	}
	if d.heliosStringLiteral != "" {
		return json.Marshal("helios")
	}
	if d.zeusStringLiteral != "" {
		return json.Marshal("zeus")
	}
	if d.String != "" {
		return json.Marshal(d.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepgramVoiceVoiceIdVisitor interface {
	VisitAsteriaStringLiteral(string) error
	VisitLunaStringLiteral(string) error
	VisitStellaStringLiteral(string) error
	VisitAthenaStringLiteral(string) error
	VisitHeraStringLiteral(string) error
	VisitOrionStringLiteral(string) error
	VisitArcasStringLiteral(string) error
	VisitPerseusStringLiteral(string) error
	VisitAngusStringLiteral(string) error
	VisitOrpheusStringLiteral(string) error
	VisitHeliosStringLiteral(string) error
	VisitZeusStringLiteral(string) error
	VisitString(string) error
}

func (d *DeepgramVoiceVoiceId) Accept(visitor DeepgramVoiceVoiceIdVisitor) error {
	if d.asteriaStringLiteral != "" {
		return visitor.VisitAsteriaStringLiteral(d.asteriaStringLiteral)
	}
	if d.lunaStringLiteral != "" {
		return visitor.VisitLunaStringLiteral(d.lunaStringLiteral)
	}
	if d.stellaStringLiteral != "" {
		return visitor.VisitStellaStringLiteral(d.stellaStringLiteral)
	}
	if d.athenaStringLiteral != "" {
		return visitor.VisitAthenaStringLiteral(d.athenaStringLiteral)
	}
	if d.heraStringLiteral != "" {
		return visitor.VisitHeraStringLiteral(d.heraStringLiteral)
	}
	if d.orionStringLiteral != "" {
		return visitor.VisitOrionStringLiteral(d.orionStringLiteral)
	}
	if d.arcasStringLiteral != "" {
		return visitor.VisitArcasStringLiteral(d.arcasStringLiteral)
	}
	if d.perseusStringLiteral != "" {
		return visitor.VisitPerseusStringLiteral(d.perseusStringLiteral)
	}
	if d.angusStringLiteral != "" {
		return visitor.VisitAngusStringLiteral(d.angusStringLiteral)
	}
	if d.orpheusStringLiteral != "" {
		return visitor.VisitOrpheusStringLiteral(d.orpheusStringLiteral)
	}
	if d.heliosStringLiteral != "" {
		return visitor.VisitHeliosStringLiteral(d.heliosStringLiteral)
	}
	if d.zeusStringLiteral != "" {
		return visitor.VisitZeusStringLiteral(d.zeusStringLiteral)
	}
	if d.String != "" {
		return visitor.VisitString(d.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtmfTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*DtmfToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DtmfTool) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DtmfTool) Type() string {
	return d.type_
}

func (d *DtmfTool) UnmarshalJSON(data []byte) error {
	type embed DtmfTool
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DtmfTool(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "dtmf" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "dtmf", unmarshaler.Type)
	}
	d.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *d, "type")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DtmfTool) MarshalJSON() ([]byte, error) {
	type embed DtmfTool
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*d),
		CreatedAt: core.NewDateTime(d.CreatedAt),
		UpdatedAt: core.NewDateTime(d.UpdatedAt),
		Type:      "dtmf",
	}
	return json.Marshal(marshaler)
}

func (d *DtmfTool) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DtmfToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (d *DtmfToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		d.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		d.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		d.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		d.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DtmfToolMessagesItem) MarshalJSON() ([]byte, error) {
	if d.ToolMessageStart != nil {
		return json.Marshal(d.ToolMessageStart)
	}
	if d.ToolMessageComplete != nil {
		return json.Marshal(d.ToolMessageComplete)
	}
	if d.ToolMessageFailed != nil {
		return json.Marshal(d.ToolMessageFailed)
	}
	if d.ToolMessageDelayed != nil {
		return json.Marshal(d.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtmfToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (d *DtmfToolMessagesItem) Accept(visitor DtmfToolMessagesItemVisitor) error {
	if d.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(d.ToolMessageStart)
	}
	if d.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(d.ToolMessageComplete)
	}
	if d.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(d.ToolMessageFailed)
	}
	if d.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(d.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type ElevenLabsCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ElevenLabsCredential) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElevenLabsCredential) Provider() string {
	return e.provider
}

func (e *ElevenLabsCredential) UnmarshalJSON(data []byte) error {
	type embed ElevenLabsCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ElevenLabsCredential(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "11labs", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElevenLabsCredential) MarshalJSON() ([]byte, error) {
	type embed ElevenLabsCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
		UpdatedAt: core.NewDateTime(e.UpdatedAt),
		Provider:  "11labs",
	}
	return json.Marshal(marshaler)
}

func (e *ElevenLabsCredential) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElevenLabsVoice struct {
	// This determines whether fillers are injected into the model output before inputting it into the voice provider.
	//
	// Default `false` because you can achieve better results with prompting the model.
	FillerInjectionEnabled *bool `json:"fillerInjectionEnabled,omitempty" url:"fillerInjectionEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.
	VoiceId *ElevenLabsVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// Defines the stability for voice settings.
	Stability *float64 `json:"stability,omitempty" url:"stability,omitempty"`
	// Defines the similarity boost for voice settings.
	SimilarityBoost *float64 `json:"similarityBoost,omitempty" url:"similarityBoost,omitempty"`
	// Defines the style for voice settings.
	Style *float64 `json:"style,omitempty" url:"style,omitempty"`
	// Defines the use speaker boost for voice settings.
	UseSpeakerBoost *bool `json:"useSpeakerBoost,omitempty" url:"useSpeakerBoost,omitempty"`
	// Defines the optimize streaming latency for voice settings. Defaults to 3.
	OptimizeStreamingLatency *float64 `json:"optimizeStreamingLatency,omitempty" url:"optimizeStreamingLatency,omitempty"`
	// This enables the use of https://elevenlabs.io/docs/speech-synthesis/prompting#pronunciation. Defaults to false to save latency.
	//
	// @default false
	EnableSsmlParsing *bool `json:"enableSsmlParsing,omitempty" url:"enableSsmlParsing,omitempty"`
	// This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.
	Model *ElevenLabsVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language (ISO 639-1) that is enforced for the model. Currently only Turbo v2.5 supports language enforcement. For other models, an error will be returned if language code is provided.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ElevenLabsVoice) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElevenLabsVoice) Provider() string {
	return e.provider
}

func (e *ElevenLabsVoice) UnmarshalJSON(data []byte) error {
	type embed ElevenLabsVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ElevenLabsVoice(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "11labs", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElevenLabsVoice) MarshalJSON() ([]byte, error) {
	type embed ElevenLabsVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*e),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (e *ElevenLabsVoice) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.
type ElevenLabsVoiceModel string

const (
	ElevenLabsVoiceModelElevenMultilingualV2 ElevenLabsVoiceModel = "eleven_multilingual_v2"
	ElevenLabsVoiceModelElevenTurboV2        ElevenLabsVoiceModel = "eleven_turbo_v2"
	ElevenLabsVoiceModelElevenTurboV25       ElevenLabsVoiceModel = "eleven_turbo_v2_5"
	ElevenLabsVoiceModelElevenMonolingualV1  ElevenLabsVoiceModel = "eleven_monolingual_v1"
)

func NewElevenLabsVoiceModelFromString(s string) (ElevenLabsVoiceModel, error) {
	switch s {
	case "eleven_multilingual_v2":
		return ElevenLabsVoiceModelElevenMultilingualV2, nil
	case "eleven_turbo_v2":
		return ElevenLabsVoiceModelElevenTurboV2, nil
	case "eleven_turbo_v2_5":
		return ElevenLabsVoiceModelElevenTurboV25, nil
	case "eleven_monolingual_v1":
		return ElevenLabsVoiceModelElevenMonolingualV1, nil
	}
	var t ElevenLabsVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ElevenLabsVoiceModel) Ptr() *ElevenLabsVoiceModel {
	return &e
}

// This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.
type ElevenLabsVoiceVoiceId struct {
	burtStringLiteral    string
	marissaStringLiteral string
	andreaStringLiteral  string
	sarahStringLiteral   string
	phillipStringLiteral string
	steveStringLiteral   string
	josephStringLiteral  string
	myraStringLiteral    string
	paulaStringLiteral   string
	ryanStringLiteral    string
	drewStringLiteral    string
	paulStringLiteral    string
	mrbStringLiteral     string
	matildaStringLiteral string
	markStringLiteral    string
	String               string
}

func NewElevenLabsVoiceVoiceIdWithBurtStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{burtStringLiteral: "burt"}
}

func NewElevenLabsVoiceVoiceIdWithMarissaStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{marissaStringLiteral: "marissa"}
}

func NewElevenLabsVoiceVoiceIdWithAndreaStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{andreaStringLiteral: "andrea"}
}

func NewElevenLabsVoiceVoiceIdWithSarahStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{sarahStringLiteral: "sarah"}
}

func NewElevenLabsVoiceVoiceIdWithPhillipStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{phillipStringLiteral: "phillip"}
}

func NewElevenLabsVoiceVoiceIdWithSteveStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{steveStringLiteral: "steve"}
}

func NewElevenLabsVoiceVoiceIdWithJosephStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{josephStringLiteral: "joseph"}
}

func NewElevenLabsVoiceVoiceIdWithMyraStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{myraStringLiteral: "myra"}
}

func NewElevenLabsVoiceVoiceIdWithPaulaStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{paulaStringLiteral: "paula"}
}

func NewElevenLabsVoiceVoiceIdWithRyanStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{ryanStringLiteral: "ryan"}
}

func NewElevenLabsVoiceVoiceIdWithDrewStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{drewStringLiteral: "drew"}
}

func NewElevenLabsVoiceVoiceIdWithPaulStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{paulStringLiteral: "paul"}
}

func NewElevenLabsVoiceVoiceIdWithMrbStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{mrbStringLiteral: "mrb"}
}

func NewElevenLabsVoiceVoiceIdWithMatildaStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{matildaStringLiteral: "matilda"}
}

func NewElevenLabsVoiceVoiceIdWithMarkStringLiteral() *ElevenLabsVoiceVoiceId {
	return &ElevenLabsVoiceVoiceId{markStringLiteral: "mark"}
}

func (e *ElevenLabsVoiceVoiceId) BurtStringLiteral() string {
	return e.burtStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) MarissaStringLiteral() string {
	return e.marissaStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) AndreaStringLiteral() string {
	return e.andreaStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) SarahStringLiteral() string {
	return e.sarahStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) PhillipStringLiteral() string {
	return e.phillipStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) SteveStringLiteral() string {
	return e.steveStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) JosephStringLiteral() string {
	return e.josephStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) MyraStringLiteral() string {
	return e.myraStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) PaulaStringLiteral() string {
	return e.paulaStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) RyanStringLiteral() string {
	return e.ryanStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) DrewStringLiteral() string {
	return e.drewStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) PaulStringLiteral() string {
	return e.paulStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) MrbStringLiteral() string {
	return e.mrbStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) MatildaStringLiteral() string {
	return e.matildaStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) MarkStringLiteral() string {
	return e.markStringLiteral
}

func (e *ElevenLabsVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueBurtStringLiteral string
	if err := json.Unmarshal(data, &valueBurtStringLiteral); err == nil {
		e.burtStringLiteral = valueBurtStringLiteral
		if e.burtStringLiteral != "burt" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "burt", valueBurtStringLiteral)
		}
		return nil
	}
	var valueMarissaStringLiteral string
	if err := json.Unmarshal(data, &valueMarissaStringLiteral); err == nil {
		e.marissaStringLiteral = valueMarissaStringLiteral
		if e.marissaStringLiteral != "marissa" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "marissa", valueMarissaStringLiteral)
		}
		return nil
	}
	var valueAndreaStringLiteral string
	if err := json.Unmarshal(data, &valueAndreaStringLiteral); err == nil {
		e.andreaStringLiteral = valueAndreaStringLiteral
		if e.andreaStringLiteral != "andrea" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "andrea", valueAndreaStringLiteral)
		}
		return nil
	}
	var valueSarahStringLiteral string
	if err := json.Unmarshal(data, &valueSarahStringLiteral); err == nil {
		e.sarahStringLiteral = valueSarahStringLiteral
		if e.sarahStringLiteral != "sarah" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "sarah", valueSarahStringLiteral)
		}
		return nil
	}
	var valuePhillipStringLiteral string
	if err := json.Unmarshal(data, &valuePhillipStringLiteral); err == nil {
		e.phillipStringLiteral = valuePhillipStringLiteral
		if e.phillipStringLiteral != "phillip" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "phillip", valuePhillipStringLiteral)
		}
		return nil
	}
	var valueSteveStringLiteral string
	if err := json.Unmarshal(data, &valueSteveStringLiteral); err == nil {
		e.steveStringLiteral = valueSteveStringLiteral
		if e.steveStringLiteral != "steve" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "steve", valueSteveStringLiteral)
		}
		return nil
	}
	var valueJosephStringLiteral string
	if err := json.Unmarshal(data, &valueJosephStringLiteral); err == nil {
		e.josephStringLiteral = valueJosephStringLiteral
		if e.josephStringLiteral != "joseph" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "joseph", valueJosephStringLiteral)
		}
		return nil
	}
	var valueMyraStringLiteral string
	if err := json.Unmarshal(data, &valueMyraStringLiteral); err == nil {
		e.myraStringLiteral = valueMyraStringLiteral
		if e.myraStringLiteral != "myra" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "myra", valueMyraStringLiteral)
		}
		return nil
	}
	var valuePaulaStringLiteral string
	if err := json.Unmarshal(data, &valuePaulaStringLiteral); err == nil {
		e.paulaStringLiteral = valuePaulaStringLiteral
		if e.paulaStringLiteral != "paula" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "paula", valuePaulaStringLiteral)
		}
		return nil
	}
	var valueRyanStringLiteral string
	if err := json.Unmarshal(data, &valueRyanStringLiteral); err == nil {
		e.ryanStringLiteral = valueRyanStringLiteral
		if e.ryanStringLiteral != "ryan" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "ryan", valueRyanStringLiteral)
		}
		return nil
	}
	var valueDrewStringLiteral string
	if err := json.Unmarshal(data, &valueDrewStringLiteral); err == nil {
		e.drewStringLiteral = valueDrewStringLiteral
		if e.drewStringLiteral != "drew" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "drew", valueDrewStringLiteral)
		}
		return nil
	}
	var valuePaulStringLiteral string
	if err := json.Unmarshal(data, &valuePaulStringLiteral); err == nil {
		e.paulStringLiteral = valuePaulStringLiteral
		if e.paulStringLiteral != "paul" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "paul", valuePaulStringLiteral)
		}
		return nil
	}
	var valueMrbStringLiteral string
	if err := json.Unmarshal(data, &valueMrbStringLiteral); err == nil {
		e.mrbStringLiteral = valueMrbStringLiteral
		if e.mrbStringLiteral != "mrb" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "mrb", valueMrbStringLiteral)
		}
		return nil
	}
	var valueMatildaStringLiteral string
	if err := json.Unmarshal(data, &valueMatildaStringLiteral); err == nil {
		e.matildaStringLiteral = valueMatildaStringLiteral
		if e.matildaStringLiteral != "matilda" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "matilda", valueMatildaStringLiteral)
		}
		return nil
	}
	var valueMarkStringLiteral string
	if err := json.Unmarshal(data, &valueMarkStringLiteral); err == nil {
		e.markStringLiteral = valueMarkStringLiteral
		if e.markStringLiteral != "mark" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "mark", valueMarkStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ElevenLabsVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if e.burtStringLiteral != "" {
		return json.Marshal("burt")
	}
	if e.marissaStringLiteral != "" {
		return json.Marshal("marissa")
	}
	if e.andreaStringLiteral != "" {
		return json.Marshal("andrea")
	}
	if e.sarahStringLiteral != "" {
		return json.Marshal("sarah")
	}
	if e.phillipStringLiteral != "" {
		return json.Marshal("phillip")
	}
	if e.steveStringLiteral != "" {
		return json.Marshal("steve")
	}
	if e.josephStringLiteral != "" {
		return json.Marshal("joseph")
	}
	if e.myraStringLiteral != "" {
		return json.Marshal("myra")
	}
	if e.paulaStringLiteral != "" {
		return json.Marshal("paula")
	}
	if e.ryanStringLiteral != "" {
		return json.Marshal("ryan")
	}
	if e.drewStringLiteral != "" {
		return json.Marshal("drew")
	}
	if e.paulStringLiteral != "" {
		return json.Marshal("paul")
	}
	if e.mrbStringLiteral != "" {
		return json.Marshal("mrb")
	}
	if e.matildaStringLiteral != "" {
		return json.Marshal("matilda")
	}
	if e.markStringLiteral != "" {
		return json.Marshal("mark")
	}
	if e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type ElevenLabsVoiceVoiceIdVisitor interface {
	VisitBurtStringLiteral(string) error
	VisitMarissaStringLiteral(string) error
	VisitAndreaStringLiteral(string) error
	VisitSarahStringLiteral(string) error
	VisitPhillipStringLiteral(string) error
	VisitSteveStringLiteral(string) error
	VisitJosephStringLiteral(string) error
	VisitMyraStringLiteral(string) error
	VisitPaulaStringLiteral(string) error
	VisitRyanStringLiteral(string) error
	VisitDrewStringLiteral(string) error
	VisitPaulStringLiteral(string) error
	VisitMrbStringLiteral(string) error
	VisitMatildaStringLiteral(string) error
	VisitMarkStringLiteral(string) error
	VisitString(string) error
}

func (e *ElevenLabsVoiceVoiceId) Accept(visitor ElevenLabsVoiceVoiceIdVisitor) error {
	if e.burtStringLiteral != "" {
		return visitor.VisitBurtStringLiteral(e.burtStringLiteral)
	}
	if e.marissaStringLiteral != "" {
		return visitor.VisitMarissaStringLiteral(e.marissaStringLiteral)
	}
	if e.andreaStringLiteral != "" {
		return visitor.VisitAndreaStringLiteral(e.andreaStringLiteral)
	}
	if e.sarahStringLiteral != "" {
		return visitor.VisitSarahStringLiteral(e.sarahStringLiteral)
	}
	if e.phillipStringLiteral != "" {
		return visitor.VisitPhillipStringLiteral(e.phillipStringLiteral)
	}
	if e.steveStringLiteral != "" {
		return visitor.VisitSteveStringLiteral(e.steveStringLiteral)
	}
	if e.josephStringLiteral != "" {
		return visitor.VisitJosephStringLiteral(e.josephStringLiteral)
	}
	if e.myraStringLiteral != "" {
		return visitor.VisitMyraStringLiteral(e.myraStringLiteral)
	}
	if e.paulaStringLiteral != "" {
		return visitor.VisitPaulaStringLiteral(e.paulaStringLiteral)
	}
	if e.ryanStringLiteral != "" {
		return visitor.VisitRyanStringLiteral(e.ryanStringLiteral)
	}
	if e.drewStringLiteral != "" {
		return visitor.VisitDrewStringLiteral(e.drewStringLiteral)
	}
	if e.paulStringLiteral != "" {
		return visitor.VisitPaulStringLiteral(e.paulStringLiteral)
	}
	if e.mrbStringLiteral != "" {
		return visitor.VisitMrbStringLiteral(e.mrbStringLiteral)
	}
	if e.matildaStringLiteral != "" {
		return visitor.VisitMatildaStringLiteral(e.matildaStringLiteral)
	}
	if e.markStringLiteral != "" {
		return visitor.VisitMarkStringLiteral(e.markStringLiteral)
	}
	if e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EndCallTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*EndCallToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EndCallTool) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndCallTool) Type() string {
	return e.type_
}

func (e *EndCallTool) UnmarshalJSON(data []byte) error {
	type embed EndCallTool
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EndCallTool(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "endCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "endCall", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EndCallTool) MarshalJSON() ([]byte, error) {
	type embed EndCallTool
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
		UpdatedAt: core.NewDateTime(e.UpdatedAt),
		Type:      "endCall",
	}
	return json.Marshal(marshaler)
}

func (e *EndCallTool) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EndCallToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (e *EndCallToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		e.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		e.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		e.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		e.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EndCallToolMessagesItem) MarshalJSON() ([]byte, error) {
	if e.ToolMessageStart != nil {
		return json.Marshal(e.ToolMessageStart)
	}
	if e.ToolMessageComplete != nil {
		return json.Marshal(e.ToolMessageComplete)
	}
	if e.ToolMessageFailed != nil {
		return json.Marshal(e.ToolMessageFailed)
	}
	if e.ToolMessageDelayed != nil {
		return json.Marshal(e.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EndCallToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (e *EndCallToolMessagesItem) Accept(visitor EndCallToolMessagesItemVisitor) error {
	if e.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(e.ToolMessageStart)
	}
	if e.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(e.ToolMessageComplete)
	}
	if e.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(e.ToolMessageFailed)
	}
	if e.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(e.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type Error struct {
	Message string `json:"message" url:"message"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExactReplacement struct {
	// This is the exact replacement type. You can use this to replace a specific word or phrase with a different word or phrase.
	//
	// Usage:
	//
	// - Replace "hello" with "hi": { type: 'exact', key: 'hello', value: 'hi' }
	// - Replace "good morning" with "good day": { type: 'exact', key: 'good morning', value: 'good day' }
	// - Replace a specific name: { type: 'exact', key: 'John Doe', value: 'Jane Smith' }
	// - Replace an acronym: { type: 'exact', key: 'AI', value: 'Artificial Intelligence' }
	// - Replace a company name with its phonetic pronunciation: { type: 'exact', key: 'Vapi', value: 'Vappy' }
	// This is the key to replace.
	Key string `json:"key" url:"key"`
	// This is the value that will replace the match.
	Value string `json:"value" url:"value"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExactReplacement) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExactReplacement) Type() string {
	return e.type_
}

func (e *ExactReplacement) UnmarshalJSON(data []byte) error {
	type embed ExactReplacement
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ExactReplacement(unmarshaler.embed)
	if unmarshaler.Type != "exact" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "exact", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExactReplacement) MarshalJSON() ([]byte, error) {
	type embed ExactReplacement
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
		Type:  "exact",
	}
	return json.Marshal(marshaler)
}

func (e *ExactReplacement) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type File struct {
	Object *string     `json:"object,omitempty" url:"object,omitempty"`
	Status *FileStatus `json:"status,omitempty" url:"status,omitempty"`
	// This is the name of the file. This is just for your own reference.
	Name         *string                `json:"name,omitempty" url:"name,omitempty"`
	OriginalName *string                `json:"originalName,omitempty" url:"originalName,omitempty"`
	Bytes        *float64               `json:"bytes,omitempty" url:"bytes,omitempty"`
	Purpose      *string                `json:"purpose,omitempty" url:"purpose,omitempty"`
	Mimetype     *string                `json:"mimetype,omitempty" url:"mimetype,omitempty"`
	Key          *string                `json:"key,omitempty" url:"key,omitempty"`
	Path         *string                `json:"path,omitempty" url:"path,omitempty"`
	Bucket       *string                `json:"bucket,omitempty" url:"bucket,omitempty"`
	Url          *string                `json:"url,omitempty" url:"url,omitempty"`
	Metadata     map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the unique identifier for the file.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this file belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the file was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the file was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *File) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *File) UnmarshalJSON(data []byte) error {
	type embed File
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = File(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.Time()
	f.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *File) MarshalJSON() ([]byte, error) {
	type embed File
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*f),
		CreatedAt: core.NewDateTime(f.CreatedAt),
		UpdatedAt: core.NewDateTime(f.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (f *File) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileStatus string

const (
	FileStatusIndexed    FileStatus = "indexed"
	FileStatusNotIndexed FileStatus = "not_indexed"
)

func NewFileStatusFromString(s string) (FileStatus, error) {
	switch s {
	case "indexed":
		return FileStatusIndexed, nil
	case "not_indexed":
		return FileStatusNotIndexed, nil
	}
	var t FileStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileStatus) Ptr() *FileStatus {
	return &f
}

type FormatPlan struct {
	// This determines whether the chunk is formatted before being sent to the voice provider. This helps with enunciation. This includes phone numbers, emails and addresses. Default `true`.
	//
	// Usage:
	//
	// - To rely on the voice provider's formatting logic, set this to `false`.
	// - To use ElevenLabs's `enableSsmlParsing` feature, set this to `false`.
	//
	// If `voice.chunkPlan.enabled` is `false`, this is automatically `false` since there's no chunk to format.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the cutoff after which a number is converted to individual digits instead of being spoken as words.
	//
	// Example:
	//
	// - If cutoff 2025, "12345" is converted to "1 2 3 4 5" while "1200" is converted to "twelve hundred".
	//
	// Usage:
	//
	// - If your use case doesn't involve IDs like zip codes, set this to a high value.
	// - If your use case involves IDs that are shorter than 5 digits, set this to a lower value.
	//
	// @default 2025
	NumberToDigitsCutoff *float64 `json:"numberToDigitsCutoff,omitempty" url:"numberToDigitsCutoff,omitempty"`
	// These are the custom replacements you can make to the chunk before it is sent to the voice provider.
	//
	// Usage:
	//
	// - To replace a specific word or phrase with a different word or phrase, use the `ExactReplacement` type. Eg. `{ type: 'exact', key: 'hello', value: 'hi' }`
	// - To replace a word or phrase that matches a pattern, use the `RegexReplacement` type. Eg. `{ type: 'regex', regex: '\\b[a-zA-Z]{5}\\b', value: 'hi' }`
	//
	// @default []
	Replacements []*FormatPlanReplacementsItem `json:"replacements,omitempty" url:"replacements,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FormatPlan) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FormatPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler FormatPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FormatPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FormatPlan) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FormatPlanReplacementsItem struct {
	ExactReplacement *ExactReplacement
	RegexReplacement *RegexReplacement
}

func (f *FormatPlanReplacementsItem) UnmarshalJSON(data []byte) error {
	valueExactReplacement := new(ExactReplacement)
	if err := json.Unmarshal(data, &valueExactReplacement); err == nil {
		f.ExactReplacement = valueExactReplacement
		return nil
	}
	valueRegexReplacement := new(RegexReplacement)
	if err := json.Unmarshal(data, &valueRegexReplacement); err == nil {
		f.RegexReplacement = valueRegexReplacement
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FormatPlanReplacementsItem) MarshalJSON() ([]byte, error) {
	if f.ExactReplacement != nil {
		return json.Marshal(f.ExactReplacement)
	}
	if f.RegexReplacement != nil {
		return json.Marshal(f.RegexReplacement)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FormatPlanReplacementsItemVisitor interface {
	VisitExactReplacement(*ExactReplacement) error
	VisitRegexReplacement(*RegexReplacement) error
}

func (f *FormatPlanReplacementsItem) Accept(visitor FormatPlanReplacementsItemVisitor) error {
	if f.ExactReplacement != nil {
		return visitor.VisitExactReplacement(f.ExactReplacement)
	}
	if f.RegexReplacement != nil {
		return visitor.VisitRegexReplacement(f.RegexReplacement)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*FunctionToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FunctionTool) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FunctionTool) Type() string {
	return f.type_
}

func (f *FunctionTool) UnmarshalJSON(data []byte) error {
	type embed FunctionTool
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FunctionTool(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.Time()
	f.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "function", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FunctionTool) MarshalJSON() ([]byte, error) {
	type embed FunctionTool
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*f),
		CreatedAt: core.NewDateTime(f.CreatedAt),
		UpdatedAt: core.NewDateTime(f.UpdatedAt),
		Type:      "function",
	}
	return json.Marshal(marshaler)
}

func (f *FunctionTool) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FunctionToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (f *FunctionToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		f.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		f.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		f.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		f.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FunctionToolMessagesItem) MarshalJSON() ([]byte, error) {
	if f.ToolMessageStart != nil {
		return json.Marshal(f.ToolMessageStart)
	}
	if f.ToolMessageComplete != nil {
		return json.Marshal(f.ToolMessageComplete)
	}
	if f.ToolMessageFailed != nil {
		return json.Marshal(f.ToolMessageFailed)
	}
	if f.ToolMessageDelayed != nil {
		return json.Marshal(f.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (f *FunctionToolMessagesItem) Accept(visitor FunctionToolMessagesItemVisitor) error {
	if f.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(f.ToolMessageStart)
	}
	if f.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(f.ToolMessageComplete)
	}
	if f.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(f.ToolMessageFailed)
	}
	if f.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(f.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "function" for Function tool.
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FunctionToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FunctionToolProviderDetails) Type() string {
	return f.type_
}

func (f *FunctionToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed FunctionToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FunctionToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "function", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FunctionToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed FunctionToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (f *FunctionToolProviderDetails) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FunctionToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*FunctionToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "function" for Function tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FunctionToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FunctionToolWithToolCall) Type() string {
	return f.type_
}

func (f *FunctionToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed FunctionToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FunctionToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "function", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FunctionToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed FunctionToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (f *FunctionToolWithToolCall) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FunctionToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (f *FunctionToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		f.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		f.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		f.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		f.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FunctionToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if f.ToolMessageStart != nil {
		return json.Marshal(f.ToolMessageStart)
	}
	if f.ToolMessageComplete != nil {
		return json.Marshal(f.ToolMessageComplete)
	}
	if f.ToolMessageFailed != nil {
		return json.Marshal(f.ToolMessageFailed)
	}
	if f.ToolMessageDelayed != nil {
		return json.Marshal(f.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (f *FunctionToolWithToolCallMessagesItem) Accept(visitor FunctionToolWithToolCallMessagesItemVisitor) error {
	if f.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(f.ToolMessageStart)
	}
	if f.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(f.ToolMessageComplete)
	}
	if f.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(f.ToolMessageFailed)
	}
	if f.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(f.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type GcpCredential struct {
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of the GCP credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.
	//
	// The schema is identical to the JSON that GCP outputs.
	GcpKey *GcpKey `json:"gcpKey,omitempty" url:"gcpKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in GCP.
	BucketPlan *BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GcpCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GcpCredential) Provider() string {
	return g.provider
}

func (g *GcpCredential) UnmarshalJSON(data []byte) error {
	type embed GcpCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GcpCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "gcp" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gcp", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GcpCredential) MarshalJSON() ([]byte, error) {
	type embed GcpCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: core.NewDateTime(g.CreatedAt),
		UpdatedAt: core.NewDateTime(g.UpdatedAt),
		Provider:  "gcp",
	}
	return json.Marshal(marshaler)
}

func (g *GcpCredential) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GcpKey struct {
	// This is the type of the key. Most likely, this is "service_account".
	Type string `json:"type" url:"type"`
	// This is the ID of the Google Cloud project associated with this key.
	ProjectId string `json:"projectId" url:"projectId"`
	// This is the unique identifier for the private key.
	PrivateKeyId string `json:"privateKeyId" url:"privateKeyId"`
	// This is the private key in PEM format.
	//
	// Note: This is not returned in the API.
	PrivateKey string `json:"privateKey" url:"privateKey"`
	// This is the email address associated with the service account.
	ClientEmail string `json:"clientEmail" url:"clientEmail"`
	// This is the unique identifier for the client.
	ClientId string `json:"clientId" url:"clientId"`
	// This is the URI for the auth provider's authorization endpoint.
	AuthUri string `json:"authUri" url:"authUri"`
	// This is the URI for the auth provider's token endpoint.
	TokenUri string `json:"tokenUri" url:"tokenUri"`
	// This is the URL of the public x509 certificate for the auth provider.
	AuthProviderX509CertUrl string `json:"authProviderX509CertUrl" url:"authProviderX509CertUrl"`
	// This is the URL of the public x509 certificate for the client.
	ClientX509CertUrl string `json:"clientX509CertUrl" url:"clientX509CertUrl"`
	// This is the domain associated with the universe this service account belongs to.
	UniverseDomain string `json:"universeDomain" url:"universeDomain"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GcpKey) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GcpKey) UnmarshalJSON(data []byte) error {
	type unmarshaler GcpKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GcpKey(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GcpKey) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GhlToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server   *Server          `json:"server,omitempty" url:"server,omitempty"`
	Metadata *GhlToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GhlTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlTool) Type() string {
	return g.type_
}

func (g *GhlTool) UnmarshalJSON(data []byte) error {
	type embed GhlTool
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GhlTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "ghl", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlTool) MarshalJSON() ([]byte, error) {
	type embed GhlTool
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: core.NewDateTime(g.CreatedAt),
		UpdatedAt: core.NewDateTime(g.UpdatedAt),
		Type:      "ghl",
	}
	return json.Marshal(marshaler)
}

func (g *GhlTool) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (g *GhlToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GhlToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GhlToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GhlToolMessagesItem) Accept(visitor GhlToolMessagesItemVisitor) error {
	if g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GhlToolMetadata struct {
	WorkflowId *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	LocationId *string `json:"locationId,omitempty" url:"locationId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GhlToolMetadata) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlToolMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler GhlToolMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GhlToolMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlToolMetadata) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "ghl" for GHL tool.
	WorkflowId      *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	WorkflowName    *string `json:"workflowName,omitempty" url:"workflowName,omitempty"`
	WebhookHookId   *string `json:"webhookHookId,omitempty" url:"webhookHookId,omitempty"`
	WebhookHookName *string `json:"webhookHookName,omitempty" url:"webhookHookName,omitempty"`
	LocationId      *string `json:"locationId,omitempty" url:"locationId,omitempty"`
	type_           string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GhlToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlToolProviderDetails) Type() string {
	return g.type_
}

func (g *GhlToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed GhlToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GhlToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "ghl", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed GhlToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "ghl",
	}
	return json.Marshal(marshaler)
}

func (g *GhlToolProviderDetails) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GhlToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "ghl" for GHL tool.
	ToolCall *ToolCall        `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	Metadata *GhlToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GhlToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlToolWithToolCall) Type() string {
	return g.type_
}

func (g *GhlToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed GhlToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GhlToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "ghl", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed GhlToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "ghl",
	}
	return json.Marshal(marshaler)
}

func (g *GhlToolWithToolCall) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (g *GhlToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GhlToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GhlToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GhlToolWithToolCallMessagesItem) Accept(visitor GhlToolWithToolCallMessagesItemVisitor) error {
	if g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GladiaCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GladiaCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GladiaCredential) Provider() string {
	return g.provider
}

func (g *GladiaCredential) UnmarshalJSON(data []byte) error {
	type embed GladiaCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GladiaCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gladia", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GladiaCredential) MarshalJSON() ([]byte, error) {
	type embed GladiaCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: core.NewDateTime(g.CreatedAt),
		UpdatedAt: core.NewDateTime(g.UpdatedAt),
		Provider:  "gladia",
	}
	return json.Marshal(marshaler)
}

func (g *GladiaCredential) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GladiaTranscriber struct {
	// This is the transcription provider that will be used.
	Model             *GladiaTranscriberModel             `json:"model,omitempty" url:"model,omitempty"`
	LanguageBehaviour *GladiaTranscriberLanguageBehaviour `json:"languageBehaviour,omitempty" url:"languageBehaviour,omitempty"`
	// Defines the language to use for the transcription. Required when languageBehaviour is 'manual'.
	Language *GladiaTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// Provides a custom vocabulary to the model to improve accuracy of transcribing context specific words, technical terms, names, etc. If empty, this argument is ignored.
	// ⚠️ Warning ⚠️: Please be aware that the transcription_hint field has a character limit of 600. If you provide a transcription_hint longer than 600 characters, it will be automatically truncated to meet this limit.
	TranscriptionHint *string `json:"transcriptionHint,omitempty" url:"transcriptionHint,omitempty"`
	// If prosody is true, you will get a transcription that can contain prosodies i.e. (laugh) (giggles) (malefic laugh) (toss) (music)… Default value is false.
	Prosody *bool `json:"prosody,omitempty" url:"prosody,omitempty"`
	// If true, audio will be pre-processed to improve accuracy but latency will increase. Default value is false.
	AudioEnhancer *bool `json:"audioEnhancer,omitempty" url:"audioEnhancer,omitempty"`
	provider      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GladiaTranscriber) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GladiaTranscriber) Provider() string {
	return g.provider
}

func (g *GladiaTranscriber) UnmarshalJSON(data []byte) error {
	type embed GladiaTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GladiaTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gladia", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GladiaTranscriber) MarshalJSON() ([]byte, error) {
	type embed GladiaTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*g),
		Provider: "gladia",
	}
	return json.Marshal(marshaler)
}

func (g *GladiaTranscriber) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the language to use for the transcription. Required when languageBehaviour is 'manual'.
type GladiaTranscriberLanguage string

const (
	GladiaTranscriberLanguageAf   GladiaTranscriberLanguage = "af"
	GladiaTranscriberLanguageSq   GladiaTranscriberLanguage = "sq"
	GladiaTranscriberLanguageAm   GladiaTranscriberLanguage = "am"
	GladiaTranscriberLanguageAr   GladiaTranscriberLanguage = "ar"
	GladiaTranscriberLanguageHy   GladiaTranscriberLanguage = "hy"
	GladiaTranscriberLanguageAs   GladiaTranscriberLanguage = "as"
	GladiaTranscriberLanguageAz   GladiaTranscriberLanguage = "az"
	GladiaTranscriberLanguageBa   GladiaTranscriberLanguage = "ba"
	GladiaTranscriberLanguageEu   GladiaTranscriberLanguage = "eu"
	GladiaTranscriberLanguageBe   GladiaTranscriberLanguage = "be"
	GladiaTranscriberLanguageBn   GladiaTranscriberLanguage = "bn"
	GladiaTranscriberLanguageBs   GladiaTranscriberLanguage = "bs"
	GladiaTranscriberLanguageBr   GladiaTranscriberLanguage = "br"
	GladiaTranscriberLanguageBg   GladiaTranscriberLanguage = "bg"
	GladiaTranscriberLanguageCa   GladiaTranscriberLanguage = "ca"
	GladiaTranscriberLanguageZh   GladiaTranscriberLanguage = "zh"
	GladiaTranscriberLanguageHr   GladiaTranscriberLanguage = "hr"
	GladiaTranscriberLanguageCs   GladiaTranscriberLanguage = "cs"
	GladiaTranscriberLanguageDa   GladiaTranscriberLanguage = "da"
	GladiaTranscriberLanguageNl   GladiaTranscriberLanguage = "nl"
	GladiaTranscriberLanguageEn   GladiaTranscriberLanguage = "en"
	GladiaTranscriberLanguageEt   GladiaTranscriberLanguage = "et"
	GladiaTranscriberLanguageFo   GladiaTranscriberLanguage = "fo"
	GladiaTranscriberLanguageFi   GladiaTranscriberLanguage = "fi"
	GladiaTranscriberLanguageFr   GladiaTranscriberLanguage = "fr"
	GladiaTranscriberLanguageGl   GladiaTranscriberLanguage = "gl"
	GladiaTranscriberLanguageKa   GladiaTranscriberLanguage = "ka"
	GladiaTranscriberLanguageDe   GladiaTranscriberLanguage = "de"
	GladiaTranscriberLanguageEl   GladiaTranscriberLanguage = "el"
	GladiaTranscriberLanguageGu   GladiaTranscriberLanguage = "gu"
	GladiaTranscriberLanguageHt   GladiaTranscriberLanguage = "ht"
	GladiaTranscriberLanguageHa   GladiaTranscriberLanguage = "ha"
	GladiaTranscriberLanguageHaw  GladiaTranscriberLanguage = "haw"
	GladiaTranscriberLanguageHe   GladiaTranscriberLanguage = "he"
	GladiaTranscriberLanguageHi   GladiaTranscriberLanguage = "hi"
	GladiaTranscriberLanguageHu   GladiaTranscriberLanguage = "hu"
	GladiaTranscriberLanguageIs   GladiaTranscriberLanguage = "is"
	GladiaTranscriberLanguageId   GladiaTranscriberLanguage = "id"
	GladiaTranscriberLanguageIt   GladiaTranscriberLanguage = "it"
	GladiaTranscriberLanguageJa   GladiaTranscriberLanguage = "ja"
	GladiaTranscriberLanguageJp   GladiaTranscriberLanguage = "jp"
	GladiaTranscriberLanguageJv   GladiaTranscriberLanguage = "jv"
	GladiaTranscriberLanguageKn   GladiaTranscriberLanguage = "kn"
	GladiaTranscriberLanguageKk   GladiaTranscriberLanguage = "kk"
	GladiaTranscriberLanguageKm   GladiaTranscriberLanguage = "km"
	GladiaTranscriberLanguageKo   GladiaTranscriberLanguage = "ko"
	GladiaTranscriberLanguageLo   GladiaTranscriberLanguage = "lo"
	GladiaTranscriberLanguageLa   GladiaTranscriberLanguage = "la"
	GladiaTranscriberLanguageLv   GladiaTranscriberLanguage = "lv"
	GladiaTranscriberLanguageLn   GladiaTranscriberLanguage = "ln"
	GladiaTranscriberLanguageLt   GladiaTranscriberLanguage = "lt"
	GladiaTranscriberLanguageLb   GladiaTranscriberLanguage = "lb"
	GladiaTranscriberLanguageMk   GladiaTranscriberLanguage = "mk"
	GladiaTranscriberLanguageMg   GladiaTranscriberLanguage = "mg"
	GladiaTranscriberLanguageMs   GladiaTranscriberLanguage = "ms"
	GladiaTranscriberLanguageMl   GladiaTranscriberLanguage = "ml"
	GladiaTranscriberLanguageMt   GladiaTranscriberLanguage = "mt"
	GladiaTranscriberLanguageMi   GladiaTranscriberLanguage = "mi"
	GladiaTranscriberLanguageMr   GladiaTranscriberLanguage = "mr"
	GladiaTranscriberLanguageMn   GladiaTranscriberLanguage = "mn"
	GladiaTranscriberLanguageMymr GladiaTranscriberLanguage = "mymr"
	GladiaTranscriberLanguageNe   GladiaTranscriberLanguage = "ne"
	GladiaTranscriberLanguageNo   GladiaTranscriberLanguage = "no"
	GladiaTranscriberLanguageNn   GladiaTranscriberLanguage = "nn"
	GladiaTranscriberLanguageOc   GladiaTranscriberLanguage = "oc"
	GladiaTranscriberLanguagePs   GladiaTranscriberLanguage = "ps"
	GladiaTranscriberLanguageFa   GladiaTranscriberLanguage = "fa"
	GladiaTranscriberLanguagePl   GladiaTranscriberLanguage = "pl"
	GladiaTranscriberLanguagePt   GladiaTranscriberLanguage = "pt"
	GladiaTranscriberLanguagePa   GladiaTranscriberLanguage = "pa"
	GladiaTranscriberLanguageRo   GladiaTranscriberLanguage = "ro"
	GladiaTranscriberLanguageRu   GladiaTranscriberLanguage = "ru"
	GladiaTranscriberLanguageSa   GladiaTranscriberLanguage = "sa"
	GladiaTranscriberLanguageSr   GladiaTranscriberLanguage = "sr"
	GladiaTranscriberLanguageSn   GladiaTranscriberLanguage = "sn"
	GladiaTranscriberLanguageSd   GladiaTranscriberLanguage = "sd"
	GladiaTranscriberLanguageSi   GladiaTranscriberLanguage = "si"
	GladiaTranscriberLanguageSk   GladiaTranscriberLanguage = "sk"
	GladiaTranscriberLanguageSl   GladiaTranscriberLanguage = "sl"
	GladiaTranscriberLanguageSo   GladiaTranscriberLanguage = "so"
	GladiaTranscriberLanguageEs   GladiaTranscriberLanguage = "es"
	GladiaTranscriberLanguageSu   GladiaTranscriberLanguage = "su"
	GladiaTranscriberLanguageSw   GladiaTranscriberLanguage = "sw"
	GladiaTranscriberLanguageSv   GladiaTranscriberLanguage = "sv"
	GladiaTranscriberLanguageTl   GladiaTranscriberLanguage = "tl"
	GladiaTranscriberLanguageTg   GladiaTranscriberLanguage = "tg"
	GladiaTranscriberLanguageTa   GladiaTranscriberLanguage = "ta"
	GladiaTranscriberLanguageTt   GladiaTranscriberLanguage = "tt"
	GladiaTranscriberLanguageTe   GladiaTranscriberLanguage = "te"
	GladiaTranscriberLanguageTh   GladiaTranscriberLanguage = "th"
	GladiaTranscriberLanguageBo   GladiaTranscriberLanguage = "bo"
	GladiaTranscriberLanguageTr   GladiaTranscriberLanguage = "tr"
	GladiaTranscriberLanguageTk   GladiaTranscriberLanguage = "tk"
	GladiaTranscriberLanguageUk   GladiaTranscriberLanguage = "uk"
	GladiaTranscriberLanguageUr   GladiaTranscriberLanguage = "ur"
	GladiaTranscriberLanguageUz   GladiaTranscriberLanguage = "uz"
	GladiaTranscriberLanguageVi   GladiaTranscriberLanguage = "vi"
	GladiaTranscriberLanguageCy   GladiaTranscriberLanguage = "cy"
	GladiaTranscriberLanguageYi   GladiaTranscriberLanguage = "yi"
	GladiaTranscriberLanguageYo   GladiaTranscriberLanguage = "yo"
)

func NewGladiaTranscriberLanguageFromString(s string) (GladiaTranscriberLanguage, error) {
	switch s {
	case "af":
		return GladiaTranscriberLanguageAf, nil
	case "sq":
		return GladiaTranscriberLanguageSq, nil
	case "am":
		return GladiaTranscriberLanguageAm, nil
	case "ar":
		return GladiaTranscriberLanguageAr, nil
	case "hy":
		return GladiaTranscriberLanguageHy, nil
	case "as":
		return GladiaTranscriberLanguageAs, nil
	case "az":
		return GladiaTranscriberLanguageAz, nil
	case "ba":
		return GladiaTranscriberLanguageBa, nil
	case "eu":
		return GladiaTranscriberLanguageEu, nil
	case "be":
		return GladiaTranscriberLanguageBe, nil
	case "bn":
		return GladiaTranscriberLanguageBn, nil
	case "bs":
		return GladiaTranscriberLanguageBs, nil
	case "br":
		return GladiaTranscriberLanguageBr, nil
	case "bg":
		return GladiaTranscriberLanguageBg, nil
	case "ca":
		return GladiaTranscriberLanguageCa, nil
	case "zh":
		return GladiaTranscriberLanguageZh, nil
	case "hr":
		return GladiaTranscriberLanguageHr, nil
	case "cs":
		return GladiaTranscriberLanguageCs, nil
	case "da":
		return GladiaTranscriberLanguageDa, nil
	case "nl":
		return GladiaTranscriberLanguageNl, nil
	case "en":
		return GladiaTranscriberLanguageEn, nil
	case "et":
		return GladiaTranscriberLanguageEt, nil
	case "fo":
		return GladiaTranscriberLanguageFo, nil
	case "fi":
		return GladiaTranscriberLanguageFi, nil
	case "fr":
		return GladiaTranscriberLanguageFr, nil
	case "gl":
		return GladiaTranscriberLanguageGl, nil
	case "ka":
		return GladiaTranscriberLanguageKa, nil
	case "de":
		return GladiaTranscriberLanguageDe, nil
	case "el":
		return GladiaTranscriberLanguageEl, nil
	case "gu":
		return GladiaTranscriberLanguageGu, nil
	case "ht":
		return GladiaTranscriberLanguageHt, nil
	case "ha":
		return GladiaTranscriberLanguageHa, nil
	case "haw":
		return GladiaTranscriberLanguageHaw, nil
	case "he":
		return GladiaTranscriberLanguageHe, nil
	case "hi":
		return GladiaTranscriberLanguageHi, nil
	case "hu":
		return GladiaTranscriberLanguageHu, nil
	case "is":
		return GladiaTranscriberLanguageIs, nil
	case "id":
		return GladiaTranscriberLanguageId, nil
	case "it":
		return GladiaTranscriberLanguageIt, nil
	case "ja":
		return GladiaTranscriberLanguageJa, nil
	case "jp":
		return GladiaTranscriberLanguageJp, nil
	case "jv":
		return GladiaTranscriberLanguageJv, nil
	case "kn":
		return GladiaTranscriberLanguageKn, nil
	case "kk":
		return GladiaTranscriberLanguageKk, nil
	case "km":
		return GladiaTranscriberLanguageKm, nil
	case "ko":
		return GladiaTranscriberLanguageKo, nil
	case "lo":
		return GladiaTranscriberLanguageLo, nil
	case "la":
		return GladiaTranscriberLanguageLa, nil
	case "lv":
		return GladiaTranscriberLanguageLv, nil
	case "ln":
		return GladiaTranscriberLanguageLn, nil
	case "lt":
		return GladiaTranscriberLanguageLt, nil
	case "lb":
		return GladiaTranscriberLanguageLb, nil
	case "mk":
		return GladiaTranscriberLanguageMk, nil
	case "mg":
		return GladiaTranscriberLanguageMg, nil
	case "ms":
		return GladiaTranscriberLanguageMs, nil
	case "ml":
		return GladiaTranscriberLanguageMl, nil
	case "mt":
		return GladiaTranscriberLanguageMt, nil
	case "mi":
		return GladiaTranscriberLanguageMi, nil
	case "mr":
		return GladiaTranscriberLanguageMr, nil
	case "mn":
		return GladiaTranscriberLanguageMn, nil
	case "mymr":
		return GladiaTranscriberLanguageMymr, nil
	case "ne":
		return GladiaTranscriberLanguageNe, nil
	case "no":
		return GladiaTranscriberLanguageNo, nil
	case "nn":
		return GladiaTranscriberLanguageNn, nil
	case "oc":
		return GladiaTranscriberLanguageOc, nil
	case "ps":
		return GladiaTranscriberLanguagePs, nil
	case "fa":
		return GladiaTranscriberLanguageFa, nil
	case "pl":
		return GladiaTranscriberLanguagePl, nil
	case "pt":
		return GladiaTranscriberLanguagePt, nil
	case "pa":
		return GladiaTranscriberLanguagePa, nil
	case "ro":
		return GladiaTranscriberLanguageRo, nil
	case "ru":
		return GladiaTranscriberLanguageRu, nil
	case "sa":
		return GladiaTranscriberLanguageSa, nil
	case "sr":
		return GladiaTranscriberLanguageSr, nil
	case "sn":
		return GladiaTranscriberLanguageSn, nil
	case "sd":
		return GladiaTranscriberLanguageSd, nil
	case "si":
		return GladiaTranscriberLanguageSi, nil
	case "sk":
		return GladiaTranscriberLanguageSk, nil
	case "sl":
		return GladiaTranscriberLanguageSl, nil
	case "so":
		return GladiaTranscriberLanguageSo, nil
	case "es":
		return GladiaTranscriberLanguageEs, nil
	case "su":
		return GladiaTranscriberLanguageSu, nil
	case "sw":
		return GladiaTranscriberLanguageSw, nil
	case "sv":
		return GladiaTranscriberLanguageSv, nil
	case "tl":
		return GladiaTranscriberLanguageTl, nil
	case "tg":
		return GladiaTranscriberLanguageTg, nil
	case "ta":
		return GladiaTranscriberLanguageTa, nil
	case "tt":
		return GladiaTranscriberLanguageTt, nil
	case "te":
		return GladiaTranscriberLanguageTe, nil
	case "th":
		return GladiaTranscriberLanguageTh, nil
	case "bo":
		return GladiaTranscriberLanguageBo, nil
	case "tr":
		return GladiaTranscriberLanguageTr, nil
	case "tk":
		return GladiaTranscriberLanguageTk, nil
	case "uk":
		return GladiaTranscriberLanguageUk, nil
	case "ur":
		return GladiaTranscriberLanguageUr, nil
	case "uz":
		return GladiaTranscriberLanguageUz, nil
	case "vi":
		return GladiaTranscriberLanguageVi, nil
	case "cy":
		return GladiaTranscriberLanguageCy, nil
	case "yi":
		return GladiaTranscriberLanguageYi, nil
	case "yo":
		return GladiaTranscriberLanguageYo, nil
	}
	var t GladiaTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GladiaTranscriberLanguage) Ptr() *GladiaTranscriberLanguage {
	return &g
}

type GladiaTranscriberLanguageBehaviour string

const (
	GladiaTranscriberLanguageBehaviourManual                     GladiaTranscriberLanguageBehaviour = "manual"
	GladiaTranscriberLanguageBehaviourAutomaticSingleLanguage    GladiaTranscriberLanguageBehaviour = "automatic single language"
	GladiaTranscriberLanguageBehaviourAutomaticMultipleLanguages GladiaTranscriberLanguageBehaviour = "automatic multiple languages"
)

func NewGladiaTranscriberLanguageBehaviourFromString(s string) (GladiaTranscriberLanguageBehaviour, error) {
	switch s {
	case "manual":
		return GladiaTranscriberLanguageBehaviourManual, nil
	case "automatic single language":
		return GladiaTranscriberLanguageBehaviourAutomaticSingleLanguage, nil
	case "automatic multiple languages":
		return GladiaTranscriberLanguageBehaviourAutomaticMultipleLanguages, nil
	}
	var t GladiaTranscriberLanguageBehaviour
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GladiaTranscriberLanguageBehaviour) Ptr() *GladiaTranscriberLanguageBehaviour {
	return &g
}

type GladiaTranscriberModel string

const (
	GladiaTranscriberModelFast     GladiaTranscriberModel = "fast"
	GladiaTranscriberModelAccurate GladiaTranscriberModel = "accurate"
)

func NewGladiaTranscriberModelFromString(s string) (GladiaTranscriberModel, error) {
	switch s {
	case "fast":
		return GladiaTranscriberModelFast, nil
	case "accurate":
		return GladiaTranscriberModelAccurate, nil
	}
	var t GladiaTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GladiaTranscriberModel) Ptr() *GladiaTranscriberModel {
	return &g
}

type GoHighLevelCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GoHighLevelCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCredential) Provider() string {
	return g.provider
}

func (g *GoHighLevelCredential) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "gohighlevel" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCredential) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: core.NewDateTime(g.CreatedAt),
		UpdatedAt: core.NewDateTime(g.UpdatedAt),
		Provider:  "gohighlevel",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelCredential) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroqCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroqCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroqCredential) Provider() string {
	return g.provider
}

func (g *GroqCredential) UnmarshalJSON(data []byte) error {
	type embed GroqCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GroqCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "groq" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "groq", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroqCredential) MarshalJSON() ([]byte, error) {
	type embed GroqCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: core.NewDateTime(g.CreatedAt),
		UpdatedAt: core.NewDateTime(g.UpdatedAt),
		Provider:  "groq",
	}
	return json.Marshal(marshaler)
}

func (g *GroqCredential) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroqModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*GroqModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model GroqModelModel `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *KnowledgeBase `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroqModel) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroqModel) Provider() string {
	return g.provider
}

func (g *GroqModel) UnmarshalJSON(data []byte) error {
	type embed GroqModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GroqModel(unmarshaler.embed)
	if unmarshaler.Provider != "groq" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "groq", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroqModel) MarshalJSON() ([]byte, error) {
	type embed GroqModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*g),
		Provider: "groq",
	}
	return json.Marshal(marshaler)
}

func (g *GroqModel) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
type GroqModelModel string

const (
	GroqModelModelLlama31405BReasoning            GroqModelModel = "llama-3.1-405b-reasoning"
	GroqModelModelLlama3170BVersatile             GroqModelModel = "llama-3.1-70b-versatile"
	GroqModelModelLlama318BInstant                GroqModelModel = "llama-3.1-8b-instant"
	GroqModelModelMixtral8X7B32768                GroqModelModel = "mixtral-8x7b-32768"
	GroqModelModelLlama38B8192                    GroqModelModel = "llama3-8b-8192"
	GroqModelModelLlama370B8192                   GroqModelModel = "llama3-70b-8192"
	GroqModelModelLlama3Groq8B8192ToolUsePreview  GroqModelModel = "llama3-groq-8b-8192-tool-use-preview"
	GroqModelModelLlama3Groq70B8192ToolUsePreview GroqModelModel = "llama3-groq-70b-8192-tool-use-preview"
	GroqModelModelGemma7BIt                       GroqModelModel = "gemma-7b-it"
	GroqModelModelGemma29BIt                      GroqModelModel = "gemma2-9b-it"
)

func NewGroqModelModelFromString(s string) (GroqModelModel, error) {
	switch s {
	case "llama-3.1-405b-reasoning":
		return GroqModelModelLlama31405BReasoning, nil
	case "llama-3.1-70b-versatile":
		return GroqModelModelLlama3170BVersatile, nil
	case "llama-3.1-8b-instant":
		return GroqModelModelLlama318BInstant, nil
	case "mixtral-8x7b-32768":
		return GroqModelModelMixtral8X7B32768, nil
	case "llama3-8b-8192":
		return GroqModelModelLlama38B8192, nil
	case "llama3-70b-8192":
		return GroqModelModelLlama370B8192, nil
	case "llama3-groq-8b-8192-tool-use-preview":
		return GroqModelModelLlama3Groq8B8192ToolUsePreview, nil
	case "llama3-groq-70b-8192-tool-use-preview":
		return GroqModelModelLlama3Groq70B8192ToolUsePreview, nil
	case "gemma-7b-it":
		return GroqModelModelGemma7BIt, nil
	case "gemma2-9b-it":
		return GroqModelModelGemma29BIt, nil
	}
	var t GroqModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GroqModelModel) Ptr() *GroqModelModel {
	return &g
}

type GroqModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (g *GroqModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		g.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		g.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		g.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		g.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		g.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		g.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		g.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GroqModelToolsItem) MarshalJSON() ([]byte, error) {
	if g.CreateDtmfToolDto != nil {
		return json.Marshal(g.CreateDtmfToolDto)
	}
	if g.CreateEndCallToolDto != nil {
		return json.Marshal(g.CreateEndCallToolDto)
	}
	if g.CreateVoicemailToolDto != nil {
		return json.Marshal(g.CreateVoicemailToolDto)
	}
	if g.CreateFunctionToolDto != nil {
		return json.Marshal(g.CreateFunctionToolDto)
	}
	if g.CreateGhlToolDto != nil {
		return json.Marshal(g.CreateGhlToolDto)
	}
	if g.CreateMakeToolDto != nil {
		return json.Marshal(g.CreateMakeToolDto)
	}
	if g.CreateTransferCallToolDto != nil {
		return json.Marshal(g.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GroqModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (g *GroqModelToolsItem) Accept(visitor GroqModelToolsItemVisitor) error {
	if g.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(g.CreateDtmfToolDto)
	}
	if g.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(g.CreateEndCallToolDto)
	}
	if g.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(g.CreateVoicemailToolDto)
	}
	if g.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(g.CreateFunctionToolDto)
	}
	if g.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(g.CreateGhlToolDto)
	}
	if g.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(g.CreateMakeToolDto)
	}
	if g.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(g.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type HandoffStep struct {
	// This is the block to use. To use an existing block, use `blockId`.
	Block *HandoffStepBlock `json:"block,omitempty" url:"block,omitempty"`
	// This is a step that takes a handoff from the previous step. This means it won't return to the calling step. The workflow execution will continue linearly.
	//
	// Use case:
	//
	// - You want to collect information linearly (e.g. a form, provide information, etc).
	// These are the destinations that the step can go to after it's done.
	Destinations []*StepDestination `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the name of the step.
	Name string `json:"name" url:"name"`
	// This is the id of the block to use. To use a transient block, use `block`.
	BlockId *string `json:"blockId,omitempty" url:"blockId,omitempty"`
	// This is the input to the block. You can use any key-value map as input to the block.
	//
	// Example:
	// {
	// "name": "John Doe",
	// "age": 20
	// }
	//
	// You can reference any variable in the context of the current block:
	//
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// Example:
	// {
	// "name": "{{my-tool-call-step.output.name}}",
	// "age": "{{my-tool-call-step.input.age}}",
	// "date": "{{workflow.input.date}}"
	// }
	//
	// You can dynamically change the key name.
	//
	// Example:
	// {
	// "{{my-tool-call-step.output.key-name-for-name}}": "{{name}}",
	// "{{my-tool-call-step.input.key-name-for-age}}": "{{age}}",
	// "{{workflow.input.key-name-for-date}}": "{{date}}"
	// }
	//
	// You can represent the value as a string, number, boolean, array, or object.
	//
	// Example:
	// {
	// "name": "john",
	// "age": 20,
	// "date": "2021-01-01",
	// "metadata": {
	// "unique-key": "{{my-tool-call-step.output.unique-key}}"
	// },
	// "array": ["A", "B", "C"],
	// }
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow.
	Input map[string]interface{} `json:"input,omitempty" url:"input,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HandoffStep) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HandoffStep) Type() string {
	return h.type_
}

func (h *HandoffStep) UnmarshalJSON(data []byte) error {
	type embed HandoffStep
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HandoffStep(unmarshaler.embed)
	if unmarshaler.Type != "handoff" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", h, "handoff", unmarshaler.Type)
	}
	h.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *h, "type")
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HandoffStep) MarshalJSON() ([]byte, error) {
	type embed HandoffStep
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*h),
		Type:  "handoff",
	}
	return json.Marshal(marshaler)
}

func (h *HandoffStep) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// This is the block to use. To use an existing block, use `blockId`.
type HandoffStepBlock struct {
	CreateConversationBlockDto *CreateConversationBlockDto
	CreateToolCallBlockDto     *CreateToolCallBlockDto
	// This is the CreateWorkflowBlockDTO object but Swagger does not display nested schemas correctly.
	CreateWorkflowBlockDto *CreateWorkflowBlockDto
}

func (h *HandoffStepBlock) UnmarshalJSON(data []byte) error {
	valueCreateConversationBlockDto := new(CreateConversationBlockDto)
	if err := json.Unmarshal(data, &valueCreateConversationBlockDto); err == nil {
		h.CreateConversationBlockDto = valueCreateConversationBlockDto
		return nil
	}
	valueCreateToolCallBlockDto := new(CreateToolCallBlockDto)
	if err := json.Unmarshal(data, &valueCreateToolCallBlockDto); err == nil {
		h.CreateToolCallBlockDto = valueCreateToolCallBlockDto
		return nil
	}
	valueCreateWorkflowBlockDto := new(CreateWorkflowBlockDto)
	if err := json.Unmarshal(data, &valueCreateWorkflowBlockDto); err == nil {
		h.CreateWorkflowBlockDto = valueCreateWorkflowBlockDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HandoffStepBlock) MarshalJSON() ([]byte, error) {
	if h.CreateConversationBlockDto != nil {
		return json.Marshal(h.CreateConversationBlockDto)
	}
	if h.CreateToolCallBlockDto != nil {
		return json.Marshal(h.CreateToolCallBlockDto)
	}
	if h.CreateWorkflowBlockDto != nil {
		return json.Marshal(h.CreateWorkflowBlockDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HandoffStepBlockVisitor interface {
	VisitCreateConversationBlockDto(*CreateConversationBlockDto) error
	VisitCreateToolCallBlockDto(*CreateToolCallBlockDto) error
	VisitCreateWorkflowBlockDto(*CreateWorkflowBlockDto) error
}

func (h *HandoffStepBlock) Accept(visitor HandoffStepBlockVisitor) error {
	if h.CreateConversationBlockDto != nil {
		return visitor.VisitCreateConversationBlockDto(h.CreateConversationBlockDto)
	}
	if h.CreateToolCallBlockDto != nil {
		return visitor.VisitCreateToolCallBlockDto(h.CreateToolCallBlockDto)
	}
	if h.CreateWorkflowBlockDto != nil {
		return visitor.VisitCreateWorkflowBlockDto(h.CreateWorkflowBlockDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", h)
}

type ImportTwilioPhoneNumberDto struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *ImportTwilioPhoneNumberDtoFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// These are the digits of the phone number you own on your Twilio.
	TwilioPhoneNumber string `json:"twilioPhoneNumber" url:"twilioPhoneNumber"`
	// This is your Twilio Account SID that will be used to handle this phone number.
	TwilioAccountSid string `json:"twilioAccountSid" url:"twilioAccountSid"`
	// This is the Twilio Auth Token that will be used to handle this phone number.
	TwilioAuthToken string `json:"twilioAuthToken" url:"twilioAuthToken"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *ImportTwilioPhoneNumberDto) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ImportTwilioPhoneNumberDto) UnmarshalJSON(data []byte) error {
	type unmarshaler ImportTwilioPhoneNumberDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ImportTwilioPhoneNumberDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImportTwilioPhoneNumberDto) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type ImportTwilioPhoneNumberDtoFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (i *ImportTwilioPhoneNumberDtoFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		i.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		i.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ImportTwilioPhoneNumberDtoFallbackDestination) MarshalJSON() ([]byte, error) {
	if i.TransferDestinationNumber != nil {
		return json.Marshal(i.TransferDestinationNumber)
	}
	if i.TransferDestinationSip != nil {
		return json.Marshal(i.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ImportTwilioPhoneNumberDtoFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (i *ImportTwilioPhoneNumberDtoFallbackDestination) Accept(visitor ImportTwilioPhoneNumberDtoFallbackDestinationVisitor) error {
	if i.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(i.TransferDestinationNumber)
	}
	if i.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(i.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ImportVonagePhoneNumberDto struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *ImportVonagePhoneNumberDtoFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// These are the digits of the phone number you own on your Vonage.
	VonagePhoneNumber string `json:"vonagePhoneNumber" url:"vonagePhoneNumber"`
	// This is the credential that is used to make outgoing calls, and do operations like call transfer and hang up.
	//
	// You can add the Vonage Credential in the Provider Credentials page on the dashboard to get the credentialId.
	CredentialId string `json:"credentialId" url:"credentialId"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *ImportVonagePhoneNumberDto) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ImportVonagePhoneNumberDto) UnmarshalJSON(data []byte) error {
	type unmarshaler ImportVonagePhoneNumberDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ImportVonagePhoneNumberDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImportVonagePhoneNumberDto) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type ImportVonagePhoneNumberDtoFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (i *ImportVonagePhoneNumberDtoFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		i.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		i.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ImportVonagePhoneNumberDtoFallbackDestination) MarshalJSON() ([]byte, error) {
	if i.TransferDestinationNumber != nil {
		return json.Marshal(i.TransferDestinationNumber)
	}
	if i.TransferDestinationSip != nil {
		return json.Marshal(i.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ImportVonagePhoneNumberDtoFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (i *ImportVonagePhoneNumberDtoFallbackDestination) Accept(visitor ImportVonagePhoneNumberDtoFallbackDestinationVisitor) error {
	if i.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(i.TransferDestinationNumber)
	}
	if i.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(i.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InviteUserDto struct {
	Email string            `json:"email" url:"email"`
	Role  InviteUserDtoRole `json:"role" url:"role"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InviteUserDto) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InviteUserDto) UnmarshalJSON(data []byte) error {
	type unmarshaler InviteUserDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InviteUserDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InviteUserDto) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InviteUserDtoRole string

const (
	InviteUserDtoRoleAdmin  InviteUserDtoRole = "admin"
	InviteUserDtoRoleEditor InviteUserDtoRole = "editor"
	InviteUserDtoRoleViewer InviteUserDtoRole = "viewer"
)

func NewInviteUserDtoRoleFromString(s string) (InviteUserDtoRole, error) {
	switch s {
	case "admin":
		return InviteUserDtoRoleAdmin, nil
	case "editor":
		return InviteUserDtoRoleEditor, nil
	case "viewer":
		return InviteUserDtoRoleViewer, nil
	}
	var t InviteUserDtoRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InviteUserDtoRole) Ptr() *InviteUserDtoRole {
	return &i
}

type JsonSchema struct {
	// This is the type of output you'd like.
	//
	// `string`, `number`, `integer`, `boolean` are the primitive types and should be obvious.
	//
	// `array` and `object` are more interesting and quite powerful. They allow you to define nested structures.
	//
	// For `array`, you can define the schema of the items in the array using the `items` property.
	//
	// For `object`, you can define the properties of the object using the `properties` property.
	Type JsonSchemaType `json:"type" url:"type"`
	// This is required if the type is "array". This is the schema of the items in the array.
	//
	// This is of type JsonSchema. However, Swagger doesn't support circular references.
	Items map[string]interface{} `json:"items,omitempty" url:"items,omitempty"`
	// This is required if the type is "object". This specifies the properties of the object.
	//
	// This is a map of string to JsonSchema. However, Swagger doesn't support circular references.
	Properties map[string]interface{} `json:"properties,omitempty" url:"properties,omitempty"`
	// This is the description to help the model understand what it needs to output.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is a list of properties that are required.
	//
	// This only makes sense if the type is "object".
	Required []string `json:"required,omitempty" url:"required,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JsonSchema) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonSchema(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JsonSchema) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// This is the type of output you'd like.
//
// `string`, `number`, `integer`, `boolean` are the primitive types and should be obvious.
//
// `array` and `object` are more interesting and quite powerful. They allow you to define nested structures.
//
// For `array`, you can define the schema of the items in the array using the `items` property.
//
// For `object`, you can define the properties of the object using the `properties` property.
type JsonSchemaType string

const (
	JsonSchemaTypeString  JsonSchemaType = "string"
	JsonSchemaTypeNumber  JsonSchemaType = "number"
	JsonSchemaTypeInteger JsonSchemaType = "integer"
	JsonSchemaTypeBoolean JsonSchemaType = "boolean"
	JsonSchemaTypeArray   JsonSchemaType = "array"
	JsonSchemaTypeObject  JsonSchemaType = "object"
)

func NewJsonSchemaTypeFromString(s string) (JsonSchemaType, error) {
	switch s {
	case "string":
		return JsonSchemaTypeString, nil
	case "number":
		return JsonSchemaTypeNumber, nil
	case "integer":
		return JsonSchemaTypeInteger, nil
	case "boolean":
		return JsonSchemaTypeBoolean, nil
	case "array":
		return JsonSchemaTypeArray, nil
	case "object":
		return JsonSchemaTypeObject, nil
	}
	var t JsonSchemaType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonSchemaType) Ptr() *JsonSchemaType {
	return &j
}

type KnowledgeBase struct {
	TopK     *float64 `json:"topK,omitempty" url:"topK,omitempty"`
	FileIds  []string `json:"fileIds,omitempty" url:"fileIds,omitempty"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (k *KnowledgeBase) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBase) Provider() string {
	return k.provider
}

func (k *KnowledgeBase) UnmarshalJSON(data []byte) error {
	type embed KnowledgeBase
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*k),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*k = KnowledgeBase(unmarshaler.embed)
	if unmarshaler.Provider != "canonical" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", k, "canonical", unmarshaler.Provider)
	}
	k.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *k, "provider")
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties

	k._rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBase) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBase
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*k),
		Provider: "canonical",
	}
	return json.Marshal(marshaler)
}

func (k *KnowledgeBase) String() string {
	if len(k._rawJSON) > 0 {
		if value, err := core.StringifyJSON(k._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

type LmntCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LmntCredential) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LmntCredential) Provider() string {
	return l.provider
}

func (l *LmntCredential) UnmarshalJSON(data []byte) error {
	type embed LmntCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LmntCredential(unmarshaler.embed)
	l.CreatedAt = unmarshaler.CreatedAt.Time()
	l.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "lmnt", unmarshaler.Provider)
	}
	l.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *l, "provider")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LmntCredential) MarshalJSON() ([]byte, error) {
	type embed LmntCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*l),
		CreatedAt: core.NewDateTime(l.CreatedAt),
		UpdatedAt: core.NewDateTime(l.UpdatedAt),
		Provider:  "lmnt",
	}
	return json.Marshal(marshaler)
}

func (l *LmntCredential) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LmntVoice struct {
	// This determines whether fillers are injected into the model output before inputting it into the voice provider.
	//
	// Default `false` because you can achieve better results with prompting the model.
	FillerInjectionEnabled *bool `json:"fillerInjectionEnabled,omitempty" url:"fillerInjectionEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *LmntVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LmntVoice) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LmntVoice) Provider() string {
	return l.provider
}

func (l *LmntVoice) UnmarshalJSON(data []byte) error {
	type embed LmntVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LmntVoice(unmarshaler.embed)
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "lmnt", unmarshaler.Provider)
	}
	l.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *l, "provider")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LmntVoice) MarshalJSON() ([]byte, error) {
	type embed LmntVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*l),
		Provider: "lmnt",
	}
	return json.Marshal(marshaler)
}

func (l *LmntVoice) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// This is the provider-specific ID that will be used.
type LmntVoiceVoiceId struct {
	lilyStringLiteral   string
	danielStringLiteral string
	String              string
}

func NewLmntVoiceVoiceIdWithLilyStringLiteral() *LmntVoiceVoiceId {
	return &LmntVoiceVoiceId{lilyStringLiteral: "lily"}
}

func NewLmntVoiceVoiceIdWithDanielStringLiteral() *LmntVoiceVoiceId {
	return &LmntVoiceVoiceId{danielStringLiteral: "daniel"}
}

func (l *LmntVoiceVoiceId) LilyStringLiteral() string {
	return l.lilyStringLiteral
}

func (l *LmntVoiceVoiceId) DanielStringLiteral() string {
	return l.danielStringLiteral
}

func (l *LmntVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueLilyStringLiteral string
	if err := json.Unmarshal(data, &valueLilyStringLiteral); err == nil {
		l.lilyStringLiteral = valueLilyStringLiteral
		if l.lilyStringLiteral != "lily" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "lily", valueLilyStringLiteral)
		}
		return nil
	}
	var valueDanielStringLiteral string
	if err := json.Unmarshal(data, &valueDanielStringLiteral); err == nil {
		l.danielStringLiteral = valueDanielStringLiteral
		if l.danielStringLiteral != "daniel" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "daniel", valueDanielStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LmntVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if l.lilyStringLiteral != "" {
		return json.Marshal("lily")
	}
	if l.danielStringLiteral != "" {
		return json.Marshal("daniel")
	}
	if l.String != "" {
		return json.Marshal(l.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LmntVoiceVoiceIdVisitor interface {
	VisitLilyStringLiteral(string) error
	VisitDanielStringLiteral(string) error
	VisitString(string) error
}

func (l *LmntVoiceVoiceId) Accept(visitor LmntVoiceVoiceIdVisitor) error {
	if l.lilyStringLiteral != "" {
		return visitor.VisitLilyStringLiteral(l.lilyStringLiteral)
	}
	if l.danielStringLiteral != "" {
		return visitor.VisitDanielStringLiteral(l.danielStringLiteral)
	}
	if l.String != "" {
		return visitor.VisitString(l.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

type Log struct {
	// This is the timestamp at which the log was written.
	Time float64 `json:"time" url:"time"`
	// This is the unique identifier for the org that this log belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the type of the log.
	Type LogType `json:"type" url:"type"`
	// This is the specific resource, relevant only to API logs.
	Resource *LogResource `json:"resource,omitempty" url:"resource,omitempty"`
	// 'This is how long the request took.
	RequestDurationSeconds float64 `json:"requestDurationSeconds" url:"requestDurationSeconds"`
	// This is the timestamp at which the request began.
	RequestStartedAt string `json:"requestStartedAt" url:"requestStartedAt"`
	// This is the timestamp at which the request finished.
	RequestFinishedAt string `json:"requestFinishedAt" url:"requestFinishedAt"`
	// This is the body of the request.
	RequestBody map[string]interface{} `json:"requestBody,omitempty" url:"requestBody,omitempty"`
	// This is the request method.
	RequestHttpMethod LogRequestHttpMethod `json:"requestHttpMethod" url:"requestHttpMethod"`
	// This is the request URL.
	RequestUrl string `json:"requestUrl" url:"requestUrl"`
	// This is the request path.
	RequestPath string `json:"requestPath" url:"requestPath"`
	// This is the request query.
	RequestQuery *string `json:"requestQuery,omitempty" url:"requestQuery,omitempty"`
	// This the HTTP status code of the response.
	ResponseHttpCode float64 `json:"responseHttpCode" url:"responseHttpCode"`
	// This is the request IP address.
	RequestIpAddress *string `json:"requestIpAddress,omitempty" url:"requestIpAddress,omitempty"`
	// This is the origin of the request
	RequestOrigin *string `json:"requestOrigin,omitempty" url:"requestOrigin,omitempty"`
	// This is the body of the response.
	ResponseBody map[string]interface{} `json:"responseBody,omitempty" url:"responseBody,omitempty"`
	// These are the headers of the request.
	RequestHeaders map[string]interface{} `json:"requestHeaders,omitempty" url:"requestHeaders,omitempty"`
	// This is the error, if one occurred.
	Error *Error `json:"error,omitempty" url:"error,omitempty"`
	// This is the ID of the assistant.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the ID of the phone number.
	PhoneNumberId *string `json:"phoneNumberId,omitempty" url:"phoneNumberId,omitempty"`
	// This is the ID of the customer.
	CustomerId *string `json:"customerId,omitempty" url:"customerId,omitempty"`
	// This is the ID of the squad.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the ID of the call.
	CallId *string `json:"callId,omitempty" url:"callId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Log) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Log) UnmarshalJSON(data []byte) error {
	type unmarshaler Log
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Log(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Log) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// This is the request method.
type LogRequestHttpMethod string

const (
	LogRequestHttpMethodPost   LogRequestHttpMethod = "POST"
	LogRequestHttpMethodGet    LogRequestHttpMethod = "GET"
	LogRequestHttpMethodPut    LogRequestHttpMethod = "PUT"
	LogRequestHttpMethodPatch  LogRequestHttpMethod = "PATCH"
	LogRequestHttpMethodDelete LogRequestHttpMethod = "DELETE"
)

func NewLogRequestHttpMethodFromString(s string) (LogRequestHttpMethod, error) {
	switch s {
	case "POST":
		return LogRequestHttpMethodPost, nil
	case "GET":
		return LogRequestHttpMethodGet, nil
	case "PUT":
		return LogRequestHttpMethodPut, nil
	case "PATCH":
		return LogRequestHttpMethodPatch, nil
	case "DELETE":
		return LogRequestHttpMethodDelete, nil
	}
	var t LogRequestHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogRequestHttpMethod) Ptr() *LogRequestHttpMethod {
	return &l
}

// This is the specific resource, relevant only to API logs.
type LogResource string

const (
	LogResourceAssistant   LogResource = "assistant"
	LogResourcePhoneNumber LogResource = "phone-number"
	LogResourceTool        LogResource = "tool"
	LogResourceSquad       LogResource = "squad"
	LogResourceCall        LogResource = "call"
	LogResourceFile        LogResource = "file"
	LogResourceMetric      LogResource = "metric"
	LogResourceLog         LogResource = "log"
)

func NewLogResourceFromString(s string) (LogResource, error) {
	switch s {
	case "assistant":
		return LogResourceAssistant, nil
	case "phone-number":
		return LogResourcePhoneNumber, nil
	case "tool":
		return LogResourceTool, nil
	case "squad":
		return LogResourceSquad, nil
	case "call":
		return LogResourceCall, nil
	case "file":
		return LogResourceFile, nil
	case "metric":
		return LogResourceMetric, nil
	case "log":
		return LogResourceLog, nil
	}
	var t LogResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogResource) Ptr() *LogResource {
	return &l
}

// This is the type of the log.
type LogType string

const (
	LogTypeApi      LogType = "API"
	LogTypeWebhook  LogType = "Webhook"
	LogTypeCall     LogType = "Call"
	LogTypeProvider LogType = "Provider"
)

func NewLogTypeFromString(s string) (LogType, error) {
	switch s {
	case "API":
		return LogTypeApi, nil
	case "Webhook":
		return LogTypeWebhook, nil
	case "Call":
		return LogTypeCall, nil
	case "Provider":
		return LogTypeProvider, nil
	}
	var t LogType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogType) Ptr() *LogType {
	return &l
}

type LogsPaginatedResponse struct {
	Results  []*Log          `json:"results,omitempty" url:"results,omitempty"`
	Metadata *PaginationMeta `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LogsPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogsPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LogsPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogsPaginatedResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogsPaginatedResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MakeCredential struct {
	// Team ID
	TeamId string `json:"teamId" url:"teamId"`
	// Region of your application. For example: eu1, eu2, us1, us2
	Region string `json:"region" url:"region"`
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MakeCredential) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeCredential) Provider() string {
	return m.provider
}

func (m *MakeCredential) UnmarshalJSON(data []byte) error {
	type embed MakeCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeCredential(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Provider)
	}
	m.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *m, "provider")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeCredential) MarshalJSON() ([]byte, error) {
	type embed MakeCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*m),
		CreatedAt: core.NewDateTime(m.CreatedAt),
		UpdatedAt: core.NewDateTime(m.UpdatedAt),
		Provider:  "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeCredential) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*MakeToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server   *Server           `json:"server,omitempty" url:"server,omitempty"`
	Metadata *MakeToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MakeTool) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeTool) Type() string {
	return m.type_
}

func (m *MakeTool) UnmarshalJSON(data []byte) error {
	type embed MakeTool
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeTool(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeTool) MarshalJSON() ([]byte, error) {
	type embed MakeTool
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*m),
		CreatedAt: core.NewDateTime(m.CreatedAt),
		UpdatedAt: core.NewDateTime(m.UpdatedAt),
		Type:      "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeTool) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (m *MakeToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		m.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		m.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		m.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		m.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MakeToolMessagesItem) MarshalJSON() ([]byte, error) {
	if m.ToolMessageStart != nil {
		return json.Marshal(m.ToolMessageStart)
	}
	if m.ToolMessageComplete != nil {
		return json.Marshal(m.ToolMessageComplete)
	}
	if m.ToolMessageFailed != nil {
		return json.Marshal(m.ToolMessageFailed)
	}
	if m.ToolMessageDelayed != nil {
		return json.Marshal(m.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MakeToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (m *MakeToolMessagesItem) Accept(visitor MakeToolMessagesItemVisitor) error {
	if m.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(m.ToolMessageStart)
	}
	if m.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(m.ToolMessageComplete)
	}
	if m.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(m.ToolMessageFailed)
	}
	if m.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(m.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MakeToolMetadata struct {
	ScenarioId    *float64 `json:"scenarioId,omitempty" url:"scenarioId,omitempty"`
	TriggerHookId *float64 `json:"triggerHookId,omitempty" url:"triggerHookId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MakeToolMetadata) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeToolMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler MakeToolMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MakeToolMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeToolMetadata) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "make" for Make tool.
	ScenarioId      *float64 `json:"scenarioId,omitempty" url:"scenarioId,omitempty"`
	ScenarioName    *string  `json:"scenarioName,omitempty" url:"scenarioName,omitempty"`
	TriggerHookId   *float64 `json:"triggerHookId,omitempty" url:"triggerHookId,omitempty"`
	TriggerHookName *string  `json:"triggerHookName,omitempty" url:"triggerHookName,omitempty"`
	type_           string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MakeToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeToolProviderDetails) Type() string {
	return m.type_
}

func (m *MakeToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed MakeToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed MakeToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeToolProviderDetails) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*MakeToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "make" for Make tool.
	ToolCall *ToolCall         `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	Metadata *MakeToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MakeToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeToolWithToolCall) Type() string {
	return m.type_
}

func (m *MakeToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed MakeToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed MakeToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeToolWithToolCall) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (m *MakeToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		m.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		m.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		m.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		m.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MakeToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if m.ToolMessageStart != nil {
		return json.Marshal(m.ToolMessageStart)
	}
	if m.ToolMessageComplete != nil {
		return json.Marshal(m.ToolMessageComplete)
	}
	if m.ToolMessageFailed != nil {
		return json.Marshal(m.ToolMessageFailed)
	}
	if m.ToolMessageDelayed != nil {
		return json.Marshal(m.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MakeToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (m *MakeToolWithToolCallMessagesItem) Accept(visitor MakeToolWithToolCallMessagesItemVisitor) error {
	if m.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(m.ToolMessageStart)
	}
	if m.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(m.ToolMessageComplete)
	}
	if m.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(m.ToolMessageFailed)
	}
	if m.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(m.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MessagePlan struct {
	// This are the messages that the assistant will speak when the user hasn't responded for `idleTimeoutSeconds`. Each time the timeout is triggered, a random message will be chosen from this array.
	//
	// Usage:
	//
	// - If user gets distracted and doesn't respond for a while, this can be used to grab their attention.
	// - If the transcriber doesn't pick up what the user said, this can be used to ask the user to repeat themselves. (From the perspective of the assistant, the conversation is idle since it didn't "hear" any user messages.)
	//
	// @default null (no idle message is spoken)
	IdleMessages []string `json:"idleMessages,omitempty" url:"idleMessages,omitempty"`
	// This determines the maximum number of times `idleMessages` can be spoken during the call.
	//
	// @default 3
	IdleMessageMaxSpokenCount *float64 `json:"idleMessageMaxSpokenCount,omitempty" url:"idleMessageMaxSpokenCount,omitempty"`
	// This is the timeout in seconds before a message from `idleMessages` is spoken. The clock starts when the assistant finishes speaking and remains active until the user speaks.
	//
	// @default 10
	IdleTimeoutSeconds *float64 `json:"idleTimeoutSeconds,omitempty" url:"idleTimeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MessagePlan) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MessagePlan) UnmarshalJSON(data []byte) error {
	type unmarshaler MessagePlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessagePlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessagePlan) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Metrics struct {
	OrgId                            string                 `json:"orgId" url:"orgId"`
	RangeStart                       string                 `json:"rangeStart" url:"rangeStart"`
	RangeEnd                         string                 `json:"rangeEnd" url:"rangeEnd"`
	Bill                             float64                `json:"bill" url:"bill"`
	BillWithinBillingLimit           bool                   `json:"billWithinBillingLimit" url:"billWithinBillingLimit"`
	BillDailyBreakdown               map[string]interface{} `json:"billDailyBreakdown,omitempty" url:"billDailyBreakdown,omitempty"`
	CallActive                       float64                `json:"callActive" url:"callActive"`
	CallActiveWithinConcurrencyLimit bool                   `json:"callActiveWithinConcurrencyLimit" url:"callActiveWithinConcurrencyLimit"`
	CallMinutes                      float64                `json:"callMinutes" url:"callMinutes"`
	CallMinutesDailyBreakdown        map[string]interface{} `json:"callMinutesDailyBreakdown,omitempty" url:"callMinutesDailyBreakdown,omitempty"`
	CallMinutesAverage               float64                `json:"callMinutesAverage" url:"callMinutesAverage"`
	CallMinutesAverageDailyBreakdown map[string]interface{} `json:"callMinutesAverageDailyBreakdown,omitempty" url:"callMinutesAverageDailyBreakdown,omitempty"`
	CallCount                        float64                `json:"callCount" url:"callCount"`
	CallCountDailyBreakdown          map[string]interface{} `json:"callCountDailyBreakdown,omitempty" url:"callCountDailyBreakdown,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Metrics) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metrics) UnmarshalJSON(data []byte) error {
	type unmarshaler Metrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metrics(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metrics) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelBasedCondition struct {
	// This condition is based on a model.
	// This is the instruction which should output a boolean value when passed to a model.
	//
	// You can reference any variable in the context of the current block execution (step):
	//
	// - "{{output.your-property-name}}" for current step's output
	// - "{{input.your-property-name}}" for current step's input
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// You can also talk about the current step's output or input directly:
	//
	// - "{{output.your-property-name}} is greater than 10"
	// - "{{input.your-property-name}} is greater than 10"
	//
	// Examples:
	//
	// - "{{input.age}} is greater than 10"
	// - "{{input.age}} is greater than {{input.age2}}"
	// - "{{output.age}} is greater than 10"
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	Instruction string `json:"instruction" url:"instruction"`
	type_       string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *ModelBasedCondition) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelBasedCondition) Type() string {
	return m.type_
}

func (m *ModelBasedCondition) UnmarshalJSON(data []byte) error {
	type embed ModelBasedCondition
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = ModelBasedCondition(unmarshaler.embed)
	if unmarshaler.Type != "model-based" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "model-based", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelBasedCondition) MarshalJSON() ([]byte, error) {
	type embed ModelBasedCondition
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "model-based",
	}
	return json.Marshal(marshaler)
}

func (m *ModelBasedCondition) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelCost struct {
	// This is the type of cost, always 'model' for this class.
	// This is the model that was used during the call.
	//
	// This matches one of the following:
	//
	// - `call.assistant.model`,
	// - `call.assistantId->model`,
	// - `call.squad[n].assistant.model`,
	// - `call.squad[n].assistantId->model`,
	// - `call.squadId->[n].assistant.model`,
	// - `call.squadId->[n].assistantId->model`.
	Model map[string]interface{} `json:"model,omitempty" url:"model,omitempty"`
	// This is the number of prompt tokens used in the call. These should be total prompt tokens used in the call for single assistant calls, while squad calls will have multiple model costs one for each assistant that was used.
	PromptTokens float64 `json:"promptTokens" url:"promptTokens"`
	// This is the number of completion tokens generated in the call. These should be total completion tokens used in the call for single assistant calls, while squad calls will have multiple model costs one for each assistant that was used.
	CompletionTokens float64 `json:"completionTokens" url:"completionTokens"`
	// This is the cost of the component in USD.
	Cost  float64 `json:"cost" url:"cost"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *ModelCost) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelCost) Type() string {
	return m.type_
}

func (m *ModelCost) UnmarshalJSON(data []byte) error {
	type embed ModelCost
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = ModelCost(unmarshaler.embed)
	if unmarshaler.Type != "model" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "model", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelCost) MarshalJSON() ([]byte, error) {
	type embed ModelCost
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "model",
	}
	return json.Marshal(marshaler)
}

func (m *ModelCost) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Monitor struct {
	// This is the URL where the assistant's calls can be listened to in real-time. To enable, set `assistant.monitorPlan.listenEnabled` to `true`.
	ListenUrl *string `json:"listenUrl,omitempty" url:"listenUrl,omitempty"`
	// This is the URL where the assistant's calls can be controlled in real-time. To enable, set `assistant.monitorPlan.controlEnabled` to `true`.
	ControlUrl *string `json:"controlUrl,omitempty" url:"controlUrl,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Monitor) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Monitor) UnmarshalJSON(data []byte) error {
	type unmarshaler Monitor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Monitor(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Monitor) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MonitorPlan struct {
	// This determines whether the assistant's calls allow live listening. Defaults to true.
	//
	// Fetch `call.monitor.listenUrl` to get the live listening URL.
	//
	// @default true
	ListenEnabled *bool `json:"listenEnabled,omitempty" url:"listenEnabled,omitempty"`
	// This determines whether the assistant's calls allow live control. Defaults to true.
	//
	// Fetch `call.monitor.controlUrl` to get the live control URL.
	//
	// To use, send any control message via a POST request to `call.monitor.controlUrl`. Here are the types of controls supported: https://docs.vapi.ai/api-reference/messages/client-inbound-message
	//
	// @default true
	ControlEnabled *bool `json:"controlEnabled,omitempty" url:"controlEnabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MonitorPlan) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MonitorPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler MonitorPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MonitorPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MonitorPlan) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NeetsVoice struct {
	// This determines whether fillers are injected into the model output before inputting it into the voice provider.
	//
	// Default `false` because you can achieve better results with prompting the model.
	FillerInjectionEnabled *bool `json:"fillerInjectionEnabled,omitempty" url:"fillerInjectionEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *NeetsVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NeetsVoice) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NeetsVoice) Provider() string {
	return n.provider
}

func (n *NeetsVoice) UnmarshalJSON(data []byte) error {
	type embed NeetsVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NeetsVoice(unmarshaler.embed)
	if unmarshaler.Provider != "neets" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", n, "neets", unmarshaler.Provider)
	}
	n.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *n, "provider")
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NeetsVoice) MarshalJSON() ([]byte, error) {
	type embed NeetsVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*n),
		Provider: "neets",
	}
	return json.Marshal(marshaler)
}

func (n *NeetsVoice) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// This is the provider-specific ID that will be used.
type NeetsVoiceVoiceId struct {
	vitsStringLiteral string
	vitsStringLiteral string
	String            string
}

func NewNeetsVoiceVoiceIdWithVitsStringLiteral() *NeetsVoiceVoiceId {
	return &NeetsVoiceVoiceId{vitsStringLiteral: "vits"}
}

func NewNeetsVoiceVoiceIdWithVitsStringLiteral() *NeetsVoiceVoiceId {
	return &NeetsVoiceVoiceId{vitsStringLiteral: "vits"}
}

func (n *NeetsVoiceVoiceId) VitsStringLiteral() string {
	return n.vitsStringLiteral
}

func (n *NeetsVoiceVoiceId) VitsStringLiteral() string {
	return n.vitsStringLiteral
}

func (n *NeetsVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueVitsStringLiteral string
	if err := json.Unmarshal(data, &valueVitsStringLiteral); err == nil {
		n.vitsStringLiteral = valueVitsStringLiteral
		if n.vitsStringLiteral != "vits" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", n, "vits", valueVitsStringLiteral)
		}
		return nil
	}
	var valueVitsStringLiteral string
	if err := json.Unmarshal(data, &valueVitsStringLiteral); err == nil {
		n.vitsStringLiteral = valueVitsStringLiteral
		if n.vitsStringLiteral != "vits" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", n, "vits", valueVitsStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NeetsVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if n.vitsStringLiteral != "" {
		return json.Marshal("vits")
	}
	if n.vitsStringLiteral != "" {
		return json.Marshal("vits")
	}
	if n.String != "" {
		return json.Marshal(n.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", n)
}

type NeetsVoiceVoiceIdVisitor interface {
	VisitVitsStringLiteral(string) error
	VisitVitsStringLiteral(string) error
	VisitString(string) error
}

func (n *NeetsVoiceVoiceId) Accept(visitor NeetsVoiceVoiceIdVisitor) error {
	if n.vitsStringLiteral != "" {
		return visitor.VisitVitsStringLiteral(n.vitsStringLiteral)
	}
	if n.vitsStringLiteral != "" {
		return visitor.VisitVitsStringLiteral(n.vitsStringLiteral)
	}
	if n.String != "" {
		return visitor.VisitString(n.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", n)
}

type OpenAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenAiCredential) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiCredential) Provider() string {
	return o.provider
}

func (o *OpenAiCredential) UnmarshalJSON(data []byte) error {
	type embed OpenAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiCredential(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiCredential) MarshalJSON() ([]byte, error) {
	type embed OpenAiCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
		Provider:  "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiCredential) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiFunction struct {
	// This is the the name of the function to be called.
	//
	// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
	Name        string  `json:"name" url:"name"`
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// These are the parameters the functions accepts, described as a JSON Schema object.
	//
	// See the [OpenAI guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema) for documentation about the format.
	//
	// Omitting parameters defines a function with an empty parameter list.
	Parameters *OpenAiFunctionParameters `json:"parameters,omitempty" url:"parameters,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenAiFunction) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiFunction) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenAiFunction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenAiFunction(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiFunction) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiFunctionParameters struct {
	// This must be set to 'object'. It instructs the model to return a JSON object containing the function call properties.
	// This provides a description of the properties required by the function.
	// JSON Schema can be used to specify expectations for each property.
	// Refer to [this doc](https://ajv.js.org/json-schema.html#json-data-type) for a comprehensive guide on JSON Schema.
	Properties map[string]*JsonSchema `json:"properties,omitempty" url:"properties,omitempty"`
	// This specifies the properties that are required by the function.
	Required []string `json:"required,omitempty" url:"required,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenAiFunctionParameters) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiFunctionParameters) Type() string {
	return o.type_
}

func (o *OpenAiFunctionParameters) UnmarshalJSON(data []byte) error {
	type embed OpenAiFunctionParameters
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiFunctionParameters(unmarshaler.embed)
	if unmarshaler.Type != "object" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "object", unmarshaler.Type)
	}
	o.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *o, "type")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiFunctionParameters) MarshalJSON() ([]byte, error) {
	type embed OpenAiFunctionParameters
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*o),
		Type:  "object",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiFunctionParameters) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiMessage struct {
	Content *string           `json:"content,omitempty" url:"content,omitempty"`
	Role    OpenAiMessageRole `json:"role" url:"role"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenAiMessage) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenAiMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenAiMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiMessage) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiMessageRole string

const (
	OpenAiMessageRoleAssistant OpenAiMessageRole = "assistant"
	OpenAiMessageRoleFunction  OpenAiMessageRole = "function"
	OpenAiMessageRoleUser      OpenAiMessageRole = "user"
	OpenAiMessageRoleSystem    OpenAiMessageRole = "system"
	OpenAiMessageRoleTool      OpenAiMessageRole = "tool"
)

func NewOpenAiMessageRoleFromString(s string) (OpenAiMessageRole, error) {
	switch s {
	case "assistant":
		return OpenAiMessageRoleAssistant, nil
	case "function":
		return OpenAiMessageRoleFunction, nil
	case "user":
		return OpenAiMessageRoleUser, nil
	case "system":
		return OpenAiMessageRoleSystem, nil
	case "tool":
		return OpenAiMessageRoleTool, nil
	}
	var t OpenAiMessageRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiMessageRole) Ptr() *OpenAiMessageRole {
	return &o
}

type OpenAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*OpenAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// This is the provider that will be used for the model.
	// This is the OpenAI model that will be used.
	Model OpenAiModelModel `json:"model" url:"model"`
	// These are the fallback models that will be used if the primary model fails. This shouldn't be specified unless you have a specific reason to do so. Vapi will automatically find the fastest fallbacks that make sense.
	FallbackModels         []OpenAiModelFallbackModelsItem `json:"fallbackModels,omitempty" url:"fallbackModels,omitempty"`
	SemanticCachingEnabled *bool                           `json:"semanticCachingEnabled,omitempty" url:"semanticCachingEnabled,omitempty"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *KnowledgeBase `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenAiModel) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiModel) Provider() string {
	return o.provider
}

func (o *OpenAiModel) UnmarshalJSON(data []byte) error {
	type embed OpenAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiModel) MarshalJSON() ([]byte, error) {
	type embed OpenAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiModel) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiModelFallbackModelsItem string

const (
	OpenAiModelFallbackModelsItemGpt4OMini         OpenAiModelFallbackModelsItem = "gpt-4o-mini"
	OpenAiModelFallbackModelsItemGpt4OMini20240718 OpenAiModelFallbackModelsItem = "gpt-4o-mini-2024-07-18"
	OpenAiModelFallbackModelsItemGpt4O             OpenAiModelFallbackModelsItem = "gpt-4o"
	OpenAiModelFallbackModelsItemGpt4O20240513     OpenAiModelFallbackModelsItem = "gpt-4o-2024-05-13"
	OpenAiModelFallbackModelsItemGpt4O20240806     OpenAiModelFallbackModelsItem = "gpt-4o-2024-08-06"
	OpenAiModelFallbackModelsItemGpt4Turbo         OpenAiModelFallbackModelsItem = "gpt-4-turbo"
	OpenAiModelFallbackModelsItemGpt4Turbo20240409 OpenAiModelFallbackModelsItem = "gpt-4-turbo-2024-04-09"
	OpenAiModelFallbackModelsItemGpt4TurboPreview  OpenAiModelFallbackModelsItem = "gpt-4-turbo-preview"
	OpenAiModelFallbackModelsItemGpt40125Preview   OpenAiModelFallbackModelsItem = "gpt-4-0125-preview"
	OpenAiModelFallbackModelsItemGpt41106Preview   OpenAiModelFallbackModelsItem = "gpt-4-1106-preview"
	OpenAiModelFallbackModelsItemGpt4              OpenAiModelFallbackModelsItem = "gpt-4"
	OpenAiModelFallbackModelsItemGpt40613          OpenAiModelFallbackModelsItem = "gpt-4-0613"
	OpenAiModelFallbackModelsItemGpt35Turbo        OpenAiModelFallbackModelsItem = "gpt-3.5-turbo"
	OpenAiModelFallbackModelsItemGpt35Turbo0125    OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-0125"
	OpenAiModelFallbackModelsItemGpt35Turbo1106    OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-1106"
	OpenAiModelFallbackModelsItemGpt35Turbo16K     OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-16k"
	OpenAiModelFallbackModelsItemGpt35Turbo0613    OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-0613"
)

func NewOpenAiModelFallbackModelsItemFromString(s string) (OpenAiModelFallbackModelsItem, error) {
	switch s {
	case "gpt-4o-mini":
		return OpenAiModelFallbackModelsItemGpt4OMini, nil
	case "gpt-4o-mini-2024-07-18":
		return OpenAiModelFallbackModelsItemGpt4OMini20240718, nil
	case "gpt-4o":
		return OpenAiModelFallbackModelsItemGpt4O, nil
	case "gpt-4o-2024-05-13":
		return OpenAiModelFallbackModelsItemGpt4O20240513, nil
	case "gpt-4o-2024-08-06":
		return OpenAiModelFallbackModelsItemGpt4O20240806, nil
	case "gpt-4-turbo":
		return OpenAiModelFallbackModelsItemGpt4Turbo, nil
	case "gpt-4-turbo-2024-04-09":
		return OpenAiModelFallbackModelsItemGpt4Turbo20240409, nil
	case "gpt-4-turbo-preview":
		return OpenAiModelFallbackModelsItemGpt4TurboPreview, nil
	case "gpt-4-0125-preview":
		return OpenAiModelFallbackModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return OpenAiModelFallbackModelsItemGpt41106Preview, nil
	case "gpt-4":
		return OpenAiModelFallbackModelsItemGpt4, nil
	case "gpt-4-0613":
		return OpenAiModelFallbackModelsItemGpt40613, nil
	case "gpt-3.5-turbo":
		return OpenAiModelFallbackModelsItemGpt35Turbo, nil
	case "gpt-3.5-turbo-0125":
		return OpenAiModelFallbackModelsItemGpt35Turbo0125, nil
	case "gpt-3.5-turbo-1106":
		return OpenAiModelFallbackModelsItemGpt35Turbo1106, nil
	case "gpt-3.5-turbo-16k":
		return OpenAiModelFallbackModelsItemGpt35Turbo16K, nil
	case "gpt-3.5-turbo-0613":
		return OpenAiModelFallbackModelsItemGpt35Turbo0613, nil
	}
	var t OpenAiModelFallbackModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiModelFallbackModelsItem) Ptr() *OpenAiModelFallbackModelsItem {
	return &o
}

// This is the OpenAI model that will be used.
type OpenAiModelModel string

const (
	OpenAiModelModelGpt4OMini         OpenAiModelModel = "gpt-4o-mini"
	OpenAiModelModelGpt4OMini20240718 OpenAiModelModel = "gpt-4o-mini-2024-07-18"
	OpenAiModelModelGpt4O             OpenAiModelModel = "gpt-4o"
	OpenAiModelModelGpt4O20240513     OpenAiModelModel = "gpt-4o-2024-05-13"
	OpenAiModelModelGpt4O20240806     OpenAiModelModel = "gpt-4o-2024-08-06"
	OpenAiModelModelGpt4Turbo         OpenAiModelModel = "gpt-4-turbo"
	OpenAiModelModelGpt4Turbo20240409 OpenAiModelModel = "gpt-4-turbo-2024-04-09"
	OpenAiModelModelGpt4TurboPreview  OpenAiModelModel = "gpt-4-turbo-preview"
	OpenAiModelModelGpt40125Preview   OpenAiModelModel = "gpt-4-0125-preview"
	OpenAiModelModelGpt41106Preview   OpenAiModelModel = "gpt-4-1106-preview"
	OpenAiModelModelGpt4              OpenAiModelModel = "gpt-4"
	OpenAiModelModelGpt40613          OpenAiModelModel = "gpt-4-0613"
	OpenAiModelModelGpt35Turbo        OpenAiModelModel = "gpt-3.5-turbo"
	OpenAiModelModelGpt35Turbo0125    OpenAiModelModel = "gpt-3.5-turbo-0125"
	OpenAiModelModelGpt35Turbo1106    OpenAiModelModel = "gpt-3.5-turbo-1106"
	OpenAiModelModelGpt35Turbo16K     OpenAiModelModel = "gpt-3.5-turbo-16k"
	OpenAiModelModelGpt35Turbo0613    OpenAiModelModel = "gpt-3.5-turbo-0613"
)

func NewOpenAiModelModelFromString(s string) (OpenAiModelModel, error) {
	switch s {
	case "gpt-4o-mini":
		return OpenAiModelModelGpt4OMini, nil
	case "gpt-4o-mini-2024-07-18":
		return OpenAiModelModelGpt4OMini20240718, nil
	case "gpt-4o":
		return OpenAiModelModelGpt4O, nil
	case "gpt-4o-2024-05-13":
		return OpenAiModelModelGpt4O20240513, nil
	case "gpt-4o-2024-08-06":
		return OpenAiModelModelGpt4O20240806, nil
	case "gpt-4-turbo":
		return OpenAiModelModelGpt4Turbo, nil
	case "gpt-4-turbo-2024-04-09":
		return OpenAiModelModelGpt4Turbo20240409, nil
	case "gpt-4-turbo-preview":
		return OpenAiModelModelGpt4TurboPreview, nil
	case "gpt-4-0125-preview":
		return OpenAiModelModelGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return OpenAiModelModelGpt41106Preview, nil
	case "gpt-4":
		return OpenAiModelModelGpt4, nil
	case "gpt-4-0613":
		return OpenAiModelModelGpt40613, nil
	case "gpt-3.5-turbo":
		return OpenAiModelModelGpt35Turbo, nil
	case "gpt-3.5-turbo-0125":
		return OpenAiModelModelGpt35Turbo0125, nil
	case "gpt-3.5-turbo-1106":
		return OpenAiModelModelGpt35Turbo1106, nil
	case "gpt-3.5-turbo-16k":
		return OpenAiModelModelGpt35Turbo16K, nil
	case "gpt-3.5-turbo-0613":
		return OpenAiModelModelGpt35Turbo0613, nil
	}
	var t OpenAiModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiModelModel) Ptr() *OpenAiModelModel {
	return &o
}

type OpenAiModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (o *OpenAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		o.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		o.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		o.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		o.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		o.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		o.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		o.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if o.CreateDtmfToolDto != nil {
		return json.Marshal(o.CreateDtmfToolDto)
	}
	if o.CreateEndCallToolDto != nil {
		return json.Marshal(o.CreateEndCallToolDto)
	}
	if o.CreateVoicemailToolDto != nil {
		return json.Marshal(o.CreateVoicemailToolDto)
	}
	if o.CreateFunctionToolDto != nil {
		return json.Marshal(o.CreateFunctionToolDto)
	}
	if o.CreateGhlToolDto != nil {
		return json.Marshal(o.CreateGhlToolDto)
	}
	if o.CreateMakeToolDto != nil {
		return json.Marshal(o.CreateMakeToolDto)
	}
	if o.CreateTransferCallToolDto != nil {
		return json.Marshal(o.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (o *OpenAiModelToolsItem) Accept(visitor OpenAiModelToolsItemVisitor) error {
	if o.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(o.CreateDtmfToolDto)
	}
	if o.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(o.CreateEndCallToolDto)
	}
	if o.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(o.CreateVoicemailToolDto)
	}
	if o.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(o.CreateFunctionToolDto)
	}
	if o.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(o.CreateGhlToolDto)
	}
	if o.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(o.CreateMakeToolDto)
	}
	if o.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(o.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiVoice struct {
	// This determines whether fillers are injected into the model output before inputting it into the voice provider.
	//
	// Default `false` because you can achieve better results with prompting the model.
	FillerInjectionEnabled *bool `json:"fillerInjectionEnabled,omitempty" url:"fillerInjectionEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId OpenAiVoiceVoiceId `json:"voiceId" url:"voiceId"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenAiVoice) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiVoice) Provider() string {
	return o.provider
}

func (o *OpenAiVoice) UnmarshalJSON(data []byte) error {
	type embed OpenAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiVoice) MarshalJSON() ([]byte, error) {
	type embed OpenAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiVoice) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// This is the provider-specific ID that will be used.
type OpenAiVoiceVoiceId string

const (
	OpenAiVoiceVoiceIdAlloy   OpenAiVoiceVoiceId = "alloy"
	OpenAiVoiceVoiceIdEcho    OpenAiVoiceVoiceId = "echo"
	OpenAiVoiceVoiceIdFable   OpenAiVoiceVoiceId = "fable"
	OpenAiVoiceVoiceIdOnyx    OpenAiVoiceVoiceId = "onyx"
	OpenAiVoiceVoiceIdNova    OpenAiVoiceVoiceId = "nova"
	OpenAiVoiceVoiceIdShimmer OpenAiVoiceVoiceId = "shimmer"
)

func NewOpenAiVoiceVoiceIdFromString(s string) (OpenAiVoiceVoiceId, error) {
	switch s {
	case "alloy":
		return OpenAiVoiceVoiceIdAlloy, nil
	case "echo":
		return OpenAiVoiceVoiceIdEcho, nil
	case "fable":
		return OpenAiVoiceVoiceIdFable, nil
	case "onyx":
		return OpenAiVoiceVoiceIdOnyx, nil
	case "nova":
		return OpenAiVoiceVoiceIdNova, nil
	case "shimmer":
		return OpenAiVoiceVoiceIdShimmer, nil
	}
	var t OpenAiVoiceVoiceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiVoiceVoiceId) Ptr() *OpenAiVoiceVoiceId {
	return &o
}

type OpenRouterCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenRouterCredential) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenRouterCredential) Provider() string {
	return o.provider
}

func (o *OpenRouterCredential) UnmarshalJSON(data []byte) error {
	type embed OpenRouterCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenRouterCredential(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "openrouter" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openrouter", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenRouterCredential) MarshalJSON() ([]byte, error) {
	type embed OpenRouterCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
		Provider:  "openrouter",
	}
	return json.Marshal(marshaler)
}

func (o *OpenRouterCredential) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenRouterModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*OpenRouterModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *KnowledgeBase `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenRouterModel) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenRouterModel) Provider() string {
	return o.provider
}

func (o *OpenRouterModel) UnmarshalJSON(data []byte) error {
	type embed OpenRouterModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenRouterModel(unmarshaler.embed)
	if unmarshaler.Provider != "openrouter" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openrouter", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenRouterModel) MarshalJSON() ([]byte, error) {
	type embed OpenRouterModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openrouter",
	}
	return json.Marshal(marshaler)
}

func (o *OpenRouterModel) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenRouterModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (o *OpenRouterModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		o.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		o.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		o.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		o.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		o.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		o.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		o.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenRouterModelToolsItem) MarshalJSON() ([]byte, error) {
	if o.CreateDtmfToolDto != nil {
		return json.Marshal(o.CreateDtmfToolDto)
	}
	if o.CreateEndCallToolDto != nil {
		return json.Marshal(o.CreateEndCallToolDto)
	}
	if o.CreateVoicemailToolDto != nil {
		return json.Marshal(o.CreateVoicemailToolDto)
	}
	if o.CreateFunctionToolDto != nil {
		return json.Marshal(o.CreateFunctionToolDto)
	}
	if o.CreateGhlToolDto != nil {
		return json.Marshal(o.CreateGhlToolDto)
	}
	if o.CreateMakeToolDto != nil {
		return json.Marshal(o.CreateMakeToolDto)
	}
	if o.CreateTransferCallToolDto != nil {
		return json.Marshal(o.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenRouterModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (o *OpenRouterModelToolsItem) Accept(visitor OpenRouterModelToolsItemVisitor) error {
	if o.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(o.CreateDtmfToolDto)
	}
	if o.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(o.CreateEndCallToolDto)
	}
	if o.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(o.CreateVoicemailToolDto)
	}
	if o.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(o.CreateFunctionToolDto)
	}
	if o.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(o.CreateGhlToolDto)
	}
	if o.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(o.CreateMakeToolDto)
	}
	if o.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(o.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type Org struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	// When HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.
	// This is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// This is the unique identifier for the org.
	Id string `json:"id" url:"id"`
	// This is the ISO 8601 date-time string of when the org was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the org was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the Stripe customer for the org.
	StripeCustomerId *string `json:"stripeCustomerId,omitempty" url:"stripeCustomerId,omitempty"`
	// This is the subscription for the org.
	StripeSubscriptionId *string `json:"stripeSubscriptionId,omitempty" url:"stripeSubscriptionId,omitempty"`
	// This is the subscription's subscription item.
	StripeSubscriptionItemId *string `json:"stripeSubscriptionItemId,omitempty" url:"stripeSubscriptionItemId,omitempty"`
	// This is the subscription's current period start.
	StripeSubscriptionCurrentPeriodStart *time.Time `json:"stripeSubscriptionCurrentPeriodStart,omitempty" url:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	// This is the subscription's status.
	StripeSubscriptionStatus *string `json:"stripeSubscriptionStatus,omitempty" url:"stripeSubscriptionStatus,omitempty"`
	// This is the plan for the org.
	Plan *OrgPlan `json:"plan,omitempty" url:"plan,omitempty"`
	// This is the name of the org. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.
	BillingLimit *float64 `json:"billingLimit,omitempty" url:"billingLimit,omitempty"`
	// This is the URL Vapi will communicate with via HTTP GET and POST Requests. This is used for retrieving context, function calling, and end-of-call reports.
	//
	// All requests will be sent with the call object among other things relevant to that message. You can find more details in the Server URL documentation.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	// This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.
	ConcurrencyLimit *float64 `json:"concurrencyLimit,omitempty" url:"concurrencyLimit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Org) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Org) UnmarshalJSON(data []byte) error {
	type embed Org
	var unmarshaler = struct {
		embed
		CreatedAt                            *core.DateTime `json:"createdAt"`
		UpdatedAt                            *core.DateTime `json:"updatedAt"`
		StripeSubscriptionCurrentPeriodStart *core.DateTime `json:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Org(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	o.StripeSubscriptionCurrentPeriodStart = unmarshaler.StripeSubscriptionCurrentPeriodStart.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *Org) MarshalJSON() ([]byte, error) {
	type embed Org
	var marshaler = struct {
		embed
		CreatedAt                            *core.DateTime `json:"createdAt"`
		UpdatedAt                            *core.DateTime `json:"updatedAt"`
		StripeSubscriptionCurrentPeriodStart *core.DateTime `json:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	}{
		embed:                                embed(*o),
		CreatedAt:                            core.NewDateTime(o.CreatedAt),
		UpdatedAt:                            core.NewDateTime(o.UpdatedAt),
		StripeSubscriptionCurrentPeriodStart: core.NewOptionalDateTime(o.StripeSubscriptionCurrentPeriodStart),
	}
	return json.Marshal(marshaler)
}

func (o *Org) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrgPlan struct {
	IncludedProviders    []map[string]interface{} `json:"includedProviders,omitempty" url:"includedProviders,omitempty"`
	IncludedMinutes      *float64                 `json:"includedMinutes,omitempty" url:"includedMinutes,omitempty"`
	CostPerOverageMinute *float64                 `json:"costPerOverageMinute,omitempty" url:"costPerOverageMinute,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrgPlan) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrgPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler OrgPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrgPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrgPlan) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OutputTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*OutputToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OutputTool) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OutputTool) Type() string {
	return o.type_
}

func (o *OutputTool) UnmarshalJSON(data []byte) error {
	type embed OutputTool
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OutputTool(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "output" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "output", unmarshaler.Type)
	}
	o.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *o, "type")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OutputTool) MarshalJSON() ([]byte, error) {
	type embed OutputTool
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
		Type:      "output",
	}
	return json.Marshal(marshaler)
}

func (o *OutputTool) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OutputToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (o *OutputToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		o.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		o.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		o.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		o.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OutputToolMessagesItem) MarshalJSON() ([]byte, error) {
	if o.ToolMessageStart != nil {
		return json.Marshal(o.ToolMessageStart)
	}
	if o.ToolMessageComplete != nil {
		return json.Marshal(o.ToolMessageComplete)
	}
	if o.ToolMessageFailed != nil {
		return json.Marshal(o.ToolMessageFailed)
	}
	if o.ToolMessageDelayed != nil {
		return json.Marshal(o.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OutputToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (o *OutputToolMessagesItem) Accept(visitor OutputToolMessagesItemVisitor) error {
	if o.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(o.ToolMessageStart)
	}
	if o.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(o.ToolMessageComplete)
	}
	if o.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(o.ToolMessageFailed)
	}
	if o.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(o.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type PaginationMeta struct {
	ItemsPerPage float64 `json:"itemsPerPage" url:"itemsPerPage"`
	TotalItems   float64 `json:"totalItems" url:"totalItems"`
	CurrentPage  float64 `json:"currentPage" url:"currentPage"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaginationMeta) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginationMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginationMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginationMeta(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginationMeta) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PerplexityAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PerplexityAiCredential) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PerplexityAiCredential) Provider() string {
	return p.provider
}

func (p *PerplexityAiCredential) UnmarshalJSON(data []byte) error {
	type embed PerplexityAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PerplexityAiCredential(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "perplexity-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "perplexity-ai", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PerplexityAiCredential) MarshalJSON() ([]byte, error) {
	type embed PerplexityAiCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*p),
		CreatedAt: core.NewDateTime(p.CreatedAt),
		UpdatedAt: core.NewDateTime(p.UpdatedAt),
		Provider:  "perplexity-ai",
	}
	return json.Marshal(marshaler)
}

func (p *PerplexityAiCredential) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PerplexityAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*PerplexityAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *KnowledgeBase `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PerplexityAiModel) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PerplexityAiModel) Provider() string {
	return p.provider
}

func (p *PerplexityAiModel) UnmarshalJSON(data []byte) error {
	type embed PerplexityAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PerplexityAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "perplexity-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "perplexity-ai", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PerplexityAiModel) MarshalJSON() ([]byte, error) {
	type embed PerplexityAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*p),
		Provider: "perplexity-ai",
	}
	return json.Marshal(marshaler)
}

func (p *PerplexityAiModel) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PerplexityAiModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (p *PerplexityAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		p.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		p.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		p.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		p.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		p.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		p.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		p.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PerplexityAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if p.CreateDtmfToolDto != nil {
		return json.Marshal(p.CreateDtmfToolDto)
	}
	if p.CreateEndCallToolDto != nil {
		return json.Marshal(p.CreateEndCallToolDto)
	}
	if p.CreateVoicemailToolDto != nil {
		return json.Marshal(p.CreateVoicemailToolDto)
	}
	if p.CreateFunctionToolDto != nil {
		return json.Marshal(p.CreateFunctionToolDto)
	}
	if p.CreateGhlToolDto != nil {
		return json.Marshal(p.CreateGhlToolDto)
	}
	if p.CreateMakeToolDto != nil {
		return json.Marshal(p.CreateMakeToolDto)
	}
	if p.CreateTransferCallToolDto != nil {
		return json.Marshal(p.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PerplexityAiModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (p *PerplexityAiModelToolsItem) Accept(visitor PerplexityAiModelToolsItemVisitor) error {
	if p.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(p.CreateDtmfToolDto)
	}
	if p.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(p.CreateEndCallToolDto)
	}
	if p.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(p.CreateVoicemailToolDto)
	}
	if p.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(p.CreateFunctionToolDto)
	}
	if p.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(p.CreateGhlToolDto)
	}
	if p.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(p.CreateMakeToolDto)
	}
	if p.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(p.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PlayHtCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	UserId    string    `json:"userId" url:"userId"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PlayHtCredential) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlayHtCredential) Provider() string {
	return p.provider
}

func (p *PlayHtCredential) UnmarshalJSON(data []byte) error {
	type embed PlayHtCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PlayHtCredential(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "playht", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlayHtCredential) MarshalJSON() ([]byte, error) {
	type embed PlayHtCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*p),
		CreatedAt: core.NewDateTime(p.CreatedAt),
		UpdatedAt: core.NewDateTime(p.UpdatedAt),
		Provider:  "playht",
	}
	return json.Marshal(marshaler)
}

func (p *PlayHtCredential) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlayHtVoice struct {
	// This determines whether fillers are injected into the model output before inputting it into the voice provider.
	//
	// Default `false` because you can achieve better results with prompting the model.
	FillerInjectionEnabled *bool `json:"fillerInjectionEnabled,omitempty" url:"fillerInjectionEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *PlayHtVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// A floating point number between 0, exclusive, and 2, inclusive. If equal to null or not provided, the model's default temperature will be used. The temperature parameter controls variance. Lower temperatures result in more predictable results, higher temperatures allow each run to vary more, so the voice may sound less like the baseline voice.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// An emotion to be applied to the speech.
	Emotion *PlayHtVoiceEmotion `json:"emotion,omitempty" url:"emotion,omitempty"`
	// A number between 1 and 6. Use lower numbers to reduce how unique your chosen voice will be compared to other voices.
	VoiceGuidance *float64 `json:"voiceGuidance,omitempty" url:"voiceGuidance,omitempty"`
	// A number between 1 and 30. Use lower numbers to to reduce how strong your chosen emotion will be. Higher numbers will create a very emotional performance.
	StyleGuidance *float64 `json:"styleGuidance,omitempty" url:"styleGuidance,omitempty"`
	// A number between 1 and 2. This number influences how closely the generated speech adheres to the input text. Use lower values to create more fluid speech, but with a higher chance of deviating from the input text. Higher numbers will make the generated speech more accurate to the input text, ensuring that the words spoken align closely with the provided text.
	TextGuidance *float64 `json:"textGuidance,omitempty" url:"textGuidance,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PlayHtVoice) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlayHtVoice) Provider() string {
	return p.provider
}

func (p *PlayHtVoice) UnmarshalJSON(data []byte) error {
	type embed PlayHtVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PlayHtVoice(unmarshaler.embed)
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "playht", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlayHtVoice) MarshalJSON() ([]byte, error) {
	type embed PlayHtVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*p),
		Provider: "playht",
	}
	return json.Marshal(marshaler)
}

func (p *PlayHtVoice) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An emotion to be applied to the speech.
type PlayHtVoiceEmotion string

const (
	PlayHtVoiceEmotionFemaleHappy     PlayHtVoiceEmotion = "female_happy"
	PlayHtVoiceEmotionFemaleSad       PlayHtVoiceEmotion = "female_sad"
	PlayHtVoiceEmotionFemaleAngry     PlayHtVoiceEmotion = "female_angry"
	PlayHtVoiceEmotionFemaleFearful   PlayHtVoiceEmotion = "female_fearful"
	PlayHtVoiceEmotionFemaleDisgust   PlayHtVoiceEmotion = "female_disgust"
	PlayHtVoiceEmotionFemaleSurprised PlayHtVoiceEmotion = "female_surprised"
	PlayHtVoiceEmotionMaleHappy       PlayHtVoiceEmotion = "male_happy"
	PlayHtVoiceEmotionMaleSad         PlayHtVoiceEmotion = "male_sad"
	PlayHtVoiceEmotionMaleAngry       PlayHtVoiceEmotion = "male_angry"
	PlayHtVoiceEmotionMaleFearful     PlayHtVoiceEmotion = "male_fearful"
	PlayHtVoiceEmotionMaleDisgust     PlayHtVoiceEmotion = "male_disgust"
	PlayHtVoiceEmotionMaleSurprised   PlayHtVoiceEmotion = "male_surprised"
)

func NewPlayHtVoiceEmotionFromString(s string) (PlayHtVoiceEmotion, error) {
	switch s {
	case "female_happy":
		return PlayHtVoiceEmotionFemaleHappy, nil
	case "female_sad":
		return PlayHtVoiceEmotionFemaleSad, nil
	case "female_angry":
		return PlayHtVoiceEmotionFemaleAngry, nil
	case "female_fearful":
		return PlayHtVoiceEmotionFemaleFearful, nil
	case "female_disgust":
		return PlayHtVoiceEmotionFemaleDisgust, nil
	case "female_surprised":
		return PlayHtVoiceEmotionFemaleSurprised, nil
	case "male_happy":
		return PlayHtVoiceEmotionMaleHappy, nil
	case "male_sad":
		return PlayHtVoiceEmotionMaleSad, nil
	case "male_angry":
		return PlayHtVoiceEmotionMaleAngry, nil
	case "male_fearful":
		return PlayHtVoiceEmotionMaleFearful, nil
	case "male_disgust":
		return PlayHtVoiceEmotionMaleDisgust, nil
	case "male_surprised":
		return PlayHtVoiceEmotionMaleSurprised, nil
	}
	var t PlayHtVoiceEmotion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlayHtVoiceEmotion) Ptr() *PlayHtVoiceEmotion {
	return &p
}

// This is the provider-specific ID that will be used.
type PlayHtVoiceVoiceId struct {
	jenniferStringLiteral string
	melissaStringLiteral  string
	willStringLiteral     string
	chrisStringLiteral    string
	mattStringLiteral     string
	jackStringLiteral     string
	rubyStringLiteral     string
	davisStringLiteral    string
	donnaStringLiteral    string
	michaelStringLiteral  string
	String                string
}

func NewPlayHtVoiceVoiceIdWithJenniferStringLiteral() *PlayHtVoiceVoiceId {
	return &PlayHtVoiceVoiceId{jenniferStringLiteral: "jennifer"}
}

func NewPlayHtVoiceVoiceIdWithMelissaStringLiteral() *PlayHtVoiceVoiceId {
	return &PlayHtVoiceVoiceId{melissaStringLiteral: "melissa"}
}

func NewPlayHtVoiceVoiceIdWithWillStringLiteral() *PlayHtVoiceVoiceId {
	return &PlayHtVoiceVoiceId{willStringLiteral: "will"}
}

func NewPlayHtVoiceVoiceIdWithChrisStringLiteral() *PlayHtVoiceVoiceId {
	return &PlayHtVoiceVoiceId{chrisStringLiteral: "chris"}
}

func NewPlayHtVoiceVoiceIdWithMattStringLiteral() *PlayHtVoiceVoiceId {
	return &PlayHtVoiceVoiceId{mattStringLiteral: "matt"}
}

func NewPlayHtVoiceVoiceIdWithJackStringLiteral() *PlayHtVoiceVoiceId {
	return &PlayHtVoiceVoiceId{jackStringLiteral: "jack"}
}

func NewPlayHtVoiceVoiceIdWithRubyStringLiteral() *PlayHtVoiceVoiceId {
	return &PlayHtVoiceVoiceId{rubyStringLiteral: "ruby"}
}

func NewPlayHtVoiceVoiceIdWithDavisStringLiteral() *PlayHtVoiceVoiceId {
	return &PlayHtVoiceVoiceId{davisStringLiteral: "davis"}
}

func NewPlayHtVoiceVoiceIdWithDonnaStringLiteral() *PlayHtVoiceVoiceId {
	return &PlayHtVoiceVoiceId{donnaStringLiteral: "donna"}
}

func NewPlayHtVoiceVoiceIdWithMichaelStringLiteral() *PlayHtVoiceVoiceId {
	return &PlayHtVoiceVoiceId{michaelStringLiteral: "michael"}
}

func (p *PlayHtVoiceVoiceId) JenniferStringLiteral() string {
	return p.jenniferStringLiteral
}

func (p *PlayHtVoiceVoiceId) MelissaStringLiteral() string {
	return p.melissaStringLiteral
}

func (p *PlayHtVoiceVoiceId) WillStringLiteral() string {
	return p.willStringLiteral
}

func (p *PlayHtVoiceVoiceId) ChrisStringLiteral() string {
	return p.chrisStringLiteral
}

func (p *PlayHtVoiceVoiceId) MattStringLiteral() string {
	return p.mattStringLiteral
}

func (p *PlayHtVoiceVoiceId) JackStringLiteral() string {
	return p.jackStringLiteral
}

func (p *PlayHtVoiceVoiceId) RubyStringLiteral() string {
	return p.rubyStringLiteral
}

func (p *PlayHtVoiceVoiceId) DavisStringLiteral() string {
	return p.davisStringLiteral
}

func (p *PlayHtVoiceVoiceId) DonnaStringLiteral() string {
	return p.donnaStringLiteral
}

func (p *PlayHtVoiceVoiceId) MichaelStringLiteral() string {
	return p.michaelStringLiteral
}

func (p *PlayHtVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueJenniferStringLiteral string
	if err := json.Unmarshal(data, &valueJenniferStringLiteral); err == nil {
		p.jenniferStringLiteral = valueJenniferStringLiteral
		if p.jenniferStringLiteral != "jennifer" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "jennifer", valueJenniferStringLiteral)
		}
		return nil
	}
	var valueMelissaStringLiteral string
	if err := json.Unmarshal(data, &valueMelissaStringLiteral); err == nil {
		p.melissaStringLiteral = valueMelissaStringLiteral
		if p.melissaStringLiteral != "melissa" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "melissa", valueMelissaStringLiteral)
		}
		return nil
	}
	var valueWillStringLiteral string
	if err := json.Unmarshal(data, &valueWillStringLiteral); err == nil {
		p.willStringLiteral = valueWillStringLiteral
		if p.willStringLiteral != "will" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "will", valueWillStringLiteral)
		}
		return nil
	}
	var valueChrisStringLiteral string
	if err := json.Unmarshal(data, &valueChrisStringLiteral); err == nil {
		p.chrisStringLiteral = valueChrisStringLiteral
		if p.chrisStringLiteral != "chris" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "chris", valueChrisStringLiteral)
		}
		return nil
	}
	var valueMattStringLiteral string
	if err := json.Unmarshal(data, &valueMattStringLiteral); err == nil {
		p.mattStringLiteral = valueMattStringLiteral
		if p.mattStringLiteral != "matt" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "matt", valueMattStringLiteral)
		}
		return nil
	}
	var valueJackStringLiteral string
	if err := json.Unmarshal(data, &valueJackStringLiteral); err == nil {
		p.jackStringLiteral = valueJackStringLiteral
		if p.jackStringLiteral != "jack" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "jack", valueJackStringLiteral)
		}
		return nil
	}
	var valueRubyStringLiteral string
	if err := json.Unmarshal(data, &valueRubyStringLiteral); err == nil {
		p.rubyStringLiteral = valueRubyStringLiteral
		if p.rubyStringLiteral != "ruby" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "ruby", valueRubyStringLiteral)
		}
		return nil
	}
	var valueDavisStringLiteral string
	if err := json.Unmarshal(data, &valueDavisStringLiteral); err == nil {
		p.davisStringLiteral = valueDavisStringLiteral
		if p.davisStringLiteral != "davis" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "davis", valueDavisStringLiteral)
		}
		return nil
	}
	var valueDonnaStringLiteral string
	if err := json.Unmarshal(data, &valueDonnaStringLiteral); err == nil {
		p.donnaStringLiteral = valueDonnaStringLiteral
		if p.donnaStringLiteral != "donna" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "donna", valueDonnaStringLiteral)
		}
		return nil
	}
	var valueMichaelStringLiteral string
	if err := json.Unmarshal(data, &valueMichaelStringLiteral); err == nil {
		p.michaelStringLiteral = valueMichaelStringLiteral
		if p.michaelStringLiteral != "michael" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "michael", valueMichaelStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PlayHtVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if p.jenniferStringLiteral != "" {
		return json.Marshal("jennifer")
	}
	if p.melissaStringLiteral != "" {
		return json.Marshal("melissa")
	}
	if p.willStringLiteral != "" {
		return json.Marshal("will")
	}
	if p.chrisStringLiteral != "" {
		return json.Marshal("chris")
	}
	if p.mattStringLiteral != "" {
		return json.Marshal("matt")
	}
	if p.jackStringLiteral != "" {
		return json.Marshal("jack")
	}
	if p.rubyStringLiteral != "" {
		return json.Marshal("ruby")
	}
	if p.davisStringLiteral != "" {
		return json.Marshal("davis")
	}
	if p.donnaStringLiteral != "" {
		return json.Marshal("donna")
	}
	if p.michaelStringLiteral != "" {
		return json.Marshal("michael")
	}
	if p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PlayHtVoiceVoiceIdVisitor interface {
	VisitJenniferStringLiteral(string) error
	VisitMelissaStringLiteral(string) error
	VisitWillStringLiteral(string) error
	VisitChrisStringLiteral(string) error
	VisitMattStringLiteral(string) error
	VisitJackStringLiteral(string) error
	VisitRubyStringLiteral(string) error
	VisitDavisStringLiteral(string) error
	VisitDonnaStringLiteral(string) error
	VisitMichaelStringLiteral(string) error
	VisitString(string) error
}

func (p *PlayHtVoiceVoiceId) Accept(visitor PlayHtVoiceVoiceIdVisitor) error {
	if p.jenniferStringLiteral != "" {
		return visitor.VisitJenniferStringLiteral(p.jenniferStringLiteral)
	}
	if p.melissaStringLiteral != "" {
		return visitor.VisitMelissaStringLiteral(p.melissaStringLiteral)
	}
	if p.willStringLiteral != "" {
		return visitor.VisitWillStringLiteral(p.willStringLiteral)
	}
	if p.chrisStringLiteral != "" {
		return visitor.VisitChrisStringLiteral(p.chrisStringLiteral)
	}
	if p.mattStringLiteral != "" {
		return visitor.VisitMattStringLiteral(p.mattStringLiteral)
	}
	if p.jackStringLiteral != "" {
		return visitor.VisitJackStringLiteral(p.jackStringLiteral)
	}
	if p.rubyStringLiteral != "" {
		return visitor.VisitRubyStringLiteral(p.rubyStringLiteral)
	}
	if p.davisStringLiteral != "" {
		return visitor.VisitDavisStringLiteral(p.davisStringLiteral)
	}
	if p.donnaStringLiteral != "" {
		return visitor.VisitDonnaStringLiteral(p.donnaStringLiteral)
	}
	if p.michaelStringLiteral != "" {
		return visitor.VisitMichaelStringLiteral(p.michaelStringLiteral)
	}
	if p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PunctuationBoundary string

const (
	// 。
	PunctuationBoundaryCircle PunctuationBoundary = "。"
	// ，
	PunctuationBoundaryFullWidthComma PunctuationBoundary = "，"
	// .
	PunctuationBoundaryDot PunctuationBoundary = "."
	// !
	PunctuationBoundaryExclamation PunctuationBoundary = "!"
	// ?
	PunctuationBoundaryQuestion PunctuationBoundary = "?"
	// ;
	PunctuationBoundarySemicolon PunctuationBoundary = ";"
	// )
	PunctuationBoundaryParenthesis PunctuationBoundary = ")"
	// ،
	PunctuationBoundaryArabicComma PunctuationBoundary = "،"
	// ۔
	PunctuationBoundaryUrduFullStop PunctuationBoundary = "۔"
	// ।
	PunctuationBoundaryBengaliFullStop PunctuationBoundary = "।"
	// ॥
	PunctuationBoundaryDoubleDanda PunctuationBoundary = "॥"
	// |
	PunctuationBoundaryPipe PunctuationBoundary = "|"
	// ||
	PunctuationBoundaryDoublePipe PunctuationBoundary = "||"
	// ,
	PunctuationBoundaryHalfWidthComma PunctuationBoundary = ","
	// :
	PunctuationBoundaryColon PunctuationBoundary = ":"
)

func NewPunctuationBoundaryFromString(s string) (PunctuationBoundary, error) {
	switch s {
	case "。":
		return PunctuationBoundaryCircle, nil
	case "，":
		return PunctuationBoundaryFullWidthComma, nil
	case ".":
		return PunctuationBoundaryDot, nil
	case "!":
		return PunctuationBoundaryExclamation, nil
	case "?":
		return PunctuationBoundaryQuestion, nil
	case ";":
		return PunctuationBoundarySemicolon, nil
	case ")":
		return PunctuationBoundaryParenthesis, nil
	case "،":
		return PunctuationBoundaryArabicComma, nil
	case "۔":
		return PunctuationBoundaryUrduFullStop, nil
	case "।":
		return PunctuationBoundaryBengaliFullStop, nil
	case "॥":
		return PunctuationBoundaryDoubleDanda, nil
	case "|":
		return PunctuationBoundaryPipe, nil
	case "||":
		return PunctuationBoundaryDoublePipe, nil
	case ",":
		return PunctuationBoundaryHalfWidthComma, nil
	case ":":
		return PunctuationBoundaryColon, nil
	}
	var t PunctuationBoundary
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PunctuationBoundary) Ptr() *PunctuationBoundary {
	return &p
}

type RegexOption struct {
	// This is the type of the regex option. Options are:
	//
	// - `ignore-case`: Ignores the case of the text being matched.
	// - `whole-word`: Matches whole words only.
	// - `multi-line`: Matches across multiple lines.
	Type RegexOptionType `json:"type" url:"type"`
	// This is whether to enable the option.
	//
	// @default false
	Enabled bool `json:"enabled" url:"enabled"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RegexOption) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RegexOption) UnmarshalJSON(data []byte) error {
	type unmarshaler RegexOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RegexOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegexOption) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// This is the type of the regex option. Options are:
//
// - `ignore-case`: Ignores the case of the text being matched.
// - `whole-word`: Matches whole words only.
// - `multi-line`: Matches across multiple lines.
type RegexOptionType string

const (
	RegexOptionTypeIgnoreCase RegexOptionType = "ignore-case"
	RegexOptionTypeWholeWord  RegexOptionType = "whole-word"
	RegexOptionTypeMultiLine  RegexOptionType = "multi-line"
)

func NewRegexOptionTypeFromString(s string) (RegexOptionType, error) {
	switch s {
	case "ignore-case":
		return RegexOptionTypeIgnoreCase, nil
	case "whole-word":
		return RegexOptionTypeWholeWord, nil
	case "multi-line":
		return RegexOptionTypeMultiLine, nil
	}
	var t RegexOptionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RegexOptionType) Ptr() *RegexOptionType {
	return &r
}

type RegexReplacement struct {
	// This is the regex replacement type. You can use this to replace a word or phrase that matches a pattern.
	//
	// Usage:
	//
	// - Replace all numbers with "some number": { type: 'regex', regex: '\\d+', value: 'some number' }
	// - Replace email addresses with "[EMAIL]": { type: 'regex', regex: '\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b', value: '[EMAIL]' }
	// - Replace phone numbers with a formatted version: { type: 'regex', regex: '(\\d{3})(\\d{3})(\\d{4})', value: '($1) $2-$3' }
	// - Replace all instances of "color" or "colour" with "hue": { type: 'regex', regex: 'colou?r', value: 'hue' }
	// - Capitalize the first letter of every sentence: { type: 'regex', regex: '(?<=\\. |^)[a-z]', value: (match) => match.toUpperCase() }
	// This is the regex pattern to replace.
	Regex string `json:"regex" url:"regex"`
	// These are the options for the regex replacement. Default all options are disabled.
	//
	// @default []
	Options []*RegexOption `json:"options,omitempty" url:"options,omitempty"`
	// This is the value that will replace the match.
	Value string `json:"value" url:"value"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RegexReplacement) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RegexReplacement) Type() string {
	return r.type_
}

func (r *RegexReplacement) UnmarshalJSON(data []byte) error {
	type embed RegexReplacement
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RegexReplacement(unmarshaler.embed)
	if unmarshaler.Type != "regex" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "regex", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegexReplacement) MarshalJSON() ([]byte, error) {
	type embed RegexReplacement
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "regex",
	}
	return json.Marshal(marshaler)
}

func (r *RegexReplacement) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RimeAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RimeAiCredential) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RimeAiCredential) Provider() string {
	return r.provider
}

func (r *RimeAiCredential) UnmarshalJSON(data []byte) error {
	type embed RimeAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RimeAiCredential(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rime-ai", unmarshaler.Provider)
	}
	r.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *r, "provider")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RimeAiCredential) MarshalJSON() ([]byte, error) {
	type embed RimeAiCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*r),
		CreatedAt: core.NewDateTime(r.CreatedAt),
		UpdatedAt: core.NewDateTime(r.UpdatedAt),
		Provider:  "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (r *RimeAiCredential) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RimeAiVoice struct {
	// This determines whether fillers are injected into the model output before inputting it into the voice provider.
	//
	// Default `false` because you can achieve better results with prompting the model.
	FillerInjectionEnabled *bool `json:"fillerInjectionEnabled,omitempty" url:"fillerInjectionEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *RimeAiVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the model that will be used. Defaults to 'v1' when not specified.
	Model *RimeAiVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RimeAiVoice) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RimeAiVoice) Provider() string {
	return r.provider
}

func (r *RimeAiVoice) UnmarshalJSON(data []byte) error {
	type embed RimeAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RimeAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rime-ai", unmarshaler.Provider)
	}
	r.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *r, "provider")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RimeAiVoice) MarshalJSON() ([]byte, error) {
	type embed RimeAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*r),
		Provider: "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (r *RimeAiVoice) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// This is the model that will be used. Defaults to 'v1' when not specified.
type RimeAiVoiceModel string

const (
	RimeAiVoiceModelV1   RimeAiVoiceModel = "v1"
	RimeAiVoiceModelMist RimeAiVoiceModel = "mist"
)

func NewRimeAiVoiceModelFromString(s string) (RimeAiVoiceModel, error) {
	switch s {
	case "v1":
		return RimeAiVoiceModelV1, nil
	case "mist":
		return RimeAiVoiceModelMist, nil
	}
	var t RimeAiVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RimeAiVoiceModel) Ptr() *RimeAiVoiceModel {
	return &r
}

// This is the provider-specific ID that will be used.
type RimeAiVoiceVoiceId struct {
	marshStringLiteral      string
	bayouStringLiteral      string
	creekStringLiteral      string
	brookStringLiteral      string
	flowerStringLiteral     string
	sporeStringLiteral      string
	glacierStringLiteral    string
	gulchStringLiteral      string
	alpineStringLiteral     string
	coveStringLiteral       string
	lagoonStringLiteral     string
	tundraStringLiteral     string
	steppeStringLiteral     string
	mesaStringLiteral       string
	groveStringLiteral      string
	rainforestStringLiteral string
	moraineStringLiteral    string
	wildflowerStringLiteral string
	peakStringLiteral       string
	boulderStringLiteral    string
	abbieStringLiteral      string
	allisonStringLiteral    string
	allyStringLiteral       string
	alonaStringLiteral      string
	amberStringLiteral      string
	anaStringLiteral        string
	antoineStringLiteral    string
	armonStringLiteral      string
	brendaStringLiteral     string
	brittanyStringLiteral   string
	carolStringLiteral      string
	colinStringLiteral      string
	courtneyStringLiteral   string
	elenaStringLiteral      string
	elliotStringLiteral     string
	evaStringLiteral        string
	geoffStringLiteral      string
	geraldStringLiteral     string
	hankStringLiteral       string
	helenStringLiteral      string
	heraStringLiteral       string
	jenStringLiteral        string
	joeStringLiteral        string
	joyStringLiteral        string
	juanStringLiteral       string
	kendraStringLiteral     string
	kendrickStringLiteral   string
	kennethStringLiteral    string
	kevinStringLiteral      string
	krisStringLiteral       string
	lindaStringLiteral      string
	madisonStringLiteral    string
	margeStringLiteral      string
	marinaStringLiteral     string
	marissaStringLiteral    string
	martaStringLiteral      string
	mayaStringLiteral       string
	nicholasStringLiteral   string
	nylesStringLiteral      string
	philStringLiteral       string
	rebaStringLiteral       string
	rexStringLiteral        string
	rickStringLiteral       string
	rituStringLiteral       string
	robStringLiteral        string
	rodneyStringLiteral     string
	rohanStringLiteral      string
	roscoStringLiteral      string
	samanthaStringLiteral   string
	sandyStringLiteral      string
	selenaStringLiteral     string
	sethStringLiteral       string
	sharonStringLiteral     string
	stanStringLiteral       string
	tamraStringLiteral      string
	tanyaStringLiteral      string
	tiburStringLiteral      string
	tjStringLiteral         string
	tylerStringLiteral      string
	vivStringLiteral        string
	yadiraStringLiteral     string
	String                  string
}

func NewRimeAiVoiceVoiceIdWithMarshStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{marshStringLiteral: "marsh"}
}

func NewRimeAiVoiceVoiceIdWithBayouStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{bayouStringLiteral: "bayou"}
}

func NewRimeAiVoiceVoiceIdWithCreekStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{creekStringLiteral: "creek"}
}

func NewRimeAiVoiceVoiceIdWithBrookStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{brookStringLiteral: "brook"}
}

func NewRimeAiVoiceVoiceIdWithFlowerStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{flowerStringLiteral: "flower"}
}

func NewRimeAiVoiceVoiceIdWithSporeStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{sporeStringLiteral: "spore"}
}

func NewRimeAiVoiceVoiceIdWithGlacierStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{glacierStringLiteral: "glacier"}
}

func NewRimeAiVoiceVoiceIdWithGulchStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{gulchStringLiteral: "gulch"}
}

func NewRimeAiVoiceVoiceIdWithAlpineStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{alpineStringLiteral: "alpine"}
}

func NewRimeAiVoiceVoiceIdWithCoveStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{coveStringLiteral: "cove"}
}

func NewRimeAiVoiceVoiceIdWithLagoonStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{lagoonStringLiteral: "lagoon"}
}

func NewRimeAiVoiceVoiceIdWithTundraStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{tundraStringLiteral: "tundra"}
}

func NewRimeAiVoiceVoiceIdWithSteppeStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{steppeStringLiteral: "steppe"}
}

func NewRimeAiVoiceVoiceIdWithMesaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{mesaStringLiteral: "mesa"}
}

func NewRimeAiVoiceVoiceIdWithGroveStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{groveStringLiteral: "grove"}
}

func NewRimeAiVoiceVoiceIdWithRainforestStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{rainforestStringLiteral: "rainforest"}
}

func NewRimeAiVoiceVoiceIdWithMoraineStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{moraineStringLiteral: "moraine"}
}

func NewRimeAiVoiceVoiceIdWithWildflowerStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{wildflowerStringLiteral: "wildflower"}
}

func NewRimeAiVoiceVoiceIdWithPeakStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{peakStringLiteral: "peak"}
}

func NewRimeAiVoiceVoiceIdWithBoulderStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{boulderStringLiteral: "boulder"}
}

func NewRimeAiVoiceVoiceIdWithAbbieStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{abbieStringLiteral: "abbie"}
}

func NewRimeAiVoiceVoiceIdWithAllisonStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{allisonStringLiteral: "allison"}
}

func NewRimeAiVoiceVoiceIdWithAllyStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{allyStringLiteral: "ally"}
}

func NewRimeAiVoiceVoiceIdWithAlonaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{alonaStringLiteral: "alona"}
}

func NewRimeAiVoiceVoiceIdWithAmberStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{amberStringLiteral: "amber"}
}

func NewRimeAiVoiceVoiceIdWithAnaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{anaStringLiteral: "ana"}
}

func NewRimeAiVoiceVoiceIdWithAntoineStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{antoineStringLiteral: "antoine"}
}

func NewRimeAiVoiceVoiceIdWithArmonStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{armonStringLiteral: "armon"}
}

func NewRimeAiVoiceVoiceIdWithBrendaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{brendaStringLiteral: "brenda"}
}

func NewRimeAiVoiceVoiceIdWithBrittanyStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{brittanyStringLiteral: "brittany"}
}

func NewRimeAiVoiceVoiceIdWithCarolStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{carolStringLiteral: "carol"}
}

func NewRimeAiVoiceVoiceIdWithColinStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{colinStringLiteral: "colin"}
}

func NewRimeAiVoiceVoiceIdWithCourtneyStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{courtneyStringLiteral: "courtney"}
}

func NewRimeAiVoiceVoiceIdWithElenaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{elenaStringLiteral: "elena"}
}

func NewRimeAiVoiceVoiceIdWithElliotStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{elliotStringLiteral: "elliot"}
}

func NewRimeAiVoiceVoiceIdWithEvaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{evaStringLiteral: "eva"}
}

func NewRimeAiVoiceVoiceIdWithGeoffStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{geoffStringLiteral: "geoff"}
}

func NewRimeAiVoiceVoiceIdWithGeraldStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{geraldStringLiteral: "gerald"}
}

func NewRimeAiVoiceVoiceIdWithHankStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{hankStringLiteral: "hank"}
}

func NewRimeAiVoiceVoiceIdWithHelenStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{helenStringLiteral: "helen"}
}

func NewRimeAiVoiceVoiceIdWithHeraStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{heraStringLiteral: "hera"}
}

func NewRimeAiVoiceVoiceIdWithJenStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{jenStringLiteral: "jen"}
}

func NewRimeAiVoiceVoiceIdWithJoeStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{joeStringLiteral: "joe"}
}

func NewRimeAiVoiceVoiceIdWithJoyStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{joyStringLiteral: "joy"}
}

func NewRimeAiVoiceVoiceIdWithJuanStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{juanStringLiteral: "juan"}
}

func NewRimeAiVoiceVoiceIdWithKendraStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{kendraStringLiteral: "kendra"}
}

func NewRimeAiVoiceVoiceIdWithKendrickStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{kendrickStringLiteral: "kendrick"}
}

func NewRimeAiVoiceVoiceIdWithKennethStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{kennethStringLiteral: "kenneth"}
}

func NewRimeAiVoiceVoiceIdWithKevinStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{kevinStringLiteral: "kevin"}
}

func NewRimeAiVoiceVoiceIdWithKrisStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{krisStringLiteral: "kris"}
}

func NewRimeAiVoiceVoiceIdWithLindaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{lindaStringLiteral: "linda"}
}

func NewRimeAiVoiceVoiceIdWithMadisonStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{madisonStringLiteral: "madison"}
}

func NewRimeAiVoiceVoiceIdWithMargeStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{margeStringLiteral: "marge"}
}

func NewRimeAiVoiceVoiceIdWithMarinaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{marinaStringLiteral: "marina"}
}

func NewRimeAiVoiceVoiceIdWithMarissaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{marissaStringLiteral: "marissa"}
}

func NewRimeAiVoiceVoiceIdWithMartaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{martaStringLiteral: "marta"}
}

func NewRimeAiVoiceVoiceIdWithMayaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{mayaStringLiteral: "maya"}
}

func NewRimeAiVoiceVoiceIdWithNicholasStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{nicholasStringLiteral: "nicholas"}
}

func NewRimeAiVoiceVoiceIdWithNylesStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{nylesStringLiteral: "nyles"}
}

func NewRimeAiVoiceVoiceIdWithPhilStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{philStringLiteral: "phil"}
}

func NewRimeAiVoiceVoiceIdWithRebaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{rebaStringLiteral: "reba"}
}

func NewRimeAiVoiceVoiceIdWithRexStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{rexStringLiteral: "rex"}
}

func NewRimeAiVoiceVoiceIdWithRickStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{rickStringLiteral: "rick"}
}

func NewRimeAiVoiceVoiceIdWithRituStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{rituStringLiteral: "ritu"}
}

func NewRimeAiVoiceVoiceIdWithRobStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{robStringLiteral: "rob"}
}

func NewRimeAiVoiceVoiceIdWithRodneyStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{rodneyStringLiteral: "rodney"}
}

func NewRimeAiVoiceVoiceIdWithRohanStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{rohanStringLiteral: "rohan"}
}

func NewRimeAiVoiceVoiceIdWithRoscoStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{roscoStringLiteral: "rosco"}
}

func NewRimeAiVoiceVoiceIdWithSamanthaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{samanthaStringLiteral: "samantha"}
}

func NewRimeAiVoiceVoiceIdWithSandyStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{sandyStringLiteral: "sandy"}
}

func NewRimeAiVoiceVoiceIdWithSelenaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{selenaStringLiteral: "selena"}
}

func NewRimeAiVoiceVoiceIdWithSethStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{sethStringLiteral: "seth"}
}

func NewRimeAiVoiceVoiceIdWithSharonStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{sharonStringLiteral: "sharon"}
}

func NewRimeAiVoiceVoiceIdWithStanStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{stanStringLiteral: "stan"}
}

func NewRimeAiVoiceVoiceIdWithTamraStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{tamraStringLiteral: "tamra"}
}

func NewRimeAiVoiceVoiceIdWithTanyaStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{tanyaStringLiteral: "tanya"}
}

func NewRimeAiVoiceVoiceIdWithTiburStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{tiburStringLiteral: "tibur"}
}

func NewRimeAiVoiceVoiceIdWithTjStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{tjStringLiteral: "tj"}
}

func NewRimeAiVoiceVoiceIdWithTylerStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{tylerStringLiteral: "tyler"}
}

func NewRimeAiVoiceVoiceIdWithVivStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{vivStringLiteral: "viv"}
}

func NewRimeAiVoiceVoiceIdWithYadiraStringLiteral() *RimeAiVoiceVoiceId {
	return &RimeAiVoiceVoiceId{yadiraStringLiteral: "yadira"}
}

func (r *RimeAiVoiceVoiceId) MarshStringLiteral() string {
	return r.marshStringLiteral
}

func (r *RimeAiVoiceVoiceId) BayouStringLiteral() string {
	return r.bayouStringLiteral
}

func (r *RimeAiVoiceVoiceId) CreekStringLiteral() string {
	return r.creekStringLiteral
}

func (r *RimeAiVoiceVoiceId) BrookStringLiteral() string {
	return r.brookStringLiteral
}

func (r *RimeAiVoiceVoiceId) FlowerStringLiteral() string {
	return r.flowerStringLiteral
}

func (r *RimeAiVoiceVoiceId) SporeStringLiteral() string {
	return r.sporeStringLiteral
}

func (r *RimeAiVoiceVoiceId) GlacierStringLiteral() string {
	return r.glacierStringLiteral
}

func (r *RimeAiVoiceVoiceId) GulchStringLiteral() string {
	return r.gulchStringLiteral
}

func (r *RimeAiVoiceVoiceId) AlpineStringLiteral() string {
	return r.alpineStringLiteral
}

func (r *RimeAiVoiceVoiceId) CoveStringLiteral() string {
	return r.coveStringLiteral
}

func (r *RimeAiVoiceVoiceId) LagoonStringLiteral() string {
	return r.lagoonStringLiteral
}

func (r *RimeAiVoiceVoiceId) TundraStringLiteral() string {
	return r.tundraStringLiteral
}

func (r *RimeAiVoiceVoiceId) SteppeStringLiteral() string {
	return r.steppeStringLiteral
}

func (r *RimeAiVoiceVoiceId) MesaStringLiteral() string {
	return r.mesaStringLiteral
}

func (r *RimeAiVoiceVoiceId) GroveStringLiteral() string {
	return r.groveStringLiteral
}

func (r *RimeAiVoiceVoiceId) RainforestStringLiteral() string {
	return r.rainforestStringLiteral
}

func (r *RimeAiVoiceVoiceId) MoraineStringLiteral() string {
	return r.moraineStringLiteral
}

func (r *RimeAiVoiceVoiceId) WildflowerStringLiteral() string {
	return r.wildflowerStringLiteral
}

func (r *RimeAiVoiceVoiceId) PeakStringLiteral() string {
	return r.peakStringLiteral
}

func (r *RimeAiVoiceVoiceId) BoulderStringLiteral() string {
	return r.boulderStringLiteral
}

func (r *RimeAiVoiceVoiceId) AbbieStringLiteral() string {
	return r.abbieStringLiteral
}

func (r *RimeAiVoiceVoiceId) AllisonStringLiteral() string {
	return r.allisonStringLiteral
}

func (r *RimeAiVoiceVoiceId) AllyStringLiteral() string {
	return r.allyStringLiteral
}

func (r *RimeAiVoiceVoiceId) AlonaStringLiteral() string {
	return r.alonaStringLiteral
}

func (r *RimeAiVoiceVoiceId) AmberStringLiteral() string {
	return r.amberStringLiteral
}

func (r *RimeAiVoiceVoiceId) AnaStringLiteral() string {
	return r.anaStringLiteral
}

func (r *RimeAiVoiceVoiceId) AntoineStringLiteral() string {
	return r.antoineStringLiteral
}

func (r *RimeAiVoiceVoiceId) ArmonStringLiteral() string {
	return r.armonStringLiteral
}

func (r *RimeAiVoiceVoiceId) BrendaStringLiteral() string {
	return r.brendaStringLiteral
}

func (r *RimeAiVoiceVoiceId) BrittanyStringLiteral() string {
	return r.brittanyStringLiteral
}

func (r *RimeAiVoiceVoiceId) CarolStringLiteral() string {
	return r.carolStringLiteral
}

func (r *RimeAiVoiceVoiceId) ColinStringLiteral() string {
	return r.colinStringLiteral
}

func (r *RimeAiVoiceVoiceId) CourtneyStringLiteral() string {
	return r.courtneyStringLiteral
}

func (r *RimeAiVoiceVoiceId) ElenaStringLiteral() string {
	return r.elenaStringLiteral
}

func (r *RimeAiVoiceVoiceId) ElliotStringLiteral() string {
	return r.elliotStringLiteral
}

func (r *RimeAiVoiceVoiceId) EvaStringLiteral() string {
	return r.evaStringLiteral
}

func (r *RimeAiVoiceVoiceId) GeoffStringLiteral() string {
	return r.geoffStringLiteral
}

func (r *RimeAiVoiceVoiceId) GeraldStringLiteral() string {
	return r.geraldStringLiteral
}

func (r *RimeAiVoiceVoiceId) HankStringLiteral() string {
	return r.hankStringLiteral
}

func (r *RimeAiVoiceVoiceId) HelenStringLiteral() string {
	return r.helenStringLiteral
}

func (r *RimeAiVoiceVoiceId) HeraStringLiteral() string {
	return r.heraStringLiteral
}

func (r *RimeAiVoiceVoiceId) JenStringLiteral() string {
	return r.jenStringLiteral
}

func (r *RimeAiVoiceVoiceId) JoeStringLiteral() string {
	return r.joeStringLiteral
}

func (r *RimeAiVoiceVoiceId) JoyStringLiteral() string {
	return r.joyStringLiteral
}

func (r *RimeAiVoiceVoiceId) JuanStringLiteral() string {
	return r.juanStringLiteral
}

func (r *RimeAiVoiceVoiceId) KendraStringLiteral() string {
	return r.kendraStringLiteral
}

func (r *RimeAiVoiceVoiceId) KendrickStringLiteral() string {
	return r.kendrickStringLiteral
}

func (r *RimeAiVoiceVoiceId) KennethStringLiteral() string {
	return r.kennethStringLiteral
}

func (r *RimeAiVoiceVoiceId) KevinStringLiteral() string {
	return r.kevinStringLiteral
}

func (r *RimeAiVoiceVoiceId) KrisStringLiteral() string {
	return r.krisStringLiteral
}

func (r *RimeAiVoiceVoiceId) LindaStringLiteral() string {
	return r.lindaStringLiteral
}

func (r *RimeAiVoiceVoiceId) MadisonStringLiteral() string {
	return r.madisonStringLiteral
}

func (r *RimeAiVoiceVoiceId) MargeStringLiteral() string {
	return r.margeStringLiteral
}

func (r *RimeAiVoiceVoiceId) MarinaStringLiteral() string {
	return r.marinaStringLiteral
}

func (r *RimeAiVoiceVoiceId) MarissaStringLiteral() string {
	return r.marissaStringLiteral
}

func (r *RimeAiVoiceVoiceId) MartaStringLiteral() string {
	return r.martaStringLiteral
}

func (r *RimeAiVoiceVoiceId) MayaStringLiteral() string {
	return r.mayaStringLiteral
}

func (r *RimeAiVoiceVoiceId) NicholasStringLiteral() string {
	return r.nicholasStringLiteral
}

func (r *RimeAiVoiceVoiceId) NylesStringLiteral() string {
	return r.nylesStringLiteral
}

func (r *RimeAiVoiceVoiceId) PhilStringLiteral() string {
	return r.philStringLiteral
}

func (r *RimeAiVoiceVoiceId) RebaStringLiteral() string {
	return r.rebaStringLiteral
}

func (r *RimeAiVoiceVoiceId) RexStringLiteral() string {
	return r.rexStringLiteral
}

func (r *RimeAiVoiceVoiceId) RickStringLiteral() string {
	return r.rickStringLiteral
}

func (r *RimeAiVoiceVoiceId) RituStringLiteral() string {
	return r.rituStringLiteral
}

func (r *RimeAiVoiceVoiceId) RobStringLiteral() string {
	return r.robStringLiteral
}

func (r *RimeAiVoiceVoiceId) RodneyStringLiteral() string {
	return r.rodneyStringLiteral
}

func (r *RimeAiVoiceVoiceId) RohanStringLiteral() string {
	return r.rohanStringLiteral
}

func (r *RimeAiVoiceVoiceId) RoscoStringLiteral() string {
	return r.roscoStringLiteral
}

func (r *RimeAiVoiceVoiceId) SamanthaStringLiteral() string {
	return r.samanthaStringLiteral
}

func (r *RimeAiVoiceVoiceId) SandyStringLiteral() string {
	return r.sandyStringLiteral
}

func (r *RimeAiVoiceVoiceId) SelenaStringLiteral() string {
	return r.selenaStringLiteral
}

func (r *RimeAiVoiceVoiceId) SethStringLiteral() string {
	return r.sethStringLiteral
}

func (r *RimeAiVoiceVoiceId) SharonStringLiteral() string {
	return r.sharonStringLiteral
}

func (r *RimeAiVoiceVoiceId) StanStringLiteral() string {
	return r.stanStringLiteral
}

func (r *RimeAiVoiceVoiceId) TamraStringLiteral() string {
	return r.tamraStringLiteral
}

func (r *RimeAiVoiceVoiceId) TanyaStringLiteral() string {
	return r.tanyaStringLiteral
}

func (r *RimeAiVoiceVoiceId) TiburStringLiteral() string {
	return r.tiburStringLiteral
}

func (r *RimeAiVoiceVoiceId) TjStringLiteral() string {
	return r.tjStringLiteral
}

func (r *RimeAiVoiceVoiceId) TylerStringLiteral() string {
	return r.tylerStringLiteral
}

func (r *RimeAiVoiceVoiceId) VivStringLiteral() string {
	return r.vivStringLiteral
}

func (r *RimeAiVoiceVoiceId) YadiraStringLiteral() string {
	return r.yadiraStringLiteral
}

func (r *RimeAiVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueMarshStringLiteral string
	if err := json.Unmarshal(data, &valueMarshStringLiteral); err == nil {
		r.marshStringLiteral = valueMarshStringLiteral
		if r.marshStringLiteral != "marsh" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "marsh", valueMarshStringLiteral)
		}
		return nil
	}
	var valueBayouStringLiteral string
	if err := json.Unmarshal(data, &valueBayouStringLiteral); err == nil {
		r.bayouStringLiteral = valueBayouStringLiteral
		if r.bayouStringLiteral != "bayou" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "bayou", valueBayouStringLiteral)
		}
		return nil
	}
	var valueCreekStringLiteral string
	if err := json.Unmarshal(data, &valueCreekStringLiteral); err == nil {
		r.creekStringLiteral = valueCreekStringLiteral
		if r.creekStringLiteral != "creek" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "creek", valueCreekStringLiteral)
		}
		return nil
	}
	var valueBrookStringLiteral string
	if err := json.Unmarshal(data, &valueBrookStringLiteral); err == nil {
		r.brookStringLiteral = valueBrookStringLiteral
		if r.brookStringLiteral != "brook" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "brook", valueBrookStringLiteral)
		}
		return nil
	}
	var valueFlowerStringLiteral string
	if err := json.Unmarshal(data, &valueFlowerStringLiteral); err == nil {
		r.flowerStringLiteral = valueFlowerStringLiteral
		if r.flowerStringLiteral != "flower" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "flower", valueFlowerStringLiteral)
		}
		return nil
	}
	var valueSporeStringLiteral string
	if err := json.Unmarshal(data, &valueSporeStringLiteral); err == nil {
		r.sporeStringLiteral = valueSporeStringLiteral
		if r.sporeStringLiteral != "spore" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "spore", valueSporeStringLiteral)
		}
		return nil
	}
	var valueGlacierStringLiteral string
	if err := json.Unmarshal(data, &valueGlacierStringLiteral); err == nil {
		r.glacierStringLiteral = valueGlacierStringLiteral
		if r.glacierStringLiteral != "glacier" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "glacier", valueGlacierStringLiteral)
		}
		return nil
	}
	var valueGulchStringLiteral string
	if err := json.Unmarshal(data, &valueGulchStringLiteral); err == nil {
		r.gulchStringLiteral = valueGulchStringLiteral
		if r.gulchStringLiteral != "gulch" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "gulch", valueGulchStringLiteral)
		}
		return nil
	}
	var valueAlpineStringLiteral string
	if err := json.Unmarshal(data, &valueAlpineStringLiteral); err == nil {
		r.alpineStringLiteral = valueAlpineStringLiteral
		if r.alpineStringLiteral != "alpine" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "alpine", valueAlpineStringLiteral)
		}
		return nil
	}
	var valueCoveStringLiteral string
	if err := json.Unmarshal(data, &valueCoveStringLiteral); err == nil {
		r.coveStringLiteral = valueCoveStringLiteral
		if r.coveStringLiteral != "cove" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "cove", valueCoveStringLiteral)
		}
		return nil
	}
	var valueLagoonStringLiteral string
	if err := json.Unmarshal(data, &valueLagoonStringLiteral); err == nil {
		r.lagoonStringLiteral = valueLagoonStringLiteral
		if r.lagoonStringLiteral != "lagoon" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "lagoon", valueLagoonStringLiteral)
		}
		return nil
	}
	var valueTundraStringLiteral string
	if err := json.Unmarshal(data, &valueTundraStringLiteral); err == nil {
		r.tundraStringLiteral = valueTundraStringLiteral
		if r.tundraStringLiteral != "tundra" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "tundra", valueTundraStringLiteral)
		}
		return nil
	}
	var valueSteppeStringLiteral string
	if err := json.Unmarshal(data, &valueSteppeStringLiteral); err == nil {
		r.steppeStringLiteral = valueSteppeStringLiteral
		if r.steppeStringLiteral != "steppe" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "steppe", valueSteppeStringLiteral)
		}
		return nil
	}
	var valueMesaStringLiteral string
	if err := json.Unmarshal(data, &valueMesaStringLiteral); err == nil {
		r.mesaStringLiteral = valueMesaStringLiteral
		if r.mesaStringLiteral != "mesa" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "mesa", valueMesaStringLiteral)
		}
		return nil
	}
	var valueGroveStringLiteral string
	if err := json.Unmarshal(data, &valueGroveStringLiteral); err == nil {
		r.groveStringLiteral = valueGroveStringLiteral
		if r.groveStringLiteral != "grove" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "grove", valueGroveStringLiteral)
		}
		return nil
	}
	var valueRainforestStringLiteral string
	if err := json.Unmarshal(data, &valueRainforestStringLiteral); err == nil {
		r.rainforestStringLiteral = valueRainforestStringLiteral
		if r.rainforestStringLiteral != "rainforest" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rainforest", valueRainforestStringLiteral)
		}
		return nil
	}
	var valueMoraineStringLiteral string
	if err := json.Unmarshal(data, &valueMoraineStringLiteral); err == nil {
		r.moraineStringLiteral = valueMoraineStringLiteral
		if r.moraineStringLiteral != "moraine" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "moraine", valueMoraineStringLiteral)
		}
		return nil
	}
	var valueWildflowerStringLiteral string
	if err := json.Unmarshal(data, &valueWildflowerStringLiteral); err == nil {
		r.wildflowerStringLiteral = valueWildflowerStringLiteral
		if r.wildflowerStringLiteral != "wildflower" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "wildflower", valueWildflowerStringLiteral)
		}
		return nil
	}
	var valuePeakStringLiteral string
	if err := json.Unmarshal(data, &valuePeakStringLiteral); err == nil {
		r.peakStringLiteral = valuePeakStringLiteral
		if r.peakStringLiteral != "peak" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "peak", valuePeakStringLiteral)
		}
		return nil
	}
	var valueBoulderStringLiteral string
	if err := json.Unmarshal(data, &valueBoulderStringLiteral); err == nil {
		r.boulderStringLiteral = valueBoulderStringLiteral
		if r.boulderStringLiteral != "boulder" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "boulder", valueBoulderStringLiteral)
		}
		return nil
	}
	var valueAbbieStringLiteral string
	if err := json.Unmarshal(data, &valueAbbieStringLiteral); err == nil {
		r.abbieStringLiteral = valueAbbieStringLiteral
		if r.abbieStringLiteral != "abbie" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "abbie", valueAbbieStringLiteral)
		}
		return nil
	}
	var valueAllisonStringLiteral string
	if err := json.Unmarshal(data, &valueAllisonStringLiteral); err == nil {
		r.allisonStringLiteral = valueAllisonStringLiteral
		if r.allisonStringLiteral != "allison" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "allison", valueAllisonStringLiteral)
		}
		return nil
	}
	var valueAllyStringLiteral string
	if err := json.Unmarshal(data, &valueAllyStringLiteral); err == nil {
		r.allyStringLiteral = valueAllyStringLiteral
		if r.allyStringLiteral != "ally" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "ally", valueAllyStringLiteral)
		}
		return nil
	}
	var valueAlonaStringLiteral string
	if err := json.Unmarshal(data, &valueAlonaStringLiteral); err == nil {
		r.alonaStringLiteral = valueAlonaStringLiteral
		if r.alonaStringLiteral != "alona" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "alona", valueAlonaStringLiteral)
		}
		return nil
	}
	var valueAmberStringLiteral string
	if err := json.Unmarshal(data, &valueAmberStringLiteral); err == nil {
		r.amberStringLiteral = valueAmberStringLiteral
		if r.amberStringLiteral != "amber" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "amber", valueAmberStringLiteral)
		}
		return nil
	}
	var valueAnaStringLiteral string
	if err := json.Unmarshal(data, &valueAnaStringLiteral); err == nil {
		r.anaStringLiteral = valueAnaStringLiteral
		if r.anaStringLiteral != "ana" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "ana", valueAnaStringLiteral)
		}
		return nil
	}
	var valueAntoineStringLiteral string
	if err := json.Unmarshal(data, &valueAntoineStringLiteral); err == nil {
		r.antoineStringLiteral = valueAntoineStringLiteral
		if r.antoineStringLiteral != "antoine" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "antoine", valueAntoineStringLiteral)
		}
		return nil
	}
	var valueArmonStringLiteral string
	if err := json.Unmarshal(data, &valueArmonStringLiteral); err == nil {
		r.armonStringLiteral = valueArmonStringLiteral
		if r.armonStringLiteral != "armon" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "armon", valueArmonStringLiteral)
		}
		return nil
	}
	var valueBrendaStringLiteral string
	if err := json.Unmarshal(data, &valueBrendaStringLiteral); err == nil {
		r.brendaStringLiteral = valueBrendaStringLiteral
		if r.brendaStringLiteral != "brenda" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "brenda", valueBrendaStringLiteral)
		}
		return nil
	}
	var valueBrittanyStringLiteral string
	if err := json.Unmarshal(data, &valueBrittanyStringLiteral); err == nil {
		r.brittanyStringLiteral = valueBrittanyStringLiteral
		if r.brittanyStringLiteral != "brittany" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "brittany", valueBrittanyStringLiteral)
		}
		return nil
	}
	var valueCarolStringLiteral string
	if err := json.Unmarshal(data, &valueCarolStringLiteral); err == nil {
		r.carolStringLiteral = valueCarolStringLiteral
		if r.carolStringLiteral != "carol" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "carol", valueCarolStringLiteral)
		}
		return nil
	}
	var valueColinStringLiteral string
	if err := json.Unmarshal(data, &valueColinStringLiteral); err == nil {
		r.colinStringLiteral = valueColinStringLiteral
		if r.colinStringLiteral != "colin" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "colin", valueColinStringLiteral)
		}
		return nil
	}
	var valueCourtneyStringLiteral string
	if err := json.Unmarshal(data, &valueCourtneyStringLiteral); err == nil {
		r.courtneyStringLiteral = valueCourtneyStringLiteral
		if r.courtneyStringLiteral != "courtney" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "courtney", valueCourtneyStringLiteral)
		}
		return nil
	}
	var valueElenaStringLiteral string
	if err := json.Unmarshal(data, &valueElenaStringLiteral); err == nil {
		r.elenaStringLiteral = valueElenaStringLiteral
		if r.elenaStringLiteral != "elena" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "elena", valueElenaStringLiteral)
		}
		return nil
	}
	var valueElliotStringLiteral string
	if err := json.Unmarshal(data, &valueElliotStringLiteral); err == nil {
		r.elliotStringLiteral = valueElliotStringLiteral
		if r.elliotStringLiteral != "elliot" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "elliot", valueElliotStringLiteral)
		}
		return nil
	}
	var valueEvaStringLiteral string
	if err := json.Unmarshal(data, &valueEvaStringLiteral); err == nil {
		r.evaStringLiteral = valueEvaStringLiteral
		if r.evaStringLiteral != "eva" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "eva", valueEvaStringLiteral)
		}
		return nil
	}
	var valueGeoffStringLiteral string
	if err := json.Unmarshal(data, &valueGeoffStringLiteral); err == nil {
		r.geoffStringLiteral = valueGeoffStringLiteral
		if r.geoffStringLiteral != "geoff" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "geoff", valueGeoffStringLiteral)
		}
		return nil
	}
	var valueGeraldStringLiteral string
	if err := json.Unmarshal(data, &valueGeraldStringLiteral); err == nil {
		r.geraldStringLiteral = valueGeraldStringLiteral
		if r.geraldStringLiteral != "gerald" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "gerald", valueGeraldStringLiteral)
		}
		return nil
	}
	var valueHankStringLiteral string
	if err := json.Unmarshal(data, &valueHankStringLiteral); err == nil {
		r.hankStringLiteral = valueHankStringLiteral
		if r.hankStringLiteral != "hank" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "hank", valueHankStringLiteral)
		}
		return nil
	}
	var valueHelenStringLiteral string
	if err := json.Unmarshal(data, &valueHelenStringLiteral); err == nil {
		r.helenStringLiteral = valueHelenStringLiteral
		if r.helenStringLiteral != "helen" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "helen", valueHelenStringLiteral)
		}
		return nil
	}
	var valueHeraStringLiteral string
	if err := json.Unmarshal(data, &valueHeraStringLiteral); err == nil {
		r.heraStringLiteral = valueHeraStringLiteral
		if r.heraStringLiteral != "hera" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "hera", valueHeraStringLiteral)
		}
		return nil
	}
	var valueJenStringLiteral string
	if err := json.Unmarshal(data, &valueJenStringLiteral); err == nil {
		r.jenStringLiteral = valueJenStringLiteral
		if r.jenStringLiteral != "jen" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "jen", valueJenStringLiteral)
		}
		return nil
	}
	var valueJoeStringLiteral string
	if err := json.Unmarshal(data, &valueJoeStringLiteral); err == nil {
		r.joeStringLiteral = valueJoeStringLiteral
		if r.joeStringLiteral != "joe" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "joe", valueJoeStringLiteral)
		}
		return nil
	}
	var valueJoyStringLiteral string
	if err := json.Unmarshal(data, &valueJoyStringLiteral); err == nil {
		r.joyStringLiteral = valueJoyStringLiteral
		if r.joyStringLiteral != "joy" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "joy", valueJoyStringLiteral)
		}
		return nil
	}
	var valueJuanStringLiteral string
	if err := json.Unmarshal(data, &valueJuanStringLiteral); err == nil {
		r.juanStringLiteral = valueJuanStringLiteral
		if r.juanStringLiteral != "juan" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "juan", valueJuanStringLiteral)
		}
		return nil
	}
	var valueKendraStringLiteral string
	if err := json.Unmarshal(data, &valueKendraStringLiteral); err == nil {
		r.kendraStringLiteral = valueKendraStringLiteral
		if r.kendraStringLiteral != "kendra" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "kendra", valueKendraStringLiteral)
		}
		return nil
	}
	var valueKendrickStringLiteral string
	if err := json.Unmarshal(data, &valueKendrickStringLiteral); err == nil {
		r.kendrickStringLiteral = valueKendrickStringLiteral
		if r.kendrickStringLiteral != "kendrick" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "kendrick", valueKendrickStringLiteral)
		}
		return nil
	}
	var valueKennethStringLiteral string
	if err := json.Unmarshal(data, &valueKennethStringLiteral); err == nil {
		r.kennethStringLiteral = valueKennethStringLiteral
		if r.kennethStringLiteral != "kenneth" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "kenneth", valueKennethStringLiteral)
		}
		return nil
	}
	var valueKevinStringLiteral string
	if err := json.Unmarshal(data, &valueKevinStringLiteral); err == nil {
		r.kevinStringLiteral = valueKevinStringLiteral
		if r.kevinStringLiteral != "kevin" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "kevin", valueKevinStringLiteral)
		}
		return nil
	}
	var valueKrisStringLiteral string
	if err := json.Unmarshal(data, &valueKrisStringLiteral); err == nil {
		r.krisStringLiteral = valueKrisStringLiteral
		if r.krisStringLiteral != "kris" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "kris", valueKrisStringLiteral)
		}
		return nil
	}
	var valueLindaStringLiteral string
	if err := json.Unmarshal(data, &valueLindaStringLiteral); err == nil {
		r.lindaStringLiteral = valueLindaStringLiteral
		if r.lindaStringLiteral != "linda" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "linda", valueLindaStringLiteral)
		}
		return nil
	}
	var valueMadisonStringLiteral string
	if err := json.Unmarshal(data, &valueMadisonStringLiteral); err == nil {
		r.madisonStringLiteral = valueMadisonStringLiteral
		if r.madisonStringLiteral != "madison" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "madison", valueMadisonStringLiteral)
		}
		return nil
	}
	var valueMargeStringLiteral string
	if err := json.Unmarshal(data, &valueMargeStringLiteral); err == nil {
		r.margeStringLiteral = valueMargeStringLiteral
		if r.margeStringLiteral != "marge" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "marge", valueMargeStringLiteral)
		}
		return nil
	}
	var valueMarinaStringLiteral string
	if err := json.Unmarshal(data, &valueMarinaStringLiteral); err == nil {
		r.marinaStringLiteral = valueMarinaStringLiteral
		if r.marinaStringLiteral != "marina" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "marina", valueMarinaStringLiteral)
		}
		return nil
	}
	var valueMarissaStringLiteral string
	if err := json.Unmarshal(data, &valueMarissaStringLiteral); err == nil {
		r.marissaStringLiteral = valueMarissaStringLiteral
		if r.marissaStringLiteral != "marissa" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "marissa", valueMarissaStringLiteral)
		}
		return nil
	}
	var valueMartaStringLiteral string
	if err := json.Unmarshal(data, &valueMartaStringLiteral); err == nil {
		r.martaStringLiteral = valueMartaStringLiteral
		if r.martaStringLiteral != "marta" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "marta", valueMartaStringLiteral)
		}
		return nil
	}
	var valueMayaStringLiteral string
	if err := json.Unmarshal(data, &valueMayaStringLiteral); err == nil {
		r.mayaStringLiteral = valueMayaStringLiteral
		if r.mayaStringLiteral != "maya" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "maya", valueMayaStringLiteral)
		}
		return nil
	}
	var valueNicholasStringLiteral string
	if err := json.Unmarshal(data, &valueNicholasStringLiteral); err == nil {
		r.nicholasStringLiteral = valueNicholasStringLiteral
		if r.nicholasStringLiteral != "nicholas" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "nicholas", valueNicholasStringLiteral)
		}
		return nil
	}
	var valueNylesStringLiteral string
	if err := json.Unmarshal(data, &valueNylesStringLiteral); err == nil {
		r.nylesStringLiteral = valueNylesStringLiteral
		if r.nylesStringLiteral != "nyles" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "nyles", valueNylesStringLiteral)
		}
		return nil
	}
	var valuePhilStringLiteral string
	if err := json.Unmarshal(data, &valuePhilStringLiteral); err == nil {
		r.philStringLiteral = valuePhilStringLiteral
		if r.philStringLiteral != "phil" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "phil", valuePhilStringLiteral)
		}
		return nil
	}
	var valueRebaStringLiteral string
	if err := json.Unmarshal(data, &valueRebaStringLiteral); err == nil {
		r.rebaStringLiteral = valueRebaStringLiteral
		if r.rebaStringLiteral != "reba" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "reba", valueRebaStringLiteral)
		}
		return nil
	}
	var valueRexStringLiteral string
	if err := json.Unmarshal(data, &valueRexStringLiteral); err == nil {
		r.rexStringLiteral = valueRexStringLiteral
		if r.rexStringLiteral != "rex" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rex", valueRexStringLiteral)
		}
		return nil
	}
	var valueRickStringLiteral string
	if err := json.Unmarshal(data, &valueRickStringLiteral); err == nil {
		r.rickStringLiteral = valueRickStringLiteral
		if r.rickStringLiteral != "rick" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rick", valueRickStringLiteral)
		}
		return nil
	}
	var valueRituStringLiteral string
	if err := json.Unmarshal(data, &valueRituStringLiteral); err == nil {
		r.rituStringLiteral = valueRituStringLiteral
		if r.rituStringLiteral != "ritu" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "ritu", valueRituStringLiteral)
		}
		return nil
	}
	var valueRobStringLiteral string
	if err := json.Unmarshal(data, &valueRobStringLiteral); err == nil {
		r.robStringLiteral = valueRobStringLiteral
		if r.robStringLiteral != "rob" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rob", valueRobStringLiteral)
		}
		return nil
	}
	var valueRodneyStringLiteral string
	if err := json.Unmarshal(data, &valueRodneyStringLiteral); err == nil {
		r.rodneyStringLiteral = valueRodneyStringLiteral
		if r.rodneyStringLiteral != "rodney" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rodney", valueRodneyStringLiteral)
		}
		return nil
	}
	var valueRohanStringLiteral string
	if err := json.Unmarshal(data, &valueRohanStringLiteral); err == nil {
		r.rohanStringLiteral = valueRohanStringLiteral
		if r.rohanStringLiteral != "rohan" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rohan", valueRohanStringLiteral)
		}
		return nil
	}
	var valueRoscoStringLiteral string
	if err := json.Unmarshal(data, &valueRoscoStringLiteral); err == nil {
		r.roscoStringLiteral = valueRoscoStringLiteral
		if r.roscoStringLiteral != "rosco" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rosco", valueRoscoStringLiteral)
		}
		return nil
	}
	var valueSamanthaStringLiteral string
	if err := json.Unmarshal(data, &valueSamanthaStringLiteral); err == nil {
		r.samanthaStringLiteral = valueSamanthaStringLiteral
		if r.samanthaStringLiteral != "samantha" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "samantha", valueSamanthaStringLiteral)
		}
		return nil
	}
	var valueSandyStringLiteral string
	if err := json.Unmarshal(data, &valueSandyStringLiteral); err == nil {
		r.sandyStringLiteral = valueSandyStringLiteral
		if r.sandyStringLiteral != "sandy" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "sandy", valueSandyStringLiteral)
		}
		return nil
	}
	var valueSelenaStringLiteral string
	if err := json.Unmarshal(data, &valueSelenaStringLiteral); err == nil {
		r.selenaStringLiteral = valueSelenaStringLiteral
		if r.selenaStringLiteral != "selena" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "selena", valueSelenaStringLiteral)
		}
		return nil
	}
	var valueSethStringLiteral string
	if err := json.Unmarshal(data, &valueSethStringLiteral); err == nil {
		r.sethStringLiteral = valueSethStringLiteral
		if r.sethStringLiteral != "seth" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "seth", valueSethStringLiteral)
		}
		return nil
	}
	var valueSharonStringLiteral string
	if err := json.Unmarshal(data, &valueSharonStringLiteral); err == nil {
		r.sharonStringLiteral = valueSharonStringLiteral
		if r.sharonStringLiteral != "sharon" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "sharon", valueSharonStringLiteral)
		}
		return nil
	}
	var valueStanStringLiteral string
	if err := json.Unmarshal(data, &valueStanStringLiteral); err == nil {
		r.stanStringLiteral = valueStanStringLiteral
		if r.stanStringLiteral != "stan" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "stan", valueStanStringLiteral)
		}
		return nil
	}
	var valueTamraStringLiteral string
	if err := json.Unmarshal(data, &valueTamraStringLiteral); err == nil {
		r.tamraStringLiteral = valueTamraStringLiteral
		if r.tamraStringLiteral != "tamra" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "tamra", valueTamraStringLiteral)
		}
		return nil
	}
	var valueTanyaStringLiteral string
	if err := json.Unmarshal(data, &valueTanyaStringLiteral); err == nil {
		r.tanyaStringLiteral = valueTanyaStringLiteral
		if r.tanyaStringLiteral != "tanya" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "tanya", valueTanyaStringLiteral)
		}
		return nil
	}
	var valueTiburStringLiteral string
	if err := json.Unmarshal(data, &valueTiburStringLiteral); err == nil {
		r.tiburStringLiteral = valueTiburStringLiteral
		if r.tiburStringLiteral != "tibur" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "tibur", valueTiburStringLiteral)
		}
		return nil
	}
	var valueTjStringLiteral string
	if err := json.Unmarshal(data, &valueTjStringLiteral); err == nil {
		r.tjStringLiteral = valueTjStringLiteral
		if r.tjStringLiteral != "tj" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "tj", valueTjStringLiteral)
		}
		return nil
	}
	var valueTylerStringLiteral string
	if err := json.Unmarshal(data, &valueTylerStringLiteral); err == nil {
		r.tylerStringLiteral = valueTylerStringLiteral
		if r.tylerStringLiteral != "tyler" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "tyler", valueTylerStringLiteral)
		}
		return nil
	}
	var valueVivStringLiteral string
	if err := json.Unmarshal(data, &valueVivStringLiteral); err == nil {
		r.vivStringLiteral = valueVivStringLiteral
		if r.vivStringLiteral != "viv" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "viv", valueVivStringLiteral)
		}
		return nil
	}
	var valueYadiraStringLiteral string
	if err := json.Unmarshal(data, &valueYadiraStringLiteral); err == nil {
		r.yadiraStringLiteral = valueYadiraStringLiteral
		if r.yadiraStringLiteral != "yadira" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "yadira", valueYadiraStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RimeAiVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if r.marshStringLiteral != "" {
		return json.Marshal("marsh")
	}
	if r.bayouStringLiteral != "" {
		return json.Marshal("bayou")
	}
	if r.creekStringLiteral != "" {
		return json.Marshal("creek")
	}
	if r.brookStringLiteral != "" {
		return json.Marshal("brook")
	}
	if r.flowerStringLiteral != "" {
		return json.Marshal("flower")
	}
	if r.sporeStringLiteral != "" {
		return json.Marshal("spore")
	}
	if r.glacierStringLiteral != "" {
		return json.Marshal("glacier")
	}
	if r.gulchStringLiteral != "" {
		return json.Marshal("gulch")
	}
	if r.alpineStringLiteral != "" {
		return json.Marshal("alpine")
	}
	if r.coveStringLiteral != "" {
		return json.Marshal("cove")
	}
	if r.lagoonStringLiteral != "" {
		return json.Marshal("lagoon")
	}
	if r.tundraStringLiteral != "" {
		return json.Marshal("tundra")
	}
	if r.steppeStringLiteral != "" {
		return json.Marshal("steppe")
	}
	if r.mesaStringLiteral != "" {
		return json.Marshal("mesa")
	}
	if r.groveStringLiteral != "" {
		return json.Marshal("grove")
	}
	if r.rainforestStringLiteral != "" {
		return json.Marshal("rainforest")
	}
	if r.moraineStringLiteral != "" {
		return json.Marshal("moraine")
	}
	if r.wildflowerStringLiteral != "" {
		return json.Marshal("wildflower")
	}
	if r.peakStringLiteral != "" {
		return json.Marshal("peak")
	}
	if r.boulderStringLiteral != "" {
		return json.Marshal("boulder")
	}
	if r.abbieStringLiteral != "" {
		return json.Marshal("abbie")
	}
	if r.allisonStringLiteral != "" {
		return json.Marshal("allison")
	}
	if r.allyStringLiteral != "" {
		return json.Marshal("ally")
	}
	if r.alonaStringLiteral != "" {
		return json.Marshal("alona")
	}
	if r.amberStringLiteral != "" {
		return json.Marshal("amber")
	}
	if r.anaStringLiteral != "" {
		return json.Marshal("ana")
	}
	if r.antoineStringLiteral != "" {
		return json.Marshal("antoine")
	}
	if r.armonStringLiteral != "" {
		return json.Marshal("armon")
	}
	if r.brendaStringLiteral != "" {
		return json.Marshal("brenda")
	}
	if r.brittanyStringLiteral != "" {
		return json.Marshal("brittany")
	}
	if r.carolStringLiteral != "" {
		return json.Marshal("carol")
	}
	if r.colinStringLiteral != "" {
		return json.Marshal("colin")
	}
	if r.courtneyStringLiteral != "" {
		return json.Marshal("courtney")
	}
	if r.elenaStringLiteral != "" {
		return json.Marshal("elena")
	}
	if r.elliotStringLiteral != "" {
		return json.Marshal("elliot")
	}
	if r.evaStringLiteral != "" {
		return json.Marshal("eva")
	}
	if r.geoffStringLiteral != "" {
		return json.Marshal("geoff")
	}
	if r.geraldStringLiteral != "" {
		return json.Marshal("gerald")
	}
	if r.hankStringLiteral != "" {
		return json.Marshal("hank")
	}
	if r.helenStringLiteral != "" {
		return json.Marshal("helen")
	}
	if r.heraStringLiteral != "" {
		return json.Marshal("hera")
	}
	if r.jenStringLiteral != "" {
		return json.Marshal("jen")
	}
	if r.joeStringLiteral != "" {
		return json.Marshal("joe")
	}
	if r.joyStringLiteral != "" {
		return json.Marshal("joy")
	}
	if r.juanStringLiteral != "" {
		return json.Marshal("juan")
	}
	if r.kendraStringLiteral != "" {
		return json.Marshal("kendra")
	}
	if r.kendrickStringLiteral != "" {
		return json.Marshal("kendrick")
	}
	if r.kennethStringLiteral != "" {
		return json.Marshal("kenneth")
	}
	if r.kevinStringLiteral != "" {
		return json.Marshal("kevin")
	}
	if r.krisStringLiteral != "" {
		return json.Marshal("kris")
	}
	if r.lindaStringLiteral != "" {
		return json.Marshal("linda")
	}
	if r.madisonStringLiteral != "" {
		return json.Marshal("madison")
	}
	if r.margeStringLiteral != "" {
		return json.Marshal("marge")
	}
	if r.marinaStringLiteral != "" {
		return json.Marshal("marina")
	}
	if r.marissaStringLiteral != "" {
		return json.Marshal("marissa")
	}
	if r.martaStringLiteral != "" {
		return json.Marshal("marta")
	}
	if r.mayaStringLiteral != "" {
		return json.Marshal("maya")
	}
	if r.nicholasStringLiteral != "" {
		return json.Marshal("nicholas")
	}
	if r.nylesStringLiteral != "" {
		return json.Marshal("nyles")
	}
	if r.philStringLiteral != "" {
		return json.Marshal("phil")
	}
	if r.rebaStringLiteral != "" {
		return json.Marshal("reba")
	}
	if r.rexStringLiteral != "" {
		return json.Marshal("rex")
	}
	if r.rickStringLiteral != "" {
		return json.Marshal("rick")
	}
	if r.rituStringLiteral != "" {
		return json.Marshal("ritu")
	}
	if r.robStringLiteral != "" {
		return json.Marshal("rob")
	}
	if r.rodneyStringLiteral != "" {
		return json.Marshal("rodney")
	}
	if r.rohanStringLiteral != "" {
		return json.Marshal("rohan")
	}
	if r.roscoStringLiteral != "" {
		return json.Marshal("rosco")
	}
	if r.samanthaStringLiteral != "" {
		return json.Marshal("samantha")
	}
	if r.sandyStringLiteral != "" {
		return json.Marshal("sandy")
	}
	if r.selenaStringLiteral != "" {
		return json.Marshal("selena")
	}
	if r.sethStringLiteral != "" {
		return json.Marshal("seth")
	}
	if r.sharonStringLiteral != "" {
		return json.Marshal("sharon")
	}
	if r.stanStringLiteral != "" {
		return json.Marshal("stan")
	}
	if r.tamraStringLiteral != "" {
		return json.Marshal("tamra")
	}
	if r.tanyaStringLiteral != "" {
		return json.Marshal("tanya")
	}
	if r.tiburStringLiteral != "" {
		return json.Marshal("tibur")
	}
	if r.tjStringLiteral != "" {
		return json.Marshal("tj")
	}
	if r.tylerStringLiteral != "" {
		return json.Marshal("tyler")
	}
	if r.vivStringLiteral != "" {
		return json.Marshal("viv")
	}
	if r.yadiraStringLiteral != "" {
		return json.Marshal("yadira")
	}
	if r.String != "" {
		return json.Marshal(r.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RimeAiVoiceVoiceIdVisitor interface {
	VisitMarshStringLiteral(string) error
	VisitBayouStringLiteral(string) error
	VisitCreekStringLiteral(string) error
	VisitBrookStringLiteral(string) error
	VisitFlowerStringLiteral(string) error
	VisitSporeStringLiteral(string) error
	VisitGlacierStringLiteral(string) error
	VisitGulchStringLiteral(string) error
	VisitAlpineStringLiteral(string) error
	VisitCoveStringLiteral(string) error
	VisitLagoonStringLiteral(string) error
	VisitTundraStringLiteral(string) error
	VisitSteppeStringLiteral(string) error
	VisitMesaStringLiteral(string) error
	VisitGroveStringLiteral(string) error
	VisitRainforestStringLiteral(string) error
	VisitMoraineStringLiteral(string) error
	VisitWildflowerStringLiteral(string) error
	VisitPeakStringLiteral(string) error
	VisitBoulderStringLiteral(string) error
	VisitAbbieStringLiteral(string) error
	VisitAllisonStringLiteral(string) error
	VisitAllyStringLiteral(string) error
	VisitAlonaStringLiteral(string) error
	VisitAmberStringLiteral(string) error
	VisitAnaStringLiteral(string) error
	VisitAntoineStringLiteral(string) error
	VisitArmonStringLiteral(string) error
	VisitBrendaStringLiteral(string) error
	VisitBrittanyStringLiteral(string) error
	VisitCarolStringLiteral(string) error
	VisitColinStringLiteral(string) error
	VisitCourtneyStringLiteral(string) error
	VisitElenaStringLiteral(string) error
	VisitElliotStringLiteral(string) error
	VisitEvaStringLiteral(string) error
	VisitGeoffStringLiteral(string) error
	VisitGeraldStringLiteral(string) error
	VisitHankStringLiteral(string) error
	VisitHelenStringLiteral(string) error
	VisitHeraStringLiteral(string) error
	VisitJenStringLiteral(string) error
	VisitJoeStringLiteral(string) error
	VisitJoyStringLiteral(string) error
	VisitJuanStringLiteral(string) error
	VisitKendraStringLiteral(string) error
	VisitKendrickStringLiteral(string) error
	VisitKennethStringLiteral(string) error
	VisitKevinStringLiteral(string) error
	VisitKrisStringLiteral(string) error
	VisitLindaStringLiteral(string) error
	VisitMadisonStringLiteral(string) error
	VisitMargeStringLiteral(string) error
	VisitMarinaStringLiteral(string) error
	VisitMarissaStringLiteral(string) error
	VisitMartaStringLiteral(string) error
	VisitMayaStringLiteral(string) error
	VisitNicholasStringLiteral(string) error
	VisitNylesStringLiteral(string) error
	VisitPhilStringLiteral(string) error
	VisitRebaStringLiteral(string) error
	VisitRexStringLiteral(string) error
	VisitRickStringLiteral(string) error
	VisitRituStringLiteral(string) error
	VisitRobStringLiteral(string) error
	VisitRodneyStringLiteral(string) error
	VisitRohanStringLiteral(string) error
	VisitRoscoStringLiteral(string) error
	VisitSamanthaStringLiteral(string) error
	VisitSandyStringLiteral(string) error
	VisitSelenaStringLiteral(string) error
	VisitSethStringLiteral(string) error
	VisitSharonStringLiteral(string) error
	VisitStanStringLiteral(string) error
	VisitTamraStringLiteral(string) error
	VisitTanyaStringLiteral(string) error
	VisitTiburStringLiteral(string) error
	VisitTjStringLiteral(string) error
	VisitTylerStringLiteral(string) error
	VisitVivStringLiteral(string) error
	VisitYadiraStringLiteral(string) error
	VisitString(string) error
}

func (r *RimeAiVoiceVoiceId) Accept(visitor RimeAiVoiceVoiceIdVisitor) error {
	if r.marshStringLiteral != "" {
		return visitor.VisitMarshStringLiteral(r.marshStringLiteral)
	}
	if r.bayouStringLiteral != "" {
		return visitor.VisitBayouStringLiteral(r.bayouStringLiteral)
	}
	if r.creekStringLiteral != "" {
		return visitor.VisitCreekStringLiteral(r.creekStringLiteral)
	}
	if r.brookStringLiteral != "" {
		return visitor.VisitBrookStringLiteral(r.brookStringLiteral)
	}
	if r.flowerStringLiteral != "" {
		return visitor.VisitFlowerStringLiteral(r.flowerStringLiteral)
	}
	if r.sporeStringLiteral != "" {
		return visitor.VisitSporeStringLiteral(r.sporeStringLiteral)
	}
	if r.glacierStringLiteral != "" {
		return visitor.VisitGlacierStringLiteral(r.glacierStringLiteral)
	}
	if r.gulchStringLiteral != "" {
		return visitor.VisitGulchStringLiteral(r.gulchStringLiteral)
	}
	if r.alpineStringLiteral != "" {
		return visitor.VisitAlpineStringLiteral(r.alpineStringLiteral)
	}
	if r.coveStringLiteral != "" {
		return visitor.VisitCoveStringLiteral(r.coveStringLiteral)
	}
	if r.lagoonStringLiteral != "" {
		return visitor.VisitLagoonStringLiteral(r.lagoonStringLiteral)
	}
	if r.tundraStringLiteral != "" {
		return visitor.VisitTundraStringLiteral(r.tundraStringLiteral)
	}
	if r.steppeStringLiteral != "" {
		return visitor.VisitSteppeStringLiteral(r.steppeStringLiteral)
	}
	if r.mesaStringLiteral != "" {
		return visitor.VisitMesaStringLiteral(r.mesaStringLiteral)
	}
	if r.groveStringLiteral != "" {
		return visitor.VisitGroveStringLiteral(r.groveStringLiteral)
	}
	if r.rainforestStringLiteral != "" {
		return visitor.VisitRainforestStringLiteral(r.rainforestStringLiteral)
	}
	if r.moraineStringLiteral != "" {
		return visitor.VisitMoraineStringLiteral(r.moraineStringLiteral)
	}
	if r.wildflowerStringLiteral != "" {
		return visitor.VisitWildflowerStringLiteral(r.wildflowerStringLiteral)
	}
	if r.peakStringLiteral != "" {
		return visitor.VisitPeakStringLiteral(r.peakStringLiteral)
	}
	if r.boulderStringLiteral != "" {
		return visitor.VisitBoulderStringLiteral(r.boulderStringLiteral)
	}
	if r.abbieStringLiteral != "" {
		return visitor.VisitAbbieStringLiteral(r.abbieStringLiteral)
	}
	if r.allisonStringLiteral != "" {
		return visitor.VisitAllisonStringLiteral(r.allisonStringLiteral)
	}
	if r.allyStringLiteral != "" {
		return visitor.VisitAllyStringLiteral(r.allyStringLiteral)
	}
	if r.alonaStringLiteral != "" {
		return visitor.VisitAlonaStringLiteral(r.alonaStringLiteral)
	}
	if r.amberStringLiteral != "" {
		return visitor.VisitAmberStringLiteral(r.amberStringLiteral)
	}
	if r.anaStringLiteral != "" {
		return visitor.VisitAnaStringLiteral(r.anaStringLiteral)
	}
	if r.antoineStringLiteral != "" {
		return visitor.VisitAntoineStringLiteral(r.antoineStringLiteral)
	}
	if r.armonStringLiteral != "" {
		return visitor.VisitArmonStringLiteral(r.armonStringLiteral)
	}
	if r.brendaStringLiteral != "" {
		return visitor.VisitBrendaStringLiteral(r.brendaStringLiteral)
	}
	if r.brittanyStringLiteral != "" {
		return visitor.VisitBrittanyStringLiteral(r.brittanyStringLiteral)
	}
	if r.carolStringLiteral != "" {
		return visitor.VisitCarolStringLiteral(r.carolStringLiteral)
	}
	if r.colinStringLiteral != "" {
		return visitor.VisitColinStringLiteral(r.colinStringLiteral)
	}
	if r.courtneyStringLiteral != "" {
		return visitor.VisitCourtneyStringLiteral(r.courtneyStringLiteral)
	}
	if r.elenaStringLiteral != "" {
		return visitor.VisitElenaStringLiteral(r.elenaStringLiteral)
	}
	if r.elliotStringLiteral != "" {
		return visitor.VisitElliotStringLiteral(r.elliotStringLiteral)
	}
	if r.evaStringLiteral != "" {
		return visitor.VisitEvaStringLiteral(r.evaStringLiteral)
	}
	if r.geoffStringLiteral != "" {
		return visitor.VisitGeoffStringLiteral(r.geoffStringLiteral)
	}
	if r.geraldStringLiteral != "" {
		return visitor.VisitGeraldStringLiteral(r.geraldStringLiteral)
	}
	if r.hankStringLiteral != "" {
		return visitor.VisitHankStringLiteral(r.hankStringLiteral)
	}
	if r.helenStringLiteral != "" {
		return visitor.VisitHelenStringLiteral(r.helenStringLiteral)
	}
	if r.heraStringLiteral != "" {
		return visitor.VisitHeraStringLiteral(r.heraStringLiteral)
	}
	if r.jenStringLiteral != "" {
		return visitor.VisitJenStringLiteral(r.jenStringLiteral)
	}
	if r.joeStringLiteral != "" {
		return visitor.VisitJoeStringLiteral(r.joeStringLiteral)
	}
	if r.joyStringLiteral != "" {
		return visitor.VisitJoyStringLiteral(r.joyStringLiteral)
	}
	if r.juanStringLiteral != "" {
		return visitor.VisitJuanStringLiteral(r.juanStringLiteral)
	}
	if r.kendraStringLiteral != "" {
		return visitor.VisitKendraStringLiteral(r.kendraStringLiteral)
	}
	if r.kendrickStringLiteral != "" {
		return visitor.VisitKendrickStringLiteral(r.kendrickStringLiteral)
	}
	if r.kennethStringLiteral != "" {
		return visitor.VisitKennethStringLiteral(r.kennethStringLiteral)
	}
	if r.kevinStringLiteral != "" {
		return visitor.VisitKevinStringLiteral(r.kevinStringLiteral)
	}
	if r.krisStringLiteral != "" {
		return visitor.VisitKrisStringLiteral(r.krisStringLiteral)
	}
	if r.lindaStringLiteral != "" {
		return visitor.VisitLindaStringLiteral(r.lindaStringLiteral)
	}
	if r.madisonStringLiteral != "" {
		return visitor.VisitMadisonStringLiteral(r.madisonStringLiteral)
	}
	if r.margeStringLiteral != "" {
		return visitor.VisitMargeStringLiteral(r.margeStringLiteral)
	}
	if r.marinaStringLiteral != "" {
		return visitor.VisitMarinaStringLiteral(r.marinaStringLiteral)
	}
	if r.marissaStringLiteral != "" {
		return visitor.VisitMarissaStringLiteral(r.marissaStringLiteral)
	}
	if r.martaStringLiteral != "" {
		return visitor.VisitMartaStringLiteral(r.martaStringLiteral)
	}
	if r.mayaStringLiteral != "" {
		return visitor.VisitMayaStringLiteral(r.mayaStringLiteral)
	}
	if r.nicholasStringLiteral != "" {
		return visitor.VisitNicholasStringLiteral(r.nicholasStringLiteral)
	}
	if r.nylesStringLiteral != "" {
		return visitor.VisitNylesStringLiteral(r.nylesStringLiteral)
	}
	if r.philStringLiteral != "" {
		return visitor.VisitPhilStringLiteral(r.philStringLiteral)
	}
	if r.rebaStringLiteral != "" {
		return visitor.VisitRebaStringLiteral(r.rebaStringLiteral)
	}
	if r.rexStringLiteral != "" {
		return visitor.VisitRexStringLiteral(r.rexStringLiteral)
	}
	if r.rickStringLiteral != "" {
		return visitor.VisitRickStringLiteral(r.rickStringLiteral)
	}
	if r.rituStringLiteral != "" {
		return visitor.VisitRituStringLiteral(r.rituStringLiteral)
	}
	if r.robStringLiteral != "" {
		return visitor.VisitRobStringLiteral(r.robStringLiteral)
	}
	if r.rodneyStringLiteral != "" {
		return visitor.VisitRodneyStringLiteral(r.rodneyStringLiteral)
	}
	if r.rohanStringLiteral != "" {
		return visitor.VisitRohanStringLiteral(r.rohanStringLiteral)
	}
	if r.roscoStringLiteral != "" {
		return visitor.VisitRoscoStringLiteral(r.roscoStringLiteral)
	}
	if r.samanthaStringLiteral != "" {
		return visitor.VisitSamanthaStringLiteral(r.samanthaStringLiteral)
	}
	if r.sandyStringLiteral != "" {
		return visitor.VisitSandyStringLiteral(r.sandyStringLiteral)
	}
	if r.selenaStringLiteral != "" {
		return visitor.VisitSelenaStringLiteral(r.selenaStringLiteral)
	}
	if r.sethStringLiteral != "" {
		return visitor.VisitSethStringLiteral(r.sethStringLiteral)
	}
	if r.sharonStringLiteral != "" {
		return visitor.VisitSharonStringLiteral(r.sharonStringLiteral)
	}
	if r.stanStringLiteral != "" {
		return visitor.VisitStanStringLiteral(r.stanStringLiteral)
	}
	if r.tamraStringLiteral != "" {
		return visitor.VisitTamraStringLiteral(r.tamraStringLiteral)
	}
	if r.tanyaStringLiteral != "" {
		return visitor.VisitTanyaStringLiteral(r.tanyaStringLiteral)
	}
	if r.tiburStringLiteral != "" {
		return visitor.VisitTiburStringLiteral(r.tiburStringLiteral)
	}
	if r.tjStringLiteral != "" {
		return visitor.VisitTjStringLiteral(r.tjStringLiteral)
	}
	if r.tylerStringLiteral != "" {
		return visitor.VisitTylerStringLiteral(r.tylerStringLiteral)
	}
	if r.vivStringLiteral != "" {
		return visitor.VisitVivStringLiteral(r.vivStringLiteral)
	}
	if r.yadiraStringLiteral != "" {
		return visitor.VisitYadiraStringLiteral(r.yadiraStringLiteral)
	}
	if r.String != "" {
		return visitor.VisitString(r.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RuleBasedCondition struct {
	// This condition is based on a strict rule.
	// This is the operator you want to use to compare the left side and right side.
	//
	// The operation becomes `(leftSide) operator (rightSide)`.
	Operator RuleBasedConditionOperator `json:"operator" url:"operator"`
	// This is the left side of the operation.
	//
	// You can reference any variable in the context of the current block execution (step):
	//
	// - "{{output.your-property-name}}" for current step's output
	// - "{{input.your-property-name}}" for current step's input
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// Or, you can use a constant:
	//
	// - "1"
	// - "text"
	// - "true"
	// - "false"
	//
	// Or, you can mix and match with string interpolation:
	//
	// - "{{your-property-name}}-{{input.your-property-name-2}}-1"
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	LeftSide string `json:"leftSide" url:"leftSide"`
	// This is the right side of the operation.
	//
	// You can reference any variable in the context of the current block execution (step):
	//
	// - "{{output.your-property-name}}" for current step's output
	// - "{{input.your-property-name}}" for current step's input
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// Or, you can use a constant:
	//
	// - "1"
	// - "text"
	// - "true"
	// - "false"
	//
	// Or, you can mix and match with string interpolation:
	//
	// - "{{your-property-name}}-{{input.your-property-name-2}}-1"
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	RightSide string `json:"rightSide" url:"rightSide"`
	type_     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RuleBasedCondition) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleBasedCondition) Type() string {
	return r.type_
}

func (r *RuleBasedCondition) UnmarshalJSON(data []byte) error {
	type embed RuleBasedCondition
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RuleBasedCondition(unmarshaler.embed)
	if unmarshaler.Type != "rule-based" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rule-based", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleBasedCondition) MarshalJSON() ([]byte, error) {
	type embed RuleBasedCondition
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "rule-based",
	}
	return json.Marshal(marshaler)
}

func (r *RuleBasedCondition) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// This is the operator you want to use to compare the left side and right side.
//
// The operation becomes `(leftSide) operator (rightSide)`.
type RuleBasedConditionOperator string

const (
	RuleBasedConditionOperatorEq  RuleBasedConditionOperator = "eq"
	RuleBasedConditionOperatorNeq RuleBasedConditionOperator = "neq"
	RuleBasedConditionOperatorGt  RuleBasedConditionOperator = "gt"
	RuleBasedConditionOperatorGte RuleBasedConditionOperator = "gte"
	RuleBasedConditionOperatorLt  RuleBasedConditionOperator = "lt"
	RuleBasedConditionOperatorLte RuleBasedConditionOperator = "lte"
)

func NewRuleBasedConditionOperatorFromString(s string) (RuleBasedConditionOperator, error) {
	switch s {
	case "eq":
		return RuleBasedConditionOperatorEq, nil
	case "neq":
		return RuleBasedConditionOperatorNeq, nil
	case "gt":
		return RuleBasedConditionOperatorGt, nil
	case "gte":
		return RuleBasedConditionOperatorGte, nil
	case "lt":
		return RuleBasedConditionOperatorLt, nil
	case "lte":
		return RuleBasedConditionOperatorLte, nil
	}
	var t RuleBasedConditionOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RuleBasedConditionOperator) Ptr() *RuleBasedConditionOperator {
	return &r
}

type RunpodCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RunpodCredential) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RunpodCredential) Provider() string {
	return r.provider
}

func (r *RunpodCredential) UnmarshalJSON(data []byte) error {
	type embed RunpodCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RunpodCredential(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "runpod" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "runpod", unmarshaler.Provider)
	}
	r.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *r, "provider")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RunpodCredential) MarshalJSON() ([]byte, error) {
	type embed RunpodCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*r),
		CreatedAt: core.NewDateTime(r.CreatedAt),
		UpdatedAt: core.NewDateTime(r.UpdatedAt),
		Provider:  "runpod",
	}
	return json.Marshal(marshaler)
}

func (r *RunpodCredential) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type S3Credential struct {
	// Credential provider. Only allowed value is s3
	// AWS access key ID.
	AwsAccessKeyId string `json:"awsAccessKeyId" url:"awsAccessKeyId"`
	// AWS access key secret. This is not returned in the API.
	AwsSecretAccessKey string `json:"awsSecretAccessKey" url:"awsSecretAccessKey"`
	// AWS region in which the S3 bucket is located.
	Region string `json:"region" url:"region"`
	// AWS S3 bucket name.
	S3BucketName string `json:"s3BucketName" url:"s3BucketName"`
	// The path prefix for the uploaded recording. Ex. "recordings/"
	S3PathPrefix string `json:"s3PathPrefix" url:"s3PathPrefix"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *S3Credential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *S3Credential) Provider() string {
	return s.provider
}

func (s *S3Credential) UnmarshalJSON(data []byte) error {
	type embed S3Credential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = S3Credential(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "s3" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "s3", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *S3Credential) MarshalJSON() ([]byte, error) {
	type embed S3Credential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
		UpdatedAt: core.NewDateTime(s.UpdatedAt),
		Provider:  "s3",
	}
	return json.Marshal(marshaler)
}

func (s *S3Credential) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SbcConfiguration struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SbcConfiguration) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SbcConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler SbcConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SbcConfiguration(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SbcConfiguration) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Server struct {
	// This is the timeout in seconds for the request to your server. Defaults to 20 seconds.
	//
	// @default 20
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`
	// API endpoint to send requests to.
	Url string `json:"url" url:"url"`
	// This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.
	//
	// Same precedence logic as server.
	Secret *string `json:"secret,omitempty" url:"secret,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Server) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Server) UnmarshalJSON(data []byte) error {
	type unmarshaler Server
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Server(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Server) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessage struct {
	// These are all the messages that can be sent to your server before, after and during the call. Configure the messages you'd like to receive in `assistant.serverMessages`.
	//
	// The server where the message is sent is determined by the following precedence order:
	//
	// 1. `tool.server.url` (if configured, and only for "tool-calls" message)
	// 2. `assistant.serverUrl` (if configure)
	// 3. `phoneNumber.serverUrl` (if configured)
	// 4. `org.serverUrl` (if configured)
	Message *ServerMessageMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessage) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageAssistantRequest struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageAssistantRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "assistant-request" is sent to fetch assistant configuration for an incoming call.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageAssistantRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageAssistantRequest) Type() string {
	return s.type_
}

func (s *ServerMessageAssistantRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageAssistantRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageAssistantRequest(unmarshaler.embed)
	if unmarshaler.Type != "assistant-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "assistant-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageAssistantRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageAssistantRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "assistant-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageAssistantRequest) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageAssistantRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageAssistantRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageAssistantRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageAssistantRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageAssistantRequestPhoneNumber) Accept(visitor ServerMessageAssistantRequestPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageConversationUpdate struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageConversationUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "conversation-update" is sent when an update is committed to the conversation history.
	// This is the most up-to-date conversation history at the time the message is sent.
	Messages []*ServerMessageConversationUpdateMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the most up-to-date conversation history at the time the message is sent, formatted for OpenAI.
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageConversationUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageConversationUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageConversationUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageConversationUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageConversationUpdate(unmarshaler.embed)
	if unmarshaler.Type != "conversation-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "conversation-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageConversationUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageConversationUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "conversation-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageConversationUpdate) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageConversationUpdateMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		s.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		s.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		s.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		s.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		s.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageConversationUpdateMessagesItem) MarshalJSON() ([]byte, error) {
	if s.UserMessage != nil {
		return json.Marshal(s.UserMessage)
	}
	if s.SystemMessage != nil {
		return json.Marshal(s.SystemMessage)
	}
	if s.BotMessage != nil {
		return json.Marshal(s.BotMessage)
	}
	if s.ToolCallMessage != nil {
		return json.Marshal(s.ToolCallMessage)
	}
	if s.ToolCallResultMessage != nil {
		return json.Marshal(s.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageConversationUpdateMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (s *ServerMessageConversationUpdateMessagesItem) Accept(visitor ServerMessageConversationUpdateMessagesItemVisitor) error {
	if s.UserMessage != nil {
		return visitor.VisitUserMessage(s.UserMessage)
	}
	if s.SystemMessage != nil {
		return visitor.VisitSystemMessage(s.SystemMessage)
	}
	if s.BotMessage != nil {
		return visitor.VisitBotMessage(s.BotMessage)
	}
	if s.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(s.ToolCallMessage)
	}
	if s.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(s.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageConversationUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageConversationUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageConversationUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageConversationUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageConversationUpdatePhoneNumber) Accept(visitor ServerMessageConversationUpdatePhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageEndOfCallReport struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageEndOfCallReportPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "end-of-call-report" is sent when the call ends and post-processing is complete.
	// This is the reason the call ended. This can also be found at `call.endedReason` on GET /call/:id.
	EndedReason ServerMessageEndOfCallReportEndedReason `json:"endedReason" url:"endedReason"`
	// This is the cost of the call in USD. This can also be found at `call.cost` on GET /call/:id.
	Cost *float64 `json:"cost,omitempty" url:"cost,omitempty"`
	// These are the costs of individual components of the call in USD. This can also be found at `call.costs` on GET /call/:id.
	Costs []*ServerMessageEndOfCallReportCostsItem `json:"costs,omitempty" url:"costs,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// These are the artifacts from the call. This can also be found at `call.artifact` on GET /call/:id.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the analysis of the call. This can also be found at `call.analysis` on GET /call/:id.
	Analysis *Analysis `json:"analysis,omitempty" url:"analysis,omitempty"`
	// This is the ISO 8601 date-time string of when the call started. This can also be found at `call.startedAt` on GET /call/:id.
	StartedAt *time.Time `json:"startedAt,omitempty" url:"startedAt,omitempty"`
	// This is the ISO 8601 date-time string of when the call ended. This can also be found at `call.endedAt` on GET /call/:id.
	EndedAt *time.Time `json:"endedAt,omitempty" url:"endedAt,omitempty"`
	type_   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageEndOfCallReport) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageEndOfCallReport) Type() string {
	return s.type_
}

func (s *ServerMessageEndOfCallReport) UnmarshalJSON(data []byte) error {
	type embed ServerMessageEndOfCallReport
	var unmarshaler = struct {
		embed
		StartedAt *core.DateTime `json:"startedAt,omitempty"`
		EndedAt   *core.DateTime `json:"endedAt,omitempty"`
		Type      string         `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageEndOfCallReport(unmarshaler.embed)
	s.StartedAt = unmarshaler.StartedAt.TimePtr()
	s.EndedAt = unmarshaler.EndedAt.TimePtr()
	if unmarshaler.Type != "end-of-call-report" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "end-of-call-report", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageEndOfCallReport) MarshalJSON() ([]byte, error) {
	type embed ServerMessageEndOfCallReport
	var marshaler = struct {
		embed
		StartedAt *core.DateTime `json:"startedAt,omitempty"`
		EndedAt   *core.DateTime `json:"endedAt,omitempty"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*s),
		StartedAt: core.NewOptionalDateTime(s.StartedAt),
		EndedAt:   core.NewOptionalDateTime(s.EndedAt),
		Type:      "end-of-call-report",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageEndOfCallReport) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageEndOfCallReportCostsItem struct {
	TransportCost   *TransportCost
	TranscriberCost *TranscriberCost
	ModelCost       *ModelCost
	VoiceCost       *VoiceCost
	VapiCost        *VapiCost
	AnalysisCost    *AnalysisCost
}

func (s *ServerMessageEndOfCallReportCostsItem) UnmarshalJSON(data []byte) error {
	valueTransportCost := new(TransportCost)
	if err := json.Unmarshal(data, &valueTransportCost); err == nil {
		s.TransportCost = valueTransportCost
		return nil
	}
	valueTranscriberCost := new(TranscriberCost)
	if err := json.Unmarshal(data, &valueTranscriberCost); err == nil {
		s.TranscriberCost = valueTranscriberCost
		return nil
	}
	valueModelCost := new(ModelCost)
	if err := json.Unmarshal(data, &valueModelCost); err == nil {
		s.ModelCost = valueModelCost
		return nil
	}
	valueVoiceCost := new(VoiceCost)
	if err := json.Unmarshal(data, &valueVoiceCost); err == nil {
		s.VoiceCost = valueVoiceCost
		return nil
	}
	valueVapiCost := new(VapiCost)
	if err := json.Unmarshal(data, &valueVapiCost); err == nil {
		s.VapiCost = valueVapiCost
		return nil
	}
	valueAnalysisCost := new(AnalysisCost)
	if err := json.Unmarshal(data, &valueAnalysisCost); err == nil {
		s.AnalysisCost = valueAnalysisCost
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageEndOfCallReportCostsItem) MarshalJSON() ([]byte, error) {
	if s.TransportCost != nil {
		return json.Marshal(s.TransportCost)
	}
	if s.TranscriberCost != nil {
		return json.Marshal(s.TranscriberCost)
	}
	if s.ModelCost != nil {
		return json.Marshal(s.ModelCost)
	}
	if s.VoiceCost != nil {
		return json.Marshal(s.VoiceCost)
	}
	if s.VapiCost != nil {
		return json.Marshal(s.VapiCost)
	}
	if s.AnalysisCost != nil {
		return json.Marshal(s.AnalysisCost)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageEndOfCallReportCostsItemVisitor interface {
	VisitTransportCost(*TransportCost) error
	VisitTranscriberCost(*TranscriberCost) error
	VisitModelCost(*ModelCost) error
	VisitVoiceCost(*VoiceCost) error
	VisitVapiCost(*VapiCost) error
	VisitAnalysisCost(*AnalysisCost) error
}

func (s *ServerMessageEndOfCallReportCostsItem) Accept(visitor ServerMessageEndOfCallReportCostsItemVisitor) error {
	if s.TransportCost != nil {
		return visitor.VisitTransportCost(s.TransportCost)
	}
	if s.TranscriberCost != nil {
		return visitor.VisitTranscriberCost(s.TranscriberCost)
	}
	if s.ModelCost != nil {
		return visitor.VisitModelCost(s.ModelCost)
	}
	if s.VoiceCost != nil {
		return visitor.VisitVoiceCost(s.VoiceCost)
	}
	if s.VapiCost != nil {
		return visitor.VisitVapiCost(s.VapiCost)
	}
	if s.AnalysisCost != nil {
		return visitor.VisitAnalysisCost(s.AnalysisCost)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the reason the call ended. This can also be found at `call.endedReason` on GET /call/:id.
type ServerMessageEndOfCallReportEndedReason string

const (
	ServerMessageEndOfCallReportEndedReasonAssistantError                                                          ServerMessageEndOfCallReportEndedReason = "assistant-error"
	ServerMessageEndOfCallReportEndedReasonAssistantNotFound                                                       ServerMessageEndOfCallReportEndedReason = "assistant-not-found"
	ServerMessageEndOfCallReportEndedReasonDbError                                                                 ServerMessageEndOfCallReportEndedReason = "db-error"
	ServerMessageEndOfCallReportEndedReasonNoServerAvailable                                                       ServerMessageEndOfCallReportEndedReason = "no-server-available"
	ServerMessageEndOfCallReportEndedReasonLicenseCheckFailed                                                      ServerMessageEndOfCallReportEndedReason = "license-check-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiLlmFailed                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenaiLlmFailed                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroqLlmFailed                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicLlmFailed                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapiLlmFailed                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi400BadRequestValidationFailed                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi401Unauthorized                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi403ModelAccessDenied                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi429ExceededQuota                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi500ServerError                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiVoiceFailed                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaVoiceFailed                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramTranscriberFailed                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramVoiceFailed                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGladiaTranscriberFailed                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-gladia-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceFailed                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceFailed                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorLmntVoiceFailed                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-lmnt-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureVoiceFailed                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRimeAiVoiceFailed                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-rime-ai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorNeetsVoiceFailed                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-neets-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineNoAvailableModel                                                ServerMessageEndOfCallReportEndedReason = "pipeline-no-available-model"
	ServerMessageEndOfCallReportEndedReasonWorkerShutdown                                                          ServerMessageEndOfCallReportEndedReason = "worker-shutdown"
	ServerMessageEndOfCallReportEndedReasonUnknownError                                                            ServerMessageEndOfCallReportEndedReason = "unknown-error"
	ServerMessageEndOfCallReportEndedReasonVonageDisconnected                                                      ServerMessageEndOfCallReportEndedReason = "vonage-disconnected"
	ServerMessageEndOfCallReportEndedReasonVonageFailedToConnectCall                                               ServerMessageEndOfCallReportEndedReason = "vonage-failed-to-connect-call"
	ServerMessageEndOfCallReportEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived                         ServerMessageEndOfCallReportEndedReason = "phone-call-provider-bypass-enabled-but-no-call-received"
	ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerSetupSocketError                                ServerMessageEndOfCallReportEndedReason = "vapifault-phone-call-worker-setup-socket-error"
	ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerWorkerSetupSocketTimeout                        ServerMessageEndOfCallReportEndedReason = "vapifault-phone-call-worker-worker-setup-socket-timeout"
	ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerCouldNotFindCall                                ServerMessageEndOfCallReportEndedReason = "vapifault-phone-call-worker-could-not-find-call"
	ServerMessageEndOfCallReportEndedReasonVapifaultTransportNeverConnected                                        ServerMessageEndOfCallReportEndedReason = "vapifault-transport-never-connected"
	ServerMessageEndOfCallReportEndedReasonVapifaultWebCallWorkerSetupFailed                                       ServerMessageEndOfCallReportEndedReason = "vapifault-web-call-worker-setup-failed"
	ServerMessageEndOfCallReportEndedReasonVapifaultTransportConnectedButCallNotActive                             ServerMessageEndOfCallReportEndedReason = "vapifault-transport-connected-but-call-not-active"
	ServerMessageEndOfCallReportEndedReasonAssistantNotInvalid                                                     ServerMessageEndOfCallReportEndedReason = "assistant-not-invalid"
	ServerMessageEndOfCallReportEndedReasonAssistantNotProvided                                                    ServerMessageEndOfCallReportEndedReason = "assistant-not-provided"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorNeitherAssistantNorServerSet                              ServerMessageEndOfCallReportEndedReason = "call-start-error-neither-assistant-nor-server-set"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestFailed                                                  ServerMessageEndOfCallReportEndedReason = "assistant-request-failed"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedError                                           ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-error"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedUnspeakableError                                ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-unspeakable-error"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedInvalidAssistant                                ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-invalid-assistant"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedNoAssistant                                     ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-no-assistant"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedForwardingPhoneNumber                           ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-forwarding-phone-number"
	ServerMessageEndOfCallReportEndedReasonAssistantEndedCall                                                      ServerMessageEndOfCallReportEndedReason = "assistant-ended-call"
	ServerMessageEndOfCallReportEndedReasonAssistantSaidEndCallPhrase                                              ServerMessageEndOfCallReportEndedReason = "assistant-said-end-call-phrase"
	ServerMessageEndOfCallReportEndedReasonAssistantForwardedCall                                                  ServerMessageEndOfCallReportEndedReason = "assistant-forwarded-call"
	ServerMessageEndOfCallReportEndedReasonAssistantJoinTimedOut                                                   ServerMessageEndOfCallReportEndedReason = "assistant-join-timed-out"
	ServerMessageEndOfCallReportEndedReasonCustomerBusy                                                            ServerMessageEndOfCallReportEndedReason = "customer-busy"
	ServerMessageEndOfCallReportEndedReasonCustomerEndedCall                                                       ServerMessageEndOfCallReportEndedReason = "customer-ended-call"
	ServerMessageEndOfCallReportEndedReasonCustomerDidNotAnswer                                                    ServerMessageEndOfCallReportEndedReason = "customer-did-not-answer"
	ServerMessageEndOfCallReportEndedReasonCustomerDidNotGiveMicrophonePermission                                  ServerMessageEndOfCallReportEndedReason = "customer-did-not-give-microphone-permission"
	ServerMessageEndOfCallReportEndedReasonAssistantSaidMessageWithEndCallEnabled                                  ServerMessageEndOfCallReportEndedReason = "assistant-said-message-with-end-call-enabled"
	ServerMessageEndOfCallReportEndedReasonExceededMaxDuration                                                     ServerMessageEndOfCallReportEndedReason = "exceeded-max-duration"
	ServerMessageEndOfCallReportEndedReasonManuallyCanceled                                                        ServerMessageEndOfCallReportEndedReason = "manually-canceled"
	ServerMessageEndOfCallReportEndedReasonPhoneCallProviderClosedWebsocket                                        ServerMessageEndOfCallReportEndedReason = "phone-call-provider-closed-websocket"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai400BadRequestValidationFailed                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai401Unauthorized                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai403ModelAccessDenied                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai429ExceededQuota                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai500ServerError                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai401Unauthorized                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai429ExceededQuota                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai500ServerError                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq400BadRequestValidationFailed                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq401Unauthorized                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq403ModelAccessDenied                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq429ExceededQuota                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq500ServerError                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic401Unauthorized                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic403ModelAccessDenied                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic429ExceededQuota                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic500ServerError                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi401Unauthorized                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi403ModelAccessDenied                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi429ExceededQuota                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi500ServerError                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAiLlmFailed                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale401Unauthorized                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale403ModelAccessDenied                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale429ExceededQuota                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale500ServerError                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscaleLlmFailed                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter401Unauthorized                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter403ModelAccessDenied                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter429ExceededQuota                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter500ServerError                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouterLlmFailed                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi401Unauthorized                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi429ExceededQuota                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi500ServerError                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAiLlmFailed                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra401Unauthorized                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra403ModelAccessDenied                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra429ExceededQuota                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra500ServerError                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfraLlmFailed                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod400BadRequestValidationFailed                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod401Unauthorized                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod403ModelAccessDenied                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod429ExceededQuota                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod500ServerError                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpodLlmFailed                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm401Unauthorized                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm403ModelAccessDenied                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm429ExceededQuota                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm500ServerError                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlmLlmFailed                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaSocketHangUp                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-socket-hang-up"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaRequestedPayment                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-requested-payment"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia500ServerError                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia503ServerError                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-503-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia522ServerError                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-522-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomVoiceFailed                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFound                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-found"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsQuotaExceeded                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-quota-exceeded"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedAccess                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-unauthorized-access"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-unauthorized-to-access-model"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus             ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade               ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade     ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-system-busy-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidApiKey                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-invalid-api-key"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-invalid-voice-samples"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-disabled-by-owner"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-account-in-probation"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-content-against-their-policy"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-missing-samples-for-voice-clone"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-allowed-for-free-users"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabs500ServerError                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-max-character-limit-exceeded"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtRequestTimedOut                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-request-timed-out"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtInvalidVoice                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-invalid-voice"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtUnexpectedError                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-unexpected-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtOutOfCredits                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-out-of-credits"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht401Unauthorized                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-403-forbidden-out-of-characters"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-403-forbidden-api-access-not-available"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht429ExceededQuota                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht502GatewayError                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-502-gateway-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht504GatewayError                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-504-gateway-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgram403ModelAccessDenied                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgram404NotFound                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-404-not-found"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgram400NoSuchModelLanguageTierCombination              ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-400-no-such-model-language-tier-combination"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgram500ReturningInvalidJson                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-500-returning-invalid-json"
	ServerMessageEndOfCallReportEndedReasonSipGatewayFailedToConnectCall                                           ServerMessageEndOfCallReportEndedReason = "sip-gateway-failed-to-connect-call"
	ServerMessageEndOfCallReportEndedReasonSilenceTimedOut                                                         ServerMessageEndOfCallReportEndedReason = "silence-timed-out"
	ServerMessageEndOfCallReportEndedReasonTwilioFailedToConnectCall                                               ServerMessageEndOfCallReportEndedReason = "twilio-failed-to-connect-call"
	ServerMessageEndOfCallReportEndedReasonTwilioReportedCustomerMisdialed                                         ServerMessageEndOfCallReportEndedReason = "twilio-reported-customer-misdialed"
	ServerMessageEndOfCallReportEndedReasonVoicemail                                                               ServerMessageEndOfCallReportEndedReason = "voicemail"
	ServerMessageEndOfCallReportEndedReasonVonageRejected                                                          ServerMessageEndOfCallReportEndedReason = "vonage-rejected"
)

func NewServerMessageEndOfCallReportEndedReasonFromString(s string) (ServerMessageEndOfCallReportEndedReason, error) {
	switch s {
	case "assistant-error":
		return ServerMessageEndOfCallReportEndedReasonAssistantError, nil
	case "assistant-not-found":
		return ServerMessageEndOfCallReportEndedReasonAssistantNotFound, nil
	case "db-error":
		return ServerMessageEndOfCallReportEndedReasonDbError, nil
	case "no-server-available":
		return ServerMessageEndOfCallReportEndedReasonNoServerAvailable, nil
	case "license-check-failed":
		return ServerMessageEndOfCallReportEndedReasonLicenseCheckFailed, nil
	case "pipeline-error-openai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiLlmFailed, nil
	case "pipeline-error-azure-openai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenaiLlmFailed, nil
	case "pipeline-error-groq-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroqLlmFailed, nil
	case "pipeline-error-anthropic-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicLlmFailed, nil
	case "pipeline-error-vapi-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapiLlmFailed, nil
	case "pipeline-error-vapi-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi400BadRequestValidationFailed, nil
	case "pipeline-error-vapi-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi401Unauthorized, nil
	case "pipeline-error-vapi-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi403ModelAccessDenied, nil
	case "pipeline-error-vapi-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi429ExceededQuota, nil
	case "pipeline-error-vapi-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi500ServerError, nil
	case "pipeline-error-openai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiVoiceFailed, nil
	case "pipeline-error-cartesia-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaVoiceFailed, nil
	case "pipeline-error-deepgram-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramTranscriberFailed, nil
	case "pipeline-error-deepgram-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramVoiceFailed, nil
	case "pipeline-error-gladia-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGladiaTranscriberFailed, nil
	case "pipeline-error-eleven-labs-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceFailed, nil
	case "pipeline-error-playht-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceFailed, nil
	case "pipeline-error-lmnt-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorLmntVoiceFailed, nil
	case "pipeline-error-azure-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureVoiceFailed, nil
	case "pipeline-error-rime-ai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRimeAiVoiceFailed, nil
	case "pipeline-error-neets-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorNeetsVoiceFailed, nil
	case "pipeline-no-available-model":
		return ServerMessageEndOfCallReportEndedReasonPipelineNoAvailableModel, nil
	case "worker-shutdown":
		return ServerMessageEndOfCallReportEndedReasonWorkerShutdown, nil
	case "unknown-error":
		return ServerMessageEndOfCallReportEndedReasonUnknownError, nil
	case "vonage-disconnected":
		return ServerMessageEndOfCallReportEndedReasonVonageDisconnected, nil
	case "vonage-failed-to-connect-call":
		return ServerMessageEndOfCallReportEndedReasonVonageFailedToConnectCall, nil
	case "phone-call-provider-bypass-enabled-but-no-call-received":
		return ServerMessageEndOfCallReportEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived, nil
	case "vapifault-phone-call-worker-setup-socket-error":
		return ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerSetupSocketError, nil
	case "vapifault-phone-call-worker-worker-setup-socket-timeout":
		return ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerWorkerSetupSocketTimeout, nil
	case "vapifault-phone-call-worker-could-not-find-call":
		return ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerCouldNotFindCall, nil
	case "vapifault-transport-never-connected":
		return ServerMessageEndOfCallReportEndedReasonVapifaultTransportNeverConnected, nil
	case "vapifault-web-call-worker-setup-failed":
		return ServerMessageEndOfCallReportEndedReasonVapifaultWebCallWorkerSetupFailed, nil
	case "vapifault-transport-connected-but-call-not-active":
		return ServerMessageEndOfCallReportEndedReasonVapifaultTransportConnectedButCallNotActive, nil
	case "assistant-not-invalid":
		return ServerMessageEndOfCallReportEndedReasonAssistantNotInvalid, nil
	case "assistant-not-provided":
		return ServerMessageEndOfCallReportEndedReasonAssistantNotProvided, nil
	case "call-start-error-neither-assistant-nor-server-set":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorNeitherAssistantNorServerSet, nil
	case "assistant-request-failed":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestFailed, nil
	case "assistant-request-returned-error":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedError, nil
	case "assistant-request-returned-unspeakable-error":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedUnspeakableError, nil
	case "assistant-request-returned-invalid-assistant":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedInvalidAssistant, nil
	case "assistant-request-returned-no-assistant":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedNoAssistant, nil
	case "assistant-request-returned-forwarding-phone-number":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedForwardingPhoneNumber, nil
	case "assistant-ended-call":
		return ServerMessageEndOfCallReportEndedReasonAssistantEndedCall, nil
	case "assistant-said-end-call-phrase":
		return ServerMessageEndOfCallReportEndedReasonAssistantSaidEndCallPhrase, nil
	case "assistant-forwarded-call":
		return ServerMessageEndOfCallReportEndedReasonAssistantForwardedCall, nil
	case "assistant-join-timed-out":
		return ServerMessageEndOfCallReportEndedReasonAssistantJoinTimedOut, nil
	case "customer-busy":
		return ServerMessageEndOfCallReportEndedReasonCustomerBusy, nil
	case "customer-ended-call":
		return ServerMessageEndOfCallReportEndedReasonCustomerEndedCall, nil
	case "customer-did-not-answer":
		return ServerMessageEndOfCallReportEndedReasonCustomerDidNotAnswer, nil
	case "customer-did-not-give-microphone-permission":
		return ServerMessageEndOfCallReportEndedReasonCustomerDidNotGiveMicrophonePermission, nil
	case "assistant-said-message-with-end-call-enabled":
		return ServerMessageEndOfCallReportEndedReasonAssistantSaidMessageWithEndCallEnabled, nil
	case "exceeded-max-duration":
		return ServerMessageEndOfCallReportEndedReasonExceededMaxDuration, nil
	case "manually-canceled":
		return ServerMessageEndOfCallReportEndedReasonManuallyCanceled, nil
	case "phone-call-provider-closed-websocket":
		return ServerMessageEndOfCallReportEndedReasonPhoneCallProviderClosedWebsocket, nil
	case "pipeline-error-openai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-openai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai401Unauthorized, nil
	case "pipeline-error-openai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai403ModelAccessDenied, nil
	case "pipeline-error-openai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai429ExceededQuota, nil
	case "pipeline-error-openai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai500ServerError, nil
	case "pipeline-error-azure-openai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-azure-openai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai401Unauthorized, nil
	case "pipeline-error-azure-openai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied, nil
	case "pipeline-error-azure-openai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai429ExceededQuota, nil
	case "pipeline-error-azure-openai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai500ServerError, nil
	case "pipeline-error-groq-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq400BadRequestValidationFailed, nil
	case "pipeline-error-groq-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq401Unauthorized, nil
	case "pipeline-error-groq-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq403ModelAccessDenied, nil
	case "pipeline-error-groq-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq429ExceededQuota, nil
	case "pipeline-error-groq-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq500ServerError, nil
	case "pipeline-error-anthropic-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic401Unauthorized, nil
	case "pipeline-error-anthropic-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic403ModelAccessDenied, nil
	case "pipeline-error-anthropic-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic429ExceededQuota, nil
	case "pipeline-error-anthropic-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic500ServerError, nil
	case "pipeline-error-together-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed, nil
	case "pipeline-error-together-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi401Unauthorized, nil
	case "pipeline-error-together-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi403ModelAccessDenied, nil
	case "pipeline-error-together-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi429ExceededQuota, nil
	case "pipeline-error-together-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi500ServerError, nil
	case "pipeline-error-together-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAiLlmFailed, nil
	case "pipeline-error-anyscale-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed, nil
	case "pipeline-error-anyscale-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale401Unauthorized, nil
	case "pipeline-error-anyscale-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale403ModelAccessDenied, nil
	case "pipeline-error-anyscale-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale429ExceededQuota, nil
	case "pipeline-error-anyscale-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale500ServerError, nil
	case "pipeline-error-anyscale-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscaleLlmFailed, nil
	case "pipeline-error-openrouter-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed, nil
	case "pipeline-error-openrouter-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter401Unauthorized, nil
	case "pipeline-error-openrouter-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter403ModelAccessDenied, nil
	case "pipeline-error-openrouter-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter429ExceededQuota, nil
	case "pipeline-error-openrouter-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter500ServerError, nil
	case "pipeline-error-openrouter-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouterLlmFailed, nil
	case "pipeline-error-perplexity-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed, nil
	case "pipeline-error-perplexity-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi401Unauthorized, nil
	case "pipeline-error-perplexity-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied, nil
	case "pipeline-error-perplexity-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi429ExceededQuota, nil
	case "pipeline-error-perplexity-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi500ServerError, nil
	case "pipeline-error-perplexity-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAiLlmFailed, nil
	case "pipeline-error-deepinfra-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed, nil
	case "pipeline-error-deepinfra-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra401Unauthorized, nil
	case "pipeline-error-deepinfra-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra403ModelAccessDenied, nil
	case "pipeline-error-deepinfra-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra429ExceededQuota, nil
	case "pipeline-error-deepinfra-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra500ServerError, nil
	case "pipeline-error-deepinfra-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfraLlmFailed, nil
	case "pipeline-error-runpod-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod400BadRequestValidationFailed, nil
	case "pipeline-error-runpod-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod401Unauthorized, nil
	case "pipeline-error-runpod-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod403ModelAccessDenied, nil
	case "pipeline-error-runpod-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod429ExceededQuota, nil
	case "pipeline-error-runpod-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod500ServerError, nil
	case "pipeline-error-runpod-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpodLlmFailed, nil
	case "pipeline-error-custom-llm-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed, nil
	case "pipeline-error-custom-llm-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm401Unauthorized, nil
	case "pipeline-error-custom-llm-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm403ModelAccessDenied, nil
	case "pipeline-error-custom-llm-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm429ExceededQuota, nil
	case "pipeline-error-custom-llm-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm500ServerError, nil
	case "pipeline-error-custom-llm-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlmLlmFailed, nil
	case "pipeline-error-cartesia-socket-hang-up":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaSocketHangUp, nil
	case "pipeline-error-cartesia-requested-payment":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaRequestedPayment, nil
	case "pipeline-error-cartesia-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia500ServerError, nil
	case "pipeline-error-cartesia-503-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia503ServerError, nil
	case "pipeline-error-cartesia-522-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia522ServerError, nil
	case "pipeline-error-custom-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomVoiceFailed, nil
	case "pipeline-error-eleven-labs-voice-not-found":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFound, nil
	case "pipeline-error-eleven-labs-quota-exceeded":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsQuotaExceeded, nil
	case "pipeline-error-eleven-labs-unauthorized-access":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedAccess, nil
	case "pipeline-error-eleven-labs-unauthorized-to-access-model":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel, nil
	case "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus, nil
	case "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-system-busy-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned, nil
	case "pipeline-error-eleven-labs-invalid-api-key":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidApiKey, nil
	case "pipeline-error-eleven-labs-invalid-voice-samples":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples, nil
	case "pipeline-error-eleven-labs-voice-disabled-by-owner":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner, nil
	case "pipeline-error-eleven-labs-blocked-account-in-probation":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation, nil
	case "pipeline-error-eleven-labs-blocked-content-against-their-policy":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy, nil
	case "pipeline-error-eleven-labs-missing-samples-for-voice-clone":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed, nil
	case "pipeline-error-eleven-labs-voice-not-allowed-for-free-users":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers, nil
	case "pipeline-error-eleven-labs-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabs500ServerError, nil
	case "pipeline-error-eleven-labs-max-character-limit-exceeded":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded, nil
	case "pipeline-error-playht-request-timed-out":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtRequestTimedOut, nil
	case "pipeline-error-playht-invalid-voice":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtInvalidVoice, nil
	case "pipeline-error-playht-unexpected-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtUnexpectedError, nil
	case "pipeline-error-playht-out-of-credits":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtOutOfCredits, nil
	case "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri, nil
	case "pipeline-error-playht-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht401Unauthorized, nil
	case "pipeline-error-playht-403-forbidden-out-of-characters":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters, nil
	case "pipeline-error-playht-403-forbidden-api-access-not-available":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable, nil
	case "pipeline-error-playht-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht429ExceededQuota, nil
	case "pipeline-error-playht-502-gateway-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht502GatewayError, nil
	case "pipeline-error-playht-504-gateway-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht504GatewayError, nil
	case "pipeline-error-deepgram-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgram403ModelAccessDenied, nil
	case "pipeline-error-deepgram-404-not-found":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgram404NotFound, nil
	case "pipeline-error-deepgram-400-no-such-model-language-tier-combination":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgram400NoSuchModelLanguageTierCombination, nil
	case "pipeline-error-deepgram-500-returning-invalid-json":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgram500ReturningInvalidJson, nil
	case "sip-gateway-failed-to-connect-call":
		return ServerMessageEndOfCallReportEndedReasonSipGatewayFailedToConnectCall, nil
	case "silence-timed-out":
		return ServerMessageEndOfCallReportEndedReasonSilenceTimedOut, nil
	case "twilio-failed-to-connect-call":
		return ServerMessageEndOfCallReportEndedReasonTwilioFailedToConnectCall, nil
	case "twilio-reported-customer-misdialed":
		return ServerMessageEndOfCallReportEndedReasonTwilioReportedCustomerMisdialed, nil
	case "voicemail":
		return ServerMessageEndOfCallReportEndedReasonVoicemail, nil
	case "vonage-rejected":
		return ServerMessageEndOfCallReportEndedReasonVonageRejected, nil
	}
	var t ServerMessageEndOfCallReportEndedReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageEndOfCallReportEndedReason) Ptr() *ServerMessageEndOfCallReportEndedReason {
	return &s
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageEndOfCallReportPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageEndOfCallReportPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageEndOfCallReportPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageEndOfCallReportPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageEndOfCallReportPhoneNumber) Accept(visitor ServerMessageEndOfCallReportPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageHang struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageHangPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "hang" is sent when the assistant is hanging due to a delay. The delay can be caused by many factors, such as:
	//
	// - the model is too slow to respond
	// - the voice is too slow to respond
	// - the tool call is still waiting for a response from your server
	// - etc.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageHang) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageHang) Type() string {
	return s.type_
}

func (s *ServerMessageHang) UnmarshalJSON(data []byte) error {
	type embed ServerMessageHang
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageHang(unmarshaler.embed)
	if unmarshaler.Type != "hang" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "hang", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageHang) MarshalJSON() ([]byte, error) {
	type embed ServerMessageHang
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "hang",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageHang) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageHangPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageHangPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageHangPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageHangPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageHangPhoneNumber) Accept(visitor ServerMessageHangPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageLanguageChanged struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageLanguageChangedPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "language-switched" is sent when the transcriber is automatically switched based on the detected language.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the language the transcriber is switched to.
	Language string `json:"language" url:"language"`
	type_    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageLanguageChanged) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageLanguageChanged) Type() string {
	return s.type_
}

func (s *ServerMessageLanguageChanged) UnmarshalJSON(data []byte) error {
	type embed ServerMessageLanguageChanged
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageLanguageChanged(unmarshaler.embed)
	if unmarshaler.Type != "language-changed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "language-changed", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageLanguageChanged) MarshalJSON() ([]byte, error) {
	type embed ServerMessageLanguageChanged
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "language-changed",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageLanguageChanged) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageLanguageChangedPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageLanguageChangedPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageLanguageChangedPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageLanguageChangedPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageLanguageChangedPhoneNumber) Accept(visitor ServerMessageLanguageChangedPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// These are all the messages that can be sent to your server before, after and during the call. Configure the messages you'd like to receive in `assistant.serverMessages`.
//
// The server where the message is sent is determined by the following precedence order:
//
// 1. `tool.server.url` (if configured, and only for "tool-calls" message)
// 2. `assistant.serverUrl` (if configure)
// 3. `phoneNumber.serverUrl` (if configured)
// 4. `org.serverUrl` (if configured)
type ServerMessageMessage struct {
	ServerMessageAssistantRequest           *ServerMessageAssistantRequest
	ServerMessageConversationUpdate         *ServerMessageConversationUpdate
	ServerMessageEndOfCallReport            *ServerMessageEndOfCallReport
	ServerMessageHang                       *ServerMessageHang
	ServerMessageModelOutput                *ServerMessageModelOutput
	ServerMessagePhoneCallControl           *ServerMessagePhoneCallControl
	ServerMessageSpeechUpdate               *ServerMessageSpeechUpdate
	ServerMessageStatusUpdate               *ServerMessageStatusUpdate
	ServerMessageToolCalls                  *ServerMessageToolCalls
	ServerMessageTransferDestinationRequest *ServerMessageTransferDestinationRequest
	ServerMessageTransferUpdate             *ServerMessageTransferUpdate
	ServerMessageTranscript                 *ServerMessageTranscript
	ServerMessageUserInterrupted            *ServerMessageUserInterrupted
	ServerMessageLanguageChanged            *ServerMessageLanguageChanged
	ServerMessageVoiceInput                 *ServerMessageVoiceInput
	ServerMessageVoiceRequest               *ServerMessageVoiceRequest
}

func (s *ServerMessageMessage) UnmarshalJSON(data []byte) error {
	valueServerMessageAssistantRequest := new(ServerMessageAssistantRequest)
	if err := json.Unmarshal(data, &valueServerMessageAssistantRequest); err == nil {
		s.ServerMessageAssistantRequest = valueServerMessageAssistantRequest
		return nil
	}
	valueServerMessageConversationUpdate := new(ServerMessageConversationUpdate)
	if err := json.Unmarshal(data, &valueServerMessageConversationUpdate); err == nil {
		s.ServerMessageConversationUpdate = valueServerMessageConversationUpdate
		return nil
	}
	valueServerMessageEndOfCallReport := new(ServerMessageEndOfCallReport)
	if err := json.Unmarshal(data, &valueServerMessageEndOfCallReport); err == nil {
		s.ServerMessageEndOfCallReport = valueServerMessageEndOfCallReport
		return nil
	}
	valueServerMessageHang := new(ServerMessageHang)
	if err := json.Unmarshal(data, &valueServerMessageHang); err == nil {
		s.ServerMessageHang = valueServerMessageHang
		return nil
	}
	valueServerMessageModelOutput := new(ServerMessageModelOutput)
	if err := json.Unmarshal(data, &valueServerMessageModelOutput); err == nil {
		s.ServerMessageModelOutput = valueServerMessageModelOutput
		return nil
	}
	valueServerMessagePhoneCallControl := new(ServerMessagePhoneCallControl)
	if err := json.Unmarshal(data, &valueServerMessagePhoneCallControl); err == nil {
		s.ServerMessagePhoneCallControl = valueServerMessagePhoneCallControl
		return nil
	}
	valueServerMessageSpeechUpdate := new(ServerMessageSpeechUpdate)
	if err := json.Unmarshal(data, &valueServerMessageSpeechUpdate); err == nil {
		s.ServerMessageSpeechUpdate = valueServerMessageSpeechUpdate
		return nil
	}
	valueServerMessageStatusUpdate := new(ServerMessageStatusUpdate)
	if err := json.Unmarshal(data, &valueServerMessageStatusUpdate); err == nil {
		s.ServerMessageStatusUpdate = valueServerMessageStatusUpdate
		return nil
	}
	valueServerMessageToolCalls := new(ServerMessageToolCalls)
	if err := json.Unmarshal(data, &valueServerMessageToolCalls); err == nil {
		s.ServerMessageToolCalls = valueServerMessageToolCalls
		return nil
	}
	valueServerMessageTransferDestinationRequest := new(ServerMessageTransferDestinationRequest)
	if err := json.Unmarshal(data, &valueServerMessageTransferDestinationRequest); err == nil {
		s.ServerMessageTransferDestinationRequest = valueServerMessageTransferDestinationRequest
		return nil
	}
	valueServerMessageTransferUpdate := new(ServerMessageTransferUpdate)
	if err := json.Unmarshal(data, &valueServerMessageTransferUpdate); err == nil {
		s.ServerMessageTransferUpdate = valueServerMessageTransferUpdate
		return nil
	}
	valueServerMessageTranscript := new(ServerMessageTranscript)
	if err := json.Unmarshal(data, &valueServerMessageTranscript); err == nil {
		s.ServerMessageTranscript = valueServerMessageTranscript
		return nil
	}
	valueServerMessageUserInterrupted := new(ServerMessageUserInterrupted)
	if err := json.Unmarshal(data, &valueServerMessageUserInterrupted); err == nil {
		s.ServerMessageUserInterrupted = valueServerMessageUserInterrupted
		return nil
	}
	valueServerMessageLanguageChanged := new(ServerMessageLanguageChanged)
	if err := json.Unmarshal(data, &valueServerMessageLanguageChanged); err == nil {
		s.ServerMessageLanguageChanged = valueServerMessageLanguageChanged
		return nil
	}
	valueServerMessageVoiceInput := new(ServerMessageVoiceInput)
	if err := json.Unmarshal(data, &valueServerMessageVoiceInput); err == nil {
		s.ServerMessageVoiceInput = valueServerMessageVoiceInput
		return nil
	}
	valueServerMessageVoiceRequest := new(ServerMessageVoiceRequest)
	if err := json.Unmarshal(data, &valueServerMessageVoiceRequest); err == nil {
		s.ServerMessageVoiceRequest = valueServerMessageVoiceRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageMessage) MarshalJSON() ([]byte, error) {
	if s.ServerMessageAssistantRequest != nil {
		return json.Marshal(s.ServerMessageAssistantRequest)
	}
	if s.ServerMessageConversationUpdate != nil {
		return json.Marshal(s.ServerMessageConversationUpdate)
	}
	if s.ServerMessageEndOfCallReport != nil {
		return json.Marshal(s.ServerMessageEndOfCallReport)
	}
	if s.ServerMessageHang != nil {
		return json.Marshal(s.ServerMessageHang)
	}
	if s.ServerMessageModelOutput != nil {
		return json.Marshal(s.ServerMessageModelOutput)
	}
	if s.ServerMessagePhoneCallControl != nil {
		return json.Marshal(s.ServerMessagePhoneCallControl)
	}
	if s.ServerMessageSpeechUpdate != nil {
		return json.Marshal(s.ServerMessageSpeechUpdate)
	}
	if s.ServerMessageStatusUpdate != nil {
		return json.Marshal(s.ServerMessageStatusUpdate)
	}
	if s.ServerMessageToolCalls != nil {
		return json.Marshal(s.ServerMessageToolCalls)
	}
	if s.ServerMessageTransferDestinationRequest != nil {
		return json.Marshal(s.ServerMessageTransferDestinationRequest)
	}
	if s.ServerMessageTransferUpdate != nil {
		return json.Marshal(s.ServerMessageTransferUpdate)
	}
	if s.ServerMessageTranscript != nil {
		return json.Marshal(s.ServerMessageTranscript)
	}
	if s.ServerMessageUserInterrupted != nil {
		return json.Marshal(s.ServerMessageUserInterrupted)
	}
	if s.ServerMessageLanguageChanged != nil {
		return json.Marshal(s.ServerMessageLanguageChanged)
	}
	if s.ServerMessageVoiceInput != nil {
		return json.Marshal(s.ServerMessageVoiceInput)
	}
	if s.ServerMessageVoiceRequest != nil {
		return json.Marshal(s.ServerMessageVoiceRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageMessageVisitor interface {
	VisitServerMessageAssistantRequest(*ServerMessageAssistantRequest) error
	VisitServerMessageConversationUpdate(*ServerMessageConversationUpdate) error
	VisitServerMessageEndOfCallReport(*ServerMessageEndOfCallReport) error
	VisitServerMessageHang(*ServerMessageHang) error
	VisitServerMessageModelOutput(*ServerMessageModelOutput) error
	VisitServerMessagePhoneCallControl(*ServerMessagePhoneCallControl) error
	VisitServerMessageSpeechUpdate(*ServerMessageSpeechUpdate) error
	VisitServerMessageStatusUpdate(*ServerMessageStatusUpdate) error
	VisitServerMessageToolCalls(*ServerMessageToolCalls) error
	VisitServerMessageTransferDestinationRequest(*ServerMessageTransferDestinationRequest) error
	VisitServerMessageTransferUpdate(*ServerMessageTransferUpdate) error
	VisitServerMessageTranscript(*ServerMessageTranscript) error
	VisitServerMessageUserInterrupted(*ServerMessageUserInterrupted) error
	VisitServerMessageLanguageChanged(*ServerMessageLanguageChanged) error
	VisitServerMessageVoiceInput(*ServerMessageVoiceInput) error
	VisitServerMessageVoiceRequest(*ServerMessageVoiceRequest) error
}

func (s *ServerMessageMessage) Accept(visitor ServerMessageMessageVisitor) error {
	if s.ServerMessageAssistantRequest != nil {
		return visitor.VisitServerMessageAssistantRequest(s.ServerMessageAssistantRequest)
	}
	if s.ServerMessageConversationUpdate != nil {
		return visitor.VisitServerMessageConversationUpdate(s.ServerMessageConversationUpdate)
	}
	if s.ServerMessageEndOfCallReport != nil {
		return visitor.VisitServerMessageEndOfCallReport(s.ServerMessageEndOfCallReport)
	}
	if s.ServerMessageHang != nil {
		return visitor.VisitServerMessageHang(s.ServerMessageHang)
	}
	if s.ServerMessageModelOutput != nil {
		return visitor.VisitServerMessageModelOutput(s.ServerMessageModelOutput)
	}
	if s.ServerMessagePhoneCallControl != nil {
		return visitor.VisitServerMessagePhoneCallControl(s.ServerMessagePhoneCallControl)
	}
	if s.ServerMessageSpeechUpdate != nil {
		return visitor.VisitServerMessageSpeechUpdate(s.ServerMessageSpeechUpdate)
	}
	if s.ServerMessageStatusUpdate != nil {
		return visitor.VisitServerMessageStatusUpdate(s.ServerMessageStatusUpdate)
	}
	if s.ServerMessageToolCalls != nil {
		return visitor.VisitServerMessageToolCalls(s.ServerMessageToolCalls)
	}
	if s.ServerMessageTransferDestinationRequest != nil {
		return visitor.VisitServerMessageTransferDestinationRequest(s.ServerMessageTransferDestinationRequest)
	}
	if s.ServerMessageTransferUpdate != nil {
		return visitor.VisitServerMessageTransferUpdate(s.ServerMessageTransferUpdate)
	}
	if s.ServerMessageTranscript != nil {
		return visitor.VisitServerMessageTranscript(s.ServerMessageTranscript)
	}
	if s.ServerMessageUserInterrupted != nil {
		return visitor.VisitServerMessageUserInterrupted(s.ServerMessageUserInterrupted)
	}
	if s.ServerMessageLanguageChanged != nil {
		return visitor.VisitServerMessageLanguageChanged(s.ServerMessageLanguageChanged)
	}
	if s.ServerMessageVoiceInput != nil {
		return visitor.VisitServerMessageVoiceInput(s.ServerMessageVoiceInput)
	}
	if s.ServerMessageVoiceRequest != nil {
		return visitor.VisitServerMessageVoiceRequest(s.ServerMessageVoiceRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageModelOutput struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageModelOutputPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "model-output" is sent as the model outputs tokens.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the output of the model. It can be a token or tool call.
	Output map[string]interface{} `json:"output,omitempty" url:"output,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageModelOutput) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageModelOutput) Type() string {
	return s.type_
}

func (s *ServerMessageModelOutput) UnmarshalJSON(data []byte) error {
	type embed ServerMessageModelOutput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageModelOutput(unmarshaler.embed)
	if unmarshaler.Type != "model-output" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "model-output", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageModelOutput) MarshalJSON() ([]byte, error) {
	type embed ServerMessageModelOutput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "model-output",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageModelOutput) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageModelOutputPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageModelOutputPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageModelOutputPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageModelOutputPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageModelOutputPhoneNumber) Accept(visitor ServerMessageModelOutputPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessagePhoneCallControl struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessagePhoneCallControlPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "phone-call-control" is an advanced type of message.
	//
	// When it is requested in `assistant.serverMessages`, the hangup and forwarding responsibilities are delegated to your server. Vapi will no longer do the actual transfer and hangup.
	// This is the request to control the phone call.
	Request ServerMessagePhoneCallControlRequest `json:"request" url:"request"`
	// This is the destination to forward the call to if the request is "forward".
	Destination *ServerMessagePhoneCallControlDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessagePhoneCallControl) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessagePhoneCallControl) Type() string {
	return s.type_
}

func (s *ServerMessagePhoneCallControl) UnmarshalJSON(data []byte) error {
	type embed ServerMessagePhoneCallControl
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessagePhoneCallControl(unmarshaler.embed)
	if unmarshaler.Type != "phone-call-control" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "phone-call-control", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessagePhoneCallControl) MarshalJSON() ([]byte, error) {
	type embed ServerMessagePhoneCallControl
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "phone-call-control",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessagePhoneCallControl) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination to forward the call to if the request is "forward".
type ServerMessagePhoneCallControlDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (s *ServerMessagePhoneCallControlDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessagePhoneCallControlDestination) MarshalJSON() ([]byte, error) {
	if s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessagePhoneCallControlDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessagePhoneCallControlDestination) Accept(visitor ServerMessagePhoneCallControlDestinationVisitor) error {
	if s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessagePhoneCallControlPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessagePhoneCallControlPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessagePhoneCallControlPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessagePhoneCallControlPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessagePhoneCallControlPhoneNumber) Accept(visitor ServerMessagePhoneCallControlPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the request to control the phone call.
type ServerMessagePhoneCallControlRequest string

const (
	ServerMessagePhoneCallControlRequestForward ServerMessagePhoneCallControlRequest = "forward"
	ServerMessagePhoneCallControlRequestHangUp  ServerMessagePhoneCallControlRequest = "hang-up"
)

func NewServerMessagePhoneCallControlRequestFromString(s string) (ServerMessagePhoneCallControlRequest, error) {
	switch s {
	case "forward":
		return ServerMessagePhoneCallControlRequestForward, nil
	case "hang-up":
		return ServerMessagePhoneCallControlRequestHangUp, nil
	}
	var t ServerMessagePhoneCallControlRequest
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessagePhoneCallControlRequest) Ptr() *ServerMessagePhoneCallControlRequest {
	return &s
}

type ServerMessageResponse struct {
	// This is the response that is expected from the server to the message.
	//
	// Note: Most messages don't expect a response. Only "assistant-request", "tool-calls" and "transfer-destination-request" do.
	MessageResponse *ServerMessageResponseMessageResponse `json:"messageResponse,omitempty" url:"messageResponse,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageResponseAssistantRequest struct {
	// This is the destination to transfer the inbound call to. This will immediately transfer without using any assistants.
	//
	// If this is sent, `assistantId`, `assistant`, `squadId`, and `squad` are ignored.
	Destination *ServerMessageResponseAssistantRequestDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	//
	// If you're unsure why you're getting an invalid assistant, try logging your response and send the JSON blob to POST /assistant which will return the validation errors.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the overrides for the `assistant` or `assistantId`'s settings and template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the call. To use a transient squad, use `squad` instead.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// This is the error if the call shouldn't be accepted. This is spoken to the customer.
	//
	// If this is sent, `assistantId`, `assistant`, `squadId`, `squad`, and `destination` are ignored.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageResponseAssistantRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseAssistantRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseAssistantRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseAssistantRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseAssistantRequest) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination to transfer the inbound call to. This will immediately transfer without using any assistants.
//
// If this is sent, `assistantId`, `assistant`, `squadId`, and `squad` are ignored.
type ServerMessageResponseAssistantRequestDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (s *ServerMessageResponseAssistantRequestDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageResponseAssistantRequestDestination) MarshalJSON() ([]byte, error) {
	if s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseAssistantRequestDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageResponseAssistantRequestDestination) Accept(visitor ServerMessageResponseAssistantRequestDestinationVisitor) error {
	if s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the response that is expected from the server to the message.
//
// Note: Most messages don't expect a response. Only "assistant-request", "tool-calls" and "transfer-destination-request" do.
type ServerMessageResponseMessageResponse struct {
	ServerMessageResponseAssistantRequest           *ServerMessageResponseAssistantRequest
	ServerMessageResponseToolCalls                  *ServerMessageResponseToolCalls
	ServerMessageResponseTransferDestinationRequest *ServerMessageResponseTransferDestinationRequest
	ServerMessageResponseVoiceRequest               *ServerMessageResponseVoiceRequest
}

func (s *ServerMessageResponseMessageResponse) UnmarshalJSON(data []byte) error {
	valueServerMessageResponseAssistantRequest := new(ServerMessageResponseAssistantRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseAssistantRequest); err == nil {
		s.ServerMessageResponseAssistantRequest = valueServerMessageResponseAssistantRequest
		return nil
	}
	valueServerMessageResponseToolCalls := new(ServerMessageResponseToolCalls)
	if err := json.Unmarshal(data, &valueServerMessageResponseToolCalls); err == nil {
		s.ServerMessageResponseToolCalls = valueServerMessageResponseToolCalls
		return nil
	}
	valueServerMessageResponseTransferDestinationRequest := new(ServerMessageResponseTransferDestinationRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseTransferDestinationRequest); err == nil {
		s.ServerMessageResponseTransferDestinationRequest = valueServerMessageResponseTransferDestinationRequest
		return nil
	}
	valueServerMessageResponseVoiceRequest := new(ServerMessageResponseVoiceRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseVoiceRequest); err == nil {
		s.ServerMessageResponseVoiceRequest = valueServerMessageResponseVoiceRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageResponseMessageResponse) MarshalJSON() ([]byte, error) {
	if s.ServerMessageResponseAssistantRequest != nil {
		return json.Marshal(s.ServerMessageResponseAssistantRequest)
	}
	if s.ServerMessageResponseToolCalls != nil {
		return json.Marshal(s.ServerMessageResponseToolCalls)
	}
	if s.ServerMessageResponseTransferDestinationRequest != nil {
		return json.Marshal(s.ServerMessageResponseTransferDestinationRequest)
	}
	if s.ServerMessageResponseVoiceRequest != nil {
		return json.Marshal(s.ServerMessageResponseVoiceRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseMessageResponseVisitor interface {
	VisitServerMessageResponseAssistantRequest(*ServerMessageResponseAssistantRequest) error
	VisitServerMessageResponseToolCalls(*ServerMessageResponseToolCalls) error
	VisitServerMessageResponseTransferDestinationRequest(*ServerMessageResponseTransferDestinationRequest) error
	VisitServerMessageResponseVoiceRequest(*ServerMessageResponseVoiceRequest) error
}

func (s *ServerMessageResponseMessageResponse) Accept(visitor ServerMessageResponseMessageResponseVisitor) error {
	if s.ServerMessageResponseAssistantRequest != nil {
		return visitor.VisitServerMessageResponseAssistantRequest(s.ServerMessageResponseAssistantRequest)
	}
	if s.ServerMessageResponseToolCalls != nil {
		return visitor.VisitServerMessageResponseToolCalls(s.ServerMessageResponseToolCalls)
	}
	if s.ServerMessageResponseTransferDestinationRequest != nil {
		return visitor.VisitServerMessageResponseTransferDestinationRequest(s.ServerMessageResponseTransferDestinationRequest)
	}
	if s.ServerMessageResponseVoiceRequest != nil {
		return visitor.VisitServerMessageResponseVoiceRequest(s.ServerMessageResponseVoiceRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseToolCalls struct {
	// These are the results of the "tool-calls" message.
	Results []*ToolCallResult `json:"results,omitempty" url:"results,omitempty"`
	// This is the error message if the tool call was not successful.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageResponseToolCalls) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseToolCalls(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseToolCalls) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageResponseTransferDestinationRequest struct {
	// This is the destination you'd like the call to be transferred to.
	Destination *ServerMessageResponseTransferDestinationRequestDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the error message if the transfer should not be made.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageResponseTransferDestinationRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseTransferDestinationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseTransferDestinationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseTransferDestinationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseTransferDestinationRequest) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination you'd like the call to be transferred to.
type ServerMessageResponseTransferDestinationRequestDestination struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationStep      *TransferDestinationStep
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		s.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationStep := new(TransferDestinationStep)
	if err := json.Unmarshal(data, &valueTransferDestinationStep); err == nil {
		s.TransferDestinationStep = valueTransferDestinationStep
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageResponseTransferDestinationRequestDestination) MarshalJSON() ([]byte, error) {
	if s.TransferDestinationAssistant != nil {
		return json.Marshal(s.TransferDestinationAssistant)
	}
	if s.TransferDestinationStep != nil {
		return json.Marshal(s.TransferDestinationStep)
	}
	if s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseTransferDestinationRequestDestinationVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationStep(*TransferDestinationStep) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) Accept(visitor ServerMessageResponseTransferDestinationRequestDestinationVisitor) error {
	if s.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(s.TransferDestinationAssistant)
	}
	if s.TransferDestinationStep != nil {
		return visitor.VisitTransferDestinationStep(s.TransferDestinationStep)
	}
	if s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseVoiceRequest struct {
	// DO NOT respond to a `voice-request` webhook with this schema of { data }. This schema just exists to document what the response should look like. Follow these instructions:
	//
	// Here is what the request will look like:
	//
	// POST https://{assistant.voice.server.url}
	// Content-Type: application/json
	//
	// {
	// "messsage": {
	// "type": "voice-request",
	// "text": "Hello, world!",
	// "sampleRate": 24000,
	// ...other metadata about the call...
	// }
	// }
	//
	// The expected response is 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:
	//
	// ```
	//
	//	response.on('data', (chunk: Buffer) => {
	//	  outputStream.write(chunk);
	//	});
	//
	// ```
	Data string `json:"data" url:"data"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageResponseVoiceRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseVoiceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseVoiceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseVoiceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseVoiceRequest) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageSpeechUpdate struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageSpeechUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "speech-update" is sent whenever assistant or user start or stop speaking.
	// This is the status of the speech update.
	Status ServerMessageSpeechUpdateStatus `json:"status" url:"status"`
	// This is the role which the speech update is for.
	Role ServerMessageSpeechUpdateRole `json:"role" url:"role"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageSpeechUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageSpeechUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageSpeechUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageSpeechUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageSpeechUpdate(unmarshaler.embed)
	if unmarshaler.Type != "speech-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "speech-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageSpeechUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageSpeechUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "speech-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageSpeechUpdate) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageSpeechUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageSpeechUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageSpeechUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageSpeechUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageSpeechUpdatePhoneNumber) Accept(visitor ServerMessageSpeechUpdatePhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the role which the speech update is for.
type ServerMessageSpeechUpdateRole string

const (
	ServerMessageSpeechUpdateRoleAssistant ServerMessageSpeechUpdateRole = "assistant"
	ServerMessageSpeechUpdateRoleUser      ServerMessageSpeechUpdateRole = "user"
)

func NewServerMessageSpeechUpdateRoleFromString(s string) (ServerMessageSpeechUpdateRole, error) {
	switch s {
	case "assistant":
		return ServerMessageSpeechUpdateRoleAssistant, nil
	case "user":
		return ServerMessageSpeechUpdateRoleUser, nil
	}
	var t ServerMessageSpeechUpdateRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageSpeechUpdateRole) Ptr() *ServerMessageSpeechUpdateRole {
	return &s
}

// This is the status of the speech update.
type ServerMessageSpeechUpdateStatus string

const (
	ServerMessageSpeechUpdateStatusStarted ServerMessageSpeechUpdateStatus = "started"
	ServerMessageSpeechUpdateStatusStopped ServerMessageSpeechUpdateStatus = "stopped"
)

func NewServerMessageSpeechUpdateStatusFromString(s string) (ServerMessageSpeechUpdateStatus, error) {
	switch s {
	case "started":
		return ServerMessageSpeechUpdateStatusStarted, nil
	case "stopped":
		return ServerMessageSpeechUpdateStatusStopped, nil
	}
	var t ServerMessageSpeechUpdateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageSpeechUpdateStatus) Ptr() *ServerMessageSpeechUpdateStatus {
	return &s
}

type ServerMessageStatusUpdate struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageStatusUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "status-update" is sent whenever the `call.status` changes.
	// This is the status of the call.
	Status ServerMessageStatusUpdateStatus `json:"status" url:"status"`
	// This is the reason the call ended. This is only sent if the status is "ended".
	EndedReason *ServerMessageStatusUpdateEndedReason `json:"endedReason,omitempty" url:"endedReason,omitempty"`
	// These are the conversation messages of the call. This is only sent if the status is "forwarding".
	Messages []*ServerMessageStatusUpdateMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the conversation messages of the call. This is only sent if the status is "forwarding".
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the destination the call is being transferred to. This is only sent if the status is "forwarding".
	Destination *ServerMessageStatusUpdateDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the transcript of the call. This is only sent if the status is "forwarding".
	Transcript *string `json:"transcript,omitempty" url:"transcript,omitempty"`
	// This is the inbound phone call debugging artifacts. This is only sent if the status is "ended" and there was an error accepting the inbound phone call.
	//
	// This will include any errors related to the "assistant-request" if one was made.
	InboundPhoneCallDebuggingArtifacts map[string]interface{} `json:"inboundPhoneCallDebuggingArtifacts,omitempty" url:"inboundPhoneCallDebuggingArtifacts,omitempty"`
	type_                              string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageStatusUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageStatusUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageStatusUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageStatusUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageStatusUpdate(unmarshaler.embed)
	if unmarshaler.Type != "status-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "status-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageStatusUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageStatusUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "status-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageStatusUpdate) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination the call is being transferred to. This is only sent if the status is "forwarding".
type ServerMessageStatusUpdateDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (s *ServerMessageStatusUpdateDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageStatusUpdateDestination) MarshalJSON() ([]byte, error) {
	if s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageStatusUpdateDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageStatusUpdateDestination) Accept(visitor ServerMessageStatusUpdateDestinationVisitor) error {
	if s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the reason the call ended. This is only sent if the status is "ended".
type ServerMessageStatusUpdateEndedReason string

const (
	ServerMessageStatusUpdateEndedReasonAssistantError                                                          ServerMessageStatusUpdateEndedReason = "assistant-error"
	ServerMessageStatusUpdateEndedReasonAssistantNotFound                                                       ServerMessageStatusUpdateEndedReason = "assistant-not-found"
	ServerMessageStatusUpdateEndedReasonDbError                                                                 ServerMessageStatusUpdateEndedReason = "db-error"
	ServerMessageStatusUpdateEndedReasonNoServerAvailable                                                       ServerMessageStatusUpdateEndedReason = "no-server-available"
	ServerMessageStatusUpdateEndedReasonLicenseCheckFailed                                                      ServerMessageStatusUpdateEndedReason = "license-check-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiLlmFailed                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenaiLlmFailed                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroqLlmFailed                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicLlmFailed                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapiLlmFailed                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi400BadRequestValidationFailed                          ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi401Unauthorized                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi403ModelAccessDenied                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi429ExceededQuota                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi500ServerError                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiVoiceFailed                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaVoiceFailed                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramTranscriberFailed                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramVoiceFailed                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGladiaTranscriberFailed                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-gladia-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceFailed                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceFailed                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorLmntVoiceFailed                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-lmnt-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureVoiceFailed                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRimeAiVoiceFailed                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-rime-ai-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorNeetsVoiceFailed                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-neets-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineNoAvailableModel                                                ServerMessageStatusUpdateEndedReason = "pipeline-no-available-model"
	ServerMessageStatusUpdateEndedReasonWorkerShutdown                                                          ServerMessageStatusUpdateEndedReason = "worker-shutdown"
	ServerMessageStatusUpdateEndedReasonUnknownError                                                            ServerMessageStatusUpdateEndedReason = "unknown-error"
	ServerMessageStatusUpdateEndedReasonVonageDisconnected                                                      ServerMessageStatusUpdateEndedReason = "vonage-disconnected"
	ServerMessageStatusUpdateEndedReasonVonageFailedToConnectCall                                               ServerMessageStatusUpdateEndedReason = "vonage-failed-to-connect-call"
	ServerMessageStatusUpdateEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived                         ServerMessageStatusUpdateEndedReason = "phone-call-provider-bypass-enabled-but-no-call-received"
	ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerSetupSocketError                                ServerMessageStatusUpdateEndedReason = "vapifault-phone-call-worker-setup-socket-error"
	ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerWorkerSetupSocketTimeout                        ServerMessageStatusUpdateEndedReason = "vapifault-phone-call-worker-worker-setup-socket-timeout"
	ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerCouldNotFindCall                                ServerMessageStatusUpdateEndedReason = "vapifault-phone-call-worker-could-not-find-call"
	ServerMessageStatusUpdateEndedReasonVapifaultTransportNeverConnected                                        ServerMessageStatusUpdateEndedReason = "vapifault-transport-never-connected"
	ServerMessageStatusUpdateEndedReasonVapifaultWebCallWorkerSetupFailed                                       ServerMessageStatusUpdateEndedReason = "vapifault-web-call-worker-setup-failed"
	ServerMessageStatusUpdateEndedReasonVapifaultTransportConnectedButCallNotActive                             ServerMessageStatusUpdateEndedReason = "vapifault-transport-connected-but-call-not-active"
	ServerMessageStatusUpdateEndedReasonAssistantNotInvalid                                                     ServerMessageStatusUpdateEndedReason = "assistant-not-invalid"
	ServerMessageStatusUpdateEndedReasonAssistantNotProvided                                                    ServerMessageStatusUpdateEndedReason = "assistant-not-provided"
	ServerMessageStatusUpdateEndedReasonCallStartErrorNeitherAssistantNorServerSet                              ServerMessageStatusUpdateEndedReason = "call-start-error-neither-assistant-nor-server-set"
	ServerMessageStatusUpdateEndedReasonAssistantRequestFailed                                                  ServerMessageStatusUpdateEndedReason = "assistant-request-failed"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedError                                           ServerMessageStatusUpdateEndedReason = "assistant-request-returned-error"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedUnspeakableError                                ServerMessageStatusUpdateEndedReason = "assistant-request-returned-unspeakable-error"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedInvalidAssistant                                ServerMessageStatusUpdateEndedReason = "assistant-request-returned-invalid-assistant"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedNoAssistant                                     ServerMessageStatusUpdateEndedReason = "assistant-request-returned-no-assistant"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedForwardingPhoneNumber                           ServerMessageStatusUpdateEndedReason = "assistant-request-returned-forwarding-phone-number"
	ServerMessageStatusUpdateEndedReasonAssistantEndedCall                                                      ServerMessageStatusUpdateEndedReason = "assistant-ended-call"
	ServerMessageStatusUpdateEndedReasonAssistantSaidEndCallPhrase                                              ServerMessageStatusUpdateEndedReason = "assistant-said-end-call-phrase"
	ServerMessageStatusUpdateEndedReasonAssistantForwardedCall                                                  ServerMessageStatusUpdateEndedReason = "assistant-forwarded-call"
	ServerMessageStatusUpdateEndedReasonAssistantJoinTimedOut                                                   ServerMessageStatusUpdateEndedReason = "assistant-join-timed-out"
	ServerMessageStatusUpdateEndedReasonCustomerBusy                                                            ServerMessageStatusUpdateEndedReason = "customer-busy"
	ServerMessageStatusUpdateEndedReasonCustomerEndedCall                                                       ServerMessageStatusUpdateEndedReason = "customer-ended-call"
	ServerMessageStatusUpdateEndedReasonCustomerDidNotAnswer                                                    ServerMessageStatusUpdateEndedReason = "customer-did-not-answer"
	ServerMessageStatusUpdateEndedReasonCustomerDidNotGiveMicrophonePermission                                  ServerMessageStatusUpdateEndedReason = "customer-did-not-give-microphone-permission"
	ServerMessageStatusUpdateEndedReasonAssistantSaidMessageWithEndCallEnabled                                  ServerMessageStatusUpdateEndedReason = "assistant-said-message-with-end-call-enabled"
	ServerMessageStatusUpdateEndedReasonExceededMaxDuration                                                     ServerMessageStatusUpdateEndedReason = "exceeded-max-duration"
	ServerMessageStatusUpdateEndedReasonManuallyCanceled                                                        ServerMessageStatusUpdateEndedReason = "manually-canceled"
	ServerMessageStatusUpdateEndedReasonPhoneCallProviderClosedWebsocket                                        ServerMessageStatusUpdateEndedReason = "phone-call-provider-closed-websocket"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai400BadRequestValidationFailed                        ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai401Unauthorized                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai403ModelAccessDenied                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai429ExceededQuota                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai500ServerError                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed                   ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai401Unauthorized                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied                            ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai429ExceededQuota                                ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai500ServerError                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq400BadRequestValidationFailed                          ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq401Unauthorized                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq403ModelAccessDenied                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq429ExceededQuota                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq500ServerError                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed                     ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic401Unauthorized                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic403ModelAccessDenied                              ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic429ExceededQuota                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic500ServerError                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed                    ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi401Unauthorized                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi403ModelAccessDenied                             ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi429ExceededQuota                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi500ServerError                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAiLlmFailed                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed                      ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale401Unauthorized                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale403ModelAccessDenied                               ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale429ExceededQuota                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale500ServerError                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscaleLlmFailed                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed                    ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter401Unauthorized                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter403ModelAccessDenied                             ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter429ExceededQuota                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter500ServerError                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouterLlmFailed                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed                  ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi401Unauthorized                                ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied                           ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi429ExceededQuota                               ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi500ServerError                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAiLlmFailed                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed                     ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra401Unauthorized                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra403ModelAccessDenied                              ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra429ExceededQuota                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra500ServerError                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfraLlmFailed                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod400BadRequestValidationFailed                        ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod401Unauthorized                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod403ModelAccessDenied                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod429ExceededQuota                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod500ServerError                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpodLlmFailed                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed                     ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm401Unauthorized                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm403ModelAccessDenied                              ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm429ExceededQuota                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm500ServerError                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlmLlmFailed                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaSocketHangUp                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-socket-hang-up"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaRequestedPayment                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-requested-payment"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia500ServerError                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia503ServerError                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-503-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia522ServerError                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-522-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomVoiceFailed                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFound                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-found"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsQuotaExceeded                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-quota-exceeded"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedAccess                               ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-unauthorized-access"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel                        ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-unauthorized-to-access-model"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus             ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade               ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade     ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade                    ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-system-busy-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned                                ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidApiKey                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-invalid-api-key"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples                              ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-invalid-voice-samples"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner                             ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-disabled-by-owner"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation                        ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-account-in-probation"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy                 ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-content-against-their-policy"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone                      ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-missing-samples-for-voice-clone"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed                 ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers                      ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-allowed-for-free-users"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabs500ServerError                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded                        ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-max-character-limit-exceeded"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtRequestTimedOut                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-request-timed-out"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtInvalidVoice                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-invalid-voice"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtUnexpectedError                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-unexpected-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtOutOfCredits                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-out-of-credits"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri                    ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht401Unauthorized                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters                          ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-403-forbidden-out-of-characters"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable                    ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-403-forbidden-api-access-not-available"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht429ExceededQuota                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht502GatewayError                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-502-gateway-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht504GatewayError                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-504-gateway-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgram403ModelAccessDenied                               ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgram404NotFound                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-404-not-found"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgram400NoSuchModelLanguageTierCombination              ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-400-no-such-model-language-tier-combination"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgram500ReturningInvalidJson                            ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-500-returning-invalid-json"
	ServerMessageStatusUpdateEndedReasonSipGatewayFailedToConnectCall                                           ServerMessageStatusUpdateEndedReason = "sip-gateway-failed-to-connect-call"
	ServerMessageStatusUpdateEndedReasonSilenceTimedOut                                                         ServerMessageStatusUpdateEndedReason = "silence-timed-out"
	ServerMessageStatusUpdateEndedReasonTwilioFailedToConnectCall                                               ServerMessageStatusUpdateEndedReason = "twilio-failed-to-connect-call"
	ServerMessageStatusUpdateEndedReasonTwilioReportedCustomerMisdialed                                         ServerMessageStatusUpdateEndedReason = "twilio-reported-customer-misdialed"
	ServerMessageStatusUpdateEndedReasonVoicemail                                                               ServerMessageStatusUpdateEndedReason = "voicemail"
	ServerMessageStatusUpdateEndedReasonVonageRejected                                                          ServerMessageStatusUpdateEndedReason = "vonage-rejected"
)

func NewServerMessageStatusUpdateEndedReasonFromString(s string) (ServerMessageStatusUpdateEndedReason, error) {
	switch s {
	case "assistant-error":
		return ServerMessageStatusUpdateEndedReasonAssistantError, nil
	case "assistant-not-found":
		return ServerMessageStatusUpdateEndedReasonAssistantNotFound, nil
	case "db-error":
		return ServerMessageStatusUpdateEndedReasonDbError, nil
	case "no-server-available":
		return ServerMessageStatusUpdateEndedReasonNoServerAvailable, nil
	case "license-check-failed":
		return ServerMessageStatusUpdateEndedReasonLicenseCheckFailed, nil
	case "pipeline-error-openai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiLlmFailed, nil
	case "pipeline-error-azure-openai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenaiLlmFailed, nil
	case "pipeline-error-groq-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroqLlmFailed, nil
	case "pipeline-error-anthropic-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicLlmFailed, nil
	case "pipeline-error-vapi-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapiLlmFailed, nil
	case "pipeline-error-vapi-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi400BadRequestValidationFailed, nil
	case "pipeline-error-vapi-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi401Unauthorized, nil
	case "pipeline-error-vapi-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi403ModelAccessDenied, nil
	case "pipeline-error-vapi-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi429ExceededQuota, nil
	case "pipeline-error-vapi-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi500ServerError, nil
	case "pipeline-error-openai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiVoiceFailed, nil
	case "pipeline-error-cartesia-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaVoiceFailed, nil
	case "pipeline-error-deepgram-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramTranscriberFailed, nil
	case "pipeline-error-deepgram-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramVoiceFailed, nil
	case "pipeline-error-gladia-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGladiaTranscriberFailed, nil
	case "pipeline-error-eleven-labs-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceFailed, nil
	case "pipeline-error-playht-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceFailed, nil
	case "pipeline-error-lmnt-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorLmntVoiceFailed, nil
	case "pipeline-error-azure-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureVoiceFailed, nil
	case "pipeline-error-rime-ai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRimeAiVoiceFailed, nil
	case "pipeline-error-neets-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorNeetsVoiceFailed, nil
	case "pipeline-no-available-model":
		return ServerMessageStatusUpdateEndedReasonPipelineNoAvailableModel, nil
	case "worker-shutdown":
		return ServerMessageStatusUpdateEndedReasonWorkerShutdown, nil
	case "unknown-error":
		return ServerMessageStatusUpdateEndedReasonUnknownError, nil
	case "vonage-disconnected":
		return ServerMessageStatusUpdateEndedReasonVonageDisconnected, nil
	case "vonage-failed-to-connect-call":
		return ServerMessageStatusUpdateEndedReasonVonageFailedToConnectCall, nil
	case "phone-call-provider-bypass-enabled-but-no-call-received":
		return ServerMessageStatusUpdateEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived, nil
	case "vapifault-phone-call-worker-setup-socket-error":
		return ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerSetupSocketError, nil
	case "vapifault-phone-call-worker-worker-setup-socket-timeout":
		return ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerWorkerSetupSocketTimeout, nil
	case "vapifault-phone-call-worker-could-not-find-call":
		return ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerCouldNotFindCall, nil
	case "vapifault-transport-never-connected":
		return ServerMessageStatusUpdateEndedReasonVapifaultTransportNeverConnected, nil
	case "vapifault-web-call-worker-setup-failed":
		return ServerMessageStatusUpdateEndedReasonVapifaultWebCallWorkerSetupFailed, nil
	case "vapifault-transport-connected-but-call-not-active":
		return ServerMessageStatusUpdateEndedReasonVapifaultTransportConnectedButCallNotActive, nil
	case "assistant-not-invalid":
		return ServerMessageStatusUpdateEndedReasonAssistantNotInvalid, nil
	case "assistant-not-provided":
		return ServerMessageStatusUpdateEndedReasonAssistantNotProvided, nil
	case "call-start-error-neither-assistant-nor-server-set":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorNeitherAssistantNorServerSet, nil
	case "assistant-request-failed":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestFailed, nil
	case "assistant-request-returned-error":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedError, nil
	case "assistant-request-returned-unspeakable-error":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedUnspeakableError, nil
	case "assistant-request-returned-invalid-assistant":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedInvalidAssistant, nil
	case "assistant-request-returned-no-assistant":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedNoAssistant, nil
	case "assistant-request-returned-forwarding-phone-number":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedForwardingPhoneNumber, nil
	case "assistant-ended-call":
		return ServerMessageStatusUpdateEndedReasonAssistantEndedCall, nil
	case "assistant-said-end-call-phrase":
		return ServerMessageStatusUpdateEndedReasonAssistantSaidEndCallPhrase, nil
	case "assistant-forwarded-call":
		return ServerMessageStatusUpdateEndedReasonAssistantForwardedCall, nil
	case "assistant-join-timed-out":
		return ServerMessageStatusUpdateEndedReasonAssistantJoinTimedOut, nil
	case "customer-busy":
		return ServerMessageStatusUpdateEndedReasonCustomerBusy, nil
	case "customer-ended-call":
		return ServerMessageStatusUpdateEndedReasonCustomerEndedCall, nil
	case "customer-did-not-answer":
		return ServerMessageStatusUpdateEndedReasonCustomerDidNotAnswer, nil
	case "customer-did-not-give-microphone-permission":
		return ServerMessageStatusUpdateEndedReasonCustomerDidNotGiveMicrophonePermission, nil
	case "assistant-said-message-with-end-call-enabled":
		return ServerMessageStatusUpdateEndedReasonAssistantSaidMessageWithEndCallEnabled, nil
	case "exceeded-max-duration":
		return ServerMessageStatusUpdateEndedReasonExceededMaxDuration, nil
	case "manually-canceled":
		return ServerMessageStatusUpdateEndedReasonManuallyCanceled, nil
	case "phone-call-provider-closed-websocket":
		return ServerMessageStatusUpdateEndedReasonPhoneCallProviderClosedWebsocket, nil
	case "pipeline-error-openai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-openai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai401Unauthorized, nil
	case "pipeline-error-openai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai403ModelAccessDenied, nil
	case "pipeline-error-openai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai429ExceededQuota, nil
	case "pipeline-error-openai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai500ServerError, nil
	case "pipeline-error-azure-openai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-azure-openai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai401Unauthorized, nil
	case "pipeline-error-azure-openai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied, nil
	case "pipeline-error-azure-openai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai429ExceededQuota, nil
	case "pipeline-error-azure-openai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai500ServerError, nil
	case "pipeline-error-groq-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq400BadRequestValidationFailed, nil
	case "pipeline-error-groq-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq401Unauthorized, nil
	case "pipeline-error-groq-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq403ModelAccessDenied, nil
	case "pipeline-error-groq-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq429ExceededQuota, nil
	case "pipeline-error-groq-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq500ServerError, nil
	case "pipeline-error-anthropic-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic401Unauthorized, nil
	case "pipeline-error-anthropic-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic403ModelAccessDenied, nil
	case "pipeline-error-anthropic-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic429ExceededQuota, nil
	case "pipeline-error-anthropic-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic500ServerError, nil
	case "pipeline-error-together-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed, nil
	case "pipeline-error-together-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi401Unauthorized, nil
	case "pipeline-error-together-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi403ModelAccessDenied, nil
	case "pipeline-error-together-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi429ExceededQuota, nil
	case "pipeline-error-together-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi500ServerError, nil
	case "pipeline-error-together-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAiLlmFailed, nil
	case "pipeline-error-anyscale-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed, nil
	case "pipeline-error-anyscale-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale401Unauthorized, nil
	case "pipeline-error-anyscale-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale403ModelAccessDenied, nil
	case "pipeline-error-anyscale-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale429ExceededQuota, nil
	case "pipeline-error-anyscale-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale500ServerError, nil
	case "pipeline-error-anyscale-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscaleLlmFailed, nil
	case "pipeline-error-openrouter-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed, nil
	case "pipeline-error-openrouter-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter401Unauthorized, nil
	case "pipeline-error-openrouter-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter403ModelAccessDenied, nil
	case "pipeline-error-openrouter-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter429ExceededQuota, nil
	case "pipeline-error-openrouter-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter500ServerError, nil
	case "pipeline-error-openrouter-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouterLlmFailed, nil
	case "pipeline-error-perplexity-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed, nil
	case "pipeline-error-perplexity-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi401Unauthorized, nil
	case "pipeline-error-perplexity-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied, nil
	case "pipeline-error-perplexity-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi429ExceededQuota, nil
	case "pipeline-error-perplexity-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi500ServerError, nil
	case "pipeline-error-perplexity-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAiLlmFailed, nil
	case "pipeline-error-deepinfra-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed, nil
	case "pipeline-error-deepinfra-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra401Unauthorized, nil
	case "pipeline-error-deepinfra-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra403ModelAccessDenied, nil
	case "pipeline-error-deepinfra-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra429ExceededQuota, nil
	case "pipeline-error-deepinfra-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra500ServerError, nil
	case "pipeline-error-deepinfra-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfraLlmFailed, nil
	case "pipeline-error-runpod-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod400BadRequestValidationFailed, nil
	case "pipeline-error-runpod-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod401Unauthorized, nil
	case "pipeline-error-runpod-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod403ModelAccessDenied, nil
	case "pipeline-error-runpod-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod429ExceededQuota, nil
	case "pipeline-error-runpod-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod500ServerError, nil
	case "pipeline-error-runpod-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpodLlmFailed, nil
	case "pipeline-error-custom-llm-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed, nil
	case "pipeline-error-custom-llm-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm401Unauthorized, nil
	case "pipeline-error-custom-llm-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm403ModelAccessDenied, nil
	case "pipeline-error-custom-llm-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm429ExceededQuota, nil
	case "pipeline-error-custom-llm-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm500ServerError, nil
	case "pipeline-error-custom-llm-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlmLlmFailed, nil
	case "pipeline-error-cartesia-socket-hang-up":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaSocketHangUp, nil
	case "pipeline-error-cartesia-requested-payment":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaRequestedPayment, nil
	case "pipeline-error-cartesia-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia500ServerError, nil
	case "pipeline-error-cartesia-503-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia503ServerError, nil
	case "pipeline-error-cartesia-522-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia522ServerError, nil
	case "pipeline-error-custom-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomVoiceFailed, nil
	case "pipeline-error-eleven-labs-voice-not-found":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFound, nil
	case "pipeline-error-eleven-labs-quota-exceeded":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsQuotaExceeded, nil
	case "pipeline-error-eleven-labs-unauthorized-access":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedAccess, nil
	case "pipeline-error-eleven-labs-unauthorized-to-access-model":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel, nil
	case "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus, nil
	case "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-system-busy-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned, nil
	case "pipeline-error-eleven-labs-invalid-api-key":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidApiKey, nil
	case "pipeline-error-eleven-labs-invalid-voice-samples":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples, nil
	case "pipeline-error-eleven-labs-voice-disabled-by-owner":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner, nil
	case "pipeline-error-eleven-labs-blocked-account-in-probation":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation, nil
	case "pipeline-error-eleven-labs-blocked-content-against-their-policy":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy, nil
	case "pipeline-error-eleven-labs-missing-samples-for-voice-clone":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed, nil
	case "pipeline-error-eleven-labs-voice-not-allowed-for-free-users":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers, nil
	case "pipeline-error-eleven-labs-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabs500ServerError, nil
	case "pipeline-error-eleven-labs-max-character-limit-exceeded":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded, nil
	case "pipeline-error-playht-request-timed-out":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtRequestTimedOut, nil
	case "pipeline-error-playht-invalid-voice":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtInvalidVoice, nil
	case "pipeline-error-playht-unexpected-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtUnexpectedError, nil
	case "pipeline-error-playht-out-of-credits":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtOutOfCredits, nil
	case "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri, nil
	case "pipeline-error-playht-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht401Unauthorized, nil
	case "pipeline-error-playht-403-forbidden-out-of-characters":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters, nil
	case "pipeline-error-playht-403-forbidden-api-access-not-available":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable, nil
	case "pipeline-error-playht-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht429ExceededQuota, nil
	case "pipeline-error-playht-502-gateway-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht502GatewayError, nil
	case "pipeline-error-playht-504-gateway-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht504GatewayError, nil
	case "pipeline-error-deepgram-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgram403ModelAccessDenied, nil
	case "pipeline-error-deepgram-404-not-found":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgram404NotFound, nil
	case "pipeline-error-deepgram-400-no-such-model-language-tier-combination":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgram400NoSuchModelLanguageTierCombination, nil
	case "pipeline-error-deepgram-500-returning-invalid-json":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgram500ReturningInvalidJson, nil
	case "sip-gateway-failed-to-connect-call":
		return ServerMessageStatusUpdateEndedReasonSipGatewayFailedToConnectCall, nil
	case "silence-timed-out":
		return ServerMessageStatusUpdateEndedReasonSilenceTimedOut, nil
	case "twilio-failed-to-connect-call":
		return ServerMessageStatusUpdateEndedReasonTwilioFailedToConnectCall, nil
	case "twilio-reported-customer-misdialed":
		return ServerMessageStatusUpdateEndedReasonTwilioReportedCustomerMisdialed, nil
	case "voicemail":
		return ServerMessageStatusUpdateEndedReasonVoicemail, nil
	case "vonage-rejected":
		return ServerMessageStatusUpdateEndedReasonVonageRejected, nil
	}
	var t ServerMessageStatusUpdateEndedReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageStatusUpdateEndedReason) Ptr() *ServerMessageStatusUpdateEndedReason {
	return &s
}

type ServerMessageStatusUpdateMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		s.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		s.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		s.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		s.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		s.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageStatusUpdateMessagesItem) MarshalJSON() ([]byte, error) {
	if s.UserMessage != nil {
		return json.Marshal(s.UserMessage)
	}
	if s.SystemMessage != nil {
		return json.Marshal(s.SystemMessage)
	}
	if s.BotMessage != nil {
		return json.Marshal(s.BotMessage)
	}
	if s.ToolCallMessage != nil {
		return json.Marshal(s.ToolCallMessage)
	}
	if s.ToolCallResultMessage != nil {
		return json.Marshal(s.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageStatusUpdateMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (s *ServerMessageStatusUpdateMessagesItem) Accept(visitor ServerMessageStatusUpdateMessagesItemVisitor) error {
	if s.UserMessage != nil {
		return visitor.VisitUserMessage(s.UserMessage)
	}
	if s.SystemMessage != nil {
		return visitor.VisitSystemMessage(s.SystemMessage)
	}
	if s.BotMessage != nil {
		return visitor.VisitBotMessage(s.BotMessage)
	}
	if s.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(s.ToolCallMessage)
	}
	if s.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(s.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageStatusUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageStatusUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageStatusUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageStatusUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageStatusUpdatePhoneNumber) Accept(visitor ServerMessageStatusUpdatePhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the status of the call.
type ServerMessageStatusUpdateStatus string

const (
	ServerMessageStatusUpdateStatusQueued     ServerMessageStatusUpdateStatus = "queued"
	ServerMessageStatusUpdateStatusRinging    ServerMessageStatusUpdateStatus = "ringing"
	ServerMessageStatusUpdateStatusInProgress ServerMessageStatusUpdateStatus = "in-progress"
	ServerMessageStatusUpdateStatusForwarding ServerMessageStatusUpdateStatus = "forwarding"
	ServerMessageStatusUpdateStatusEnded      ServerMessageStatusUpdateStatus = "ended"
)

func NewServerMessageStatusUpdateStatusFromString(s string) (ServerMessageStatusUpdateStatus, error) {
	switch s {
	case "queued":
		return ServerMessageStatusUpdateStatusQueued, nil
	case "ringing":
		return ServerMessageStatusUpdateStatusRinging, nil
	case "in-progress":
		return ServerMessageStatusUpdateStatusInProgress, nil
	case "forwarding":
		return ServerMessageStatusUpdateStatusForwarding, nil
	case "ended":
		return ServerMessageStatusUpdateStatusEnded, nil
	}
	var t ServerMessageStatusUpdateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageStatusUpdateStatus) Ptr() *ServerMessageStatusUpdateStatus {
	return &s
}

type ServerMessageToolCalls struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageToolCallsPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "tool-calls" is sent to call a tool.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// This is the list of tools calls that the model is requesting along with the original tool configuration.
	ToolWithToolCallList []*ServerMessageToolCallsToolWithToolCallListItem `json:"toolWithToolCallList,omitempty" url:"toolWithToolCallList,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the list of tool calls that the model is requesting.
	ToolCallList []*ToolCall `json:"toolCallList,omitempty" url:"toolCallList,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageToolCalls) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageToolCalls(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageToolCalls) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageToolCallsPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageToolCallsPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageToolCallsPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageToolCallsPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageToolCallsPhoneNumber) Accept(visitor ServerMessageToolCallsPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageToolCallsToolWithToolCallListItem struct {
	FunctionToolWithToolCall *FunctionToolWithToolCall
	GhlToolWithToolCall      *GhlToolWithToolCall
	MakeToolWithToolCall     *MakeToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) UnmarshalJSON(data []byte) error {
	valueFunctionToolWithToolCall := new(FunctionToolWithToolCall)
	if err := json.Unmarshal(data, &valueFunctionToolWithToolCall); err == nil {
		s.FunctionToolWithToolCall = valueFunctionToolWithToolCall
		return nil
	}
	valueGhlToolWithToolCall := new(GhlToolWithToolCall)
	if err := json.Unmarshal(data, &valueGhlToolWithToolCall); err == nil {
		s.GhlToolWithToolCall = valueGhlToolWithToolCall
		return nil
	}
	valueMakeToolWithToolCall := new(MakeToolWithToolCall)
	if err := json.Unmarshal(data, &valueMakeToolWithToolCall); err == nil {
		s.MakeToolWithToolCall = valueMakeToolWithToolCall
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageToolCallsToolWithToolCallListItem) MarshalJSON() ([]byte, error) {
	if s.FunctionToolWithToolCall != nil {
		return json.Marshal(s.FunctionToolWithToolCall)
	}
	if s.GhlToolWithToolCall != nil {
		return json.Marshal(s.GhlToolWithToolCall)
	}
	if s.MakeToolWithToolCall != nil {
		return json.Marshal(s.MakeToolWithToolCall)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageToolCallsToolWithToolCallListItemVisitor interface {
	VisitFunctionToolWithToolCall(*FunctionToolWithToolCall) error
	VisitGhlToolWithToolCall(*GhlToolWithToolCall) error
	VisitMakeToolWithToolCall(*MakeToolWithToolCall) error
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) Accept(visitor ServerMessageToolCallsToolWithToolCallListItemVisitor) error {
	if s.FunctionToolWithToolCall != nil {
		return visitor.VisitFunctionToolWithToolCall(s.FunctionToolWithToolCall)
	}
	if s.GhlToolWithToolCall != nil {
		return visitor.VisitGhlToolWithToolCall(s.GhlToolWithToolCall)
	}
	if s.MakeToolWithToolCall != nil {
		return visitor.VisitMakeToolWithToolCall(s.MakeToolWithToolCall)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTranscript struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageTranscriptPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transcript" is sent as transcriber outputs partial or final transcript.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the role for which the transcript is for.
	Role ServerMessageTranscriptRole `json:"role" url:"role"`
	// This is the type of the transcript.
	TranscriptType ServerMessageTranscriptTranscriptType `json:"transcriptType" url:"transcriptType"`
	// This is the transcript content.
	Transcript string `json:"transcript" url:"transcript"`
	type_      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageTranscript) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageTranscript) Type() string {
	return s.type_
}

func (s *ServerMessageTranscript) UnmarshalJSON(data []byte) error {
	type embed ServerMessageTranscript
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageTranscript(unmarshaler.embed)
	if unmarshaler.Type != "transcript" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "transcript", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageTranscript) MarshalJSON() ([]byte, error) {
	type embed ServerMessageTranscript
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "transcript",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageTranscript) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageTranscriptPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageTranscriptPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTranscriptPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTranscriptPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageTranscriptPhoneNumber) Accept(visitor ServerMessageTranscriptPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the role for which the transcript is for.
type ServerMessageTranscriptRole string

const (
	ServerMessageTranscriptRoleAssistant ServerMessageTranscriptRole = "assistant"
	ServerMessageTranscriptRoleUser      ServerMessageTranscriptRole = "user"
)

func NewServerMessageTranscriptRoleFromString(s string) (ServerMessageTranscriptRole, error) {
	switch s {
	case "assistant":
		return ServerMessageTranscriptRoleAssistant, nil
	case "user":
		return ServerMessageTranscriptRoleUser, nil
	}
	var t ServerMessageTranscriptRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageTranscriptRole) Ptr() *ServerMessageTranscriptRole {
	return &s
}

// This is the type of the transcript.
type ServerMessageTranscriptTranscriptType string

const (
	ServerMessageTranscriptTranscriptTypePartial ServerMessageTranscriptTranscriptType = "partial"
	ServerMessageTranscriptTranscriptTypeFinal   ServerMessageTranscriptTranscriptType = "final"
)

func NewServerMessageTranscriptTranscriptTypeFromString(s string) (ServerMessageTranscriptTranscriptType, error) {
	switch s {
	case "partial":
		return ServerMessageTranscriptTranscriptTypePartial, nil
	case "final":
		return ServerMessageTranscriptTranscriptTypeFinal, nil
	}
	var t ServerMessageTranscriptTranscriptType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageTranscriptTranscriptType) Ptr() *ServerMessageTranscriptTranscriptType {
	return &s
}

type ServerMessageTransferDestinationRequest struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageTransferDestinationRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transfer-destination-request" is sent when the model is requesting transfer but destination is unknown.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageTransferDestinationRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageTransferDestinationRequest) Type() string {
	return s.type_
}

func (s *ServerMessageTransferDestinationRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageTransferDestinationRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageTransferDestinationRequest(unmarshaler.embed)
	if unmarshaler.Type != "transfer-destination-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "transfer-destination-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageTransferDestinationRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageTransferDestinationRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "transfer-destination-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageTransferDestinationRequest) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageTransferDestinationRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTransferDestinationRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferDestinationRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) Accept(visitor ServerMessageTransferDestinationRequestPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferUpdate struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageTransferUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transfer-update" is sent whenever a transfer happens.
	// This is the destination of the transfer.
	Destination *ServerMessageTransferUpdateDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the assistant that the call is being transferred to. This is only sent if `destination.type` is "assistant".
	ToAssistant *CreateAssistantDto `json:"toAssistant,omitempty" url:"toAssistant,omitempty"`
	// This is the assistant that the call is being transferred from. This is only sent if `destination.type` is "assistant".
	FromAssistant *CreateAssistantDto `json:"fromAssistant,omitempty" url:"fromAssistant,omitempty"`
	type_         string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageTransferUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageTransferUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageTransferUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageTransferUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageTransferUpdate(unmarshaler.embed)
	if unmarshaler.Type != "transfer-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "transfer-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageTransferUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageTransferUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "transfer-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageTransferUpdate) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination of the transfer.
type ServerMessageTransferUpdateDestination struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationStep      *TransferDestinationStep
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip
}

func (s *ServerMessageTransferUpdateDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		s.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationStep := new(TransferDestinationStep)
	if err := json.Unmarshal(data, &valueTransferDestinationStep); err == nil {
		s.TransferDestinationStep = valueTransferDestinationStep
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTransferUpdateDestination) MarshalJSON() ([]byte, error) {
	if s.TransferDestinationAssistant != nil {
		return json.Marshal(s.TransferDestinationAssistant)
	}
	if s.TransferDestinationStep != nil {
		return json.Marshal(s.TransferDestinationStep)
	}
	if s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferUpdateDestinationVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationStep(*TransferDestinationStep) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageTransferUpdateDestination) Accept(visitor ServerMessageTransferUpdateDestinationVisitor) error {
	if s.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(s.TransferDestinationAssistant)
	}
	if s.TransferDestinationStep != nil {
		return visitor.VisitTransferDestinationStep(s.TransferDestinationStep)
	}
	if s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageTransferUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageTransferUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTransferUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageTransferUpdatePhoneNumber) Accept(visitor ServerMessageTransferUpdatePhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageUserInterrupted struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageUserInterruptedPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "user-interrupted" is sent when the user interrupts the assistant.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageUserInterrupted) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageUserInterrupted) Type() string {
	return s.type_
}

func (s *ServerMessageUserInterrupted) UnmarshalJSON(data []byte) error {
	type embed ServerMessageUserInterrupted
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageUserInterrupted(unmarshaler.embed)
	if unmarshaler.Type != "user-interrupted" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "user-interrupted", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageUserInterrupted) MarshalJSON() ([]byte, error) {
	type embed ServerMessageUserInterrupted
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "user-interrupted",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageUserInterrupted) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageUserInterruptedPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageUserInterruptedPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageUserInterruptedPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageUserInterruptedPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageUserInterruptedPhoneNumber) Accept(visitor ServerMessageUserInterruptedPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceInput struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageVoiceInputPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "voice-input" is sent when a generation is requested from voice provider.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the voice input content
	Input string `json:"input" url:"input"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageVoiceInput) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageVoiceInput) Type() string {
	return s.type_
}

func (s *ServerMessageVoiceInput) UnmarshalJSON(data []byte) error {
	type embed ServerMessageVoiceInput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageVoiceInput(unmarshaler.embed)
	if unmarshaler.Type != "voice-input" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "voice-input", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageVoiceInput) MarshalJSON() ([]byte, error) {
	type embed ServerMessageVoiceInput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "voice-input",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageVoiceInput) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageVoiceInputPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageVoiceInputPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageVoiceInputPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceInputPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageVoiceInputPhoneNumber) Accept(visitor ServerMessageVoiceInputPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceRequest struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageVoiceRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "voice-request" is sent when using `assistant.voice={ "type": "custom-voice" }`.
	//
	// Here is what the request will look like:
	//
	// POST https://{assistant.voice.server.url}
	// Content-Type: application/json
	//
	// {
	// "messsage": {
	// "type": "voice-request",
	// "text": "Hello, world!",
	// "sampleRate": 24000,
	// ...other metadata about the call...
	// }
	// }
	//
	// The expected response is 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:
	//
	// ```
	//
	//	response.on('data', (chunk: Buffer) => {
	//	  outputStream.write(chunk);
	//	});
	//
	// ```
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	//
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	//
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the text to be synthesized.
	Text string `json:"text" url:"text"`
	// This is the sample rate to be synthesized.
	SampleRate float64 `json:"sampleRate" url:"sampleRate"`
	type_      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ServerMessageVoiceRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageVoiceRequest) Type() string {
	return s.type_
}

func (s *ServerMessageVoiceRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageVoiceRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageVoiceRequest(unmarshaler.embed)
	if unmarshaler.Type != "voice-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "voice-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageVoiceRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageVoiceRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "voice-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageVoiceRequest) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
//
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageVoiceRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
}

func (s *ServerMessageVoiceRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageVoiceRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageVoiceRequestPhoneNumber) Accept(visitor ServerMessageVoiceRequestPhoneNumberVisitor) error {
	if s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SipTrunkGateway struct {
	// This is the address of the gateway. It can be an IPv4 address like 1.1.1.1 or a fully qualified domain name like my-sip-trunk.pstn.twilio.com.
	Ip string `json:"ip" url:"ip"`
	// This is the port number of the gateway. Default is 5060.
	//
	// @default 5060
	Port *float64 `json:"port,omitempty" url:"port,omitempty"`
	// This is the netmask of the gateway. Defaults to 32.
	//
	// @default 32
	Netmask *float64 `json:"netmask,omitempty" url:"netmask,omitempty"`
	// This is whether inbound calls are allowed from this gateway. Default is true.
	//
	// @default true
	InboundEnabled *bool `json:"inboundEnabled,omitempty" url:"inboundEnabled,omitempty"`
	// This is whether outbound calls should be sent to this gateway. Default is true.
	//
	// Note, if netmask is less than 32, it doesn't affect the outbound IPs that are tried. 1 attempt is made to `ip:port`.
	//
	// @default true
	OutboundEnabled *bool `json:"outboundEnabled,omitempty" url:"outboundEnabled,omitempty"`
	// This is the protocol to use for SIP signaling outbound calls. Default is udp.
	//
	// @default udp
	OutboundProtocol *SipTrunkGatewayOutboundProtocol `json:"outboundProtocol,omitempty" url:"outboundProtocol,omitempty"`
	// This is whether to send options ping to the gateway. This can be used to check if the gateway is reachable. Default is false.
	//
	// This is useful for high availability setups where you want to check if the gateway is reachable before routing calls to it. Note, if no gateway for a trunk is reachable, outbound calls will be rejected.
	//
	// @default false
	OptionsPingEnabled *bool `json:"optionsPingEnabled,omitempty" url:"optionsPingEnabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SipTrunkGateway) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SipTrunkGateway) UnmarshalJSON(data []byte) error {
	type unmarshaler SipTrunkGateway
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SipTrunkGateway(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SipTrunkGateway) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the protocol to use for SIP signaling outbound calls. Default is udp.
//
// @default udp
type SipTrunkGatewayOutboundProtocol string

const (
	SipTrunkGatewayOutboundProtocolTlsSrtp SipTrunkGatewayOutboundProtocol = "tls/srtp"
	SipTrunkGatewayOutboundProtocolTcp     SipTrunkGatewayOutboundProtocol = "tcp"
	SipTrunkGatewayOutboundProtocolTls     SipTrunkGatewayOutboundProtocol = "tls"
	SipTrunkGatewayOutboundProtocolUdp     SipTrunkGatewayOutboundProtocol = "udp"
)

func NewSipTrunkGatewayOutboundProtocolFromString(s string) (SipTrunkGatewayOutboundProtocol, error) {
	switch s {
	case "tls/srtp":
		return SipTrunkGatewayOutboundProtocolTlsSrtp, nil
	case "tcp":
		return SipTrunkGatewayOutboundProtocolTcp, nil
	case "tls":
		return SipTrunkGatewayOutboundProtocolTls, nil
	case "udp":
		return SipTrunkGatewayOutboundProtocolUdp, nil
	}
	var t SipTrunkGatewayOutboundProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SipTrunkGatewayOutboundProtocol) Ptr() *SipTrunkGatewayOutboundProtocol {
	return &s
}

type SipTrunkOutboundAuthenticationPlan struct {
	// This is not returned in the API.
	AuthPassword *string `json:"authPassword,omitempty" url:"authPassword,omitempty"`
	AuthUsername *string `json:"authUsername,omitempty" url:"authUsername,omitempty"`
	// This can be used to configure if SIP register is required by the SIP trunk. If not provided, no SIP registration will be attempted.
	SipRegisterPlan *SipTrunkOutboundSipRegisterPlan `json:"sipRegisterPlan,omitempty" url:"sipRegisterPlan,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SipTrunkOutboundAuthenticationPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SipTrunkOutboundAuthenticationPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SipTrunkOutboundAuthenticationPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SipTrunkOutboundAuthenticationPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SipTrunkOutboundAuthenticationPlan) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SipTrunkOutboundSipRegisterPlan struct {
	Domain   *string `json:"domain,omitempty" url:"domain,omitempty"`
	Username *string `json:"username,omitempty" url:"username,omitempty"`
	Realm    *string `json:"realm,omitempty" url:"realm,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SipTrunkOutboundSipRegisterPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SipTrunkOutboundSipRegisterPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SipTrunkOutboundSipRegisterPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SipTrunkOutboundSipRegisterPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SipTrunkOutboundSipRegisterPlan) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Squad struct {
	// This is the name of the squad.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the list of assistants that make up the squad.
	//
	// The call will start with the first assistant in the list.
	Members []*SquadMemberDto `json:"members,omitempty" url:"members,omitempty"`
	// This can be used to override all the assistants' settings and provide values for their template variables.
	//
	// Both `membersOverrides` and `members[n].assistantOverrides` can be used together. First, `members[n].assistantOverrides` is applied. Then, `membersOverrides` is applied as a global override.
	MembersOverrides *AssistantOverrides `json:"membersOverrides,omitempty" url:"membersOverrides,omitempty"`
	// This is the unique identifier for the squad.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this squad belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the squad was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the squad was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Squad) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Squad) UnmarshalJSON(data []byte) error {
	type embed Squad
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Squad(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Squad) MarshalJSON() ([]byte, error) {
	type embed Squad
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
		UpdatedAt: core.NewDateTime(s.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Squad) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SquadMemberDto struct {
	// This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This can be used to override the assistant's settings and provide values for it's template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// These are the others assistants that this assistant can transfer to.
	//
	// If the assistant already has transfer call tool, these destinations are just appended to existing ones.
	AssistantDestinations []*TransferDestinationAssistant `json:"assistantDestinations,omitempty" url:"assistantDestinations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SquadMemberDto) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SquadMemberDto) UnmarshalJSON(data []byte) error {
	type unmarshaler SquadMemberDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SquadMemberDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SquadMemberDto) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StartSpeakingPlan struct {
	// This is how long assistant waits before speaking. Defaults to 0.4.
	//
	// This is the minimum it will wait but if there is latency is the pipeline, this minimum will be exceeded. This is really a stopgap in case the pipeline is moving too fast.
	//
	// Example:
	//
	// - If model generates tokens and voice generates bytes within 100ms, the pipeline still waits 300ms before outputting speech.
	//
	// Usage:
	//
	// - If the customer is taking long pauses, set this to a higher value.
	// - If the assistant is accidentally jumping in too much, set this to a higher value.
	//
	// @default 0.4
	WaitSeconds *float64 `json:"waitSeconds,omitempty" url:"waitSeconds,omitempty"`
	// This determines if a customer speech is considered done (endpointing) using the VAP model on customer's speech. This is good for middle-of-thought detection.
	//
	// Once an endpoint is triggered, the request is sent to `assistant.model`.
	//
	// Default `false` since experimental.
	//
	// @default false
	SmartEndpointingEnabled *bool `json:"smartEndpointingEnabled,omitempty" url:"smartEndpointingEnabled,omitempty"`
	// This determines how a customer speech is considered done (endpointing) using the transcription of customer's speech.
	//
	// Once an endpoint is triggered, the request is sent to `assistant.model`.
	TranscriptionEndpointingPlan *TranscriptionEndpointingPlan `json:"transcriptionEndpointingPlan,omitempty" url:"transcriptionEndpointingPlan,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StartSpeakingPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StartSpeakingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler StartSpeakingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StartSpeakingPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StartSpeakingPlan) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StepDestination struct {
	// This is an optional array of conditions that must be met for this destination to be triggered. If empty, this is the default destination that the step transfers to.
	Conditions []*StepDestinationConditionsItem `json:"conditions,omitempty" url:"conditions,omitempty"`
	StepName   string                           `json:"stepName" url:"stepName"`
	type_      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StepDestination) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StepDestination) Type() string {
	return s.type_
}

func (s *StepDestination) UnmarshalJSON(data []byte) error {
	type embed StepDestination
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = StepDestination(unmarshaler.embed)
	if unmarshaler.Type != "step" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "step", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StepDestination) MarshalJSON() ([]byte, error) {
	type embed StepDestination
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "step",
	}
	return json.Marshal(marshaler)
}

func (s *StepDestination) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StepDestinationConditionsItem struct {
	ModelBasedCondition *ModelBasedCondition
	RuleBasedCondition  *RuleBasedCondition
}

func (s *StepDestinationConditionsItem) UnmarshalJSON(data []byte) error {
	valueModelBasedCondition := new(ModelBasedCondition)
	if err := json.Unmarshal(data, &valueModelBasedCondition); err == nil {
		s.ModelBasedCondition = valueModelBasedCondition
		return nil
	}
	valueRuleBasedCondition := new(RuleBasedCondition)
	if err := json.Unmarshal(data, &valueRuleBasedCondition); err == nil {
		s.RuleBasedCondition = valueRuleBasedCondition
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s StepDestinationConditionsItem) MarshalJSON() ([]byte, error) {
	if s.ModelBasedCondition != nil {
		return json.Marshal(s.ModelBasedCondition)
	}
	if s.RuleBasedCondition != nil {
		return json.Marshal(s.RuleBasedCondition)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StepDestinationConditionsItemVisitor interface {
	VisitModelBasedCondition(*ModelBasedCondition) error
	VisitRuleBasedCondition(*RuleBasedCondition) error
}

func (s *StepDestinationConditionsItem) Accept(visitor StepDestinationConditionsItemVisitor) error {
	if s.ModelBasedCondition != nil {
		return visitor.VisitModelBasedCondition(s.ModelBasedCondition)
	}
	if s.RuleBasedCondition != nil {
		return visitor.VisitRuleBasedCondition(s.RuleBasedCondition)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StopSpeakingPlan struct {
	// This is the number of words that the customer has to say before the assistant will stop talking.
	//
	// Words like "stop", "actually", "no", etc. will always interrupt immediately regardless of this value.
	//
	// Words like "okay", "yeah", "right" will never interrupt.
	//
	// When set to 0, `voiceSeconds` is used in addition to the transcriptions to determine the customer has started speaking.
	//
	// Defaults to 0.
	//
	// @default 0
	NumWords *float64 `json:"numWords,omitempty" url:"numWords,omitempty"`
	// This is the seconds customer has to speak before the assistant stops talking. This uses the VAD (Voice Activity Detection) spike to determine if the customer has started speaking.
	//
	// Considerations:
	//
	// - A lower value might be more responsive but could potentially pick up non-speech sounds.
	// - A higher value reduces false positives but might slightly delay the detection of speech onset.
	//
	// This is only used if `numWords` is set to 0.
	//
	// # Defaults to 0.2
	//
	// @default 0.2
	VoiceSeconds *float64 `json:"voiceSeconds,omitempty" url:"voiceSeconds,omitempty"`
	// This is the seconds to wait before the assistant will start talking again after being interrupted.
	//
	// Defaults to 1.
	//
	// @default 1
	BackoffSeconds *float64 `json:"backoffSeconds,omitempty" url:"backoffSeconds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StopSpeakingPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StopSpeakingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler StopSpeakingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StopSpeakingPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StopSpeakingPlan) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StructuredDataPlan struct {
	// These are the messages used to generate the structured data.
	//
	// @default: ` [ { "role": "system", "content": "You are an expert data extractor. You will be given a transcript of a call. Extract structured data per the JSON Schema. DO NOT return anything except the structured data.\n\nJson Schema:\\n{{schema}}\n\nOnly respond with the JSON." }, { "role": "user", "content": "Here is the transcript:\n\n{{transcript}}\n\n" } ]`
	//
	// You can customize by providing any messages you want.
	//
	// Here are the template variables available:
	//
	// - {{transcript}}: the transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: the system prompt of the call from `assistant.model.messages[type=system].content`- {{schema}}: the schema of the structured data from `structuredDataPlan.schema`
	Messages []map[string]interface{} `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines whether structured data is generated and stored in `call.analysis.structuredData`. Defaults to false.
	//
	// Usage:
	//
	// - If you want to extract structured data, set this to true and provide a `schema`.
	//
	// @default false
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the schema of the structured data. The output is stored in `call.analysis.structuredData`.
	//
	// Complete guide on JSON Schema can be found [here](https://ajv.js.org/json-schema.html#json-data-type).
	Schema *JsonSchema `json:"schema,omitempty" url:"schema,omitempty"`
	// This is how long the request is tried before giving up. When request times out, `call.analysis.structuredData` will be empty.
	//
	// Usage:
	//
	// - To guarantee the structured data is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.
	//
	// @default 5 seconds
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StructuredDataPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StructuredDataPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler StructuredDataPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StructuredDataPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StructuredDataPlan) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SuccessEvaluationPlan struct {
	// This enforces the rubric of the evaluation. The output is stored in `call.analysis.successEvaluation`.
	//
	// Options include:
	//
	// - 'NumericScale': A scale of 1 to 10.
	// - 'DescriptiveScale': A scale of Excellent, Good, Fair, Poor.
	// - 'Checklist': A checklist of criteria and their status.
	// - 'Matrix': A grid that evaluates multiple criteria across different performance levels.
	// - 'PercentageScale': A scale of 0% to 100%.
	// - 'LikertScale': A scale of Strongly Agree, Agree, Neutral, Disagree, Strongly Disagree.
	// - 'AutomaticRubric': Automatically break down evaluation into several criteria, each with its own score.
	// - 'PassFail': A simple 'true' if call passed, 'false' if not.
	//
	// Default is 'PassFail'.
	Rubric *SuccessEvaluationPlanRubric `json:"rubric,omitempty" url:"rubric,omitempty"`
	// These are the messages used to generate the success evaluation.
	//
	// @default: ` [ { "role": "system", "content": "You are an expert call evaluator. You will be given a transcript of a call and the system prompt of the AI participant. Determine if the call was successful based on the objectives inferred from the system prompt. DO NOT return anything except the result.\n\nRubric:\\n{{rubric}}\n\nOnly respond with the result." }, { "role": "user", "content": "Here is the transcript:\n\n{{transcript}}\n\n" }, { "role": "user", "content": "Here was the system prompt of the call:\n\n{{systemPrompt}}\n\n" } ]`
	//
	// You can customize by providing any messages you want.
	//
	// Here are the template variables available:
	//
	// - {{transcript}}: the transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: the system prompt of the call from `assistant.model.messages[type=system].content`- {{rubric}}: the rubric of the success evaluation from `successEvaluationPlan.rubric`
	Messages []map[string]interface{} `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines whether a success evaluation is generated and stored in `call.analysis.successEvaluation`. Defaults to true.
	//
	// Usage:
	//
	// - If you want to disable the success evaluation, set this to false.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is how long the request is tried before giving up. When request times out, `call.analysis.successEvaluation` will be empty.
	//
	// Usage:
	//
	// - To guarantee the success evaluation is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.
	//
	// @default 5 seconds
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SuccessEvaluationPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessEvaluationPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessEvaluationPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessEvaluationPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessEvaluationPlan) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This enforces the rubric of the evaluation. The output is stored in `call.analysis.successEvaluation`.
//
// Options include:
//
// - 'NumericScale': A scale of 1 to 10.
// - 'DescriptiveScale': A scale of Excellent, Good, Fair, Poor.
// - 'Checklist': A checklist of criteria and their status.
// - 'Matrix': A grid that evaluates multiple criteria across different performance levels.
// - 'PercentageScale': A scale of 0% to 100%.
// - 'LikertScale': A scale of Strongly Agree, Agree, Neutral, Disagree, Strongly Disagree.
// - 'AutomaticRubric': Automatically break down evaluation into several criteria, each with its own score.
// - 'PassFail': A simple 'true' if call passed, 'false' if not.
//
// Default is 'PassFail'.
type SuccessEvaluationPlanRubric string

const (
	SuccessEvaluationPlanRubricNumericScale     SuccessEvaluationPlanRubric = "NumericScale"
	SuccessEvaluationPlanRubricDescriptiveScale SuccessEvaluationPlanRubric = "DescriptiveScale"
	SuccessEvaluationPlanRubricChecklist        SuccessEvaluationPlanRubric = "Checklist"
	SuccessEvaluationPlanRubricMatrix           SuccessEvaluationPlanRubric = "Matrix"
	SuccessEvaluationPlanRubricPercentageScale  SuccessEvaluationPlanRubric = "PercentageScale"
	SuccessEvaluationPlanRubricLikertScale      SuccessEvaluationPlanRubric = "LikertScale"
	SuccessEvaluationPlanRubricAutomaticRubric  SuccessEvaluationPlanRubric = "AutomaticRubric"
	SuccessEvaluationPlanRubricPassFail         SuccessEvaluationPlanRubric = "PassFail"
)

func NewSuccessEvaluationPlanRubricFromString(s string) (SuccessEvaluationPlanRubric, error) {
	switch s {
	case "NumericScale":
		return SuccessEvaluationPlanRubricNumericScale, nil
	case "DescriptiveScale":
		return SuccessEvaluationPlanRubricDescriptiveScale, nil
	case "Checklist":
		return SuccessEvaluationPlanRubricChecklist, nil
	case "Matrix":
		return SuccessEvaluationPlanRubricMatrix, nil
	case "PercentageScale":
		return SuccessEvaluationPlanRubricPercentageScale, nil
	case "LikertScale":
		return SuccessEvaluationPlanRubricLikertScale, nil
	case "AutomaticRubric":
		return SuccessEvaluationPlanRubricAutomaticRubric, nil
	case "PassFail":
		return SuccessEvaluationPlanRubricPassFail, nil
	}
	var t SuccessEvaluationPlanRubric
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SuccessEvaluationPlanRubric) Ptr() *SuccessEvaluationPlanRubric {
	return &s
}

type SummaryPlan struct {
	// These are the messages used to generate the summary.
	//
	// @default: ` [ { "role": "system", "content": "You are an expert note-taker. You will be given a transcript of a call. Summarize the call in 2-3 sentences. DO NOT return anything except the summary." }, { "role": "user", "content": "Here is the transcript:\n\n{{transcript}}\n\n" } ]`
	//
	// You can customize by providing any messages you want.
	//
	// Here are the template variables available:
	//
	// - {{transcript}}: The transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: The system prompt of the call from `assistant.model.messages[type=system].content`
	Messages []map[string]interface{} `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines whether a summary is generated and stored in `call.analysis.summary`. Defaults to true.
	//
	// Usage:
	//
	// - If you want to disable the summary, set this to false.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is how long the request is tried before giving up. When request times out, `call.analysis.summary` will be empty.
	//
	// Usage:
	//
	// - To guarantee the summary is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.
	//
	// @default 5 seconds
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SummaryPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SummaryPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SummaryPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SummaryPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SummaryPlan) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncVoiceLibraryDto struct {
	// List of providers you want to sync.
	Providers []SyncVoiceLibraryDtoProvidersItem `json:"providers,omitempty" url:"providers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SyncVoiceLibraryDto) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SyncVoiceLibraryDto) UnmarshalJSON(data []byte) error {
	type unmarshaler SyncVoiceLibraryDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SyncVoiceLibraryDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncVoiceLibraryDto) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncVoiceLibraryDtoProvidersItem string

const (
	SyncVoiceLibraryDtoProvidersItemElevenLabs  SyncVoiceLibraryDtoProvidersItem = "11labs"
	SyncVoiceLibraryDtoProvidersItemAzure       SyncVoiceLibraryDtoProvidersItem = "azure"
	SyncVoiceLibraryDtoProvidersItemCartesia    SyncVoiceLibraryDtoProvidersItem = "cartesia"
	SyncVoiceLibraryDtoProvidersItemCustomVoice SyncVoiceLibraryDtoProvidersItem = "custom-voice"
	SyncVoiceLibraryDtoProvidersItemDeepgram    SyncVoiceLibraryDtoProvidersItem = "deepgram"
	SyncVoiceLibraryDtoProvidersItemLmnt        SyncVoiceLibraryDtoProvidersItem = "lmnt"
	SyncVoiceLibraryDtoProvidersItemNeets       SyncVoiceLibraryDtoProvidersItem = "neets"
	SyncVoiceLibraryDtoProvidersItemOpenai      SyncVoiceLibraryDtoProvidersItem = "openai"
	SyncVoiceLibraryDtoProvidersItemPlayht      SyncVoiceLibraryDtoProvidersItem = "playht"
	SyncVoiceLibraryDtoProvidersItemRimeAi      SyncVoiceLibraryDtoProvidersItem = "rime-ai"
)

func NewSyncVoiceLibraryDtoProvidersItemFromString(s string) (SyncVoiceLibraryDtoProvidersItem, error) {
	switch s {
	case "11labs":
		return SyncVoiceLibraryDtoProvidersItemElevenLabs, nil
	case "azure":
		return SyncVoiceLibraryDtoProvidersItemAzure, nil
	case "cartesia":
		return SyncVoiceLibraryDtoProvidersItemCartesia, nil
	case "custom-voice":
		return SyncVoiceLibraryDtoProvidersItemCustomVoice, nil
	case "deepgram":
		return SyncVoiceLibraryDtoProvidersItemDeepgram, nil
	case "lmnt":
		return SyncVoiceLibraryDtoProvidersItemLmnt, nil
	case "neets":
		return SyncVoiceLibraryDtoProvidersItemNeets, nil
	case "openai":
		return SyncVoiceLibraryDtoProvidersItemOpenai, nil
	case "playht":
		return SyncVoiceLibraryDtoProvidersItemPlayht, nil
	case "rime-ai":
		return SyncVoiceLibraryDtoProvidersItemRimeAi, nil
	}
	var t SyncVoiceLibraryDtoProvidersItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SyncVoiceLibraryDtoProvidersItem) Ptr() *SyncVoiceLibraryDtoProvidersItem {
	return &s
}

type SystemMessage struct {
	// The role of the system in the conversation.
	Role string `json:"role" url:"role"`
	// The message content from the system.
	Message string `json:"message" url:"message"`
	// The timestamp when the message was sent.
	Time float64 `json:"time" url:"time"`
	// The number of seconds from the start of the conversation.
	SecondsFromStart float64 `json:"secondsFromStart" url:"secondsFromStart"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SystemMessage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SystemMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler SystemMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SystemMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemMessage) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TalkscriberTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be set for the transcription. The list of languages Whisper supports can be found here: https://github.com/openai/whisper/blob/main/whisper/tokenizer.py
	Language *TalkscriberTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TalkscriberTranscriber) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TalkscriberTranscriber) Provider() string {
	return t.provider
}

func (t *TalkscriberTranscriber) UnmarshalJSON(data []byte) error {
	type embed TalkscriberTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TalkscriberTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "talkscriber" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "talkscriber", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TalkscriberTranscriber) MarshalJSON() ([]byte, error) {
	type embed TalkscriberTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "talkscriber",
	}
	return json.Marshal(marshaler)
}

func (t *TalkscriberTranscriber) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the language that will be set for the transcription. The list of languages Whisper supports can be found here: https://github.com/openai/whisper/blob/main/whisper/tokenizer.py
type TalkscriberTranscriberLanguage string

const (
	TalkscriberTranscriberLanguageEn  TalkscriberTranscriberLanguage = "en"
	TalkscriberTranscriberLanguageZh  TalkscriberTranscriberLanguage = "zh"
	TalkscriberTranscriberLanguageDe  TalkscriberTranscriberLanguage = "de"
	TalkscriberTranscriberLanguageEs  TalkscriberTranscriberLanguage = "es"
	TalkscriberTranscriberLanguageRu  TalkscriberTranscriberLanguage = "ru"
	TalkscriberTranscriberLanguageKo  TalkscriberTranscriberLanguage = "ko"
	TalkscriberTranscriberLanguageFr  TalkscriberTranscriberLanguage = "fr"
	TalkscriberTranscriberLanguageJa  TalkscriberTranscriberLanguage = "ja"
	TalkscriberTranscriberLanguagePt  TalkscriberTranscriberLanguage = "pt"
	TalkscriberTranscriberLanguageTr  TalkscriberTranscriberLanguage = "tr"
	TalkscriberTranscriberLanguagePl  TalkscriberTranscriberLanguage = "pl"
	TalkscriberTranscriberLanguageCa  TalkscriberTranscriberLanguage = "ca"
	TalkscriberTranscriberLanguageNl  TalkscriberTranscriberLanguage = "nl"
	TalkscriberTranscriberLanguageAr  TalkscriberTranscriberLanguage = "ar"
	TalkscriberTranscriberLanguageSv  TalkscriberTranscriberLanguage = "sv"
	TalkscriberTranscriberLanguageIt  TalkscriberTranscriberLanguage = "it"
	TalkscriberTranscriberLanguageId  TalkscriberTranscriberLanguage = "id"
	TalkscriberTranscriberLanguageHi  TalkscriberTranscriberLanguage = "hi"
	TalkscriberTranscriberLanguageFi  TalkscriberTranscriberLanguage = "fi"
	TalkscriberTranscriberLanguageVi  TalkscriberTranscriberLanguage = "vi"
	TalkscriberTranscriberLanguageHe  TalkscriberTranscriberLanguage = "he"
	TalkscriberTranscriberLanguageUk  TalkscriberTranscriberLanguage = "uk"
	TalkscriberTranscriberLanguageEl  TalkscriberTranscriberLanguage = "el"
	TalkscriberTranscriberLanguageMs  TalkscriberTranscriberLanguage = "ms"
	TalkscriberTranscriberLanguageCs  TalkscriberTranscriberLanguage = "cs"
	TalkscriberTranscriberLanguageRo  TalkscriberTranscriberLanguage = "ro"
	TalkscriberTranscriberLanguageDa  TalkscriberTranscriberLanguage = "da"
	TalkscriberTranscriberLanguageHu  TalkscriberTranscriberLanguage = "hu"
	TalkscriberTranscriberLanguageTa  TalkscriberTranscriberLanguage = "ta"
	TalkscriberTranscriberLanguageNo  TalkscriberTranscriberLanguage = "no"
	TalkscriberTranscriberLanguageTh  TalkscriberTranscriberLanguage = "th"
	TalkscriberTranscriberLanguageUr  TalkscriberTranscriberLanguage = "ur"
	TalkscriberTranscriberLanguageHr  TalkscriberTranscriberLanguage = "hr"
	TalkscriberTranscriberLanguageBg  TalkscriberTranscriberLanguage = "bg"
	TalkscriberTranscriberLanguageLt  TalkscriberTranscriberLanguage = "lt"
	TalkscriberTranscriberLanguageLa  TalkscriberTranscriberLanguage = "la"
	TalkscriberTranscriberLanguageMi  TalkscriberTranscriberLanguage = "mi"
	TalkscriberTranscriberLanguageMl  TalkscriberTranscriberLanguage = "ml"
	TalkscriberTranscriberLanguageCy  TalkscriberTranscriberLanguage = "cy"
	TalkscriberTranscriberLanguageSk  TalkscriberTranscriberLanguage = "sk"
	TalkscriberTranscriberLanguageTe  TalkscriberTranscriberLanguage = "te"
	TalkscriberTranscriberLanguageFa  TalkscriberTranscriberLanguage = "fa"
	TalkscriberTranscriberLanguageLv  TalkscriberTranscriberLanguage = "lv"
	TalkscriberTranscriberLanguageBn  TalkscriberTranscriberLanguage = "bn"
	TalkscriberTranscriberLanguageSr  TalkscriberTranscriberLanguage = "sr"
	TalkscriberTranscriberLanguageAz  TalkscriberTranscriberLanguage = "az"
	TalkscriberTranscriberLanguageSl  TalkscriberTranscriberLanguage = "sl"
	TalkscriberTranscriberLanguageKn  TalkscriberTranscriberLanguage = "kn"
	TalkscriberTranscriberLanguageEt  TalkscriberTranscriberLanguage = "et"
	TalkscriberTranscriberLanguageMk  TalkscriberTranscriberLanguage = "mk"
	TalkscriberTranscriberLanguageBr  TalkscriberTranscriberLanguage = "br"
	TalkscriberTranscriberLanguageEu  TalkscriberTranscriberLanguage = "eu"
	TalkscriberTranscriberLanguageIs  TalkscriberTranscriberLanguage = "is"
	TalkscriberTranscriberLanguageHy  TalkscriberTranscriberLanguage = "hy"
	TalkscriberTranscriberLanguageNe  TalkscriberTranscriberLanguage = "ne"
	TalkscriberTranscriberLanguageMn  TalkscriberTranscriberLanguage = "mn"
	TalkscriberTranscriberLanguageBs  TalkscriberTranscriberLanguage = "bs"
	TalkscriberTranscriberLanguageKk  TalkscriberTranscriberLanguage = "kk"
	TalkscriberTranscriberLanguageSq  TalkscriberTranscriberLanguage = "sq"
	TalkscriberTranscriberLanguageSw  TalkscriberTranscriberLanguage = "sw"
	TalkscriberTranscriberLanguageGl  TalkscriberTranscriberLanguage = "gl"
	TalkscriberTranscriberLanguageMr  TalkscriberTranscriberLanguage = "mr"
	TalkscriberTranscriberLanguagePa  TalkscriberTranscriberLanguage = "pa"
	TalkscriberTranscriberLanguageSi  TalkscriberTranscriberLanguage = "si"
	TalkscriberTranscriberLanguageKm  TalkscriberTranscriberLanguage = "km"
	TalkscriberTranscriberLanguageSn  TalkscriberTranscriberLanguage = "sn"
	TalkscriberTranscriberLanguageYo  TalkscriberTranscriberLanguage = "yo"
	TalkscriberTranscriberLanguageSo  TalkscriberTranscriberLanguage = "so"
	TalkscriberTranscriberLanguageAf  TalkscriberTranscriberLanguage = "af"
	TalkscriberTranscriberLanguageOc  TalkscriberTranscriberLanguage = "oc"
	TalkscriberTranscriberLanguageKa  TalkscriberTranscriberLanguage = "ka"
	TalkscriberTranscriberLanguageBe  TalkscriberTranscriberLanguage = "be"
	TalkscriberTranscriberLanguageTg  TalkscriberTranscriberLanguage = "tg"
	TalkscriberTranscriberLanguageSd  TalkscriberTranscriberLanguage = "sd"
	TalkscriberTranscriberLanguageGu  TalkscriberTranscriberLanguage = "gu"
	TalkscriberTranscriberLanguageAm  TalkscriberTranscriberLanguage = "am"
	TalkscriberTranscriberLanguageYi  TalkscriberTranscriberLanguage = "yi"
	TalkscriberTranscriberLanguageLo  TalkscriberTranscriberLanguage = "lo"
	TalkscriberTranscriberLanguageUz  TalkscriberTranscriberLanguage = "uz"
	TalkscriberTranscriberLanguageFo  TalkscriberTranscriberLanguage = "fo"
	TalkscriberTranscriberLanguageHt  TalkscriberTranscriberLanguage = "ht"
	TalkscriberTranscriberLanguagePs  TalkscriberTranscriberLanguage = "ps"
	TalkscriberTranscriberLanguageTk  TalkscriberTranscriberLanguage = "tk"
	TalkscriberTranscriberLanguageNn  TalkscriberTranscriberLanguage = "nn"
	TalkscriberTranscriberLanguageMt  TalkscriberTranscriberLanguage = "mt"
	TalkscriberTranscriberLanguageSa  TalkscriberTranscriberLanguage = "sa"
	TalkscriberTranscriberLanguageLb  TalkscriberTranscriberLanguage = "lb"
	TalkscriberTranscriberLanguageMy  TalkscriberTranscriberLanguage = "my"
	TalkscriberTranscriberLanguageBo  TalkscriberTranscriberLanguage = "bo"
	TalkscriberTranscriberLanguageTl  TalkscriberTranscriberLanguage = "tl"
	TalkscriberTranscriberLanguageMg  TalkscriberTranscriberLanguage = "mg"
	TalkscriberTranscriberLanguageAs  TalkscriberTranscriberLanguage = "as"
	TalkscriberTranscriberLanguageTt  TalkscriberTranscriberLanguage = "tt"
	TalkscriberTranscriberLanguageHaw TalkscriberTranscriberLanguage = "haw"
	TalkscriberTranscriberLanguageLn  TalkscriberTranscriberLanguage = "ln"
	TalkscriberTranscriberLanguageHa  TalkscriberTranscriberLanguage = "ha"
	TalkscriberTranscriberLanguageBa  TalkscriberTranscriberLanguage = "ba"
	TalkscriberTranscriberLanguageJw  TalkscriberTranscriberLanguage = "jw"
	TalkscriberTranscriberLanguageSu  TalkscriberTranscriberLanguage = "su"
	TalkscriberTranscriberLanguageYue TalkscriberTranscriberLanguage = "yue"
)

func NewTalkscriberTranscriberLanguageFromString(s string) (TalkscriberTranscriberLanguage, error) {
	switch s {
	case "en":
		return TalkscriberTranscriberLanguageEn, nil
	case "zh":
		return TalkscriberTranscriberLanguageZh, nil
	case "de":
		return TalkscriberTranscriberLanguageDe, nil
	case "es":
		return TalkscriberTranscriberLanguageEs, nil
	case "ru":
		return TalkscriberTranscriberLanguageRu, nil
	case "ko":
		return TalkscriberTranscriberLanguageKo, nil
	case "fr":
		return TalkscriberTranscriberLanguageFr, nil
	case "ja":
		return TalkscriberTranscriberLanguageJa, nil
	case "pt":
		return TalkscriberTranscriberLanguagePt, nil
	case "tr":
		return TalkscriberTranscriberLanguageTr, nil
	case "pl":
		return TalkscriberTranscriberLanguagePl, nil
	case "ca":
		return TalkscriberTranscriberLanguageCa, nil
	case "nl":
		return TalkscriberTranscriberLanguageNl, nil
	case "ar":
		return TalkscriberTranscriberLanguageAr, nil
	case "sv":
		return TalkscriberTranscriberLanguageSv, nil
	case "it":
		return TalkscriberTranscriberLanguageIt, nil
	case "id":
		return TalkscriberTranscriberLanguageId, nil
	case "hi":
		return TalkscriberTranscriberLanguageHi, nil
	case "fi":
		return TalkscriberTranscriberLanguageFi, nil
	case "vi":
		return TalkscriberTranscriberLanguageVi, nil
	case "he":
		return TalkscriberTranscriberLanguageHe, nil
	case "uk":
		return TalkscriberTranscriberLanguageUk, nil
	case "el":
		return TalkscriberTranscriberLanguageEl, nil
	case "ms":
		return TalkscriberTranscriberLanguageMs, nil
	case "cs":
		return TalkscriberTranscriberLanguageCs, nil
	case "ro":
		return TalkscriberTranscriberLanguageRo, nil
	case "da":
		return TalkscriberTranscriberLanguageDa, nil
	case "hu":
		return TalkscriberTranscriberLanguageHu, nil
	case "ta":
		return TalkscriberTranscriberLanguageTa, nil
	case "no":
		return TalkscriberTranscriberLanguageNo, nil
	case "th":
		return TalkscriberTranscriberLanguageTh, nil
	case "ur":
		return TalkscriberTranscriberLanguageUr, nil
	case "hr":
		return TalkscriberTranscriberLanguageHr, nil
	case "bg":
		return TalkscriberTranscriberLanguageBg, nil
	case "lt":
		return TalkscriberTranscriberLanguageLt, nil
	case "la":
		return TalkscriberTranscriberLanguageLa, nil
	case "mi":
		return TalkscriberTranscriberLanguageMi, nil
	case "ml":
		return TalkscriberTranscriberLanguageMl, nil
	case "cy":
		return TalkscriberTranscriberLanguageCy, nil
	case "sk":
		return TalkscriberTranscriberLanguageSk, nil
	case "te":
		return TalkscriberTranscriberLanguageTe, nil
	case "fa":
		return TalkscriberTranscriberLanguageFa, nil
	case "lv":
		return TalkscriberTranscriberLanguageLv, nil
	case "bn":
		return TalkscriberTranscriberLanguageBn, nil
	case "sr":
		return TalkscriberTranscriberLanguageSr, nil
	case "az":
		return TalkscriberTranscriberLanguageAz, nil
	case "sl":
		return TalkscriberTranscriberLanguageSl, nil
	case "kn":
		return TalkscriberTranscriberLanguageKn, nil
	case "et":
		return TalkscriberTranscriberLanguageEt, nil
	case "mk":
		return TalkscriberTranscriberLanguageMk, nil
	case "br":
		return TalkscriberTranscriberLanguageBr, nil
	case "eu":
		return TalkscriberTranscriberLanguageEu, nil
	case "is":
		return TalkscriberTranscriberLanguageIs, nil
	case "hy":
		return TalkscriberTranscriberLanguageHy, nil
	case "ne":
		return TalkscriberTranscriberLanguageNe, nil
	case "mn":
		return TalkscriberTranscriberLanguageMn, nil
	case "bs":
		return TalkscriberTranscriberLanguageBs, nil
	case "kk":
		return TalkscriberTranscriberLanguageKk, nil
	case "sq":
		return TalkscriberTranscriberLanguageSq, nil
	case "sw":
		return TalkscriberTranscriberLanguageSw, nil
	case "gl":
		return TalkscriberTranscriberLanguageGl, nil
	case "mr":
		return TalkscriberTranscriberLanguageMr, nil
	case "pa":
		return TalkscriberTranscriberLanguagePa, nil
	case "si":
		return TalkscriberTranscriberLanguageSi, nil
	case "km":
		return TalkscriberTranscriberLanguageKm, nil
	case "sn":
		return TalkscriberTranscriberLanguageSn, nil
	case "yo":
		return TalkscriberTranscriberLanguageYo, nil
	case "so":
		return TalkscriberTranscriberLanguageSo, nil
	case "af":
		return TalkscriberTranscriberLanguageAf, nil
	case "oc":
		return TalkscriberTranscriberLanguageOc, nil
	case "ka":
		return TalkscriberTranscriberLanguageKa, nil
	case "be":
		return TalkscriberTranscriberLanguageBe, nil
	case "tg":
		return TalkscriberTranscriberLanguageTg, nil
	case "sd":
		return TalkscriberTranscriberLanguageSd, nil
	case "gu":
		return TalkscriberTranscriberLanguageGu, nil
	case "am":
		return TalkscriberTranscriberLanguageAm, nil
	case "yi":
		return TalkscriberTranscriberLanguageYi, nil
	case "lo":
		return TalkscriberTranscriberLanguageLo, nil
	case "uz":
		return TalkscriberTranscriberLanguageUz, nil
	case "fo":
		return TalkscriberTranscriberLanguageFo, nil
	case "ht":
		return TalkscriberTranscriberLanguageHt, nil
	case "ps":
		return TalkscriberTranscriberLanguagePs, nil
	case "tk":
		return TalkscriberTranscriberLanguageTk, nil
	case "nn":
		return TalkscriberTranscriberLanguageNn, nil
	case "mt":
		return TalkscriberTranscriberLanguageMt, nil
	case "sa":
		return TalkscriberTranscriberLanguageSa, nil
	case "lb":
		return TalkscriberTranscriberLanguageLb, nil
	case "my":
		return TalkscriberTranscriberLanguageMy, nil
	case "bo":
		return TalkscriberTranscriberLanguageBo, nil
	case "tl":
		return TalkscriberTranscriberLanguageTl, nil
	case "mg":
		return TalkscriberTranscriberLanguageMg, nil
	case "as":
		return TalkscriberTranscriberLanguageAs, nil
	case "tt":
		return TalkscriberTranscriberLanguageTt, nil
	case "haw":
		return TalkscriberTranscriberLanguageHaw, nil
	case "ln":
		return TalkscriberTranscriberLanguageLn, nil
	case "ha":
		return TalkscriberTranscriberLanguageHa, nil
	case "ba":
		return TalkscriberTranscriberLanguageBa, nil
	case "jw":
		return TalkscriberTranscriberLanguageJw, nil
	case "su":
		return TalkscriberTranscriberLanguageSu, nil
	case "yue":
		return TalkscriberTranscriberLanguageYue, nil
	}
	var t TalkscriberTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TalkscriberTranscriberLanguage) Ptr() *TalkscriberTranscriberLanguage {
	return &t
}

type Template struct {
	Details         *TemplateDetails         `json:"details,omitempty" url:"details,omitempty"`
	ProviderDetails *TemplateProviderDetails `json:"providerDetails,omitempty" url:"providerDetails,omitempty"`
	Metadata        *ToolTemplateMetadata    `json:"metadata,omitempty" url:"metadata,omitempty"`
	Visibility      *TemplateVisibility      `json:"visibility,omitempty" url:"visibility,omitempty"`
	// The name of the template. This is just for your own reference.
	Name     *string           `json:"name,omitempty" url:"name,omitempty"`
	Provider *TemplateProvider `json:"provider,omitempty" url:"provider,omitempty"`
	// The unique identifier for the template.
	Id string `json:"id" url:"id"`
	// The unique identifier for the organization that this template belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// The ISO 8601 date-time string of when the template was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The ISO 8601 date-time string of when the template was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	type_     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Template) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Template) Type() string {
	return t.type_
}

func (t *Template) UnmarshalJSON(data []byte) error {
	type embed Template
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Template(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "tool", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Template) MarshalJSON() ([]byte, error) {
	type embed Template
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
		UpdatedAt: core.NewDateTime(t.UpdatedAt),
		Type:      "tool",
	}
	return json.Marshal(marshaler)
}

func (t *Template) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TemplateDetails struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (t *TemplateDetails) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		t.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		t.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		t.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		t.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		t.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		t.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		t.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TemplateDetails) MarshalJSON() ([]byte, error) {
	if t.CreateDtmfToolDto != nil {
		return json.Marshal(t.CreateDtmfToolDto)
	}
	if t.CreateEndCallToolDto != nil {
		return json.Marshal(t.CreateEndCallToolDto)
	}
	if t.CreateVoicemailToolDto != nil {
		return json.Marshal(t.CreateVoicemailToolDto)
	}
	if t.CreateFunctionToolDto != nil {
		return json.Marshal(t.CreateFunctionToolDto)
	}
	if t.CreateGhlToolDto != nil {
		return json.Marshal(t.CreateGhlToolDto)
	}
	if t.CreateMakeToolDto != nil {
		return json.Marshal(t.CreateMakeToolDto)
	}
	if t.CreateTransferCallToolDto != nil {
		return json.Marshal(t.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateDetailsVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (t *TemplateDetails) Accept(visitor TemplateDetailsVisitor) error {
	if t.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(t.CreateDtmfToolDto)
	}
	if t.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(t.CreateEndCallToolDto)
	}
	if t.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(t.CreateVoicemailToolDto)
	}
	if t.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(t.CreateFunctionToolDto)
	}
	if t.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(t.CreateGhlToolDto)
	}
	if t.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(t.CreateMakeToolDto)
	}
	if t.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(t.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateProvider string

const (
	TemplateProviderMake        TemplateProvider = "make"
	TemplateProviderGohighlevel TemplateProvider = "gohighlevel"
	TemplateProviderFunction    TemplateProvider = "function"
)

func NewTemplateProviderFromString(s string) (TemplateProvider, error) {
	switch s {
	case "make":
		return TemplateProviderMake, nil
	case "gohighlevel":
		return TemplateProviderGohighlevel, nil
	case "function":
		return TemplateProviderFunction, nil
	}
	var t TemplateProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TemplateProvider) Ptr() *TemplateProvider {
	return &t
}

type TemplateProviderDetails struct {
	MakeToolProviderDetails     *MakeToolProviderDetails
	GhlToolProviderDetails      *GhlToolProviderDetails
	FunctionToolProviderDetails *FunctionToolProviderDetails
}

func (t *TemplateProviderDetails) UnmarshalJSON(data []byte) error {
	valueMakeToolProviderDetails := new(MakeToolProviderDetails)
	if err := json.Unmarshal(data, &valueMakeToolProviderDetails); err == nil {
		t.MakeToolProviderDetails = valueMakeToolProviderDetails
		return nil
	}
	valueGhlToolProviderDetails := new(GhlToolProviderDetails)
	if err := json.Unmarshal(data, &valueGhlToolProviderDetails); err == nil {
		t.GhlToolProviderDetails = valueGhlToolProviderDetails
		return nil
	}
	valueFunctionToolProviderDetails := new(FunctionToolProviderDetails)
	if err := json.Unmarshal(data, &valueFunctionToolProviderDetails); err == nil {
		t.FunctionToolProviderDetails = valueFunctionToolProviderDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TemplateProviderDetails) MarshalJSON() ([]byte, error) {
	if t.MakeToolProviderDetails != nil {
		return json.Marshal(t.MakeToolProviderDetails)
	}
	if t.GhlToolProviderDetails != nil {
		return json.Marshal(t.GhlToolProviderDetails)
	}
	if t.FunctionToolProviderDetails != nil {
		return json.Marshal(t.FunctionToolProviderDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateProviderDetailsVisitor interface {
	VisitMakeToolProviderDetails(*MakeToolProviderDetails) error
	VisitGhlToolProviderDetails(*GhlToolProviderDetails) error
	VisitFunctionToolProviderDetails(*FunctionToolProviderDetails) error
}

func (t *TemplateProviderDetails) Accept(visitor TemplateProviderDetailsVisitor) error {
	if t.MakeToolProviderDetails != nil {
		return visitor.VisitMakeToolProviderDetails(t.MakeToolProviderDetails)
	}
	if t.GhlToolProviderDetails != nil {
		return visitor.VisitGhlToolProviderDetails(t.GhlToolProviderDetails)
	}
	if t.FunctionToolProviderDetails != nil {
		return visitor.VisitFunctionToolProviderDetails(t.FunctionToolProviderDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateVisibility string

const (
	TemplateVisibilityPublic  TemplateVisibility = "public"
	TemplateVisibilityPrivate TemplateVisibility = "private"
)

func NewTemplateVisibilityFromString(s string) (TemplateVisibility, error) {
	switch s {
	case "public":
		return TemplateVisibilityPublic, nil
	case "private":
		return TemplateVisibilityPrivate, nil
	}
	var t TemplateVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TemplateVisibility) Ptr() *TemplateVisibility {
	return &t
}

type TimeRange struct {
	// This is the time step for aggregations.
	//
	// If not provided, defaults to returning for the entire time range.
	Step *TimeRangeStep `json:"step,omitempty" url:"step,omitempty"`
	// This is the start date for the time range.
	//
	// If not provided, defaults to the 7 days ago.
	Start *time.Time `json:"start,omitempty" url:"start,omitempty"`
	// This is the end date for the time range.
	//
	// If not provided, defaults to now.
	End *time.Time `json:"end,omitempty" url:"end,omitempty"`
	// This is the timezone you want to set for the query.
	//
	// If not provided, defaults to UTC.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeRange) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeRange) UnmarshalJSON(data []byte) error {
	type embed TimeRange
	var unmarshaler = struct {
		embed
		Start *core.DateTime `json:"start,omitempty"`
		End   *core.DateTime `json:"end,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TimeRange(unmarshaler.embed)
	t.Start = unmarshaler.Start.TimePtr()
	t.End = unmarshaler.End.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeRange) MarshalJSON() ([]byte, error) {
	type embed TimeRange
	var marshaler = struct {
		embed
		Start *core.DateTime `json:"start,omitempty"`
		End   *core.DateTime `json:"end,omitempty"`
	}{
		embed: embed(*t),
		Start: core.NewOptionalDateTime(t.Start),
		End:   core.NewOptionalDateTime(t.End),
	}
	return json.Marshal(marshaler)
}

func (t *TimeRange) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the time step for aggregations.
//
// If not provided, defaults to returning for the entire time range.
type TimeRangeStep string

const (
	TimeRangeStepMinute     TimeRangeStep = "minute"
	TimeRangeStepHour       TimeRangeStep = "hour"
	TimeRangeStepDay        TimeRangeStep = "day"
	TimeRangeStepWeek       TimeRangeStep = "week"
	TimeRangeStepMonth      TimeRangeStep = "month"
	TimeRangeStepQuarter    TimeRangeStep = "quarter"
	TimeRangeStepYear       TimeRangeStep = "year"
	TimeRangeStepDecade     TimeRangeStep = "decade"
	TimeRangeStepCentury    TimeRangeStep = "century"
	TimeRangeStepMillennium TimeRangeStep = "millennium"
)

func NewTimeRangeStepFromString(s string) (TimeRangeStep, error) {
	switch s {
	case "minute":
		return TimeRangeStepMinute, nil
	case "hour":
		return TimeRangeStepHour, nil
	case "day":
		return TimeRangeStepDay, nil
	case "week":
		return TimeRangeStepWeek, nil
	case "month":
		return TimeRangeStepMonth, nil
	case "quarter":
		return TimeRangeStepQuarter, nil
	case "year":
		return TimeRangeStepYear, nil
	case "decade":
		return TimeRangeStepDecade, nil
	case "century":
		return TimeRangeStepCentury, nil
	case "millennium":
		return TimeRangeStepMillennium, nil
	}
	var t TimeRangeStep
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeRangeStep) Ptr() *TimeRangeStep {
	return &t
}

type TogetherAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TogetherAiCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TogetherAiCredential) Provider() string {
	return t.provider
}

func (t *TogetherAiCredential) UnmarshalJSON(data []byte) error {
	type embed TogetherAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TogetherAiCredential(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "together-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "together-ai", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TogetherAiCredential) MarshalJSON() ([]byte, error) {
	type embed TogetherAiCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
		UpdatedAt: core.NewDateTime(t.UpdatedAt),
		Provider:  "together-ai",
	}
	return json.Marshal(marshaler)
}

func (t *TogetherAiCredential) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TogetherAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*TogetherAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *KnowledgeBase `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TogetherAiModel) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TogetherAiModel) Provider() string {
	return t.provider
}

func (t *TogetherAiModel) UnmarshalJSON(data []byte) error {
	type embed TogetherAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TogetherAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "together-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "together-ai", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TogetherAiModel) MarshalJSON() ([]byte, error) {
	type embed TogetherAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "together-ai",
	}
	return json.Marshal(marshaler)
}

func (t *TogetherAiModel) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TogetherAiModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (t *TogetherAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		t.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		t.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		t.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		t.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		t.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		t.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		t.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TogetherAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if t.CreateDtmfToolDto != nil {
		return json.Marshal(t.CreateDtmfToolDto)
	}
	if t.CreateEndCallToolDto != nil {
		return json.Marshal(t.CreateEndCallToolDto)
	}
	if t.CreateVoicemailToolDto != nil {
		return json.Marshal(t.CreateVoicemailToolDto)
	}
	if t.CreateFunctionToolDto != nil {
		return json.Marshal(t.CreateFunctionToolDto)
	}
	if t.CreateGhlToolDto != nil {
		return json.Marshal(t.CreateGhlToolDto)
	}
	if t.CreateMakeToolDto != nil {
		return json.Marshal(t.CreateMakeToolDto)
	}
	if t.CreateTransferCallToolDto != nil {
		return json.Marshal(t.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TogetherAiModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (t *TogetherAiModelToolsItem) Accept(visitor TogetherAiModelToolsItemVisitor) error {
	if t.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(t.CreateDtmfToolDto)
	}
	if t.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(t.CreateEndCallToolDto)
	}
	if t.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(t.CreateVoicemailToolDto)
	}
	if t.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(t.CreateFunctionToolDto)
	}
	if t.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(t.CreateGhlToolDto)
	}
	if t.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(t.CreateMakeToolDto)
	}
	if t.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(t.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type Token struct {
	// This is the tag for the token. It represents its scope.
	Tag *TokenTag `json:"tag,omitempty" url:"tag,omitempty"`
	// This is the unique identifier for the token.
	Id string `json:"id" url:"id"`
	// This is unique identifier for the org that this token belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the token was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the token was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the token key.
	Value string `json:"value" url:"value"`
	// This is the name of the token. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This are the restrictions for the token.
	Restrictions *TokenRestrictions `json:"restrictions,omitempty" url:"restrictions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Token) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Token) UnmarshalJSON(data []byte) error {
	type embed Token
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Token(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Token) MarshalJSON() ([]byte, error) {
	type embed Token
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
		UpdatedAt: core.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *Token) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenRestrictions struct {
	// This determines whether the token is enabled or disabled. Default is true, it's enabled.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This determines the allowed origins for this token. Validates the `Origin` header. Default is any origin.
	//
	// Only relevant for `public` tokens.
	AllowedOrigins []string `json:"allowedOrigins,omitempty" url:"allowedOrigins,omitempty"`
	// This determines which assistantIds can be used when creating a call. Default is any assistantId.
	//
	// Only relevant for `public` tokens.
	AllowedAssistantIds []string `json:"allowedAssistantIds,omitempty" url:"allowedAssistantIds,omitempty"`
	// This determines whether transient assistants can be used when creating a call. Default is true.
	//
	// If `allowedAssistantIds` is provided, this is automatically false.
	//
	// Only relevant for `public` tokens.
	AllowTransientAssistant *bool `json:"allowTransientAssistant,omitempty" url:"allowTransientAssistant,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenRestrictions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenRestrictions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenRestrictions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenRestrictions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenRestrictions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the tag for the token. It represents its scope.
type TokenTag string

const (
	TokenTagPrivate TokenTag = "private"
	TokenTagPublic  TokenTag = "public"
)

func NewTokenTagFromString(s string) (TokenTag, error) {
	switch s {
	case "private":
		return TokenTagPrivate, nil
	case "public":
		return TokenTagPublic, nil
	}
	var t TokenTag
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokenTag) Ptr() *TokenTag {
	return &t
}

type ToolCall struct {
	// This is the type of tool the model called.
	// This is the function the model called.
	Function *ToolCallFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the unique identifier for the tool call.
	Id    string `json:"id" url:"id"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolCall) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCall) Type() string {
	return t.type_
}

func (t *ToolCall) UnmarshalJSON(data []byte) error {
	type embed ToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolCall(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "function", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCall) MarshalJSON() ([]byte, error) {
	type embed ToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (t *ToolCall) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallBlock struct {
	// These are the pre-configured messages that will be spoken to the user while the block is running.
	Messages []*ToolCallBlockMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the input schema for the block. This is the input the block needs to run. It's given to the block as `steps[0].input`
	//
	// These are accessible as variables:
	//
	// - ({{input.propertyName}}) in context of the block execution (step)
	// - ({{stepName.input.propertyName}}) in context of the workflow
	InputSchema *JsonSchema `json:"inputSchema,omitempty" url:"inputSchema,omitempty"`
	// This is the output schema for the block. This is the output the block will return to the workflow (`{{stepName.output}}`).
	//
	// These are accessible as variables:
	//
	// - ({{output.propertyName}}) in context of the block execution (step)
	// - ({{stepName.output.propertyName}}) in context of the workflow (read caveat #1)
	// - ({{blockName.output.propertyName}}) in context of the workflow (read caveat #2)
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	OutputSchema *JsonSchema `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	// This is the tool that the block will call. To use an existing tool, use `toolId`.
	Tool *ToolCallBlockTool `json:"tool,omitempty" url:"tool,omitempty"`
	// This is the unique identifier for the block.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this block belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the block was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the block was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of the block. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the id of the tool that the block will call. To use a transient tool, use `tool`.
	ToolId *string `json:"toolId,omitempty" url:"toolId,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolCallBlock) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallBlock) Type() string {
	return t.type_
}

func (t *ToolCallBlock) UnmarshalJSON(data []byte) error {
	type embed ToolCallBlock
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolCallBlock(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "tool-call" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "tool-call", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallBlock) MarshalJSON() ([]byte, error) {
	type embed ToolCallBlock
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
		UpdatedAt: core.NewDateTime(t.UpdatedAt),
		Type:      "tool-call",
	}
	return json.Marshal(marshaler)
}

func (t *ToolCallBlock) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallBlockMessagesItem struct {
	BlockStartMessage    *BlockStartMessage
	BlockCompleteMessage *BlockCompleteMessage
}

func (t *ToolCallBlockMessagesItem) UnmarshalJSON(data []byte) error {
	valueBlockStartMessage := new(BlockStartMessage)
	if err := json.Unmarshal(data, &valueBlockStartMessage); err == nil {
		t.BlockStartMessage = valueBlockStartMessage
		return nil
	}
	valueBlockCompleteMessage := new(BlockCompleteMessage)
	if err := json.Unmarshal(data, &valueBlockCompleteMessage); err == nil {
		t.BlockCompleteMessage = valueBlockCompleteMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolCallBlockMessagesItem) MarshalJSON() ([]byte, error) {
	if t.BlockStartMessage != nil {
		return json.Marshal(t.BlockStartMessage)
	}
	if t.BlockCompleteMessage != nil {
		return json.Marshal(t.BlockCompleteMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolCallBlockMessagesItemVisitor interface {
	VisitBlockStartMessage(*BlockStartMessage) error
	VisitBlockCompleteMessage(*BlockCompleteMessage) error
}

func (t *ToolCallBlockMessagesItem) Accept(visitor ToolCallBlockMessagesItemVisitor) error {
	if t.BlockStartMessage != nil {
		return visitor.VisitBlockStartMessage(t.BlockStartMessage)
	}
	if t.BlockCompleteMessage != nil {
		return visitor.VisitBlockCompleteMessage(t.BlockCompleteMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// This is the tool that the block will call. To use an existing tool, use `toolId`.
type ToolCallBlockTool struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (t *ToolCallBlockTool) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		t.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		t.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		t.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		t.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		t.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		t.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		t.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolCallBlockTool) MarshalJSON() ([]byte, error) {
	if t.CreateDtmfToolDto != nil {
		return json.Marshal(t.CreateDtmfToolDto)
	}
	if t.CreateEndCallToolDto != nil {
		return json.Marshal(t.CreateEndCallToolDto)
	}
	if t.CreateVoicemailToolDto != nil {
		return json.Marshal(t.CreateVoicemailToolDto)
	}
	if t.CreateFunctionToolDto != nil {
		return json.Marshal(t.CreateFunctionToolDto)
	}
	if t.CreateGhlToolDto != nil {
		return json.Marshal(t.CreateGhlToolDto)
	}
	if t.CreateMakeToolDto != nil {
		return json.Marshal(t.CreateMakeToolDto)
	}
	if t.CreateTransferCallToolDto != nil {
		return json.Marshal(t.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolCallBlockToolVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (t *ToolCallBlockTool) Accept(visitor ToolCallBlockToolVisitor) error {
	if t.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(t.CreateDtmfToolDto)
	}
	if t.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(t.CreateEndCallToolDto)
	}
	if t.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(t.CreateVoicemailToolDto)
	}
	if t.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(t.CreateFunctionToolDto)
	}
	if t.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(t.CreateGhlToolDto)
	}
	if t.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(t.CreateMakeToolDto)
	}
	if t.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(t.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolCallFunction struct {
	// This is the name of the function the model called.
	Name string `json:"name" url:"name"`
	// These are the arguments that the function was called with.
	Arguments map[string]interface{} `json:"arguments,omitempty" url:"arguments,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolCallFunction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallFunction) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallFunction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallFunction(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallFunction) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallMessage struct {
	// The role of the tool call in the conversation.
	Role string `json:"role" url:"role"`
	// The list of tool calls made during the conversation.
	ToolCalls []map[string]interface{} `json:"toolCalls,omitempty" url:"toolCalls,omitempty"`
	// The message content for the tool call.
	Message string `json:"message" url:"message"`
	// The timestamp when the message was sent.
	Time float64 `json:"time" url:"time"`
	// The number of seconds from the start of the conversation.
	SecondsFromStart float64 `json:"secondsFromStart" url:"secondsFromStart"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolCallMessage) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallMessage) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallResult struct {
	// This is the message that will be spoken to the user.
	//
	// If this is not returned, assistant will speak:
	//
	// 1. a `request-complete` or `request-failed` message from `tool.messages`, if it exists
	// 2. a response generated by the model, if not
	Message []*ToolCallResultMessageItem `json:"message,omitempty" url:"message,omitempty"`
	// This is the name of the function the model called.
	Name string `json:"name" url:"name"`
	// This is the unique identifier for the tool call.
	ToolCallId string `json:"toolCallId" url:"toolCallId"`
	// This is the result if the tool call was successful. This is added to the conversation history.
	//
	// Further, if this is returned, assistant will speak:
	//
	// 1. the `message`, if it exists and is of type `request-complete`
	// 2. a `request-complete` message from `tool.messages`, if it exists
	// 3. a response generated by the model, if neither exist
	Result *string `json:"result,omitempty" url:"result,omitempty"`
	// This is the error if the tool call was not successful. This is added to the conversation history.
	//
	// Further, if this is returned, assistant will speak:
	//
	// 1. the `message`, if it exists and is of type `request-failed`
	// 2. a `request-failed` message from `tool.messages`, if it exists
	// 3. a response generated by the model, if neither exist
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolCallResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallResult) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallResultMessage struct {
	// The role of the tool call result in the conversation.
	Role string `json:"role" url:"role"`
	// The ID of the tool call.
	ToolCallId string `json:"toolCallId" url:"toolCallId"`
	// The name of the tool that returned the result.
	Name string `json:"name" url:"name"`
	// The result of the tool call in JSON format.
	Result string `json:"result" url:"result"`
	// The timestamp when the message was sent.
	Time float64 `json:"time" url:"time"`
	// The number of seconds from the start of the conversation.
	SecondsFromStart float64 `json:"secondsFromStart" url:"secondsFromStart"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolCallResultMessage) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallResultMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallResultMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallResultMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallResultMessage) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallResultMessageItem struct {
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
}

func (t *ToolCallResultMessageItem) UnmarshalJSON(data []byte) error {
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		t.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		t.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolCallResultMessageItem) MarshalJSON() ([]byte, error) {
	if t.ToolMessageComplete != nil {
		return json.Marshal(t.ToolMessageComplete)
	}
	if t.ToolMessageFailed != nil {
		return json.Marshal(t.ToolMessageFailed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolCallResultMessageItemVisitor interface {
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
}

func (t *ToolCallResultMessageItem) Accept(visitor ToolCallResultMessageItemVisitor) error {
	if t.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(t.ToolMessageComplete)
	}
	if t.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(t.ToolMessageFailed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolMessageComplete struct {
	// This message is triggered when the tool call is complete.
	//
	// This message is triggered immediately without waiting for your server to respond for async tool calls.
	//
	// If this message is not provided, the model will be requested to respond.
	//
	// If this message is provided, only this message will be spoken and the model will not be requested to come up with a response. It's an exclusive OR.
	// This is optional and defaults to "assistant".
	//
	// When role=assistant, `content` is said out loud.
	//
	// When role=system, `content` is passed to the model in a system message. Example:
	// system: default one
	// assistant:
	// user:
	// assistant:
	// user:
	// assistant:
	// user:
	// assistant: tool called
	// tool: your server response
	// <--- system prompt as hint
	// ---> model generates response which is spoken
	// This is useful when you want to provide a hint to the model about what to say next.
	Role *ToolMessageCompleteRole `json:"role,omitempty" url:"role,omitempty"`
	// This is an optional boolean that if true, the call will end after the message is spoken. Default is false.
	//
	// This is ignored if `role` is set to `system`.
	//
	// @default false
	EndCallAfterSpokenEnabled *bool `json:"endCallAfterSpokenEnabled,omitempty" url:"endCallAfterSpokenEnabled,omitempty"`
	// This is the content that the assistant says when this message is triggered.
	Content string `json:"content" url:"content"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolMessageComplete) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageComplete) Type() string {
	return t.type_
}

func (t *ToolMessageComplete) UnmarshalJSON(data []byte) error {
	type embed ToolMessageComplete
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageComplete(unmarshaler.embed)
	if unmarshaler.Type != "request-complete" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-complete", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageComplete) MarshalJSON() ([]byte, error) {
	type embed ToolMessageComplete
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-complete",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageComplete) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is optional and defaults to "assistant".
//
// When role=assistant, `content` is said out loud.
//
// When role=system, `content` is passed to the model in a system message. Example:
// system: default one
// assistant:
// user:
// assistant:
// user:
// assistant:
// user:
// assistant: tool called
// tool: your server response
// <--- system prompt as hint
// ---> model generates response which is spoken
// This is useful when you want to provide a hint to the model about what to say next.
type ToolMessageCompleteRole string

const (
	ToolMessageCompleteRoleAssistant ToolMessageCompleteRole = "assistant"
	ToolMessageCompleteRoleSystem    ToolMessageCompleteRole = "system"
)

func NewToolMessageCompleteRoleFromString(s string) (ToolMessageCompleteRole, error) {
	switch s {
	case "assistant":
		return ToolMessageCompleteRoleAssistant, nil
	case "system":
		return ToolMessageCompleteRoleSystem, nil
	}
	var t ToolMessageCompleteRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t ToolMessageCompleteRole) Ptr() *ToolMessageCompleteRole {
	return &t
}

type ToolMessageDelayed struct {
	// This message is triggered when the tool call is delayed.
	//
	// There are the two things that can trigger this message:
	//
	// 1. The user talks with the assistant while your server is processing the request. Default is "Sorry, a few more seconds."
	// 2. The server doesn't respond within `timingMilliseconds`.
	//
	// This message is never triggered for async tool calls.
	// The number of milliseconds to wait for the server response before saying this message.
	TimingMilliseconds *float64 `json:"timingMilliseconds,omitempty" url:"timingMilliseconds,omitempty"`
	// This is the content that the assistant says when this message is triggered.
	Content string `json:"content" url:"content"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolMessageDelayed) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageDelayed) Type() string {
	return t.type_
}

func (t *ToolMessageDelayed) UnmarshalJSON(data []byte) error {
	type embed ToolMessageDelayed
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageDelayed(unmarshaler.embed)
	if unmarshaler.Type != "request-response-delayed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-response-delayed", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageDelayed) MarshalJSON() ([]byte, error) {
	type embed ToolMessageDelayed
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-response-delayed",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageDelayed) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolMessageFailed struct {
	// This message is triggered when the tool call fails.
	//
	// This message is never triggered for async tool calls.
	//
	// If this message is not provided, the model will be requested to respond.
	//
	// If this message is provided, only this message will be spoken and the model will not be requested to come up with a response. It's an exclusive OR.
	// This is an optional boolean that if true, the call will end after the message is spoken. Default is false.
	//
	// @default false
	EndCallAfterSpokenEnabled *bool `json:"endCallAfterSpokenEnabled,omitempty" url:"endCallAfterSpokenEnabled,omitempty"`
	// This is the content that the assistant says when this message is triggered.
	Content string `json:"content" url:"content"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolMessageFailed) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageFailed) Type() string {
	return t.type_
}

func (t *ToolMessageFailed) UnmarshalJSON(data []byte) error {
	type embed ToolMessageFailed
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageFailed(unmarshaler.embed)
	if unmarshaler.Type != "request-failed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-failed", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageFailed) MarshalJSON() ([]byte, error) {
	type embed ToolMessageFailed
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-failed",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageFailed) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolMessageStart struct {
	// This message is triggered when the tool call starts.
	//
	// This message is never triggered for async tools.
	//
	// If this message is not provided, one of the default filler messages "Hold on a sec", "One moment", "Just a sec", "Give me a moment" or "This'll just take a sec" will be used.
	// This is the content that the assistant says when this message is triggered.
	Content string `json:"content" url:"content"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolMessageStart) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageStart) Type() string {
	return t.type_
}

func (t *ToolMessageStart) UnmarshalJSON(data []byte) error {
	type embed ToolMessageStart
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageStart(unmarshaler.embed)
	if unmarshaler.Type != "request-start" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-start", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageStart) MarshalJSON() ([]byte, error) {
	type embed ToolMessageStart
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-start",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageStart) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolTemplateMetadata struct {
	CollectionType *string `json:"collectionType,omitempty" url:"collectionType,omitempty"`
	CollectionId   *string `json:"collectionId,omitempty" url:"collectionId,omitempty"`
	CollectionName *string `json:"collectionName,omitempty" url:"collectionName,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolTemplateMetadata) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolTemplateMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolTemplateMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolTemplateMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolTemplateMetadata) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolTemplateSetup struct {
	Title       string  `json:"title" url:"title"`
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	VideoUrl    *string `json:"videoUrl,omitempty" url:"videoUrl,omitempty"`
	DocsUrl     *string `json:"docsUrl,omitempty" url:"docsUrl,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolTemplateSetup) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolTemplateSetup) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolTemplateSetup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolTemplateSetup(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolTemplateSetup) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TranscriberCost struct {
	// This is the type of cost, always 'transcriber' for this class.
	// This is the transcriber that was used during the call.
	//
	// This matches one of the below:
	//
	// - `call.assistant.transcriber`,
	// - `call.assistantId->transcriber`,
	// - `call.squad[n].assistant.transcriber`,
	// - `call.squad[n].assistantId->transcriber`,
	// - `call.squadId->[n].assistant.transcriber`,
	// - `call.squadId->[n].assistantId->transcriber`.
	Transcriber map[string]interface{} `json:"transcriber,omitempty" url:"transcriber,omitempty"`
	// This is the minutes of `transcriber` usage. This should match `call.endedAt` - `call.startedAt` for single assistant calls, while squad calls will have multiple transcriber costs one for each assistant that was used.
	Minutes float64 `json:"minutes" url:"minutes"`
	// This is the cost of the component in USD.
	Cost  float64 `json:"cost" url:"cost"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TranscriberCost) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TranscriberCost) Type() string {
	return t.type_
}

func (t *TranscriberCost) UnmarshalJSON(data []byte) error {
	type embed TranscriberCost
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TranscriberCost(unmarshaler.embed)
	if unmarshaler.Type != "transcriber" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "transcriber", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TranscriberCost) MarshalJSON() ([]byte, error) {
	type embed TranscriberCost
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transcriber",
	}
	return json.Marshal(marshaler)
}

func (t *TranscriberCost) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TranscriptPlan struct {
	// This determines whether the transcript is stored in `call.artifact.transcript`. Defaults to true.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the name of the assistant in the transcript. Defaults to 'AI'.
	//
	// Usage:
	//
	// - If you want to change the name of the assistant in the transcript, set this. Example, here is what the transcript would look like with `assistantName` set to 'Buyer':
	//
	// ```
	// User: Hello, how are you?
	// Buyer: I'm fine.
	// User: Do you want to buy a car?
	// Buyer: No.
	// ```
	//
	// @default 'AI'
	AssistantName *string `json:"assistantName,omitempty" url:"assistantName,omitempty"`
	// This is the name of the user in the transcript. Defaults to 'User'.
	//
	// Usage:
	//
	// - If you want to change the name of the user in the transcript, set this. Example, here is what the transcript would look like with `userName` set to 'Seller':
	//
	// ```
	// Seller: Hello, how are you?
	// AI: I'm fine.
	// Seller: Do you want to buy a car?
	// AI: No.
	// ```
	//
	// @default 'User'
	UserName *string `json:"userName,omitempty" url:"userName,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TranscriptPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TranscriptPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TranscriptPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TranscriptPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TranscriptPlan) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TranscriptionEndpointingPlan struct {
	// The minimum number of seconds to wait after transcription ending with punctuation before sending a request to the model. Defaults to 0.1.
	//
	// This setting exists because the transcriber punctuates the transcription when it's more confident that customer has completed a thought.
	//
	// @default 0.1
	OnPunctuationSeconds *float64 `json:"onPunctuationSeconds,omitempty" url:"onPunctuationSeconds,omitempty"`
	// The minimum number of seconds to wait after transcription ending without punctuation before sending a request to the model. Defaults to 1.5.
	//
	// This setting exists to catch the cases where the transcriber was not confident enough to punctuate the transcription, but the customer is done and has been silent for a long time.
	//
	// @default 1.5
	OnNoPunctuationSeconds *float64 `json:"onNoPunctuationSeconds,omitempty" url:"onNoPunctuationSeconds,omitempty"`
	// The minimum number of seconds to wait after transcription ending with a number before sending a request to the model. Defaults to 0.4.
	//
	// This setting exists because the transcriber will sometimes punctuate the transcription ending with a number, even though the customer hasn't uttered the full number. This happens commonly for long numbers when the customer reads the number in chunks.
	//
	// @default 0.5
	OnNumberSeconds *float64 `json:"onNumberSeconds,omitempty" url:"onNumberSeconds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TranscriptionEndpointingPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TranscriptionEndpointingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TranscriptionEndpointingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TranscriptionEndpointingPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TranscriptionEndpointingPlan) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransferCallTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*TransferCallToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.
	Destinations []*TransferCallToolDestinationsItem `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransferCallTool) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferCallTool) Type() string {
	return t.type_
}

func (t *TransferCallTool) UnmarshalJSON(data []byte) error {
	type embed TransferCallTool
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferCallTool(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "transferCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "transferCall", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferCallTool) MarshalJSON() ([]byte, error) {
	type embed TransferCallTool
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
		UpdatedAt: core.NewDateTime(t.UpdatedAt),
		Type:      "transferCall",
	}
	return json.Marshal(marshaler)
}

func (t *TransferCallTool) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransferCallToolDestinationsItem struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationStep      *TransferDestinationStep
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip
}

func (t *TransferCallToolDestinationsItem) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		t.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationStep := new(TransferDestinationStep)
	if err := json.Unmarshal(data, &valueTransferDestinationStep); err == nil {
		t.TransferDestinationStep = valueTransferDestinationStep
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		t.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		t.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferCallToolDestinationsItem) MarshalJSON() ([]byte, error) {
	if t.TransferDestinationAssistant != nil {
		return json.Marshal(t.TransferDestinationAssistant)
	}
	if t.TransferDestinationStep != nil {
		return json.Marshal(t.TransferDestinationStep)
	}
	if t.TransferDestinationNumber != nil {
		return json.Marshal(t.TransferDestinationNumber)
	}
	if t.TransferDestinationSip != nil {
		return json.Marshal(t.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferCallToolDestinationsItemVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationStep(*TransferDestinationStep) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (t *TransferCallToolDestinationsItem) Accept(visitor TransferCallToolDestinationsItemVisitor) error {
	if t.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(t.TransferDestinationAssistant)
	}
	if t.TransferDestinationStep != nil {
		return visitor.VisitTransferDestinationStep(t.TransferDestinationStep)
	}
	if t.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(t.TransferDestinationNumber)
	}
	if t.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(t.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferCallToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed
}

func (t *TransferCallToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		t.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		t.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		t.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		t.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferCallToolMessagesItem) MarshalJSON() ([]byte, error) {
	if t.ToolMessageStart != nil {
		return json.Marshal(t.ToolMessageStart)
	}
	if t.ToolMessageComplete != nil {
		return json.Marshal(t.ToolMessageComplete)
	}
	if t.ToolMessageFailed != nil {
		return json.Marshal(t.ToolMessageFailed)
	}
	if t.ToolMessageDelayed != nil {
		return json.Marshal(t.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferCallToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (t *TransferCallToolMessagesItem) Accept(visitor TransferCallToolMessagesItemVisitor) error {
	if t.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(t.ToolMessageStart)
	}
	if t.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(t.ToolMessageComplete)
	}
	if t.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(t.ToolMessageFailed)
	}
	if t.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(t.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationAssistant struct {
	// This is the mode to use for the transfer. Default is `rolling-history`.
	//
	// - `rolling-history`: This is the default mode. It keeps the entire conversation history and appends the new assistant's system message on transfer.
	//
	//	Example:
	//
	//	Pre-transfer:
	//	system: assistant1 system message
	//	assistant: assistant1 first message
	//	user: hey, good morning
	//	assistant: how can i help?
	//	user: i need help with my account
	//	assistant: (destination.message)
	//
	//	Post-transfer:
	//	system: assistant1 system message
	//	assistant: assistant1 first message
	//	user: hey, good morning
	//	assistant: how can i help?
	//	user: i need help with my account
	//	assistant: (destination.message)
	//	system: assistant2 system message
	//	assistant: assistant2 first message (or model generated if firstMessageMode is set to `assistant-speaks-first-with-model-generated-message`)
	//
	// - `swap-system-message-in-history`: This replaces the original system message with the new assistant's system message on transfer.
	//
	//	Example:
	//
	//	Pre-transfer:
	//	system: assistant1 system message
	//	assistant: assistant1 first message
	//	user: hey, good morning
	//	assistant: how can i help?
	//	user: i need help with my account
	//	assistant: (destination.message)
	//
	//	Post-transfer:
	//	system: assistant2 system message
	//	assistant: assistant1 first message
	//	user: hey, good morning
	//	assistant: how can i help?
	//	user: i need help with my account
	//	assistant: (destination.message)
	//	assistant: assistant2 first message (or model generated if firstMessageMode is set to `assistant-speaks-first-with-model-generated-message`)
	TransferMode *TransferMode `json:"transferMode,omitempty" url:"transferMode,omitempty"`
	// This is the assistant to transfer the call to.
	AssistantName string `json:"assistantName" url:"assistantName"`
	// This is the message to say before transferring the call to the destination.
	//
	// If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	//
	// If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransferDestinationAssistant) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationAssistant) Type() string {
	return t.type_
}

func (t *TransferDestinationAssistant) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationAssistant
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationAssistant(unmarshaler.embed)
	if unmarshaler.Type != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "assistant", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationAssistant) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationAssistant
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "assistant",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationAssistant) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransferDestinationNumber struct {
	// This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.
	//
	// Use cases:
	//
	// - `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.
	// - `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.
	//
	// If `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\+?[a-zA-Z0-9]+$/`).
	//
	// @default true (E164 check is enabled)
	NumberE164CheckEnabled *bool `json:"numberE164CheckEnabled,omitempty" url:"numberE164CheckEnabled,omitempty"`
	// This is the phone number to transfer the call to.
	Number string `json:"number" url:"number"`
	// This is the extension to dial after transferring the call to the `number`.
	Extension *string `json:"extension,omitempty" url:"extension,omitempty"`
	// This is the caller ID to use when transferring the call to the `number`.
	//
	// Usage:
	//
	// - If not provided, the caller ID will be the number the call is coming from. Example, +14151111111 calls in to and the assistant transfers out to +16470000000. +16470000000 will see +14151111111 as the caller.
	// - To change this behavior, provide a `callerId`.
	// - Set to '{{customer.number}}' to always use the customer's number as the caller ID.
	// - Set to '{{phoneNumber.number}}' to always use the phone number of the assistant as the caller ID.
	// - Set to any E164 number to always use that number as the caller ID. This needs to be a number that is owned or verified by your Transport provider like Twilio.
	//
	// For Twilio, you can read up more here: https://www.twilio.com/docs/voice/twiml/dial#callerid
	CallerId *string `json:"callerId,omitempty" url:"callerId,omitempty"`
	// This is the message to say before transferring the call to the destination.
	//
	// If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	//
	// If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransferDestinationNumber) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationNumber) Type() string {
	return t.type_
}

func (t *TransferDestinationNumber) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationNumber
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationNumber(unmarshaler.embed)
	if unmarshaler.Type != "number" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "number", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationNumber) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationNumber
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "number",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationNumber) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransferDestinationSip struct {
	// This is the SIP URI to transfer the call to.
	SipUri string `json:"sipUri" url:"sipUri"`
	// This is the message to say before transferring the call to the destination.
	//
	// If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	//
	// If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransferDestinationSip) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationSip) Type() string {
	return t.type_
}

func (t *TransferDestinationSip) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationSip
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationSip(unmarshaler.embed)
	if unmarshaler.Type != "sip" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "sip", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationSip) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationSip
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "sip",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationSip) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransferDestinationStep struct {
	// This is the step to transfer to.
	StepName string `json:"stepName" url:"stepName"`
	// This is the message to say before transferring the call to the destination.
	//
	// If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	//
	// If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransferDestinationStep) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationStep) Type() string {
	return t.type_
}

func (t *TransferDestinationStep) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationStep
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationStep(unmarshaler.embed)
	if unmarshaler.Type != "step" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "step", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationStep) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationStep
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "step",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationStep) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransferMode string

const (
	TransferModeRollingHistory             TransferMode = "rolling-history"
	TransferModeSwapSystemMessageInHistory TransferMode = "swap-system-message-in-history"
)

func NewTransferModeFromString(s string) (TransferMode, error) {
	switch s {
	case "rolling-history":
		return TransferModeRollingHistory, nil
	case "swap-system-message-in-history":
		return TransferModeSwapSystemMessageInHistory, nil
	}
	var t TransferMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransferMode) Ptr() *TransferMode {
	return &t
}

type TransportConfigurationTwilio struct {
	// The integer number of seconds that we should allow the phone to ring before assuming there is no answer.
	// The default is `60` seconds and the maximum is `600` seconds.
	// For some call flows, we will add a 5-second buffer to the timeout value you provide.
	// For this reason, a timeout value of 10 seconds could result in an actual timeout closer to 15 seconds.
	// You can set this to a short time, such as `15` seconds, to hang up before reaching an answering machine or voicemail.
	//
	// @default 60
	Timeout *float64 `json:"timeout,omitempty" url:"timeout,omitempty"`
	// Whether to record the call.
	// Can be `true` to record the phone call, or `false` to not.
	// The default is `false`.
	//
	// @default false
	Record *bool `json:"record,omitempty" url:"record,omitempty"`
	// The number of channels in the final recording.
	// Can be: `mono` or `dual`.
	// The default is `mono`.
	// `mono` records both legs of the call in a single channel of the recording file.
	// `dual` records each leg to a separate channel of the recording file.
	// The first channel of a dual-channel recording contains the parent call and the second channel contains the child call.
	//
	// @default 'mono'
	RecordingChannels *TransportConfigurationTwilioRecordingChannels `json:"recordingChannels,omitempty" url:"recordingChannels,omitempty"`
	provider          string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransportConfigurationTwilio) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransportConfigurationTwilio) Provider() string {
	return t.provider
}

func (t *TransportConfigurationTwilio) UnmarshalJSON(data []byte) error {
	type embed TransportConfigurationTwilio
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransportConfigurationTwilio(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "twilio", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransportConfigurationTwilio) MarshalJSON() ([]byte, error) {
	type embed TransportConfigurationTwilio
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (t *TransportConfigurationTwilio) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The number of channels in the final recording.
// Can be: `mono` or `dual`.
// The default is `mono`.
// `mono` records both legs of the call in a single channel of the recording file.
// `dual` records each leg to a separate channel of the recording file.
// The first channel of a dual-channel recording contains the parent call and the second channel contains the child call.
//
// @default 'mono'
type TransportConfigurationTwilioRecordingChannels string

const (
	TransportConfigurationTwilioRecordingChannelsMono TransportConfigurationTwilioRecordingChannels = "mono"
	TransportConfigurationTwilioRecordingChannelsDual TransportConfigurationTwilioRecordingChannels = "dual"
)

func NewTransportConfigurationTwilioRecordingChannelsFromString(s string) (TransportConfigurationTwilioRecordingChannels, error) {
	switch s {
	case "mono":
		return TransportConfigurationTwilioRecordingChannelsMono, nil
	case "dual":
		return TransportConfigurationTwilioRecordingChannelsDual, nil
	}
	var t TransportConfigurationTwilioRecordingChannels
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransportConfigurationTwilioRecordingChannels) Ptr() *TransportConfigurationTwilioRecordingChannels {
	return &t
}

type TransportCost struct {
	// This is the type of cost, always 'transport' for this class.
	// This is the minutes of `transport` usage. This should match `call.endedAt` - `call.startedAt`.
	Minutes float64 `json:"minutes" url:"minutes"`
	// This is the cost of the component in USD.
	Cost  float64 `json:"cost" url:"cost"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransportCost) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransportCost) Type() string {
	return t.type_
}

func (t *TransportCost) UnmarshalJSON(data []byte) error {
	type embed TransportCost
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransportCost(unmarshaler.embed)
	if unmarshaler.Type != "transport" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "transport", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransportCost) MarshalJSON() ([]byte, error) {
	type embed TransportCost
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transport",
	}
	return json.Marshal(marshaler)
}

func (t *TransportCost) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TwilioCredential struct {
	// This is not returned in the API.
	AuthToken string `json:"authToken" url:"authToken"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt  time.Time `json:"updatedAt" url:"updatedAt"`
	AccountSid string    `json:"accountSid" url:"accountSid"`
	provider   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TwilioCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TwilioCredential) Provider() string {
	return t.provider
}

func (t *TwilioCredential) UnmarshalJSON(data []byte) error {
	type embed TwilioCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TwilioCredential(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "twilio", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TwilioCredential) MarshalJSON() ([]byte, error) {
	type embed TwilioCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
		UpdatedAt: core.NewDateTime(t.UpdatedAt),
		Provider:  "twilio",
	}
	return json.Marshal(marshaler)
}

func (t *TwilioCredential) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TwilioPhoneNumber struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *TwilioPhoneNumberFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// This is the unique identifier for the phone number.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this phone number belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the phone number was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the phone number was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	// These are the digits of the phone number you own on your Twilio.
	Number string `json:"number" url:"number"`
	// This is the Twilio Account SID for the phone number.
	TwilioAccountSid string `json:"twilioAccountSid" url:"twilioAccountSid"`
	// This is the Twilio Auth Token for the phone number.
	TwilioAuthToken string `json:"twilioAuthToken" url:"twilioAuthToken"`
	provider        string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TwilioPhoneNumber) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TwilioPhoneNumber) Provider() string {
	return t.provider
}

func (t *TwilioPhoneNumber) UnmarshalJSON(data []byte) error {
	type embed TwilioPhoneNumber
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TwilioPhoneNumber(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "twilio", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TwilioPhoneNumber) MarshalJSON() ([]byte, error) {
	type embed TwilioPhoneNumber
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
		UpdatedAt: core.NewDateTime(t.UpdatedAt),
		Provider:  "twilio",
	}
	return json.Marshal(marshaler)
}

func (t *TwilioPhoneNumber) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type TwilioPhoneNumberFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (t *TwilioPhoneNumberFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		t.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		t.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TwilioPhoneNumberFallbackDestination) MarshalJSON() ([]byte, error) {
	if t.TransferDestinationNumber != nil {
		return json.Marshal(t.TransferDestinationNumber)
	}
	if t.TransferDestinationSip != nil {
		return json.Marshal(t.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TwilioPhoneNumberFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (t *TwilioPhoneNumberFallbackDestination) Accept(visitor TwilioPhoneNumberFallbackDestinationVisitor) error {
	if t.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(t.TransferDestinationNumber)
	}
	if t.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(t.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TwilioVoicemailDetection struct {
	// This is the provider to use for voicemail detection.
	// These are the AMD messages from Twilio that are considered as voicemail. Default is ['machine_end_beep', 'machine_end_silence'].
	//
	// @default {Array} ['machine_end_beep', 'machine_end_silence']
	VoicemailDetectionTypes []TwilioVoicemailDetectionVoicemailDetectionTypesItem `json:"voicemailDetectionTypes,omitempty" url:"voicemailDetectionTypes,omitempty"`
	// This sets whether the assistant should detect voicemail. Defaults to true.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The number of seconds that Twilio should attempt to perform answering machine detection before timing out and returning AnsweredBy as unknown. Default is 30 seconds.
	//
	// Increasing this value will provide the engine more time to make a determination. This can be useful when DetectMessageEnd is provided in the MachineDetection parameter and there is an expectation of long answering machine greetings that can exceed 30 seconds.
	//
	// Decreasing this value will reduce the amount of time the engine has to make a determination. This can be particularly useful when the Enable option is provided in the MachineDetection parameter and you want to limit the time for initial detection.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 30
	MachineDetectionTimeout *float64 `json:"machineDetectionTimeout,omitempty" url:"machineDetectionTimeout,omitempty"`
	// The number of milliseconds that is used as the measuring stick for the length of the speech activity. Durations lower than this value will be interpreted as a human, longer as a machine. Default is 2400 milliseconds.
	//
	// Increasing this value will reduce the chance of a False Machine (detected machine, actually human) for a long human greeting (e.g., a business greeting) but increase the time it takes to detect a machine.
	//
	// Decreasing this value will reduce the chances of a False Human (detected human, actually machine) for short voicemail greetings. The value of this parameter may need to be reduced by more than 1000ms to detect very short voicemail greetings. A reduction of that significance can result in increased False Machine detections. Adjusting the MachineDetectionSpeechEndThreshold is likely the better approach for short voicemails. Decreasing MachineDetectionSpeechThreshold will also reduce the time it takes to detect a machine.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 2400
	MachineDetectionSpeechThreshold *float64 `json:"machineDetectionSpeechThreshold,omitempty" url:"machineDetectionSpeechThreshold,omitempty"`
	// The number of milliseconds of silence after speech activity at which point the speech activity is considered complete. Default is 1200 milliseconds.
	//
	// Increasing this value will typically be used to better address the short voicemail greeting scenarios. For short voicemails, there is typically 1000-2000ms of audio followed by 1200-2400ms of silence and then additional audio before the beep. Increasing the MachineDetectionSpeechEndThreshold to ~2500ms will treat the 1200-2400ms of silence as a gap in the greeting but not the end of the greeting and will result in a machine detection. The downsides of such a change include:
	//
	// - Increasing the delay for human detection by the amount you increase this parameter, e.g., a change of 1200ms to 2500ms increases human detection delay by 1300ms.
	// - Cases where a human has two utterances separated by a period of silence (e.g. a "Hello", then 2000ms of silence, and another "Hello") may be interpreted as a machine.
	//
	// Decreasing this value will result in faster human detection. The consequence is that it can lead to increased False Human (detected human, actually machine) detections because a silence gap in a voicemail greeting (not necessarily just in short voicemail scenarios) can be incorrectly interpreted as the end of speech.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 1200
	MachineDetectionSpeechEndThreshold *float64 `json:"machineDetectionSpeechEndThreshold,omitempty" url:"machineDetectionSpeechEndThreshold,omitempty"`
	// The number of milliseconds of initial silence after which an unknown AnsweredBy result will be returned. Default is 5000 milliseconds.
	//
	// Increasing this value will result in waiting for a longer period of initial silence before returning an 'unknown' AMD result.
	//
	// Decreasing this value will result in waiting for a shorter period of initial silence before returning an 'unknown' AMD result.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 5000
	MachineDetectionSilenceTimeout *float64 `json:"machineDetectionSilenceTimeout,omitempty" url:"machineDetectionSilenceTimeout,omitempty"`
	provider                       string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TwilioVoicemailDetection) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TwilioVoicemailDetection) Provider() string {
	return t.provider
}

func (t *TwilioVoicemailDetection) UnmarshalJSON(data []byte) error {
	type embed TwilioVoicemailDetection
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TwilioVoicemailDetection(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "twilio", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TwilioVoicemailDetection) MarshalJSON() ([]byte, error) {
	type embed TwilioVoicemailDetection
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (t *TwilioVoicemailDetection) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TwilioVoicemailDetectionVoicemailDetectionTypesItem string

const (
	TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineStart      TwilioVoicemailDetectionVoicemailDetectionTypesItem = "machine_start"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemHuman             TwilioVoicemailDetectionVoicemailDetectionTypesItem = "human"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemFax               TwilioVoicemailDetectionVoicemailDetectionTypesItem = "fax"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemUnknown           TwilioVoicemailDetectionVoicemailDetectionTypesItem = "unknown"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndBeep    TwilioVoicemailDetectionVoicemailDetectionTypesItem = "machine_end_beep"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndSilence TwilioVoicemailDetectionVoicemailDetectionTypesItem = "machine_end_silence"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndOther   TwilioVoicemailDetectionVoicemailDetectionTypesItem = "machine_end_other"
)

func NewTwilioVoicemailDetectionVoicemailDetectionTypesItemFromString(s string) (TwilioVoicemailDetectionVoicemailDetectionTypesItem, error) {
	switch s {
	case "machine_start":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineStart, nil
	case "human":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemHuman, nil
	case "fax":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemFax, nil
	case "unknown":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemUnknown, nil
	case "machine_end_beep":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndBeep, nil
	case "machine_end_silence":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndSilence, nil
	case "machine_end_other":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndOther, nil
	}
	var t TwilioVoicemailDetectionVoicemailDetectionTypesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TwilioVoicemailDetectionVoicemailDetectionTypesItem) Ptr() *TwilioVoicemailDetectionVoicemailDetectionTypesItem {
	return &t
}

type UpdateAnthropicCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateAnthropicCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAnthropicCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateAnthropicCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateAnthropicCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateAnthropicCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "anthropic", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAnthropicCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateAnthropicCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "anthropic",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateAnthropicCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAnyscaleCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateAnyscaleCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAnyscaleCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateAnyscaleCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateAnyscaleCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateAnyscaleCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "anyscale" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "anyscale", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAnyscaleCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateAnyscaleCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "anyscale",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateAnyscaleCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAzureOpenAiCredentialDto struct {
	Region UpdateAzureOpenAiCredentialDtoRegion       `json:"region" url:"region"`
	Models []UpdateAzureOpenAiCredentialDtoModelsItem `json:"models,omitempty" url:"models,omitempty"`
	// This is not returned in the API.
	OpenAiKey      string `json:"openAIKey" url:"openAIKey"`
	OpenAiEndpoint string `json:"openAIEndpoint" url:"openAIEndpoint"`
	provider       string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateAzureOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAzureOpenAiCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateAzureOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateAzureOpenAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateAzureOpenAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "azure-openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "azure-openai", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAzureOpenAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateAzureOpenAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "azure-openai",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateAzureOpenAiCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAzureOpenAiCredentialDtoModelsItem string

const (
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718 UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-mini-2024-07-18"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20240513     UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-05-13"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409 UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-turbo-2024-04-09"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt40125Preview   UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0125-preview"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt41106Preview   UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-1106-preview"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt40613          UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0613"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125    UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-0125"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106    UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-1106"
)

func NewUpdateAzureOpenAiCredentialDtoModelsItemFromString(s string) (UpdateAzureOpenAiCredentialDtoModelsItem, error) {
	switch s {
	case "gpt-4o-mini-2024-07-18":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718, nil
	case "gpt-4o-2024-05-13":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20240513, nil
	case "gpt-4-turbo-2024-04-09":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409, nil
	case "gpt-4-0125-preview":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt41106Preview, nil
	case "gpt-4-0613":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt40613, nil
	case "gpt-35-turbo-0125":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125, nil
	case "gpt-35-turbo-1106":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106, nil
	}
	var t UpdateAzureOpenAiCredentialDtoModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAzureOpenAiCredentialDtoModelsItem) Ptr() *UpdateAzureOpenAiCredentialDtoModelsItem {
	return &u
}

type UpdateAzureOpenAiCredentialDtoRegion string

const (
	UpdateAzureOpenAiCredentialDtoRegionAustralia      UpdateAzureOpenAiCredentialDtoRegion = "australia"
	UpdateAzureOpenAiCredentialDtoRegionCanada         UpdateAzureOpenAiCredentialDtoRegion = "canada"
	UpdateAzureOpenAiCredentialDtoRegionEastus2        UpdateAzureOpenAiCredentialDtoRegion = "eastus2"
	UpdateAzureOpenAiCredentialDtoRegionEastus         UpdateAzureOpenAiCredentialDtoRegion = "eastus"
	UpdateAzureOpenAiCredentialDtoRegionFrance         UpdateAzureOpenAiCredentialDtoRegion = "france"
	UpdateAzureOpenAiCredentialDtoRegionIndia          UpdateAzureOpenAiCredentialDtoRegion = "india"
	UpdateAzureOpenAiCredentialDtoRegionJapan          UpdateAzureOpenAiCredentialDtoRegion = "japan"
	UpdateAzureOpenAiCredentialDtoRegionNorthcentralus UpdateAzureOpenAiCredentialDtoRegion = "northcentralus"
	UpdateAzureOpenAiCredentialDtoRegionNorway         UpdateAzureOpenAiCredentialDtoRegion = "norway"
	UpdateAzureOpenAiCredentialDtoRegionSouthcentralus UpdateAzureOpenAiCredentialDtoRegion = "southcentralus"
	UpdateAzureOpenAiCredentialDtoRegionSweden         UpdateAzureOpenAiCredentialDtoRegion = "sweden"
	UpdateAzureOpenAiCredentialDtoRegionSwitzerland    UpdateAzureOpenAiCredentialDtoRegion = "switzerland"
	UpdateAzureOpenAiCredentialDtoRegionUk             UpdateAzureOpenAiCredentialDtoRegion = "uk"
	UpdateAzureOpenAiCredentialDtoRegionWestus         UpdateAzureOpenAiCredentialDtoRegion = "westus"
	UpdateAzureOpenAiCredentialDtoRegionWestus3        UpdateAzureOpenAiCredentialDtoRegion = "westus3"
)

func NewUpdateAzureOpenAiCredentialDtoRegionFromString(s string) (UpdateAzureOpenAiCredentialDtoRegion, error) {
	switch s {
	case "australia":
		return UpdateAzureOpenAiCredentialDtoRegionAustralia, nil
	case "canada":
		return UpdateAzureOpenAiCredentialDtoRegionCanada, nil
	case "eastus2":
		return UpdateAzureOpenAiCredentialDtoRegionEastus2, nil
	case "eastus":
		return UpdateAzureOpenAiCredentialDtoRegionEastus, nil
	case "france":
		return UpdateAzureOpenAiCredentialDtoRegionFrance, nil
	case "india":
		return UpdateAzureOpenAiCredentialDtoRegionIndia, nil
	case "japan":
		return UpdateAzureOpenAiCredentialDtoRegionJapan, nil
	case "northcentralus":
		return UpdateAzureOpenAiCredentialDtoRegionNorthcentralus, nil
	case "norway":
		return UpdateAzureOpenAiCredentialDtoRegionNorway, nil
	case "southcentralus":
		return UpdateAzureOpenAiCredentialDtoRegionSouthcentralus, nil
	case "sweden":
		return UpdateAzureOpenAiCredentialDtoRegionSweden, nil
	case "switzerland":
		return UpdateAzureOpenAiCredentialDtoRegionSwitzerland, nil
	case "uk":
		return UpdateAzureOpenAiCredentialDtoRegionUk, nil
	case "westus":
		return UpdateAzureOpenAiCredentialDtoRegionWestus, nil
	case "westus3":
		return UpdateAzureOpenAiCredentialDtoRegionWestus3, nil
	}
	var t UpdateAzureOpenAiCredentialDtoRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAzureOpenAiCredentialDtoRegion) Ptr() *UpdateAzureOpenAiCredentialDtoRegion {
	return &u
}

type UpdateByoSipTrunkCredentialDto struct {
	// This can be used to bring your own SIP trunks or to connect to a Carrier.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// This is the list of SIP trunk's gateways.
	Gateways []*SipTrunkGateway `json:"gateways,omitempty" url:"gateways,omitempty"`
	// This is the name of the SIP trunk. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This can be used to configure the outbound authentication if required by the SIP trunk.
	OutboundAuthenticationPlan *SipTrunkOutboundAuthenticationPlan `json:"outboundAuthenticationPlan,omitempty" url:"outboundAuthenticationPlan,omitempty"`
	// This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.
	//
	// Usage:
	//
	// - Vonage/Twilio requires leading plus for all outbound calls. Set this to true.
	//
	// @default false
	OutboundLeadingPlusEnabled *bool `json:"outboundLeadingPlusEnabled,omitempty" url:"outboundLeadingPlusEnabled,omitempty"`
	// This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.
	SbcConfiguration *SbcConfiguration `json:"sbcConfiguration,omitempty" url:"sbcConfiguration,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateByoSipTrunkCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateByoSipTrunkCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateByoSipTrunkCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateByoSipTrunkCredentialDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateByoSipTrunkCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCartesiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateCartesiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCartesiaCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateCartesiaCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateCartesiaCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateCartesiaCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "cartesia", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCartesiaCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateCartesiaCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "cartesia",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateCartesiaCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCustomLlmCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateCustomLlmCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomLlmCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateCustomLlmCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateCustomLlmCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateCustomLlmCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "custom-llm", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomLlmCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateCustomLlmCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "custom-llm",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateCustomLlmCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateDeepInfraCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateDeepInfraCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateDeepInfraCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateDeepInfraCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateDeepInfraCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateDeepInfraCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "deepinfra" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "deepinfra", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateDeepInfraCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateDeepInfraCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "deepinfra",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateDeepInfraCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateDeepgramCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com.
	ApiUrl   *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateDeepgramCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateDeepgramCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateDeepgramCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateDeepgramCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateDeepgramCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "deepgram", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateDeepgramCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateDeepgramCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateDeepgramCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateElevenLabsCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateElevenLabsCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateElevenLabsCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateElevenLabsCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateElevenLabsCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateElevenLabsCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "11labs", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateElevenLabsCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateElevenLabsCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateElevenLabsCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGcpCredentialDto struct {
	// This is the name of the GCP credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.
	//
	// The schema is identical to the JSON that GCP outputs.
	GcpKey *GcpKey `json:"gcpKey,omitempty" url:"gcpKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in GCP.
	BucketPlan *BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateGcpCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGcpCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateGcpCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateGcpCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateGcpCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gcp" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "gcp", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGcpCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGcpCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "gcp",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateGcpCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGladiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateGladiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGladiaCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateGladiaCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateGladiaCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateGladiaCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "gladia", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGladiaCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGladiaCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "gladia",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateGladiaCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateGoHighLevelCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateGoHighLevelCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateGoHighLevelCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateGoHighLevelCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gohighlevel" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "gohighlevel", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGoHighLevelCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "gohighlevel",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateGoHighLevelCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGroqCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateGroqCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGroqCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateGroqCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateGroqCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateGroqCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "groq" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "groq", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGroqCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGroqCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "groq",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateGroqCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateLmntCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateLmntCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateLmntCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateLmntCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateLmntCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateLmntCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "lmnt", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateLmntCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateLmntCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "lmnt",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateLmntCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateMakeCredentialDto struct {
	// Team ID
	TeamId string `json:"teamId" url:"teamId"`
	// Region of your application. For example: eu1, eu2, us1, us2
	Region string `json:"region" url:"region"`
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateMakeCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMakeCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateMakeCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateMakeCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateMakeCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "make", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMakeCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateMakeCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "make",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateMakeCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateOpenAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOpenAiCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateOpenAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateOpenAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "openai", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOpenAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateOpenAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateOpenAiCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateOpenRouterCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateOpenRouterCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOpenRouterCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateOpenRouterCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateOpenRouterCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateOpenRouterCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "openrouter" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "openrouter", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOpenRouterCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateOpenRouterCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "openrouter",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateOpenRouterCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateOrgDto struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	// When HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.
	// This is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// This is the name of the org. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.
	BillingLimit *float64 `json:"billingLimit,omitempty" url:"billingLimit,omitempty"`
	// This is the URL Vapi will communicate with via HTTP GET and POST Requests. This is used for retrieving context, function calling, and end-of-call reports.
	//
	// All requests will be sent with the call object among other things relevant to that message. You can find more details in the Server URL documentation.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	// This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.
	ConcurrencyLimit *float64 `json:"concurrencyLimit,omitempty" url:"concurrencyLimit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateOrgDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOrgDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOrgDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOrgDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOrgDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdatePerplexityAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdatePerplexityAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePerplexityAiCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdatePerplexityAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdatePerplexityAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdatePerplexityAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "perplexity-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "perplexity-ai", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePerplexityAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdatePerplexityAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "perplexity-ai",
	}
	return json.Marshal(marshaler)
}

func (u *UpdatePerplexityAiCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdatePlayHtCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	UserId   string `json:"userId" url:"userId"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdatePlayHtCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePlayHtCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdatePlayHtCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdatePlayHtCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdatePlayHtCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "playht", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePlayHtCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdatePlayHtCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "playht",
	}
	return json.Marshal(marshaler)
}

func (u *UpdatePlayHtCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateRimeAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateRimeAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateRimeAiCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateRimeAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateRimeAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateRimeAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "rime-ai", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateRimeAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateRimeAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateRimeAiCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateRunpodCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateRunpodCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateRunpodCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateRunpodCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateRunpodCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateRunpodCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "runpod" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "runpod", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateRunpodCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateRunpodCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "runpod",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateRunpodCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateS3CredentialDto struct {
	// Credential provider. Only allowed value is s3
	// AWS access key ID.
	AwsAccessKeyId string `json:"awsAccessKeyId" url:"awsAccessKeyId"`
	// AWS access key secret. This is not returned in the API.
	AwsSecretAccessKey string `json:"awsSecretAccessKey" url:"awsSecretAccessKey"`
	// AWS region in which the S3 bucket is located.
	Region string `json:"region" url:"region"`
	// AWS S3 bucket name.
	S3BucketName string `json:"s3BucketName" url:"s3BucketName"`
	// The path prefix for the uploaded recording. Ex. "recordings/"
	S3PathPrefix string `json:"s3PathPrefix" url:"s3PathPrefix"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateS3CredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateS3CredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateS3CredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateS3CredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateS3CredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "s3" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "s3", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateS3CredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateS3CredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "s3",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateS3CredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTogetherAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey   string `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateTogetherAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTogetherAiCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateTogetherAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateTogetherAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateTogetherAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "together-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "together-ai", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTogetherAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateTogetherAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "together-ai",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateTogetherAiCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateToolTemplateDto struct {
	Details         *UpdateToolTemplateDtoDetails         `json:"details,omitempty" url:"details,omitempty"`
	ProviderDetails *UpdateToolTemplateDtoProviderDetails `json:"providerDetails,omitempty" url:"providerDetails,omitempty"`
	Metadata        *ToolTemplateMetadata                 `json:"metadata,omitempty" url:"metadata,omitempty"`
	Visibility      *UpdateToolTemplateDtoVisibility      `json:"visibility,omitempty" url:"visibility,omitempty"`
	// The name of the template. This is just for your own reference.
	Name     *string                        `json:"name,omitempty" url:"name,omitempty"`
	Provider *UpdateToolTemplateDtoProvider `json:"provider,omitempty" url:"provider,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateToolTemplateDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateToolTemplateDto) Type() string {
	return u.type_
}

func (u *UpdateToolTemplateDto) UnmarshalJSON(data []byte) error {
	type embed UpdateToolTemplateDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateToolTemplateDto(unmarshaler.embed)
	if unmarshaler.Type != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "tool", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateToolTemplateDto) MarshalJSON() ([]byte, error) {
	type embed UpdateToolTemplateDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "tool",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateToolTemplateDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateToolTemplateDtoDetails struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (u *UpdateToolTemplateDtoDetails) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		u.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		u.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		u.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		u.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		u.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		u.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		u.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateToolTemplateDtoDetails) MarshalJSON() ([]byte, error) {
	if u.CreateDtmfToolDto != nil {
		return json.Marshal(u.CreateDtmfToolDto)
	}
	if u.CreateEndCallToolDto != nil {
		return json.Marshal(u.CreateEndCallToolDto)
	}
	if u.CreateVoicemailToolDto != nil {
		return json.Marshal(u.CreateVoicemailToolDto)
	}
	if u.CreateFunctionToolDto != nil {
		return json.Marshal(u.CreateFunctionToolDto)
	}
	if u.CreateGhlToolDto != nil {
		return json.Marshal(u.CreateGhlToolDto)
	}
	if u.CreateMakeToolDto != nil {
		return json.Marshal(u.CreateMakeToolDto)
	}
	if u.CreateTransferCallToolDto != nil {
		return json.Marshal(u.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoDetailsVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (u *UpdateToolTemplateDtoDetails) Accept(visitor UpdateToolTemplateDtoDetailsVisitor) error {
	if u.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(u.CreateDtmfToolDto)
	}
	if u.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(u.CreateEndCallToolDto)
	}
	if u.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(u.CreateVoicemailToolDto)
	}
	if u.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(u.CreateFunctionToolDto)
	}
	if u.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(u.CreateGhlToolDto)
	}
	if u.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(u.CreateMakeToolDto)
	}
	if u.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(u.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoProvider string

const (
	UpdateToolTemplateDtoProviderMake        UpdateToolTemplateDtoProvider = "make"
	UpdateToolTemplateDtoProviderGohighlevel UpdateToolTemplateDtoProvider = "gohighlevel"
	UpdateToolTemplateDtoProviderFunction    UpdateToolTemplateDtoProvider = "function"
)

func NewUpdateToolTemplateDtoProviderFromString(s string) (UpdateToolTemplateDtoProvider, error) {
	switch s {
	case "make":
		return UpdateToolTemplateDtoProviderMake, nil
	case "gohighlevel":
		return UpdateToolTemplateDtoProviderGohighlevel, nil
	case "function":
		return UpdateToolTemplateDtoProviderFunction, nil
	}
	var t UpdateToolTemplateDtoProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateToolTemplateDtoProvider) Ptr() *UpdateToolTemplateDtoProvider {
	return &u
}

type UpdateToolTemplateDtoProviderDetails struct {
	MakeToolProviderDetails     *MakeToolProviderDetails
	GhlToolProviderDetails      *GhlToolProviderDetails
	FunctionToolProviderDetails *FunctionToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) UnmarshalJSON(data []byte) error {
	valueMakeToolProviderDetails := new(MakeToolProviderDetails)
	if err := json.Unmarshal(data, &valueMakeToolProviderDetails); err == nil {
		u.MakeToolProviderDetails = valueMakeToolProviderDetails
		return nil
	}
	valueGhlToolProviderDetails := new(GhlToolProviderDetails)
	if err := json.Unmarshal(data, &valueGhlToolProviderDetails); err == nil {
		u.GhlToolProviderDetails = valueGhlToolProviderDetails
		return nil
	}
	valueFunctionToolProviderDetails := new(FunctionToolProviderDetails)
	if err := json.Unmarshal(data, &valueFunctionToolProviderDetails); err == nil {
		u.FunctionToolProviderDetails = valueFunctionToolProviderDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateToolTemplateDtoProviderDetails) MarshalJSON() ([]byte, error) {
	if u.MakeToolProviderDetails != nil {
		return json.Marshal(u.MakeToolProviderDetails)
	}
	if u.GhlToolProviderDetails != nil {
		return json.Marshal(u.GhlToolProviderDetails)
	}
	if u.FunctionToolProviderDetails != nil {
		return json.Marshal(u.FunctionToolProviderDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoProviderDetailsVisitor interface {
	VisitMakeToolProviderDetails(*MakeToolProviderDetails) error
	VisitGhlToolProviderDetails(*GhlToolProviderDetails) error
	VisitFunctionToolProviderDetails(*FunctionToolProviderDetails) error
}

func (u *UpdateToolTemplateDtoProviderDetails) Accept(visitor UpdateToolTemplateDtoProviderDetailsVisitor) error {
	if u.MakeToolProviderDetails != nil {
		return visitor.VisitMakeToolProviderDetails(u.MakeToolProviderDetails)
	}
	if u.GhlToolProviderDetails != nil {
		return visitor.VisitGhlToolProviderDetails(u.GhlToolProviderDetails)
	}
	if u.FunctionToolProviderDetails != nil {
		return visitor.VisitFunctionToolProviderDetails(u.FunctionToolProviderDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoVisibility string

const (
	UpdateToolTemplateDtoVisibilityPublic  UpdateToolTemplateDtoVisibility = "public"
	UpdateToolTemplateDtoVisibilityPrivate UpdateToolTemplateDtoVisibility = "private"
)

func NewUpdateToolTemplateDtoVisibilityFromString(s string) (UpdateToolTemplateDtoVisibility, error) {
	switch s {
	case "public":
		return UpdateToolTemplateDtoVisibilityPublic, nil
	case "private":
		return UpdateToolTemplateDtoVisibilityPrivate, nil
	}
	var t UpdateToolTemplateDtoVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateToolTemplateDtoVisibility) Ptr() *UpdateToolTemplateDtoVisibility {
	return &u
}

type UpdateTwilioCredentialDto struct {
	// This is not returned in the API.
	AuthToken  string `json:"authToken" url:"authToken"`
	AccountSid string `json:"accountSid" url:"accountSid"`
	provider   string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateTwilioCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTwilioCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateTwilioCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateTwilioCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateTwilioCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "twilio", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTwilioCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateTwilioCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateTwilioCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateUserRoleDto struct {
	UserId string                `json:"userId" url:"userId"`
	Role   UpdateUserRoleDtoRole `json:"role" url:"role"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateUserRoleDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateUserRoleDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateUserRoleDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateUserRoleDto(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateUserRoleDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateUserRoleDtoRole string

const (
	UpdateUserRoleDtoRoleAdmin  UpdateUserRoleDtoRole = "admin"
	UpdateUserRoleDtoRoleEditor UpdateUserRoleDtoRole = "editor"
	UpdateUserRoleDtoRoleViewer UpdateUserRoleDtoRole = "viewer"
)

func NewUpdateUserRoleDtoRoleFromString(s string) (UpdateUserRoleDtoRole, error) {
	switch s {
	case "admin":
		return UpdateUserRoleDtoRoleAdmin, nil
	case "editor":
		return UpdateUserRoleDtoRoleEditor, nil
	case "viewer":
		return UpdateUserRoleDtoRoleViewer, nil
	}
	var t UpdateUserRoleDtoRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateUserRoleDtoRole) Ptr() *UpdateUserRoleDtoRole {
	return &u
}

type UpdateVonageCredentialDto struct {
	// This is not returned in the API.
	ApiSecret string `json:"apiSecret" url:"apiSecret"`
	ApiKey    string `json:"apiKey" url:"apiKey"`
	provider  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateVonageCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateVonageCredentialDto) Provider() string {
	return u.provider
}

func (u *UpdateVonageCredentialDto) UnmarshalJSON(data []byte) error {
	type embed UpdateVonageCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateVonageCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "vonage" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "vonage", unmarshaler.Provider)
	}
	u.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *u, "provider")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateVonageCredentialDto) MarshalJSON() ([]byte, error) {
	type embed UpdateVonageCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*u),
		Provider: "vonage",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateVonageCredentialDto) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type User struct {
	// This is the unique identifier for the profile or user.
	Id string `json:"id" url:"id"`
	// This is the ISO 8601 date-time string of when the profile was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the profile was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the email of the user that is associated with the profile.
	Email string `json:"email" url:"email"`
	// This is the full name of the user that is associated with the profile.
	FullName *string `json:"fullName,omitempty" url:"fullName,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type embed User
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = User(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.Time()
	u.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) MarshalJSON() ([]byte, error) {
	type embed User
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*u),
		CreatedAt: core.NewDateTime(u.CreatedAt),
		UpdatedAt: core.NewDateTime(u.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (u *User) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserMessage struct {
	// The role of the user in the conversation.
	Role string `json:"role" url:"role"`
	// The message content from the user.
	Message string `json:"message" url:"message"`
	// The timestamp when the message was sent.
	Time float64 `json:"time" url:"time"`
	// The timestamp when the message ended.
	EndTime float64 `json:"endTime" url:"endTime"`
	// The number of seconds from the start of the conversation.
	SecondsFromStart float64 `json:"secondsFromStart" url:"secondsFromStart"`
	// The duration of the message in seconds.
	Duration *float64 `json:"duration,omitempty" url:"duration,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserMessage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler UserMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserMessage) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type VapiCost struct {
	// This is the type of cost, always 'vapi' for this class.
	// This is the minutes of Vapi usage. This should match `call.endedAt` - `call.startedAt`.
	Minutes float64 `json:"minutes" url:"minutes"`
	// This is the cost of the component in USD.
	Cost  float64 `json:"cost" url:"cost"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VapiCost) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VapiCost) Type() string {
	return v.type_
}

func (v *VapiCost) UnmarshalJSON(data []byte) error {
	type embed VapiCost
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VapiCost(unmarshaler.embed)
	if unmarshaler.Type != "vapi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vapi", unmarshaler.Type)
	}
	v.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *v, "type")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VapiCost) MarshalJSON() ([]byte, error) {
	type embed VapiCost
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "vapi",
	}
	return json.Marshal(marshaler)
}

func (v *VapiCost) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VapiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*VapiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string              `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	Steps   []*VapiModelStepsItem `json:"steps,omitempty" url:"steps,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *KnowledgeBase `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VapiModel) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VapiModel) Provider() string {
	return v.provider
}

func (v *VapiModel) UnmarshalJSON(data []byte) error {
	type embed VapiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VapiModel(unmarshaler.embed)
	if unmarshaler.Provider != "vapi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vapi", unmarshaler.Provider)
	}
	v.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *v, "provider")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VapiModel) MarshalJSON() ([]byte, error) {
	type embed VapiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*v),
		Provider: "vapi",
	}
	return json.Marshal(marshaler)
}

func (v *VapiModel) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VapiModelStepsItem struct {
	HandoffStep  *HandoffStep
	CallbackStep *CallbackStep
}

func (v *VapiModelStepsItem) UnmarshalJSON(data []byte) error {
	valueHandoffStep := new(HandoffStep)
	if err := json.Unmarshal(data, &valueHandoffStep); err == nil {
		v.HandoffStep = valueHandoffStep
		return nil
	}
	valueCallbackStep := new(CallbackStep)
	if err := json.Unmarshal(data, &valueCallbackStep); err == nil {
		v.CallbackStep = valueCallbackStep
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VapiModelStepsItem) MarshalJSON() ([]byte, error) {
	if v.HandoffStep != nil {
		return json.Marshal(v.HandoffStep)
	}
	if v.CallbackStep != nil {
		return json.Marshal(v.CallbackStep)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VapiModelStepsItemVisitor interface {
	VisitHandoffStep(*HandoffStep) error
	VisitCallbackStep(*CallbackStep) error
}

func (v *VapiModelStepsItem) Accept(visitor VapiModelStepsItemVisitor) error {
	if v.HandoffStep != nil {
		return visitor.VisitHandoffStep(v.HandoffStep)
	}
	if v.CallbackStep != nil {
		return visitor.VisitCallbackStep(v.CallbackStep)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VapiModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto
}

func (v *VapiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		v.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		v.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		v.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		v.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		v.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		v.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		v.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VapiModelToolsItem) MarshalJSON() ([]byte, error) {
	if v.CreateDtmfToolDto != nil {
		return json.Marshal(v.CreateDtmfToolDto)
	}
	if v.CreateEndCallToolDto != nil {
		return json.Marshal(v.CreateEndCallToolDto)
	}
	if v.CreateVoicemailToolDto != nil {
		return json.Marshal(v.CreateVoicemailToolDto)
	}
	if v.CreateFunctionToolDto != nil {
		return json.Marshal(v.CreateFunctionToolDto)
	}
	if v.CreateGhlToolDto != nil {
		return json.Marshal(v.CreateGhlToolDto)
	}
	if v.CreateMakeToolDto != nil {
		return json.Marshal(v.CreateMakeToolDto)
	}
	if v.CreateTransferCallToolDto != nil {
		return json.Marshal(v.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VapiModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (v *VapiModelToolsItem) Accept(visitor VapiModelToolsItemVisitor) error {
	if v.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(v.CreateDtmfToolDto)
	}
	if v.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(v.CreateEndCallToolDto)
	}
	if v.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(v.CreateVoicemailToolDto)
	}
	if v.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(v.CreateFunctionToolDto)
	}
	if v.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(v.CreateGhlToolDto)
	}
	if v.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(v.CreateMakeToolDto)
	}
	if v.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(v.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VapiPhoneNumber struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *VapiPhoneNumberFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// This is the unique identifier for the phone number.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this phone number belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the phone number was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the phone number was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	// This is the SIP URI of the phone number. You can SIP INVITE this. The assistant attached to this number will answer.
	//
	// This is case-insensitive.
	SipUri   string `json:"sipUri" url:"sipUri"`
	provider string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VapiPhoneNumber) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VapiPhoneNumber) Provider() string {
	return v.provider
}

func (v *VapiPhoneNumber) UnmarshalJSON(data []byte) error {
	type embed VapiPhoneNumber
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VapiPhoneNumber(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.Time()
	v.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "vapi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vapi", unmarshaler.Provider)
	}
	v.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *v, "provider")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VapiPhoneNumber) MarshalJSON() ([]byte, error) {
	type embed VapiPhoneNumber
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*v),
		CreatedAt: core.NewDateTime(v.CreatedAt),
		UpdatedAt: core.NewDateTime(v.UpdatedAt),
		Provider:  "vapi",
	}
	return json.Marshal(marshaler)
}

func (v *VapiPhoneNumber) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type VapiPhoneNumberFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (v *VapiPhoneNumberFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		v.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		v.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VapiPhoneNumberFallbackDestination) MarshalJSON() ([]byte, error) {
	if v.TransferDestinationNumber != nil {
		return json.Marshal(v.TransferDestinationNumber)
	}
	if v.TransferDestinationSip != nil {
		return json.Marshal(v.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VapiPhoneNumberFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (v *VapiPhoneNumberFallbackDestination) Accept(visitor VapiPhoneNumberFallbackDestinationVisitor) error {
	if v.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(v.TransferDestinationNumber)
	}
	if v.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(v.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VoiceCost struct {
	// This is the type of cost, always 'voice' for this class.
	// This is the voice that was used during the call.
	//
	// This matches one of the following:
	//
	// - `call.assistant.voice`,
	// - `call.assistantId->voice`,
	// - `call.squad[n].assistant.voice`,
	// - `call.squad[n].assistantId->voice`,
	// - `call.squadId->[n].assistant.voice`,
	// - `call.squadId->[n].assistantId->voice`.
	Voice map[string]interface{} `json:"voice,omitempty" url:"voice,omitempty"`
	// This is the number of characters that were generated during the call. These should be total characters used in the call for single assistant calls, while squad calls will have multiple voice costs one for each assistant that was used.
	Characters float64 `json:"characters" url:"characters"`
	// This is the cost of the component in USD.
	Cost  float64 `json:"cost" url:"cost"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VoiceCost) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceCost) Type() string {
	return v.type_
}

func (v *VoiceCost) UnmarshalJSON(data []byte) error {
	type embed VoiceCost
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VoiceCost(unmarshaler.embed)
	if unmarshaler.Type != "voice" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "voice", unmarshaler.Type)
	}
	v.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *v, "type")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoiceCost) MarshalJSON() ([]byte, error) {
	type embed VoiceCost
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "voice",
	}
	return json.Marshal(marshaler)
}

func (v *VoiceCost) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VoiceLibrary struct {
	// This is the voice provider that will be used.
	Provider map[string]interface{} `json:"provider,omitempty" url:"provider,omitempty"`
	// The ID of the voice provided by the provider.
	ProviderId *string `json:"providerId,omitempty" url:"providerId,omitempty"`
	// The unique slug of the voice.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// The name of the voice.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The language of the voice.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The language code of the voice.
	LanguageCode *string `json:"languageCode,omitempty" url:"languageCode,omitempty"`
	// The model of the voice.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// The supported models of the voice.
	SupportedModels *string `json:"supportedModels,omitempty" url:"supportedModels,omitempty"`
	// The gender of the voice.
	Gender *VoiceLibraryGender `json:"gender,omitempty" url:"gender,omitempty"`
	// The accent of the voice.
	Accent *string `json:"accent,omitempty" url:"accent,omitempty"`
	// The preview URL of the voice.
	PreviewUrl *string `json:"previewUrl,omitempty" url:"previewUrl,omitempty"`
	// The description of the voice.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The credential ID of the voice.
	CredentialId *string `json:"credentialId,omitempty" url:"credentialId,omitempty"`
	// The unique identifier for the voice library.
	Id string `json:"id" url:"id"`
	// The unique identifier for the organization that this voice library belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// The Public voice is shared accross all the organizations.
	IsPublic bool `json:"isPublic" url:"isPublic"`
	// The deletion status of the voice.
	IsDeleted bool `json:"isDeleted" url:"isDeleted"`
	// The ISO 8601 date-time string of when the voice library was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The ISO 8601 date-time string of when the voice library was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VoiceLibrary) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceLibrary) UnmarshalJSON(data []byte) error {
	type embed VoiceLibrary
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VoiceLibrary(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.Time()
	v.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoiceLibrary) MarshalJSON() ([]byte, error) {
	type embed VoiceLibrary
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*v),
		CreatedAt: core.NewDateTime(v.CreatedAt),
		UpdatedAt: core.NewDateTime(v.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (v *VoiceLibrary) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The gender of the voice.
type VoiceLibraryGender string

const (
	VoiceLibraryGenderMale   VoiceLibraryGender = "male"
	VoiceLibraryGenderFemale VoiceLibraryGender = "female"
)

func NewVoiceLibraryGenderFromString(s string) (VoiceLibraryGender, error) {
	switch s {
	case "male":
		return VoiceLibraryGenderMale, nil
	case "female":
		return VoiceLibraryGenderFemale, nil
	}
	var t VoiceLibraryGender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VoiceLibraryGender) Ptr() *VoiceLibraryGender {
	return &v
}

type VoiceLibraryVoiceResponse struct {
	VoiceId       string                 `json:"voiceId" url:"voiceId"`
	Name          string                 `json:"name" url:"name"`
	PublicOwnerId *string                `json:"publicOwnerId,omitempty" url:"publicOwnerId,omitempty"`
	Description   *string                `json:"description,omitempty" url:"description,omitempty"`
	Gender        *string                `json:"gender,omitempty" url:"gender,omitempty"`
	Age           map[string]interface{} `json:"age,omitempty" url:"age,omitempty"`
	Accent        *string                `json:"accent,omitempty" url:"accent,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VoiceLibraryVoiceResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceLibraryVoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceLibraryVoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceLibraryVoiceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoiceLibraryVoiceResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VonageCredential struct {
	// This is not returned in the API.
	VonageApplicationPrivateKey string `json:"vonageApplicationPrivateKey" url:"vonageApplicationPrivateKey"`
	// This is not returned in the API.
	ApiSecret string `json:"apiSecret" url:"apiSecret"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the Vonage Application ID for the credential.
	//
	// Only relevant for Vonage credentials.
	VonageApplicationId string `json:"vonageApplicationId" url:"vonageApplicationId"`
	ApiKey              string `json:"apiKey" url:"apiKey"`
	provider            string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VonageCredential) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VonageCredential) Provider() string {
	return v.provider
}

func (v *VonageCredential) UnmarshalJSON(data []byte) error {
	type embed VonageCredential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VonageCredential(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.Time()
	v.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "vonage" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vonage", unmarshaler.Provider)
	}
	v.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *v, "provider")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VonageCredential) MarshalJSON() ([]byte, error) {
	type embed VonageCredential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*v),
		CreatedAt: core.NewDateTime(v.CreatedAt),
		UpdatedAt: core.NewDateTime(v.UpdatedAt),
		Provider:  "vonage",
	}
	return json.Marshal(marshaler)
}

func (v *VonageCredential) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VonagePhoneNumber struct {
	// This is the fallback destination an inbound call will be transferred to if:
	//
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *VonagePhoneNumberFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// This is the unique identifier for the phone number.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this phone number belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the phone number was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the phone number was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the server URL where messages will be sent for calls on this number. This includes the `assistant-request` message.
	//
	// You can see the shape of the messages sent in `ServerMessage`.
	//
	// This overrides the `org.serverUrl`. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl.
	ServerUrl *string `json:"serverUrl,omitempty" url:"serverUrl,omitempty"`
	// This is the secret Vapi will send with every message to your server. It's sent as a header called x-vapi-secret.
	//
	// Same precedence logic as serverUrl.
	ServerUrlSecret *string `json:"serverUrlSecret,omitempty" url:"serverUrlSecret,omitempty"`
	// These are the digits of the phone number you own on your Vonage.
	Number string `json:"number" url:"number"`
	// This is the credential that is used to make outgoing calls, and do operations like call transfer and hang up.
	CredentialId string `json:"credentialId" url:"credentialId"`
	provider     string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VonagePhoneNumber) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VonagePhoneNumber) Provider() string {
	return v.provider
}

func (v *VonagePhoneNumber) UnmarshalJSON(data []byte) error {
	type embed VonagePhoneNumber
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VonagePhoneNumber(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.Time()
	v.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "vonage" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vonage", unmarshaler.Provider)
	}
	v.provider = unmarshaler.Provider

	extraProperties, err := core.ExtractExtraProperties(data, *v, "provider")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VonagePhoneNumber) MarshalJSON() ([]byte, error) {
	type embed VonagePhoneNumber
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Provider  string         `json:"provider"`
	}{
		embed:     embed(*v),
		CreatedAt: core.NewDateTime(v.CreatedAt),
		UpdatedAt: core.NewDateTime(v.UpdatedAt),
		Provider:  "vonage",
	}
	return json.Marshal(marshaler)
}

func (v *VonagePhoneNumber) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// This is the fallback destination an inbound call will be transferred to if:
//
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type VonagePhoneNumberFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip
}

func (v *VonagePhoneNumberFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		v.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		v.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VonagePhoneNumberFallbackDestination) MarshalJSON() ([]byte, error) {
	if v.TransferDestinationNumber != nil {
		return json.Marshal(v.TransferDestinationNumber)
	}
	if v.TransferDestinationSip != nil {
		return json.Marshal(v.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VonagePhoneNumberFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (v *VonagePhoneNumberFallbackDestination) Accept(visitor VonagePhoneNumberFallbackDestinationVisitor) error {
	if v.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(v.TransferDestinationNumber)
	}
	if v.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(v.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type WorkflowBlock struct {
	// These are the pre-configured messages that will be spoken to the user while the block is running.
	Messages []*WorkflowBlockMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the input schema for the block. This is the input the block needs to run. It's given to the block as `steps[0].input`
	//
	// These are accessible as variables:
	//
	// - ({{input.propertyName}}) in context of the block execution (step)
	// - ({{stepName.input.propertyName}}) in context of the workflow
	InputSchema *JsonSchema `json:"inputSchema,omitempty" url:"inputSchema,omitempty"`
	// This is the output schema for the block. This is the output the block will return to the workflow (`{{stepName.output}}`).
	//
	// These are accessible as variables:
	//
	// - ({{output.propertyName}}) in context of the block execution (step)
	// - ({{stepName.output.propertyName}}) in context of the workflow (read caveat #1)
	// - ({{blockName.output.propertyName}}) in context of the workflow (read caveat #2)
	//
	// Caveats:
	//
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	OutputSchema *JsonSchema `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	// These are the steps in the workflow.
	Steps []*WorkflowBlockStepsItem `json:"steps,omitempty" url:"steps,omitempty"`
	// This is the unique identifier for the block.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this block belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the block was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the block was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of the block. This is just for your reference.
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WorkflowBlock) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkflowBlock) Type() string {
	return w.type_
}

func (w *WorkflowBlock) UnmarshalJSON(data []byte) error {
	type embed WorkflowBlock
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = WorkflowBlock(unmarshaler.embed)
	w.CreatedAt = unmarshaler.CreatedAt.Time()
	w.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "workflow" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", w, "workflow", unmarshaler.Type)
	}
	w.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *w, "type")
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkflowBlock) MarshalJSON() ([]byte, error) {
	type embed WorkflowBlock
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		Type      string         `json:"type"`
	}{
		embed:     embed(*w),
		CreatedAt: core.NewDateTime(w.CreatedAt),
		UpdatedAt: core.NewDateTime(w.UpdatedAt),
		Type:      "workflow",
	}
	return json.Marshal(marshaler)
}

func (w *WorkflowBlock) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WorkflowBlockMessagesItem struct {
	BlockStartMessage    *BlockStartMessage
	BlockCompleteMessage *BlockCompleteMessage
}

func (w *WorkflowBlockMessagesItem) UnmarshalJSON(data []byte) error {
	valueBlockStartMessage := new(BlockStartMessage)
	if err := json.Unmarshal(data, &valueBlockStartMessage); err == nil {
		w.BlockStartMessage = valueBlockStartMessage
		return nil
	}
	valueBlockCompleteMessage := new(BlockCompleteMessage)
	if err := json.Unmarshal(data, &valueBlockCompleteMessage); err == nil {
		w.BlockCompleteMessage = valueBlockCompleteMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, w)
}

func (w WorkflowBlockMessagesItem) MarshalJSON() ([]byte, error) {
	if w.BlockStartMessage != nil {
		return json.Marshal(w.BlockStartMessage)
	}
	if w.BlockCompleteMessage != nil {
		return json.Marshal(w.BlockCompleteMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", w)
}

type WorkflowBlockMessagesItemVisitor interface {
	VisitBlockStartMessage(*BlockStartMessage) error
	VisitBlockCompleteMessage(*BlockCompleteMessage) error
}

func (w *WorkflowBlockMessagesItem) Accept(visitor WorkflowBlockMessagesItemVisitor) error {
	if w.BlockStartMessage != nil {
		return visitor.VisitBlockStartMessage(w.BlockStartMessage)
	}
	if w.BlockCompleteMessage != nil {
		return visitor.VisitBlockCompleteMessage(w.BlockCompleteMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", w)
}

type WorkflowBlockStepsItem struct {
	HandoffStep  *HandoffStep
	CallbackStep *CallbackStep
}

func (w *WorkflowBlockStepsItem) UnmarshalJSON(data []byte) error {
	valueHandoffStep := new(HandoffStep)
	if err := json.Unmarshal(data, &valueHandoffStep); err == nil {
		w.HandoffStep = valueHandoffStep
		return nil
	}
	valueCallbackStep := new(CallbackStep)
	if err := json.Unmarshal(data, &valueCallbackStep); err == nil {
		w.CallbackStep = valueCallbackStep
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, w)
}

func (w WorkflowBlockStepsItem) MarshalJSON() ([]byte, error) {
	if w.HandoffStep != nil {
		return json.Marshal(w.HandoffStep)
	}
	if w.CallbackStep != nil {
		return json.Marshal(w.CallbackStep)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", w)
}

type WorkflowBlockStepsItemVisitor interface {
	VisitHandoffStep(*HandoffStep) error
	VisitCallbackStep(*CallbackStep) error
}

func (w *WorkflowBlockStepsItem) Accept(visitor WorkflowBlockStepsItemVisitor) error {
	if w.HandoffStep != nil {
		return visitor.VisitHandoffStep(w.HandoffStep)
	}
	if w.CallbackStep != nil {
		return visitor.VisitCallbackStep(w.CallbackStep)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", w)
}
