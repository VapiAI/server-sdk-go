// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/VapiAI/server-sdk-go/v505/internal"
	big "math/big"
	time "time"
)

var (
	evalControllerGetRequestFieldId = big.NewInt(1 << 0)
)

type EvalControllerGetRequest struct {
	Id string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EvalControllerGetRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRequest) SetId(id string) {
	e.Id = id
	e.require(evalControllerGetRequestFieldId)
}

var (
	evalControllerGetPaginatedRequestFieldId          = big.NewInt(1 << 0)
	evalControllerGetPaginatedRequestFieldPage        = big.NewInt(1 << 1)
	evalControllerGetPaginatedRequestFieldSortOrder   = big.NewInt(1 << 2)
	evalControllerGetPaginatedRequestFieldLimit       = big.NewInt(1 << 3)
	evalControllerGetPaginatedRequestFieldCreatedAtGt = big.NewInt(1 << 4)
	evalControllerGetPaginatedRequestFieldCreatedAtLt = big.NewInt(1 << 5)
	evalControllerGetPaginatedRequestFieldCreatedAtGe = big.NewInt(1 << 6)
	evalControllerGetPaginatedRequestFieldCreatedAtLe = big.NewInt(1 << 7)
	evalControllerGetPaginatedRequestFieldUpdatedAtGt = big.NewInt(1 << 8)
	evalControllerGetPaginatedRequestFieldUpdatedAtLt = big.NewInt(1 << 9)
	evalControllerGetPaginatedRequestFieldUpdatedAtGe = big.NewInt(1 << 10)
	evalControllerGetPaginatedRequestFieldUpdatedAtLe = big.NewInt(1 << 11)
)

type EvalControllerGetPaginatedRequest struct {
	Id *string `json:"-" url:"id,omitempty"`
	// This is the page number to return. Defaults to 1.
	Page *float64 `json:"-" url:"page,omitempty"`
	// This is the sort order for pagination. Defaults to 'DESC'.
	SortOrder *EvalControllerGetPaginatedRequestSortOrder `json:"-" url:"sortOrder,omitempty"`
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EvalControllerGetPaginatedRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetId(id *string) {
	e.Id = id
	e.require(evalControllerGetPaginatedRequestFieldId)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetPage(page *float64) {
	e.Page = page
	e.require(evalControllerGetPaginatedRequestFieldPage)
}

// SetSortOrder sets the SortOrder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetSortOrder(sortOrder *EvalControllerGetPaginatedRequestSortOrder) {
	e.SortOrder = sortOrder
	e.require(evalControllerGetPaginatedRequestFieldSortOrder)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetLimit(limit *float64) {
	e.Limit = limit
	e.require(evalControllerGetPaginatedRequestFieldLimit)
}

// SetCreatedAtGt sets the CreatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetCreatedAtGt(createdAtGt *time.Time) {
	e.CreatedAtGt = createdAtGt
	e.require(evalControllerGetPaginatedRequestFieldCreatedAtGt)
}

// SetCreatedAtLt sets the CreatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetCreatedAtLt(createdAtLt *time.Time) {
	e.CreatedAtLt = createdAtLt
	e.require(evalControllerGetPaginatedRequestFieldCreatedAtLt)
}

// SetCreatedAtGe sets the CreatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetCreatedAtGe(createdAtGe *time.Time) {
	e.CreatedAtGe = createdAtGe
	e.require(evalControllerGetPaginatedRequestFieldCreatedAtGe)
}

// SetCreatedAtLe sets the CreatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetCreatedAtLe(createdAtLe *time.Time) {
	e.CreatedAtLe = createdAtLe
	e.require(evalControllerGetPaginatedRequestFieldCreatedAtLe)
}

// SetUpdatedAtGt sets the UpdatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetUpdatedAtGt(updatedAtGt *time.Time) {
	e.UpdatedAtGt = updatedAtGt
	e.require(evalControllerGetPaginatedRequestFieldUpdatedAtGt)
}

// SetUpdatedAtLt sets the UpdatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetUpdatedAtLt(updatedAtLt *time.Time) {
	e.UpdatedAtLt = updatedAtLt
	e.require(evalControllerGetPaginatedRequestFieldUpdatedAtLt)
}

// SetUpdatedAtGe sets the UpdatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetUpdatedAtGe(updatedAtGe *time.Time) {
	e.UpdatedAtGe = updatedAtGe
	e.require(evalControllerGetPaginatedRequestFieldUpdatedAtGe)
}

// SetUpdatedAtLe sets the UpdatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetUpdatedAtLe(updatedAtLe *time.Time) {
	e.UpdatedAtLe = updatedAtLe
	e.require(evalControllerGetPaginatedRequestFieldUpdatedAtLe)
}

var (
	evalControllerGetRunRequestFieldId = big.NewInt(1 << 0)
)

type EvalControllerGetRunRequest struct {
	Id string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EvalControllerGetRunRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunRequest) SetId(id string) {
	e.Id = id
	e.require(evalControllerGetRunRequestFieldId)
}

var (
	evalControllerGetRunsPaginatedRequestFieldId          = big.NewInt(1 << 0)
	evalControllerGetRunsPaginatedRequestFieldPage        = big.NewInt(1 << 1)
	evalControllerGetRunsPaginatedRequestFieldSortOrder   = big.NewInt(1 << 2)
	evalControllerGetRunsPaginatedRequestFieldLimit       = big.NewInt(1 << 3)
	evalControllerGetRunsPaginatedRequestFieldCreatedAtGt = big.NewInt(1 << 4)
	evalControllerGetRunsPaginatedRequestFieldCreatedAtLt = big.NewInt(1 << 5)
	evalControllerGetRunsPaginatedRequestFieldCreatedAtGe = big.NewInt(1 << 6)
	evalControllerGetRunsPaginatedRequestFieldCreatedAtLe = big.NewInt(1 << 7)
	evalControllerGetRunsPaginatedRequestFieldUpdatedAtGt = big.NewInt(1 << 8)
	evalControllerGetRunsPaginatedRequestFieldUpdatedAtLt = big.NewInt(1 << 9)
	evalControllerGetRunsPaginatedRequestFieldUpdatedAtGe = big.NewInt(1 << 10)
	evalControllerGetRunsPaginatedRequestFieldUpdatedAtLe = big.NewInt(1 << 11)
)

type EvalControllerGetRunsPaginatedRequest struct {
	Id *string `json:"-" url:"id,omitempty"`
	// This is the page number to return. Defaults to 1.
	Page *float64 `json:"-" url:"page,omitempty"`
	// This is the sort order for pagination. Defaults to 'DESC'.
	SortOrder *EvalControllerGetRunsPaginatedRequestSortOrder `json:"-" url:"sortOrder,omitempty"`
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EvalControllerGetRunsPaginatedRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetId(id *string) {
	e.Id = id
	e.require(evalControllerGetRunsPaginatedRequestFieldId)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetPage(page *float64) {
	e.Page = page
	e.require(evalControllerGetRunsPaginatedRequestFieldPage)
}

// SetSortOrder sets the SortOrder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetSortOrder(sortOrder *EvalControllerGetRunsPaginatedRequestSortOrder) {
	e.SortOrder = sortOrder
	e.require(evalControllerGetRunsPaginatedRequestFieldSortOrder)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetLimit(limit *float64) {
	e.Limit = limit
	e.require(evalControllerGetRunsPaginatedRequestFieldLimit)
}

// SetCreatedAtGt sets the CreatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetCreatedAtGt(createdAtGt *time.Time) {
	e.CreatedAtGt = createdAtGt
	e.require(evalControllerGetRunsPaginatedRequestFieldCreatedAtGt)
}

// SetCreatedAtLt sets the CreatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetCreatedAtLt(createdAtLt *time.Time) {
	e.CreatedAtLt = createdAtLt
	e.require(evalControllerGetRunsPaginatedRequestFieldCreatedAtLt)
}

// SetCreatedAtGe sets the CreatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetCreatedAtGe(createdAtGe *time.Time) {
	e.CreatedAtGe = createdAtGe
	e.require(evalControllerGetRunsPaginatedRequestFieldCreatedAtGe)
}

// SetCreatedAtLe sets the CreatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetCreatedAtLe(createdAtLe *time.Time) {
	e.CreatedAtLe = createdAtLe
	e.require(evalControllerGetRunsPaginatedRequestFieldCreatedAtLe)
}

// SetUpdatedAtGt sets the UpdatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetUpdatedAtGt(updatedAtGt *time.Time) {
	e.UpdatedAtGt = updatedAtGt
	e.require(evalControllerGetRunsPaginatedRequestFieldUpdatedAtGt)
}

// SetUpdatedAtLt sets the UpdatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetUpdatedAtLt(updatedAtLt *time.Time) {
	e.UpdatedAtLt = updatedAtLt
	e.require(evalControllerGetRunsPaginatedRequestFieldUpdatedAtLt)
}

// SetUpdatedAtGe sets the UpdatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetUpdatedAtGe(updatedAtGe *time.Time) {
	e.UpdatedAtGe = updatedAtGe
	e.require(evalControllerGetRunsPaginatedRequestFieldUpdatedAtGe)
}

// SetUpdatedAtLe sets the UpdatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetUpdatedAtLe(updatedAtLe *time.Time) {
	e.UpdatedAtLe = updatedAtLe
	e.require(evalControllerGetRunsPaginatedRequestFieldUpdatedAtLe)
}

var (
	evalControllerRemoveRequestFieldId = big.NewInt(1 << 0)
)

type EvalControllerRemoveRequest struct {
	Id string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EvalControllerRemoveRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerRemoveRequest) SetId(id string) {
	e.Id = id
	e.require(evalControllerRemoveRequestFieldId)
}

var (
	evalControllerRemoveRunRequestFieldId = big.NewInt(1 << 0)
)

type EvalControllerRemoveRunRequest struct {
	Id string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EvalControllerRemoveRunRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerRemoveRunRequest) SetId(id string) {
	e.Id = id
	e.require(evalControllerRemoveRunRequestFieldId)
}

var (
	createEvalRunDtoFieldEval   = big.NewInt(1 << 0)
	createEvalRunDtoFieldTarget = big.NewInt(1 << 1)
	createEvalRunDtoFieldType   = big.NewInt(1 << 2)
	createEvalRunDtoFieldEvalId = big.NewInt(1 << 3)
)

type CreateEvalRunDto struct {
	// This is the transient eval that will be run
	Eval *CreateEvalDto `json:"eval,omitempty" url:"-"`
	// This is the target that will be run against the eval
	Target *CreateEvalRunDtoTarget `json:"target,omitempty" url:"-"`
	// This is the type of the run.
	// Currently it is fixed to `eval`.
	Type CreateEvalRunDtoType `json:"type" url:"-"`
	// This is the id of the eval that will be run.
	EvalId *string `json:"evalId,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CreateEvalRunDto) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetEval sets the Eval field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalRunDto) SetEval(eval *CreateEvalDto) {
	c.Eval = eval
	c.require(createEvalRunDtoFieldEval)
}

// SetTarget sets the Target field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalRunDto) SetTarget(target *CreateEvalRunDtoTarget) {
	c.Target = target
	c.require(createEvalRunDtoFieldTarget)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalRunDto) SetType(type_ CreateEvalRunDtoType) {
	c.Type = type_
	c.require(createEvalRunDtoFieldType)
}

// SetEvalId sets the EvalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalRunDto) SetEvalId(evalId *string) {
	c.EvalId = evalId
	c.require(createEvalRunDtoFieldEvalId)
}

var (
	updateEvalDtoFieldId          = big.NewInt(1 << 0)
	updateEvalDtoFieldMessages    = big.NewInt(1 << 1)
	updateEvalDtoFieldName        = big.NewInt(1 << 2)
	updateEvalDtoFieldDescription = big.NewInt(1 << 3)
	updateEvalDtoFieldType        = big.NewInt(1 << 4)
)

type UpdateEvalDto struct {
	Id string `json:"-" url:"-"`
	// This is the mock conversation that will be used to evaluate the flow of the conversation.
	//
	// # Mock Messages are used to simulate the flow of the conversation
	//
	// Evaluation Messages are used as checkpoints in the flow where the model's response to previous conversation needs to be evaluated to check the content and tool calls
	Messages []*UpdateEvalDtoMessagesItem `json:"messages,omitempty" url:"-"`
	// This is the name of the eval.
	// It helps identify what the eval is checking for.
	Name *string `json:"name,omitempty" url:"-"`
	// This is the description of the eval.
	// This helps describe the eval and its purpose in detail. It will not be used to evaluate the flow of the conversation.
	Description *string `json:"description,omitempty" url:"-"`
	// This is the type of the eval.
	// Currently it is fixed to `chat.mockConversation`.
	Type *UpdateEvalDtoType `json:"type,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UpdateEvalDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEvalDto) SetId(id string) {
	u.Id = id
	u.require(updateEvalDtoFieldId)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEvalDto) SetMessages(messages []*UpdateEvalDtoMessagesItem) {
	u.Messages = messages
	u.require(updateEvalDtoFieldMessages)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEvalDto) SetName(name *string) {
	u.Name = name
	u.require(updateEvalDtoFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEvalDto) SetDescription(description *string) {
	u.Description = description
	u.require(updateEvalDtoFieldDescription)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEvalDto) SetType(type_ *UpdateEvalDtoType) {
	u.Type = type_
	u.require(updateEvalDtoFieldType)
}

var (
	assistantMessageEvaluationContinuePlanFieldExitOnFailureEnabled = big.NewInt(1 << 0)
	assistantMessageEvaluationContinuePlanFieldContentOverride      = big.NewInt(1 << 1)
	assistantMessageEvaluationContinuePlanFieldToolCallsOverride    = big.NewInt(1 << 2)
)

type AssistantMessageEvaluationContinuePlan struct {
	// This is whether the evaluation should exit if the assistant message evaluates to false.
	// By default, it is false and the evaluation will continue.
	// @default false
	ExitOnFailureEnabled *bool `json:"exitOnFailureEnabled,omitempty" url:"exitOnFailureEnabled,omitempty"`
	// This is the content that will be used in the conversation for this assistant turn moving forward if provided.
	// It will override the content received from the model.
	ContentOverride *string `json:"contentOverride,omitempty" url:"contentOverride,omitempty"`
	// This is the tool calls that will be used in the conversation for this assistant turn moving forward if provided.
	// It will override the tool calls received from the model.
	ToolCallsOverride []*ChatEvalAssistantMessageMockToolCall `json:"toolCallsOverride,omitempty" url:"toolCallsOverride,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessageEvaluationContinuePlan) GetExitOnFailureEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.ExitOnFailureEnabled
}

func (a *AssistantMessageEvaluationContinuePlan) GetContentOverride() *string {
	if a == nil {
		return nil
	}
	return a.ContentOverride
}

func (a *AssistantMessageEvaluationContinuePlan) GetToolCallsOverride() []*ChatEvalAssistantMessageMockToolCall {
	if a == nil {
		return nil
	}
	return a.ToolCallsOverride
}

func (a *AssistantMessageEvaluationContinuePlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessageEvaluationContinuePlan) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetExitOnFailureEnabled sets the ExitOnFailureEnabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageEvaluationContinuePlan) SetExitOnFailureEnabled(exitOnFailureEnabled *bool) {
	a.ExitOnFailureEnabled = exitOnFailureEnabled
	a.require(assistantMessageEvaluationContinuePlanFieldExitOnFailureEnabled)
}

// SetContentOverride sets the ContentOverride field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageEvaluationContinuePlan) SetContentOverride(contentOverride *string) {
	a.ContentOverride = contentOverride
	a.require(assistantMessageEvaluationContinuePlanFieldContentOverride)
}

// SetToolCallsOverride sets the ToolCallsOverride field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageEvaluationContinuePlan) SetToolCallsOverride(toolCallsOverride []*ChatEvalAssistantMessageMockToolCall) {
	a.ToolCallsOverride = toolCallsOverride
	a.require(assistantMessageEvaluationContinuePlanFieldToolCallsOverride)
}

func (a *AssistantMessageEvaluationContinuePlan) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantMessageEvaluationContinuePlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantMessageEvaluationContinuePlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessageEvaluationContinuePlan) MarshalJSON() ([]byte, error) {
	type embed AssistantMessageEvaluationContinuePlan
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AssistantMessageEvaluationContinuePlan) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	assistantMessageJudgePlanAiFieldModel = big.NewInt(1 << 0)
	assistantMessageJudgePlanAiFieldType  = big.NewInt(1 << 1)
)

type AssistantMessageJudgePlanAi struct {
	// This is the model to use for the LLM-as-a-judge.
	// If not provided, will default to the assistant's model.
	//
	// The instructions on how to evaluate the model output with this LLM-Judge must be passed as a system message in the messages array of the model.
	//
	// The Mock conversation can be passed to the LLM-Judge to evaluate using the prompt {{messages}} and will be evaluated as a LiquidJS Variable. To access and judge only the last message, use {{messages[-1]}}
	//
	// The LLM-Judge must respond with "pass" or "fail" and only those two responses are allowed.
	Model *AssistantMessageJudgePlanAiModel `json:"model" url:"model"`
	// This is the type of the judge plan.
	// Use 'ai' to evaluate the assistant message content using LLM-as-a-judge.
	// @default 'ai'
	Type AssistantMessageJudgePlanAiType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessageJudgePlanAi) GetModel() *AssistantMessageJudgePlanAiModel {
	if a == nil {
		return nil
	}
	return a.Model
}

func (a *AssistantMessageJudgePlanAi) GetType() AssistantMessageJudgePlanAiType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AssistantMessageJudgePlanAi) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessageJudgePlanAi) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanAi) SetModel(model *AssistantMessageJudgePlanAiModel) {
	a.Model = model
	a.require(assistantMessageJudgePlanAiFieldModel)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanAi) SetType(type_ AssistantMessageJudgePlanAiType) {
	a.Type = type_
	a.require(assistantMessageJudgePlanAiFieldType)
}

func (a *AssistantMessageJudgePlanAi) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantMessageJudgePlanAi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantMessageJudgePlanAi(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessageJudgePlanAi) MarshalJSON() ([]byte, error) {
	type embed AssistantMessageJudgePlanAi
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AssistantMessageJudgePlanAi) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the model to use for the LLM-as-a-judge.
// If not provided, will default to the assistant's model.
//
// The instructions on how to evaluate the model output with this LLM-Judge must be passed as a system message in the messages array of the model.
//
// The Mock conversation can be passed to the LLM-Judge to evaluate using the prompt {{messages}} and will be evaluated as a LiquidJS Variable. To access and judge only the last message, use {{messages[-1]}}
//
// The LLM-Judge must respond with "pass" or "fail" and only those two responses are allowed.
type AssistantMessageJudgePlanAiModel struct {
	EvalOpenAiModel    *EvalOpenAiModel
	EvalAnthropicModel *EvalAnthropicModel
	EvalGoogleModel    *EvalGoogleModel
	EvalCustomModel    *EvalCustomModel

	typ string
}

func (a *AssistantMessageJudgePlanAiModel) GetEvalOpenAiModel() *EvalOpenAiModel {
	if a == nil {
		return nil
	}
	return a.EvalOpenAiModel
}

func (a *AssistantMessageJudgePlanAiModel) GetEvalAnthropicModel() *EvalAnthropicModel {
	if a == nil {
		return nil
	}
	return a.EvalAnthropicModel
}

func (a *AssistantMessageJudgePlanAiModel) GetEvalGoogleModel() *EvalGoogleModel {
	if a == nil {
		return nil
	}
	return a.EvalGoogleModel
}

func (a *AssistantMessageJudgePlanAiModel) GetEvalCustomModel() *EvalCustomModel {
	if a == nil {
		return nil
	}
	return a.EvalCustomModel
}

func (a *AssistantMessageJudgePlanAiModel) UnmarshalJSON(data []byte) error {
	valueEvalOpenAiModel := new(EvalOpenAiModel)
	if err := json.Unmarshal(data, &valueEvalOpenAiModel); err == nil {
		a.typ = "EvalOpenAiModel"
		a.EvalOpenAiModel = valueEvalOpenAiModel
		return nil
	}
	valueEvalAnthropicModel := new(EvalAnthropicModel)
	if err := json.Unmarshal(data, &valueEvalAnthropicModel); err == nil {
		a.typ = "EvalAnthropicModel"
		a.EvalAnthropicModel = valueEvalAnthropicModel
		return nil
	}
	valueEvalGoogleModel := new(EvalGoogleModel)
	if err := json.Unmarshal(data, &valueEvalGoogleModel); err == nil {
		a.typ = "EvalGoogleModel"
		a.EvalGoogleModel = valueEvalGoogleModel
		return nil
	}
	valueEvalCustomModel := new(EvalCustomModel)
	if err := json.Unmarshal(data, &valueEvalCustomModel); err == nil {
		a.typ = "EvalCustomModel"
		a.EvalCustomModel = valueEvalCustomModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantMessageJudgePlanAiModel) MarshalJSON() ([]byte, error) {
	if a.typ == "EvalOpenAiModel" || a.EvalOpenAiModel != nil {
		return json.Marshal(a.EvalOpenAiModel)
	}
	if a.typ == "EvalAnthropicModel" || a.EvalAnthropicModel != nil {
		return json.Marshal(a.EvalAnthropicModel)
	}
	if a.typ == "EvalGoogleModel" || a.EvalGoogleModel != nil {
		return json.Marshal(a.EvalGoogleModel)
	}
	if a.typ == "EvalCustomModel" || a.EvalCustomModel != nil {
		return json.Marshal(a.EvalCustomModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantMessageJudgePlanAiModelVisitor interface {
	VisitEvalOpenAiModel(*EvalOpenAiModel) error
	VisitEvalAnthropicModel(*EvalAnthropicModel) error
	VisitEvalGoogleModel(*EvalGoogleModel) error
	VisitEvalCustomModel(*EvalCustomModel) error
}

func (a *AssistantMessageJudgePlanAiModel) Accept(visitor AssistantMessageJudgePlanAiModelVisitor) error {
	if a.typ == "EvalOpenAiModel" || a.EvalOpenAiModel != nil {
		return visitor.VisitEvalOpenAiModel(a.EvalOpenAiModel)
	}
	if a.typ == "EvalAnthropicModel" || a.EvalAnthropicModel != nil {
		return visitor.VisitEvalAnthropicModel(a.EvalAnthropicModel)
	}
	if a.typ == "EvalGoogleModel" || a.EvalGoogleModel != nil {
		return visitor.VisitEvalGoogleModel(a.EvalGoogleModel)
	}
	if a.typ == "EvalCustomModel" || a.EvalCustomModel != nil {
		return visitor.VisitEvalCustomModel(a.EvalCustomModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// This is the type of the judge plan.
// Use 'ai' to evaluate the assistant message content using LLM-as-a-judge.
// @default 'ai'
type AssistantMessageJudgePlanAiType string

const (
	AssistantMessageJudgePlanAiTypeAi AssistantMessageJudgePlanAiType = "ai"
)

func NewAssistantMessageJudgePlanAiTypeFromString(s string) (AssistantMessageJudgePlanAiType, error) {
	switch s {
	case "ai":
		return AssistantMessageJudgePlanAiTypeAi, nil
	}
	var t AssistantMessageJudgePlanAiType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantMessageJudgePlanAiType) Ptr() *AssistantMessageJudgePlanAiType {
	return &a
}

var (
	assistantMessageJudgePlanExactFieldType      = big.NewInt(1 << 0)
	assistantMessageJudgePlanExactFieldContent   = big.NewInt(1 << 1)
	assistantMessageJudgePlanExactFieldToolCalls = big.NewInt(1 << 2)
)

type AssistantMessageJudgePlanExact struct {
	// This is the type of the judge plan.
	// Use 'exact' for an exact match on the content and tool calls - without using LLM-as-a-judge.
	// @default 'exact'
	Type AssistantMessageJudgePlanExactType `json:"type" url:"type"`
	// This is what that will be used to evaluate the model's message content.
	// If you provide a string, the assistant message content will be evaluated against it as an exact match, case-insensitive.
	Content string `json:"content" url:"content"`
	// This is the tool calls that will be used to evaluate the model's message content.
	// The tool name must be a valid tool that the assistant is allowed to call.
	//
	// For the Query tool, the arguments for the tool call are in the format - {knowledgeBaseNames: ['kb_name', 'kb_name_2']}
	//
	// For the DTMF tool, the arguments for the tool call are in the format - {dtmf: "1234*"}
	//
	// For the Handoff tool, the arguments for the tool call are in the format - {destination: "assistant_id"}
	//
	// For the Transfer Call tool, the arguments for the tool call are in the format - {destination: "phone_number_or_assistant_id"}
	//
	// For all other tools, they are called without arguments or with user-defined arguments
	ToolCalls []*ChatEvalAssistantMessageMockToolCall `json:"toolCalls,omitempty" url:"toolCalls,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessageJudgePlanExact) GetType() AssistantMessageJudgePlanExactType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AssistantMessageJudgePlanExact) GetContent() string {
	if a == nil {
		return ""
	}
	return a.Content
}

func (a *AssistantMessageJudgePlanExact) GetToolCalls() []*ChatEvalAssistantMessageMockToolCall {
	if a == nil {
		return nil
	}
	return a.ToolCalls
}

func (a *AssistantMessageJudgePlanExact) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessageJudgePlanExact) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanExact) SetType(type_ AssistantMessageJudgePlanExactType) {
	a.Type = type_
	a.require(assistantMessageJudgePlanExactFieldType)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanExact) SetContent(content string) {
	a.Content = content
	a.require(assistantMessageJudgePlanExactFieldContent)
}

// SetToolCalls sets the ToolCalls field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanExact) SetToolCalls(toolCalls []*ChatEvalAssistantMessageMockToolCall) {
	a.ToolCalls = toolCalls
	a.require(assistantMessageJudgePlanExactFieldToolCalls)
}

func (a *AssistantMessageJudgePlanExact) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantMessageJudgePlanExact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantMessageJudgePlanExact(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessageJudgePlanExact) MarshalJSON() ([]byte, error) {
	type embed AssistantMessageJudgePlanExact
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AssistantMessageJudgePlanExact) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the type of the judge plan.
// Use 'exact' for an exact match on the content and tool calls - without using LLM-as-a-judge.
// @default 'exact'
type AssistantMessageJudgePlanExactType string

const (
	AssistantMessageJudgePlanExactTypeExact AssistantMessageJudgePlanExactType = "exact"
)

func NewAssistantMessageJudgePlanExactTypeFromString(s string) (AssistantMessageJudgePlanExactType, error) {
	switch s {
	case "exact":
		return AssistantMessageJudgePlanExactTypeExact, nil
	}
	var t AssistantMessageJudgePlanExactType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantMessageJudgePlanExactType) Ptr() *AssistantMessageJudgePlanExactType {
	return &a
}

var (
	assistantMessageJudgePlanRegexFieldType      = big.NewInt(1 << 0)
	assistantMessageJudgePlanRegexFieldContent   = big.NewInt(1 << 1)
	assistantMessageJudgePlanRegexFieldToolCalls = big.NewInt(1 << 2)
)

type AssistantMessageJudgePlanRegex struct {
	// This is the type of the judge plan.
	// Use 'regex' for a regex match on the content and tool calls - without using LLM-as-a-judge.
	// @default 'regex'
	Type AssistantMessageJudgePlanRegexType `json:"type" url:"type"`
	// This is what that will be used to evaluate the model's message content.
	// The content will be evaluated against the regex pattern provided in the Judge Plan content field.
	// Evaluation is considered successful if the regex pattern matches any part of the assistant message content.
	Content string `json:"content" url:"content"`
	// This is the tool calls that will be used to evaluate the model's message content.
	// The tool name must be a valid tool that the assistant is allowed to call.
	// The values to the arguments for the tool call should be a Regular Expression.
	// Evaluation is considered successful if the regex pattern matches any part of each tool call argument.
	//
	// For the Query tool, the arguments for the tool call are in the format - {knowledgeBaseNames: ['kb_name', 'kb_name_2']}
	//
	// For the DTMF tool, the arguments for the tool call are in the format - {dtmf: "1234*"}
	//
	// For the Handoff tool, the arguments for the tool call are in the format - {destination: "assistant_id"}
	//
	// For the Transfer Call tool, the arguments for the tool call are in the format - {destination: "phone_number_or_assistant_id"}
	//
	// For all other tools, they are called without arguments or with user-defined arguments
	ToolCalls []*ChatEvalAssistantMessageMockToolCall `json:"toolCalls,omitempty" url:"toolCalls,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessageJudgePlanRegex) GetType() AssistantMessageJudgePlanRegexType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AssistantMessageJudgePlanRegex) GetContent() string {
	if a == nil {
		return ""
	}
	return a.Content
}

func (a *AssistantMessageJudgePlanRegex) GetToolCalls() []*ChatEvalAssistantMessageMockToolCall {
	if a == nil {
		return nil
	}
	return a.ToolCalls
}

func (a *AssistantMessageJudgePlanRegex) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessageJudgePlanRegex) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanRegex) SetType(type_ AssistantMessageJudgePlanRegexType) {
	a.Type = type_
	a.require(assistantMessageJudgePlanRegexFieldType)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanRegex) SetContent(content string) {
	a.Content = content
	a.require(assistantMessageJudgePlanRegexFieldContent)
}

// SetToolCalls sets the ToolCalls field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanRegex) SetToolCalls(toolCalls []*ChatEvalAssistantMessageMockToolCall) {
	a.ToolCalls = toolCalls
	a.require(assistantMessageJudgePlanRegexFieldToolCalls)
}

func (a *AssistantMessageJudgePlanRegex) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantMessageJudgePlanRegex
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantMessageJudgePlanRegex(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessageJudgePlanRegex) MarshalJSON() ([]byte, error) {
	type embed AssistantMessageJudgePlanRegex
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AssistantMessageJudgePlanRegex) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the type of the judge plan.
// Use 'regex' for a regex match on the content and tool calls - without using LLM-as-a-judge.
// @default 'regex'
type AssistantMessageJudgePlanRegexType string

const (
	AssistantMessageJudgePlanRegexTypeRegex AssistantMessageJudgePlanRegexType = "regex"
)

func NewAssistantMessageJudgePlanRegexTypeFromString(s string) (AssistantMessageJudgePlanRegexType, error) {
	switch s {
	case "regex":
		return AssistantMessageJudgePlanRegexTypeRegex, nil
	}
	var t AssistantMessageJudgePlanRegexType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantMessageJudgePlanRegexType) Ptr() *AssistantMessageJudgePlanRegexType {
	return &a
}

var (
	chatEvalAssistantMessageEvaluationFieldRole         = big.NewInt(1 << 0)
	chatEvalAssistantMessageEvaluationFieldJudgePlan    = big.NewInt(1 << 1)
	chatEvalAssistantMessageEvaluationFieldContinuePlan = big.NewInt(1 << 2)
)

type ChatEvalAssistantMessageEvaluation struct {
	// This is the role of the message author.
	// For an assistant message evaluation, the role is always 'assistant'
	// @default 'assistant'
	Role ChatEvalAssistantMessageEvaluationRole `json:"role" url:"role"`
	// This is the judge plan that instructs how to evaluate the assistant message.
	// The assistant message can be evaluated against fixed content (exact match or RegEx) or with an LLM-as-judge by defining the evaluation criteria in a prompt.
	JudgePlan *ChatEvalAssistantMessageEvaluationJudgePlan `json:"judgePlan" url:"judgePlan"`
	// This is the plan for how the overall evaluation will proceed after the assistant message is evaluated.
	// This lets you configure whether to stop the evaluation if this message fails, and whether to override any content for future turns
	ContinuePlan *AssistantMessageEvaluationContinuePlan `json:"continuePlan,omitempty" url:"continuePlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalAssistantMessageEvaluation) GetRole() ChatEvalAssistantMessageEvaluationRole {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ChatEvalAssistantMessageEvaluation) GetJudgePlan() *ChatEvalAssistantMessageEvaluationJudgePlan {
	if c == nil {
		return nil
	}
	return c.JudgePlan
}

func (c *ChatEvalAssistantMessageEvaluation) GetContinuePlan() *AssistantMessageEvaluationContinuePlan {
	if c == nil {
		return nil
	}
	return c.ContinuePlan
}

func (c *ChatEvalAssistantMessageEvaluation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalAssistantMessageEvaluation) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetRole sets the Role field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageEvaluation) SetRole(role ChatEvalAssistantMessageEvaluationRole) {
	c.Role = role
	c.require(chatEvalAssistantMessageEvaluationFieldRole)
}

// SetJudgePlan sets the JudgePlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageEvaluation) SetJudgePlan(judgePlan *ChatEvalAssistantMessageEvaluationJudgePlan) {
	c.JudgePlan = judgePlan
	c.require(chatEvalAssistantMessageEvaluationFieldJudgePlan)
}

// SetContinuePlan sets the ContinuePlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageEvaluation) SetContinuePlan(continuePlan *AssistantMessageEvaluationContinuePlan) {
	c.ContinuePlan = continuePlan
	c.require(chatEvalAssistantMessageEvaluationFieldContinuePlan)
}

func (c *ChatEvalAssistantMessageEvaluation) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatEvalAssistantMessageEvaluation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatEvalAssistantMessageEvaluation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalAssistantMessageEvaluation) MarshalJSON() ([]byte, error) {
	type embed ChatEvalAssistantMessageEvaluation
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalAssistantMessageEvaluation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the judge plan that instructs how to evaluate the assistant message.
// The assistant message can be evaluated against fixed content (exact match or RegEx) or with an LLM-as-judge by defining the evaluation criteria in a prompt.
type ChatEvalAssistantMessageEvaluationJudgePlan struct {
	AssistantMessageJudgePlanExact *AssistantMessageJudgePlanExact
	AssistantMessageJudgePlanRegex *AssistantMessageJudgePlanRegex
	AssistantMessageJudgePlanAi    *AssistantMessageJudgePlanAi

	typ string
}

func (c *ChatEvalAssistantMessageEvaluationJudgePlan) GetAssistantMessageJudgePlanExact() *AssistantMessageJudgePlanExact {
	if c == nil {
		return nil
	}
	return c.AssistantMessageJudgePlanExact
}

func (c *ChatEvalAssistantMessageEvaluationJudgePlan) GetAssistantMessageJudgePlanRegex() *AssistantMessageJudgePlanRegex {
	if c == nil {
		return nil
	}
	return c.AssistantMessageJudgePlanRegex
}

func (c *ChatEvalAssistantMessageEvaluationJudgePlan) GetAssistantMessageJudgePlanAi() *AssistantMessageJudgePlanAi {
	if c == nil {
		return nil
	}
	return c.AssistantMessageJudgePlanAi
}

func (c *ChatEvalAssistantMessageEvaluationJudgePlan) UnmarshalJSON(data []byte) error {
	valueAssistantMessageJudgePlanExact := new(AssistantMessageJudgePlanExact)
	if err := json.Unmarshal(data, &valueAssistantMessageJudgePlanExact); err == nil {
		c.typ = "AssistantMessageJudgePlanExact"
		c.AssistantMessageJudgePlanExact = valueAssistantMessageJudgePlanExact
		return nil
	}
	valueAssistantMessageJudgePlanRegex := new(AssistantMessageJudgePlanRegex)
	if err := json.Unmarshal(data, &valueAssistantMessageJudgePlanRegex); err == nil {
		c.typ = "AssistantMessageJudgePlanRegex"
		c.AssistantMessageJudgePlanRegex = valueAssistantMessageJudgePlanRegex
		return nil
	}
	valueAssistantMessageJudgePlanAi := new(AssistantMessageJudgePlanAi)
	if err := json.Unmarshal(data, &valueAssistantMessageJudgePlanAi); err == nil {
		c.typ = "AssistantMessageJudgePlanAi"
		c.AssistantMessageJudgePlanAi = valueAssistantMessageJudgePlanAi
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatEvalAssistantMessageEvaluationJudgePlan) MarshalJSON() ([]byte, error) {
	if c.typ == "AssistantMessageJudgePlanExact" || c.AssistantMessageJudgePlanExact != nil {
		return json.Marshal(c.AssistantMessageJudgePlanExact)
	}
	if c.typ == "AssistantMessageJudgePlanRegex" || c.AssistantMessageJudgePlanRegex != nil {
		return json.Marshal(c.AssistantMessageJudgePlanRegex)
	}
	if c.typ == "AssistantMessageJudgePlanAi" || c.AssistantMessageJudgePlanAi != nil {
		return json.Marshal(c.AssistantMessageJudgePlanAi)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatEvalAssistantMessageEvaluationJudgePlanVisitor interface {
	VisitAssistantMessageJudgePlanExact(*AssistantMessageJudgePlanExact) error
	VisitAssistantMessageJudgePlanRegex(*AssistantMessageJudgePlanRegex) error
	VisitAssistantMessageJudgePlanAi(*AssistantMessageJudgePlanAi) error
}

func (c *ChatEvalAssistantMessageEvaluationJudgePlan) Accept(visitor ChatEvalAssistantMessageEvaluationJudgePlanVisitor) error {
	if c.typ == "AssistantMessageJudgePlanExact" || c.AssistantMessageJudgePlanExact != nil {
		return visitor.VisitAssistantMessageJudgePlanExact(c.AssistantMessageJudgePlanExact)
	}
	if c.typ == "AssistantMessageJudgePlanRegex" || c.AssistantMessageJudgePlanRegex != nil {
		return visitor.VisitAssistantMessageJudgePlanRegex(c.AssistantMessageJudgePlanRegex)
	}
	if c.typ == "AssistantMessageJudgePlanAi" || c.AssistantMessageJudgePlanAi != nil {
		return visitor.VisitAssistantMessageJudgePlanAi(c.AssistantMessageJudgePlanAi)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the role of the message author.
// For an assistant message evaluation, the role is always 'assistant'
// @default 'assistant'
type ChatEvalAssistantMessageEvaluationRole string

const (
	ChatEvalAssistantMessageEvaluationRoleAssistant ChatEvalAssistantMessageEvaluationRole = "assistant"
)

func NewChatEvalAssistantMessageEvaluationRoleFromString(s string) (ChatEvalAssistantMessageEvaluationRole, error) {
	switch s {
	case "assistant":
		return ChatEvalAssistantMessageEvaluationRoleAssistant, nil
	}
	var t ChatEvalAssistantMessageEvaluationRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatEvalAssistantMessageEvaluationRole) Ptr() *ChatEvalAssistantMessageEvaluationRole {
	return &c
}

var (
	chatEvalAssistantMessageMockFieldRole      = big.NewInt(1 << 0)
	chatEvalAssistantMessageMockFieldContent   = big.NewInt(1 << 1)
	chatEvalAssistantMessageMockFieldToolCalls = big.NewInt(1 << 2)
)

type ChatEvalAssistantMessageMock struct {
	// This is the role of the message author.
	// For a mock assistant message, the role is always 'assistant'
	// @default 'assistant'
	Role ChatEvalAssistantMessageMockRole `json:"role" url:"role"`
	// This is the content of the assistant message.
	// This is the message that the assistant would have sent.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is the tool calls that will be made by the assistant.
	ToolCalls []*ChatEvalAssistantMessageMockToolCall `json:"toolCalls,omitempty" url:"toolCalls,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalAssistantMessageMock) GetRole() ChatEvalAssistantMessageMockRole {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ChatEvalAssistantMessageMock) GetContent() *string {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *ChatEvalAssistantMessageMock) GetToolCalls() []*ChatEvalAssistantMessageMockToolCall {
	if c == nil {
		return nil
	}
	return c.ToolCalls
}

func (c *ChatEvalAssistantMessageMock) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalAssistantMessageMock) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetRole sets the Role field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageMock) SetRole(role ChatEvalAssistantMessageMockRole) {
	c.Role = role
	c.require(chatEvalAssistantMessageMockFieldRole)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageMock) SetContent(content *string) {
	c.Content = content
	c.require(chatEvalAssistantMessageMockFieldContent)
}

// SetToolCalls sets the ToolCalls field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageMock) SetToolCalls(toolCalls []*ChatEvalAssistantMessageMockToolCall) {
	c.ToolCalls = toolCalls
	c.require(chatEvalAssistantMessageMockFieldToolCalls)
}

func (c *ChatEvalAssistantMessageMock) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatEvalAssistantMessageMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatEvalAssistantMessageMock(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalAssistantMessageMock) MarshalJSON() ([]byte, error) {
	type embed ChatEvalAssistantMessageMock
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalAssistantMessageMock) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the role of the message author.
// For a mock assistant message, the role is always 'assistant'
// @default 'assistant'
type ChatEvalAssistantMessageMockRole string

const (
	ChatEvalAssistantMessageMockRoleAssistant ChatEvalAssistantMessageMockRole = "assistant"
)

func NewChatEvalAssistantMessageMockRoleFromString(s string) (ChatEvalAssistantMessageMockRole, error) {
	switch s {
	case "assistant":
		return ChatEvalAssistantMessageMockRoleAssistant, nil
	}
	var t ChatEvalAssistantMessageMockRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatEvalAssistantMessageMockRole) Ptr() *ChatEvalAssistantMessageMockRole {
	return &c
}

var (
	chatEvalAssistantMessageMockToolCallFieldName      = big.NewInt(1 << 0)
	chatEvalAssistantMessageMockToolCallFieldArguments = big.NewInt(1 << 1)
)

type ChatEvalAssistantMessageMockToolCall struct {
	// This is the name of the tool that will be called.
	// It should be one of the tools created in the organization.
	Name string `json:"name" url:"name"`
	// This is the arguments that will be passed to the tool call.
	Arguments map[string]interface{} `json:"arguments,omitempty" url:"arguments,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalAssistantMessageMockToolCall) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *ChatEvalAssistantMessageMockToolCall) GetArguments() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Arguments
}

func (c *ChatEvalAssistantMessageMockToolCall) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalAssistantMessageMockToolCall) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageMockToolCall) SetName(name string) {
	c.Name = name
	c.require(chatEvalAssistantMessageMockToolCallFieldName)
}

// SetArguments sets the Arguments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageMockToolCall) SetArguments(arguments map[string]interface{}) {
	c.Arguments = arguments
	c.require(chatEvalAssistantMessageMockToolCallFieldArguments)
}

func (c *ChatEvalAssistantMessageMockToolCall) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatEvalAssistantMessageMockToolCall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatEvalAssistantMessageMockToolCall(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalAssistantMessageMockToolCall) MarshalJSON() ([]byte, error) {
	type embed ChatEvalAssistantMessageMockToolCall
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalAssistantMessageMockToolCall) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	chatEvalSystemMessageMockFieldRole    = big.NewInt(1 << 0)
	chatEvalSystemMessageMockFieldContent = big.NewInt(1 << 1)
)

type ChatEvalSystemMessageMock struct {
	// This is the role of the message author.
	// For a mock system message, the role is always 'system'
	// @default 'system'
	Role ChatEvalSystemMessageMockRole `json:"role" url:"role"`
	// This is the content of the system message that would have been added in the middle of the conversation.
	// Do not include the assistant prompt as a part of this message. It will automatically be fetched during runtime.
	Content string `json:"content" url:"content"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalSystemMessageMock) GetRole() ChatEvalSystemMessageMockRole {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ChatEvalSystemMessageMock) GetContent() string {
	if c == nil {
		return ""
	}
	return c.Content
}

func (c *ChatEvalSystemMessageMock) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalSystemMessageMock) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetRole sets the Role field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalSystemMessageMock) SetRole(role ChatEvalSystemMessageMockRole) {
	c.Role = role
	c.require(chatEvalSystemMessageMockFieldRole)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalSystemMessageMock) SetContent(content string) {
	c.Content = content
	c.require(chatEvalSystemMessageMockFieldContent)
}

func (c *ChatEvalSystemMessageMock) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatEvalSystemMessageMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatEvalSystemMessageMock(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalSystemMessageMock) MarshalJSON() ([]byte, error) {
	type embed ChatEvalSystemMessageMock
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalSystemMessageMock) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the role of the message author.
// For a mock system message, the role is always 'system'
// @default 'system'
type ChatEvalSystemMessageMockRole string

const (
	ChatEvalSystemMessageMockRoleSystem ChatEvalSystemMessageMockRole = "system"
)

func NewChatEvalSystemMessageMockRoleFromString(s string) (ChatEvalSystemMessageMockRole, error) {
	switch s {
	case "system":
		return ChatEvalSystemMessageMockRoleSystem, nil
	}
	var t ChatEvalSystemMessageMockRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatEvalSystemMessageMockRole) Ptr() *ChatEvalSystemMessageMockRole {
	return &c
}

var (
	chatEvalToolResponseMessageEvaluationFieldRole      = big.NewInt(1 << 0)
	chatEvalToolResponseMessageEvaluationFieldJudgePlan = big.NewInt(1 << 1)
)

type ChatEvalToolResponseMessageEvaluation struct {
	// This is the role of the message author.
	// For a tool response message evaluation, the role is always 'tool'
	// @default 'tool'
	Role ChatEvalToolResponseMessageEvaluationRole `json:"role" url:"role"`
	// This is the judge plan that instructs how to evaluate the tool response message.
	// The tool response message can be evaluated with an LLM-as-judge by defining the evaluation criteria in a prompt.
	JudgePlan *AssistantMessageJudgePlanAi `json:"judgePlan" url:"judgePlan"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalToolResponseMessageEvaluation) GetRole() ChatEvalToolResponseMessageEvaluationRole {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ChatEvalToolResponseMessageEvaluation) GetJudgePlan() *AssistantMessageJudgePlanAi {
	if c == nil {
		return nil
	}
	return c.JudgePlan
}

func (c *ChatEvalToolResponseMessageEvaluation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalToolResponseMessageEvaluation) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetRole sets the Role field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalToolResponseMessageEvaluation) SetRole(role ChatEvalToolResponseMessageEvaluationRole) {
	c.Role = role
	c.require(chatEvalToolResponseMessageEvaluationFieldRole)
}

// SetJudgePlan sets the JudgePlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalToolResponseMessageEvaluation) SetJudgePlan(judgePlan *AssistantMessageJudgePlanAi) {
	c.JudgePlan = judgePlan
	c.require(chatEvalToolResponseMessageEvaluationFieldJudgePlan)
}

func (c *ChatEvalToolResponseMessageEvaluation) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatEvalToolResponseMessageEvaluation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatEvalToolResponseMessageEvaluation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalToolResponseMessageEvaluation) MarshalJSON() ([]byte, error) {
	type embed ChatEvalToolResponseMessageEvaluation
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalToolResponseMessageEvaluation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the role of the message author.
// For a tool response message evaluation, the role is always 'tool'
// @default 'tool'
type ChatEvalToolResponseMessageEvaluationRole string

const (
	ChatEvalToolResponseMessageEvaluationRoleTool ChatEvalToolResponseMessageEvaluationRole = "tool"
)

func NewChatEvalToolResponseMessageEvaluationRoleFromString(s string) (ChatEvalToolResponseMessageEvaluationRole, error) {
	switch s {
	case "tool":
		return ChatEvalToolResponseMessageEvaluationRoleTool, nil
	}
	var t ChatEvalToolResponseMessageEvaluationRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatEvalToolResponseMessageEvaluationRole) Ptr() *ChatEvalToolResponseMessageEvaluationRole {
	return &c
}

var (
	chatEvalToolResponseMessageMockFieldRole    = big.NewInt(1 << 0)
	chatEvalToolResponseMessageMockFieldContent = big.NewInt(1 << 1)
)

type ChatEvalToolResponseMessageMock struct {
	// This is the role of the message author.
	// For a mock tool response message, the role is always 'tool'
	// @default 'tool'
	Role ChatEvalToolResponseMessageMockRole `json:"role" url:"role"`
	// This is the content of the tool response message. JSON Objects should be stringified.
	Content string `json:"content" url:"content"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalToolResponseMessageMock) GetRole() ChatEvalToolResponseMessageMockRole {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ChatEvalToolResponseMessageMock) GetContent() string {
	if c == nil {
		return ""
	}
	return c.Content
}

func (c *ChatEvalToolResponseMessageMock) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalToolResponseMessageMock) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetRole sets the Role field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalToolResponseMessageMock) SetRole(role ChatEvalToolResponseMessageMockRole) {
	c.Role = role
	c.require(chatEvalToolResponseMessageMockFieldRole)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalToolResponseMessageMock) SetContent(content string) {
	c.Content = content
	c.require(chatEvalToolResponseMessageMockFieldContent)
}

func (c *ChatEvalToolResponseMessageMock) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatEvalToolResponseMessageMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatEvalToolResponseMessageMock(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalToolResponseMessageMock) MarshalJSON() ([]byte, error) {
	type embed ChatEvalToolResponseMessageMock
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalToolResponseMessageMock) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the role of the message author.
// For a mock tool response message, the role is always 'tool'
// @default 'tool'
type ChatEvalToolResponseMessageMockRole string

const (
	ChatEvalToolResponseMessageMockRoleTool ChatEvalToolResponseMessageMockRole = "tool"
)

func NewChatEvalToolResponseMessageMockRoleFromString(s string) (ChatEvalToolResponseMessageMockRole, error) {
	switch s {
	case "tool":
		return ChatEvalToolResponseMessageMockRoleTool, nil
	}
	var t ChatEvalToolResponseMessageMockRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatEvalToolResponseMessageMockRole) Ptr() *ChatEvalToolResponseMessageMockRole {
	return &c
}

var (
	chatEvalUserMessageMockFieldRole    = big.NewInt(1 << 0)
	chatEvalUserMessageMockFieldContent = big.NewInt(1 << 1)
)

type ChatEvalUserMessageMock struct {
	// This is the role of the message author.
	// For a mock user message, the role is always 'user'
	// @default 'user'
	Role ChatEvalUserMessageMockRole `json:"role" url:"role"`
	// This is the content of the user message.
	// This is the message that the user would have sent.
	Content string `json:"content" url:"content"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalUserMessageMock) GetRole() ChatEvalUserMessageMockRole {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ChatEvalUserMessageMock) GetContent() string {
	if c == nil {
		return ""
	}
	return c.Content
}

func (c *ChatEvalUserMessageMock) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalUserMessageMock) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetRole sets the Role field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalUserMessageMock) SetRole(role ChatEvalUserMessageMockRole) {
	c.Role = role
	c.require(chatEvalUserMessageMockFieldRole)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalUserMessageMock) SetContent(content string) {
	c.Content = content
	c.require(chatEvalUserMessageMockFieldContent)
}

func (c *ChatEvalUserMessageMock) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatEvalUserMessageMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatEvalUserMessageMock(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalUserMessageMock) MarshalJSON() ([]byte, error) {
	type embed ChatEvalUserMessageMock
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalUserMessageMock) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the role of the message author.
// For a mock user message, the role is always 'user'
// @default 'user'
type ChatEvalUserMessageMockRole string

const (
	ChatEvalUserMessageMockRoleUser ChatEvalUserMessageMockRole = "user"
)

func NewChatEvalUserMessageMockRoleFromString(s string) (ChatEvalUserMessageMockRole, error) {
	switch s {
	case "user":
		return ChatEvalUserMessageMockRoleUser, nil
	}
	var t ChatEvalUserMessageMockRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatEvalUserMessageMockRole) Ptr() *ChatEvalUserMessageMockRole {
	return &c
}

var (
	createEvalDtoFieldMessages    = big.NewInt(1 << 0)
	createEvalDtoFieldName        = big.NewInt(1 << 1)
	createEvalDtoFieldDescription = big.NewInt(1 << 2)
	createEvalDtoFieldType        = big.NewInt(1 << 3)
)

type CreateEvalDto struct {
	// This is the mock conversation that will be used to evaluate the flow of the conversation.
	//
	// # Mock Messages are used to simulate the flow of the conversation
	//
	// Evaluation Messages are used as checkpoints in the flow where the model's response to previous conversation needs to be evaluated to check the content and tool calls
	Messages []*CreateEvalDtoMessagesItem `json:"messages" url:"messages"`
	// This is the name of the eval.
	// It helps identify what the eval is checking for.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the description of the eval.
	// This helps describe the eval and its purpose in detail. It will not be used to evaluate the flow of the conversation.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is the type of the eval.
	// Currently it is fixed to `chat.mockConversation`.
	Type CreateEvalDtoType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateEvalDto) GetMessages() []*CreateEvalDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateEvalDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateEvalDto) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateEvalDto) GetType() CreateEvalDtoType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CreateEvalDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateEvalDto) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalDto) SetMessages(messages []*CreateEvalDtoMessagesItem) {
	c.Messages = messages
	c.require(createEvalDtoFieldMessages)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalDto) SetName(name *string) {
	c.Name = name
	c.require(createEvalDtoFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalDto) SetDescription(description *string) {
	c.Description = description
	c.require(createEvalDtoFieldDescription)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalDto) SetType(type_ CreateEvalDtoType) {
	c.Type = type_
	c.require(createEvalDtoFieldType)
}

func (c *CreateEvalDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateEvalDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateEvalDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEvalDto) MarshalJSON() ([]byte, error) {
	type embed CreateEvalDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateEvalDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEvalDtoMessagesItem struct {
	ChatEvalAssistantMessageMock          *ChatEvalAssistantMessageMock
	ChatEvalSystemMessageMock             *ChatEvalSystemMessageMock
	ChatEvalToolResponseMessageMock       *ChatEvalToolResponseMessageMock
	ChatEvalToolResponseMessageEvaluation *ChatEvalToolResponseMessageEvaluation
	ChatEvalUserMessageMock               *ChatEvalUserMessageMock
	ChatEvalAssistantMessageEvaluation    *ChatEvalAssistantMessageEvaluation

	typ string
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalAssistantMessageMock() *ChatEvalAssistantMessageMock {
	if c == nil {
		return nil
	}
	return c.ChatEvalAssistantMessageMock
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalSystemMessageMock() *ChatEvalSystemMessageMock {
	if c == nil {
		return nil
	}
	return c.ChatEvalSystemMessageMock
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalToolResponseMessageMock() *ChatEvalToolResponseMessageMock {
	if c == nil {
		return nil
	}
	return c.ChatEvalToolResponseMessageMock
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalToolResponseMessageEvaluation() *ChatEvalToolResponseMessageEvaluation {
	if c == nil {
		return nil
	}
	return c.ChatEvalToolResponseMessageEvaluation
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalUserMessageMock() *ChatEvalUserMessageMock {
	if c == nil {
		return nil
	}
	return c.ChatEvalUserMessageMock
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalAssistantMessageEvaluation() *ChatEvalAssistantMessageEvaluation {
	if c == nil {
		return nil
	}
	return c.ChatEvalAssistantMessageEvaluation
}

func (c *CreateEvalDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueChatEvalAssistantMessageMock := new(ChatEvalAssistantMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageMock); err == nil {
		c.typ = "ChatEvalAssistantMessageMock"
		c.ChatEvalAssistantMessageMock = valueChatEvalAssistantMessageMock
		return nil
	}
	valueChatEvalSystemMessageMock := new(ChatEvalSystemMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalSystemMessageMock); err == nil {
		c.typ = "ChatEvalSystemMessageMock"
		c.ChatEvalSystemMessageMock = valueChatEvalSystemMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageMock := new(ChatEvalToolResponseMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageMock); err == nil {
		c.typ = "ChatEvalToolResponseMessageMock"
		c.ChatEvalToolResponseMessageMock = valueChatEvalToolResponseMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageEvaluation := new(ChatEvalToolResponseMessageEvaluation)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageEvaluation); err == nil {
		c.typ = "ChatEvalToolResponseMessageEvaluation"
		c.ChatEvalToolResponseMessageEvaluation = valueChatEvalToolResponseMessageEvaluation
		return nil
	}
	valueChatEvalUserMessageMock := new(ChatEvalUserMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalUserMessageMock); err == nil {
		c.typ = "ChatEvalUserMessageMock"
		c.ChatEvalUserMessageMock = valueChatEvalUserMessageMock
		return nil
	}
	valueChatEvalAssistantMessageEvaluation := new(ChatEvalAssistantMessageEvaluation)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageEvaluation); err == nil {
		c.typ = "ChatEvalAssistantMessageEvaluation"
		c.ChatEvalAssistantMessageEvaluation = valueChatEvalAssistantMessageEvaluation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEvalDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ChatEvalAssistantMessageMock" || c.ChatEvalAssistantMessageMock != nil {
		return json.Marshal(c.ChatEvalAssistantMessageMock)
	}
	if c.typ == "ChatEvalSystemMessageMock" || c.ChatEvalSystemMessageMock != nil {
		return json.Marshal(c.ChatEvalSystemMessageMock)
	}
	if c.typ == "ChatEvalToolResponseMessageMock" || c.ChatEvalToolResponseMessageMock != nil {
		return json.Marshal(c.ChatEvalToolResponseMessageMock)
	}
	if c.typ == "ChatEvalToolResponseMessageEvaluation" || c.ChatEvalToolResponseMessageEvaluation != nil {
		return json.Marshal(c.ChatEvalToolResponseMessageEvaluation)
	}
	if c.typ == "ChatEvalUserMessageMock" || c.ChatEvalUserMessageMock != nil {
		return json.Marshal(c.ChatEvalUserMessageMock)
	}
	if c.typ == "ChatEvalAssistantMessageEvaluation" || c.ChatEvalAssistantMessageEvaluation != nil {
		return json.Marshal(c.ChatEvalAssistantMessageEvaluation)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateEvalDtoMessagesItemVisitor interface {
	VisitChatEvalAssistantMessageMock(*ChatEvalAssistantMessageMock) error
	VisitChatEvalSystemMessageMock(*ChatEvalSystemMessageMock) error
	VisitChatEvalToolResponseMessageMock(*ChatEvalToolResponseMessageMock) error
	VisitChatEvalToolResponseMessageEvaluation(*ChatEvalToolResponseMessageEvaluation) error
	VisitChatEvalUserMessageMock(*ChatEvalUserMessageMock) error
	VisitChatEvalAssistantMessageEvaluation(*ChatEvalAssistantMessageEvaluation) error
}

func (c *CreateEvalDtoMessagesItem) Accept(visitor CreateEvalDtoMessagesItemVisitor) error {
	if c.typ == "ChatEvalAssistantMessageMock" || c.ChatEvalAssistantMessageMock != nil {
		return visitor.VisitChatEvalAssistantMessageMock(c.ChatEvalAssistantMessageMock)
	}
	if c.typ == "ChatEvalSystemMessageMock" || c.ChatEvalSystemMessageMock != nil {
		return visitor.VisitChatEvalSystemMessageMock(c.ChatEvalSystemMessageMock)
	}
	if c.typ == "ChatEvalToolResponseMessageMock" || c.ChatEvalToolResponseMessageMock != nil {
		return visitor.VisitChatEvalToolResponseMessageMock(c.ChatEvalToolResponseMessageMock)
	}
	if c.typ == "ChatEvalToolResponseMessageEvaluation" || c.ChatEvalToolResponseMessageEvaluation != nil {
		return visitor.VisitChatEvalToolResponseMessageEvaluation(c.ChatEvalToolResponseMessageEvaluation)
	}
	if c.typ == "ChatEvalUserMessageMock" || c.ChatEvalUserMessageMock != nil {
		return visitor.VisitChatEvalUserMessageMock(c.ChatEvalUserMessageMock)
	}
	if c.typ == "ChatEvalAssistantMessageEvaluation" || c.ChatEvalAssistantMessageEvaluation != nil {
		return visitor.VisitChatEvalAssistantMessageEvaluation(c.ChatEvalAssistantMessageEvaluation)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the type of the eval.
// Currently it is fixed to `chat.mockConversation`.
type CreateEvalDtoType string

const (
	CreateEvalDtoTypeChatMockConversation CreateEvalDtoType = "chat.mockConversation"
)

func NewCreateEvalDtoTypeFromString(s string) (CreateEvalDtoType, error) {
	switch s {
	case "chat.mockConversation":
		return CreateEvalDtoTypeChatMockConversation, nil
	}
	var t CreateEvalDtoType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateEvalDtoType) Ptr() *CreateEvalDtoType {
	return &c
}

var (
	evalFieldMessages    = big.NewInt(1 << 0)
	evalFieldId          = big.NewInt(1 << 1)
	evalFieldOrgId       = big.NewInt(1 << 2)
	evalFieldCreatedAt   = big.NewInt(1 << 3)
	evalFieldUpdatedAt   = big.NewInt(1 << 4)
	evalFieldName        = big.NewInt(1 << 5)
	evalFieldDescription = big.NewInt(1 << 6)
	evalFieldType        = big.NewInt(1 << 7)
)

type Eval struct {
	// This is the mock conversation that will be used to evaluate the flow of the conversation.
	//
	// # Mock Messages are used to simulate the flow of the conversation
	//
	// Evaluation Messages are used as checkpoints in the flow where the model's response to previous conversation needs to be evaluated to check the content and tool calls
	Messages  []*EvalMessagesItem `json:"messages" url:"messages"`
	Id        string              `json:"id" url:"id"`
	OrgId     string              `json:"orgId" url:"orgId"`
	CreatedAt time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time           `json:"updatedAt" url:"updatedAt"`
	// This is the name of the eval.
	// It helps identify what the eval is checking for.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the description of the eval.
	// This helps describe the eval and its purpose in detail. It will not be used to evaluate the flow of the conversation.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is the type of the eval.
	// Currently it is fixed to `chat.mockConversation`.
	Type EvalType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Eval) GetMessages() []*EvalMessagesItem {
	if e == nil {
		return nil
	}
	return e.Messages
}

func (e *Eval) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *Eval) GetOrgId() string {
	if e == nil {
		return ""
	}
	return e.OrgId
}

func (e *Eval) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *Eval) GetUpdatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.UpdatedAt
}

func (e *Eval) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *Eval) GetDescription() *string {
	if e == nil {
		return nil
	}
	return e.Description
}

func (e *Eval) GetType() EvalType {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *Eval) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Eval) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetMessages(messages []*EvalMessagesItem) {
	e.Messages = messages
	e.require(evalFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetId(id string) {
	e.Id = id
	e.require(evalFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetOrgId(orgId string) {
	e.OrgId = orgId
	e.require(evalFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetCreatedAt(createdAt time.Time) {
	e.CreatedAt = createdAt
	e.require(evalFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetUpdatedAt(updatedAt time.Time) {
	e.UpdatedAt = updatedAt
	e.require(evalFieldUpdatedAt)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetName(name *string) {
	e.Name = name
	e.require(evalFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetDescription(description *string) {
	e.Description = description
	e.require(evalFieldDescription)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetType(type_ EvalType) {
	e.Type = type_
	e.require(evalFieldType)
}

func (e *Eval) UnmarshalJSON(data []byte) error {
	type embed Eval
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Eval(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Eval) MarshalJSON() ([]byte, error) {
	type embed Eval
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		UpdatedAt: internal.NewDateTime(e.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *Eval) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	evalAnthropicModelFieldProvider    = big.NewInt(1 << 0)
	evalAnthropicModelFieldModel       = big.NewInt(1 << 1)
	evalAnthropicModelFieldThinking    = big.NewInt(1 << 2)
	evalAnthropicModelFieldTemperature = big.NewInt(1 << 3)
	evalAnthropicModelFieldMaxTokens   = big.NewInt(1 << 4)
	evalAnthropicModelFieldMessages    = big.NewInt(1 << 5)
)

type EvalAnthropicModel struct {
	// This is the provider of the model (`anthropic`).
	Provider EvalAnthropicModelProvider `json:"provider" url:"provider"`
	// This is the specific model that will be used.
	Model EvalAnthropicModelModel `json:"model" url:"model"`
	// This is the optional configuration for Anthropic's thinking feature.
	//
	// - Only applicable for `claude-3-7-sonnet-20250219` model.
	// - If provided, `maxTokens` must be greater than `thinking.budgetTokens`.
	Thinking *AnthropicThinkingConfig `json:"thinking,omitempty" url:"thinking,omitempty"`
	// This is the temperature of the model. For LLM-as-a-judge, it's recommended to set it between 0 - 0.3 to avoid hallucinations and ensure the model judges the output correctly based on the instructions.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max tokens of the model.
	// If your Judge instructions return `true` or `false` takes only 1 token (as per the OpenAI Tokenizer), and therefore is recommended to set it to a low number to force the model to return a short response.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// These are the messages which will instruct the AI Judge on how to evaluate the assistant message.
	// The LLM-Judge must respond with "pass" or "fail" to indicate if the assistant message passes the eval.
	//
	// To access the messages in the mock conversation, use the LiquidJS variable `{{messages}}`.
	// The assistant message to be evaluated will be passed as the last message in the `messages` array and can be accessed using `{{messages[-1]}}`.
	//
	// It is recommended to use the system message to instruct the LLM how to evaluate the assistant message, and then use the first user message to pass the assistant message to be evaluated.
	Messages []map[string]interface{} `json:"messages" url:"messages"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalAnthropicModel) GetProvider() EvalAnthropicModelProvider {
	if e == nil {
		return ""
	}
	return e.Provider
}

func (e *EvalAnthropicModel) GetModel() EvalAnthropicModelModel {
	if e == nil {
		return ""
	}
	return e.Model
}

func (e *EvalAnthropicModel) GetThinking() *AnthropicThinkingConfig {
	if e == nil {
		return nil
	}
	return e.Thinking
}

func (e *EvalAnthropicModel) GetTemperature() *float64 {
	if e == nil {
		return nil
	}
	return e.Temperature
}

func (e *EvalAnthropicModel) GetMaxTokens() *float64 {
	if e == nil {
		return nil
	}
	return e.MaxTokens
}

func (e *EvalAnthropicModel) GetMessages() []map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Messages
}

func (e *EvalAnthropicModel) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalAnthropicModel) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalAnthropicModel) SetProvider(provider EvalAnthropicModelProvider) {
	e.Provider = provider
	e.require(evalAnthropicModelFieldProvider)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalAnthropicModel) SetModel(model EvalAnthropicModelModel) {
	e.Model = model
	e.require(evalAnthropicModelFieldModel)
}

// SetThinking sets the Thinking field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalAnthropicModel) SetThinking(thinking *AnthropicThinkingConfig) {
	e.Thinking = thinking
	e.require(evalAnthropicModelFieldThinking)
}

// SetTemperature sets the Temperature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalAnthropicModel) SetTemperature(temperature *float64) {
	e.Temperature = temperature
	e.require(evalAnthropicModelFieldTemperature)
}

// SetMaxTokens sets the MaxTokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalAnthropicModel) SetMaxTokens(maxTokens *float64) {
	e.MaxTokens = maxTokens
	e.require(evalAnthropicModelFieldMaxTokens)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalAnthropicModel) SetMessages(messages []map[string]interface{}) {
	e.Messages = messages
	e.require(evalAnthropicModelFieldMessages)
}

func (e *EvalAnthropicModel) UnmarshalJSON(data []byte) error {
	type unmarshaler EvalAnthropicModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EvalAnthropicModel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalAnthropicModel) MarshalJSON() ([]byte, error) {
	type embed EvalAnthropicModel
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalAnthropicModel) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the specific model that will be used.
type EvalAnthropicModelModel string

const (
	EvalAnthropicModelModelClaude3Opus20240229    EvalAnthropicModelModel = "claude-3-opus-20240229"
	EvalAnthropicModelModelClaude3Sonnet20240229  EvalAnthropicModelModel = "claude-3-sonnet-20240229"
	EvalAnthropicModelModelClaude3Haiku20240307   EvalAnthropicModelModel = "claude-3-haiku-20240307"
	EvalAnthropicModelModelClaude35Sonnet20240620 EvalAnthropicModelModel = "claude-3-5-sonnet-20240620"
	EvalAnthropicModelModelClaude35Sonnet20241022 EvalAnthropicModelModel = "claude-3-5-sonnet-20241022"
	EvalAnthropicModelModelClaude35Haiku20241022  EvalAnthropicModelModel = "claude-3-5-haiku-20241022"
	EvalAnthropicModelModelClaude37Sonnet20250219 EvalAnthropicModelModel = "claude-3-7-sonnet-20250219"
	EvalAnthropicModelModelClaudeOpus420250514    EvalAnthropicModelModel = "claude-opus-4-20250514"
	EvalAnthropicModelModelClaudeSonnet420250514  EvalAnthropicModelModel = "claude-sonnet-4-20250514"
	EvalAnthropicModelModelClaudeSonnet4520250929 EvalAnthropicModelModel = "claude-sonnet-4-5-20250929"
	EvalAnthropicModelModelClaudeHaiku4520251001  EvalAnthropicModelModel = "claude-haiku-4-5-20251001"
)

func NewEvalAnthropicModelModelFromString(s string) (EvalAnthropicModelModel, error) {
	switch s {
	case "claude-3-opus-20240229":
		return EvalAnthropicModelModelClaude3Opus20240229, nil
	case "claude-3-sonnet-20240229":
		return EvalAnthropicModelModelClaude3Sonnet20240229, nil
	case "claude-3-haiku-20240307":
		return EvalAnthropicModelModelClaude3Haiku20240307, nil
	case "claude-3-5-sonnet-20240620":
		return EvalAnthropicModelModelClaude35Sonnet20240620, nil
	case "claude-3-5-sonnet-20241022":
		return EvalAnthropicModelModelClaude35Sonnet20241022, nil
	case "claude-3-5-haiku-20241022":
		return EvalAnthropicModelModelClaude35Haiku20241022, nil
	case "claude-3-7-sonnet-20250219":
		return EvalAnthropicModelModelClaude37Sonnet20250219, nil
	case "claude-opus-4-20250514":
		return EvalAnthropicModelModelClaudeOpus420250514, nil
	case "claude-sonnet-4-20250514":
		return EvalAnthropicModelModelClaudeSonnet420250514, nil
	case "claude-sonnet-4-5-20250929":
		return EvalAnthropicModelModelClaudeSonnet4520250929, nil
	case "claude-haiku-4-5-20251001":
		return EvalAnthropicModelModelClaudeHaiku4520251001, nil
	}
	var t EvalAnthropicModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalAnthropicModelModel) Ptr() *EvalAnthropicModelModel {
	return &e
}

// This is the provider of the model (`anthropic`).
type EvalAnthropicModelProvider string

const (
	EvalAnthropicModelProviderAnthropic EvalAnthropicModelProvider = "anthropic"
)

func NewEvalAnthropicModelProviderFromString(s string) (EvalAnthropicModelProvider, error) {
	switch s {
	case "anthropic":
		return EvalAnthropicModelProviderAnthropic, nil
	}
	var t EvalAnthropicModelProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalAnthropicModelProvider) Ptr() *EvalAnthropicModelProvider {
	return &e
}

var (
	evalCustomModelFieldProvider       = big.NewInt(1 << 0)
	evalCustomModelFieldUrl            = big.NewInt(1 << 1)
	evalCustomModelFieldHeaders        = big.NewInt(1 << 2)
	evalCustomModelFieldTimeoutSeconds = big.NewInt(1 << 3)
	evalCustomModelFieldModel          = big.NewInt(1 << 4)
	evalCustomModelFieldTemperature    = big.NewInt(1 << 5)
	evalCustomModelFieldMaxTokens      = big.NewInt(1 << 6)
	evalCustomModelFieldMessages       = big.NewInt(1 << 7)
)

type EvalCustomModel struct {
	// This is the provider of the model (`custom-llm`).
	Provider EvalCustomModelProvider `json:"provider" url:"provider"`
	// These is the URL we'll use for the OpenAI client's `baseURL`. Ex. https://openrouter.ai/api/v1
	Url string `json:"url" url:"url"`
	// These are the headers we'll use for the OpenAI client's `headers`.
	Headers map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`
	// This sets the timeout for the connection to the custom provider without needing to stream any tokens back. Default is 20 seconds.
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`
	// This is the name of the model. Ex. gpt-4o
	Model string `json:"model" url:"model"`
	// This is the temperature of the model. For LLM-as-a-judge, it's recommended to set it between 0 - 0.3 to avoid hallucinations and ensure the model judges the output correctly based on the instructions.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max tokens of the model.
	// If your Judge instructions return `true` or `false` takes only 1 token (as per the OpenAI Tokenizer), and therefore is recommended to set it to a low number to force the model to return a short response.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// These are the messages which will instruct the AI Judge on how to evaluate the assistant message.
	// The LLM-Judge must respond with "pass" or "fail" to indicate if the assistant message passes the eval.
	//
	// To access the messages in the mock conversation, use the LiquidJS variable `{{messages}}`.
	// The assistant message to be evaluated will be passed as the last message in the `messages` array and can be accessed using `{{messages[-1]}}`.
	//
	// It is recommended to use the system message to instruct the LLM how to evaluate the assistant message, and then use the first user message to pass the assistant message to be evaluated.
	Messages []map[string]interface{} `json:"messages" url:"messages"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalCustomModel) GetProvider() EvalCustomModelProvider {
	if e == nil {
		return ""
	}
	return e.Provider
}

func (e *EvalCustomModel) GetUrl() string {
	if e == nil {
		return ""
	}
	return e.Url
}

func (e *EvalCustomModel) GetHeaders() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Headers
}

func (e *EvalCustomModel) GetTimeoutSeconds() *float64 {
	if e == nil {
		return nil
	}
	return e.TimeoutSeconds
}

func (e *EvalCustomModel) GetModel() string {
	if e == nil {
		return ""
	}
	return e.Model
}

func (e *EvalCustomModel) GetTemperature() *float64 {
	if e == nil {
		return nil
	}
	return e.Temperature
}

func (e *EvalCustomModel) GetMaxTokens() *float64 {
	if e == nil {
		return nil
	}
	return e.MaxTokens
}

func (e *EvalCustomModel) GetMessages() []map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Messages
}

func (e *EvalCustomModel) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalCustomModel) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetProvider(provider EvalCustomModelProvider) {
	e.Provider = provider
	e.require(evalCustomModelFieldProvider)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetUrl(url string) {
	e.Url = url
	e.require(evalCustomModelFieldUrl)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetHeaders(headers map[string]interface{}) {
	e.Headers = headers
	e.require(evalCustomModelFieldHeaders)
}

// SetTimeoutSeconds sets the TimeoutSeconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetTimeoutSeconds(timeoutSeconds *float64) {
	e.TimeoutSeconds = timeoutSeconds
	e.require(evalCustomModelFieldTimeoutSeconds)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetModel(model string) {
	e.Model = model
	e.require(evalCustomModelFieldModel)
}

// SetTemperature sets the Temperature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetTemperature(temperature *float64) {
	e.Temperature = temperature
	e.require(evalCustomModelFieldTemperature)
}

// SetMaxTokens sets the MaxTokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetMaxTokens(maxTokens *float64) {
	e.MaxTokens = maxTokens
	e.require(evalCustomModelFieldMaxTokens)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetMessages(messages []map[string]interface{}) {
	e.Messages = messages
	e.require(evalCustomModelFieldMessages)
}

func (e *EvalCustomModel) UnmarshalJSON(data []byte) error {
	type unmarshaler EvalCustomModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EvalCustomModel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalCustomModel) MarshalJSON() ([]byte, error) {
	type embed EvalCustomModel
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalCustomModel) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the provider of the model (`custom-llm`).
type EvalCustomModelProvider string

const (
	EvalCustomModelProviderCustomLlm EvalCustomModelProvider = "custom-llm"
)

func NewEvalCustomModelProviderFromString(s string) (EvalCustomModelProvider, error) {
	switch s {
	case "custom-llm":
		return EvalCustomModelProviderCustomLlm, nil
	}
	var t EvalCustomModelProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalCustomModelProvider) Ptr() *EvalCustomModelProvider {
	return &e
}

var (
	evalGoogleModelFieldProvider    = big.NewInt(1 << 0)
	evalGoogleModelFieldModel       = big.NewInt(1 << 1)
	evalGoogleModelFieldTemperature = big.NewInt(1 << 2)
	evalGoogleModelFieldMaxTokens   = big.NewInt(1 << 3)
	evalGoogleModelFieldMessages    = big.NewInt(1 << 4)
)

type EvalGoogleModel struct {
	// This is the provider of the model (`google`).
	Provider EvalGoogleModelProvider `json:"provider" url:"provider"`
	// This is the name of the model. Ex. gpt-4o
	Model EvalGoogleModelModel `json:"model" url:"model"`
	// This is the temperature of the model. For LLM-as-a-judge, it's recommended to set it between 0 - 0.3 to avoid hallucinations and ensure the model judges the output correctly based on the instructions.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max tokens of the model.
	// If your Judge instructions return `true` or `false` takes only 1 token (as per the OpenAI Tokenizer), and therefore is recommended to set it to a low number to force the model to return a short response.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// These are the messages which will instruct the AI Judge on how to evaluate the assistant message.
	// The LLM-Judge must respond with "pass" or "fail" to indicate if the assistant message passes the eval.
	//
	// To access the messages in the mock conversation, use the LiquidJS variable `{{messages}}`.
	// The assistant message to be evaluated will be passed as the last message in the `messages` array and can be accessed using `{{messages[-1]}}`.
	//
	// It is recommended to use the system message to instruct the LLM how to evaluate the assistant message, and then use the first user message to pass the assistant message to be evaluated.
	Messages []map[string]interface{} `json:"messages" url:"messages"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalGoogleModel) GetProvider() EvalGoogleModelProvider {
	if e == nil {
		return ""
	}
	return e.Provider
}

func (e *EvalGoogleModel) GetModel() EvalGoogleModelModel {
	if e == nil {
		return ""
	}
	return e.Model
}

func (e *EvalGoogleModel) GetTemperature() *float64 {
	if e == nil {
		return nil
	}
	return e.Temperature
}

func (e *EvalGoogleModel) GetMaxTokens() *float64 {
	if e == nil {
		return nil
	}
	return e.MaxTokens
}

func (e *EvalGoogleModel) GetMessages() []map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Messages
}

func (e *EvalGoogleModel) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalGoogleModel) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalGoogleModel) SetProvider(provider EvalGoogleModelProvider) {
	e.Provider = provider
	e.require(evalGoogleModelFieldProvider)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalGoogleModel) SetModel(model EvalGoogleModelModel) {
	e.Model = model
	e.require(evalGoogleModelFieldModel)
}

// SetTemperature sets the Temperature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalGoogleModel) SetTemperature(temperature *float64) {
	e.Temperature = temperature
	e.require(evalGoogleModelFieldTemperature)
}

// SetMaxTokens sets the MaxTokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalGoogleModel) SetMaxTokens(maxTokens *float64) {
	e.MaxTokens = maxTokens
	e.require(evalGoogleModelFieldMaxTokens)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalGoogleModel) SetMessages(messages []map[string]interface{}) {
	e.Messages = messages
	e.require(evalGoogleModelFieldMessages)
}

func (e *EvalGoogleModel) UnmarshalJSON(data []byte) error {
	type unmarshaler EvalGoogleModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EvalGoogleModel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalGoogleModel) MarshalJSON() ([]byte, error) {
	type embed EvalGoogleModel
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalGoogleModel) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the name of the model. Ex. gpt-4o
type EvalGoogleModelModel string

const (
	EvalGoogleModelModelGemini25Pro              EvalGoogleModelModel = "gemini-2.5-pro"
	EvalGoogleModelModelGemini25Flash            EvalGoogleModelModel = "gemini-2.5-flash"
	EvalGoogleModelModelGemini25FlashLite        EvalGoogleModelModel = "gemini-2.5-flash-lite"
	EvalGoogleModelModelGemini20FlashThinkingExp EvalGoogleModelModel = "gemini-2.0-flash-thinking-exp"
	EvalGoogleModelModelGemini20ProExp0205       EvalGoogleModelModel = "gemini-2.0-pro-exp-02-05"
	EvalGoogleModelModelGemini20Flash            EvalGoogleModelModel = "gemini-2.0-flash"
	EvalGoogleModelModelGemini20FlashLite        EvalGoogleModelModel = "gemini-2.0-flash-lite"
	EvalGoogleModelModelGemini20FlashExp         EvalGoogleModelModel = "gemini-2.0-flash-exp"
	EvalGoogleModelModelGemini20FlashRealtimeExp EvalGoogleModelModel = "gemini-2.0-flash-realtime-exp"
	EvalGoogleModelModelGemini15Flash            EvalGoogleModelModel = "gemini-1.5-flash"
	EvalGoogleModelModelGemini15Flash002         EvalGoogleModelModel = "gemini-1.5-flash-002"
	EvalGoogleModelModelGemini15Pro              EvalGoogleModelModel = "gemini-1.5-pro"
	EvalGoogleModelModelGemini15Pro002           EvalGoogleModelModel = "gemini-1.5-pro-002"
	EvalGoogleModelModelGemini10Pro              EvalGoogleModelModel = "gemini-1.0-pro"
)

func NewEvalGoogleModelModelFromString(s string) (EvalGoogleModelModel, error) {
	switch s {
	case "gemini-2.5-pro":
		return EvalGoogleModelModelGemini25Pro, nil
	case "gemini-2.5-flash":
		return EvalGoogleModelModelGemini25Flash, nil
	case "gemini-2.5-flash-lite":
		return EvalGoogleModelModelGemini25FlashLite, nil
	case "gemini-2.0-flash-thinking-exp":
		return EvalGoogleModelModelGemini20FlashThinkingExp, nil
	case "gemini-2.0-pro-exp-02-05":
		return EvalGoogleModelModelGemini20ProExp0205, nil
	case "gemini-2.0-flash":
		return EvalGoogleModelModelGemini20Flash, nil
	case "gemini-2.0-flash-lite":
		return EvalGoogleModelModelGemini20FlashLite, nil
	case "gemini-2.0-flash-exp":
		return EvalGoogleModelModelGemini20FlashExp, nil
	case "gemini-2.0-flash-realtime-exp":
		return EvalGoogleModelModelGemini20FlashRealtimeExp, nil
	case "gemini-1.5-flash":
		return EvalGoogleModelModelGemini15Flash, nil
	case "gemini-1.5-flash-002":
		return EvalGoogleModelModelGemini15Flash002, nil
	case "gemini-1.5-pro":
		return EvalGoogleModelModelGemini15Pro, nil
	case "gemini-1.5-pro-002":
		return EvalGoogleModelModelGemini15Pro002, nil
	case "gemini-1.0-pro":
		return EvalGoogleModelModelGemini10Pro, nil
	}
	var t EvalGoogleModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalGoogleModelModel) Ptr() *EvalGoogleModelModel {
	return &e
}

// This is the provider of the model (`google`).
type EvalGoogleModelProvider string

const (
	EvalGoogleModelProviderGoogle EvalGoogleModelProvider = "google"
)

func NewEvalGoogleModelProviderFromString(s string) (EvalGoogleModelProvider, error) {
	switch s {
	case "google":
		return EvalGoogleModelProviderGoogle, nil
	}
	var t EvalGoogleModelProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalGoogleModelProvider) Ptr() *EvalGoogleModelProvider {
	return &e
}

type EvalMessagesItem struct {
	ChatEvalAssistantMessageMock          *ChatEvalAssistantMessageMock
	ChatEvalSystemMessageMock             *ChatEvalSystemMessageMock
	ChatEvalToolResponseMessageMock       *ChatEvalToolResponseMessageMock
	ChatEvalToolResponseMessageEvaluation *ChatEvalToolResponseMessageEvaluation
	ChatEvalUserMessageMock               *ChatEvalUserMessageMock
	ChatEvalAssistantMessageEvaluation    *ChatEvalAssistantMessageEvaluation

	typ string
}

func (e *EvalMessagesItem) GetChatEvalAssistantMessageMock() *ChatEvalAssistantMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalAssistantMessageMock
}

func (e *EvalMessagesItem) GetChatEvalSystemMessageMock() *ChatEvalSystemMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalSystemMessageMock
}

func (e *EvalMessagesItem) GetChatEvalToolResponseMessageMock() *ChatEvalToolResponseMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalToolResponseMessageMock
}

func (e *EvalMessagesItem) GetChatEvalToolResponseMessageEvaluation() *ChatEvalToolResponseMessageEvaluation {
	if e == nil {
		return nil
	}
	return e.ChatEvalToolResponseMessageEvaluation
}

func (e *EvalMessagesItem) GetChatEvalUserMessageMock() *ChatEvalUserMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalUserMessageMock
}

func (e *EvalMessagesItem) GetChatEvalAssistantMessageEvaluation() *ChatEvalAssistantMessageEvaluation {
	if e == nil {
		return nil
	}
	return e.ChatEvalAssistantMessageEvaluation
}

func (e *EvalMessagesItem) UnmarshalJSON(data []byte) error {
	valueChatEvalAssistantMessageMock := new(ChatEvalAssistantMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageMock); err == nil {
		e.typ = "ChatEvalAssistantMessageMock"
		e.ChatEvalAssistantMessageMock = valueChatEvalAssistantMessageMock
		return nil
	}
	valueChatEvalSystemMessageMock := new(ChatEvalSystemMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalSystemMessageMock); err == nil {
		e.typ = "ChatEvalSystemMessageMock"
		e.ChatEvalSystemMessageMock = valueChatEvalSystemMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageMock := new(ChatEvalToolResponseMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageMock); err == nil {
		e.typ = "ChatEvalToolResponseMessageMock"
		e.ChatEvalToolResponseMessageMock = valueChatEvalToolResponseMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageEvaluation := new(ChatEvalToolResponseMessageEvaluation)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageEvaluation); err == nil {
		e.typ = "ChatEvalToolResponseMessageEvaluation"
		e.ChatEvalToolResponseMessageEvaluation = valueChatEvalToolResponseMessageEvaluation
		return nil
	}
	valueChatEvalUserMessageMock := new(ChatEvalUserMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalUserMessageMock); err == nil {
		e.typ = "ChatEvalUserMessageMock"
		e.ChatEvalUserMessageMock = valueChatEvalUserMessageMock
		return nil
	}
	valueChatEvalAssistantMessageEvaluation := new(ChatEvalAssistantMessageEvaluation)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageEvaluation); err == nil {
		e.typ = "ChatEvalAssistantMessageEvaluation"
		e.ChatEvalAssistantMessageEvaluation = valueChatEvalAssistantMessageEvaluation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EvalMessagesItem) MarshalJSON() ([]byte, error) {
	if e.typ == "ChatEvalAssistantMessageMock" || e.ChatEvalAssistantMessageMock != nil {
		return json.Marshal(e.ChatEvalAssistantMessageMock)
	}
	if e.typ == "ChatEvalSystemMessageMock" || e.ChatEvalSystemMessageMock != nil {
		return json.Marshal(e.ChatEvalSystemMessageMock)
	}
	if e.typ == "ChatEvalToolResponseMessageMock" || e.ChatEvalToolResponseMessageMock != nil {
		return json.Marshal(e.ChatEvalToolResponseMessageMock)
	}
	if e.typ == "ChatEvalToolResponseMessageEvaluation" || e.ChatEvalToolResponseMessageEvaluation != nil {
		return json.Marshal(e.ChatEvalToolResponseMessageEvaluation)
	}
	if e.typ == "ChatEvalUserMessageMock" || e.ChatEvalUserMessageMock != nil {
		return json.Marshal(e.ChatEvalUserMessageMock)
	}
	if e.typ == "ChatEvalAssistantMessageEvaluation" || e.ChatEvalAssistantMessageEvaluation != nil {
		return json.Marshal(e.ChatEvalAssistantMessageEvaluation)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EvalMessagesItemVisitor interface {
	VisitChatEvalAssistantMessageMock(*ChatEvalAssistantMessageMock) error
	VisitChatEvalSystemMessageMock(*ChatEvalSystemMessageMock) error
	VisitChatEvalToolResponseMessageMock(*ChatEvalToolResponseMessageMock) error
	VisitChatEvalToolResponseMessageEvaluation(*ChatEvalToolResponseMessageEvaluation) error
	VisitChatEvalUserMessageMock(*ChatEvalUserMessageMock) error
	VisitChatEvalAssistantMessageEvaluation(*ChatEvalAssistantMessageEvaluation) error
}

func (e *EvalMessagesItem) Accept(visitor EvalMessagesItemVisitor) error {
	if e.typ == "ChatEvalAssistantMessageMock" || e.ChatEvalAssistantMessageMock != nil {
		return visitor.VisitChatEvalAssistantMessageMock(e.ChatEvalAssistantMessageMock)
	}
	if e.typ == "ChatEvalSystemMessageMock" || e.ChatEvalSystemMessageMock != nil {
		return visitor.VisitChatEvalSystemMessageMock(e.ChatEvalSystemMessageMock)
	}
	if e.typ == "ChatEvalToolResponseMessageMock" || e.ChatEvalToolResponseMessageMock != nil {
		return visitor.VisitChatEvalToolResponseMessageMock(e.ChatEvalToolResponseMessageMock)
	}
	if e.typ == "ChatEvalToolResponseMessageEvaluation" || e.ChatEvalToolResponseMessageEvaluation != nil {
		return visitor.VisitChatEvalToolResponseMessageEvaluation(e.ChatEvalToolResponseMessageEvaluation)
	}
	if e.typ == "ChatEvalUserMessageMock" || e.ChatEvalUserMessageMock != nil {
		return visitor.VisitChatEvalUserMessageMock(e.ChatEvalUserMessageMock)
	}
	if e.typ == "ChatEvalAssistantMessageEvaluation" || e.ChatEvalAssistantMessageEvaluation != nil {
		return visitor.VisitChatEvalAssistantMessageEvaluation(e.ChatEvalAssistantMessageEvaluation)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

var (
	evalOpenAiModelFieldProvider    = big.NewInt(1 << 0)
	evalOpenAiModelFieldModel       = big.NewInt(1 << 1)
	evalOpenAiModelFieldTemperature = big.NewInt(1 << 2)
	evalOpenAiModelFieldMaxTokens   = big.NewInt(1 << 3)
	evalOpenAiModelFieldMessages    = big.NewInt(1 << 4)
)

type EvalOpenAiModel struct {
	// This is the provider of the model (`openai`).
	Provider EvalOpenAiModelProvider `json:"provider" url:"provider"`
	// This is the OpenAI model that will be used.
	//
	// When using Vapi OpenAI or your own Azure Credentials, you have the option to specify the region for the selected model. This shouldn't be specified unless you have a specific reason to do so. Vapi will automatically find the fastest region that make sense.
	// This is helpful when you are required to comply with Data Residency rules. Learn more about Azure regions here https://azure.microsoft.com/en-us/explore/global-infrastructure/data-residency/.
	Model EvalOpenAiModelModel `json:"model" url:"model"`
	// This is the temperature of the model. For LLM-as-a-judge, it's recommended to set it between 0 - 0.3 to avoid hallucinations and ensure the model judges the output correctly based on the instructions.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max tokens of the model.
	// If your Judge instructions return `true` or `false` takes only 1 token (as per the OpenAI Tokenizer), and therefore is recommended to set it to a low number to force the model to return a short response.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// These are the messages which will instruct the AI Judge on how to evaluate the assistant message.
	// The LLM-Judge must respond with "pass" or "fail" to indicate if the assistant message passes the eval.
	//
	// To access the messages in the mock conversation, use the LiquidJS variable `{{messages}}`.
	// The assistant message to be evaluated will be passed as the last message in the `messages` array and can be accessed using `{{messages[-1]}}`.
	//
	// It is recommended to use the system message to instruct the LLM how to evaluate the assistant message, and then use the first user message to pass the assistant message to be evaluated.
	Messages []map[string]interface{} `json:"messages" url:"messages"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalOpenAiModel) GetProvider() EvalOpenAiModelProvider {
	if e == nil {
		return ""
	}
	return e.Provider
}

func (e *EvalOpenAiModel) GetModel() EvalOpenAiModelModel {
	if e == nil {
		return ""
	}
	return e.Model
}

func (e *EvalOpenAiModel) GetTemperature() *float64 {
	if e == nil {
		return nil
	}
	return e.Temperature
}

func (e *EvalOpenAiModel) GetMaxTokens() *float64 {
	if e == nil {
		return nil
	}
	return e.MaxTokens
}

func (e *EvalOpenAiModel) GetMessages() []map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Messages
}

func (e *EvalOpenAiModel) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalOpenAiModel) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalOpenAiModel) SetProvider(provider EvalOpenAiModelProvider) {
	e.Provider = provider
	e.require(evalOpenAiModelFieldProvider)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalOpenAiModel) SetModel(model EvalOpenAiModelModel) {
	e.Model = model
	e.require(evalOpenAiModelFieldModel)
}

// SetTemperature sets the Temperature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalOpenAiModel) SetTemperature(temperature *float64) {
	e.Temperature = temperature
	e.require(evalOpenAiModelFieldTemperature)
}

// SetMaxTokens sets the MaxTokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalOpenAiModel) SetMaxTokens(maxTokens *float64) {
	e.MaxTokens = maxTokens
	e.require(evalOpenAiModelFieldMaxTokens)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalOpenAiModel) SetMessages(messages []map[string]interface{}) {
	e.Messages = messages
	e.require(evalOpenAiModelFieldMessages)
}

func (e *EvalOpenAiModel) UnmarshalJSON(data []byte) error {
	type unmarshaler EvalOpenAiModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EvalOpenAiModel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalOpenAiModel) MarshalJSON() ([]byte, error) {
	type embed EvalOpenAiModel
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalOpenAiModel) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the OpenAI model that will be used.
//
// When using Vapi OpenAI or your own Azure Credentials, you have the option to specify the region for the selected model. This shouldn't be specified unless you have a specific reason to do so. Vapi will automatically find the fastest region that make sense.
// This is helpful when you are required to comply with Data Residency rules. Learn more about Azure regions here https://azure.microsoft.com/en-us/explore/global-infrastructure/data-residency/.
type EvalOpenAiModelModel string

const (
	EvalOpenAiModelModelGpt51                           EvalOpenAiModelModel = "gpt-5.1"
	EvalOpenAiModelModelGpt51ChatLatest                 EvalOpenAiModelModel = "gpt-5.1-chat-latest"
	EvalOpenAiModelModelGpt5                            EvalOpenAiModelModel = "gpt-5"
	EvalOpenAiModelModelGpt5Mini                        EvalOpenAiModelModel = "gpt-5-mini"
	EvalOpenAiModelModelGpt5Nano                        EvalOpenAiModelModel = "gpt-5-nano"
	EvalOpenAiModelModelGpt4120250414                   EvalOpenAiModelModel = "gpt-4.1-2025-04-14"
	EvalOpenAiModelModelGpt41Mini20250414               EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14"
	EvalOpenAiModelModelGpt41Nano20250414               EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14"
	EvalOpenAiModelModelGpt41                           EvalOpenAiModelModel = "gpt-4.1"
	EvalOpenAiModelModelGpt41Mini                       EvalOpenAiModelModel = "gpt-4.1-mini"
	EvalOpenAiModelModelGpt41Nano                       EvalOpenAiModelModel = "gpt-4.1-nano"
	EvalOpenAiModelModelChatgpt4OLatest                 EvalOpenAiModelModel = "chatgpt-4o-latest"
	EvalOpenAiModelModelO3                              EvalOpenAiModelModel = "o3"
	EvalOpenAiModelModelO3Mini                          EvalOpenAiModelModel = "o3-mini"
	EvalOpenAiModelModelO4Mini                          EvalOpenAiModelModel = "o4-mini"
	EvalOpenAiModelModelO1Mini                          EvalOpenAiModelModel = "o1-mini"
	EvalOpenAiModelModelO1Mini20240912                  EvalOpenAiModelModel = "o1-mini-2024-09-12"
	EvalOpenAiModelModelGpt4OMini20240718               EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18"
	EvalOpenAiModelModelGpt4OMini                       EvalOpenAiModelModel = "gpt-4o-mini"
	EvalOpenAiModelModelGpt4O                           EvalOpenAiModelModel = "gpt-4o"
	EvalOpenAiModelModelGpt4O20240513                   EvalOpenAiModelModel = "gpt-4o-2024-05-13"
	EvalOpenAiModelModelGpt4O20240806                   EvalOpenAiModelModel = "gpt-4o-2024-08-06"
	EvalOpenAiModelModelGpt4O20241120                   EvalOpenAiModelModel = "gpt-4o-2024-11-20"
	EvalOpenAiModelModelGpt4Turbo                       EvalOpenAiModelModel = "gpt-4-turbo"
	EvalOpenAiModelModelGpt4Turbo20240409               EvalOpenAiModelModel = "gpt-4-turbo-2024-04-09"
	EvalOpenAiModelModelGpt4TurboPreview                EvalOpenAiModelModel = "gpt-4-turbo-preview"
	EvalOpenAiModelModelGpt40125Preview                 EvalOpenAiModelModel = "gpt-4-0125-preview"
	EvalOpenAiModelModelGpt41106Preview                 EvalOpenAiModelModel = "gpt-4-1106-preview"
	EvalOpenAiModelModelGpt4                            EvalOpenAiModelModel = "gpt-4"
	EvalOpenAiModelModelGpt40613                        EvalOpenAiModelModel = "gpt-4-0613"
	EvalOpenAiModelModelGpt35Turbo                      EvalOpenAiModelModel = "gpt-3.5-turbo"
	EvalOpenAiModelModelGpt35Turbo0125                  EvalOpenAiModelModel = "gpt-3.5-turbo-0125"
	EvalOpenAiModelModelGpt35Turbo1106                  EvalOpenAiModelModel = "gpt-3.5-turbo-1106"
	EvalOpenAiModelModelGpt35Turbo16K                   EvalOpenAiModelModel = "gpt-3.5-turbo-16k"
	EvalOpenAiModelModelGpt35Turbo0613                  EvalOpenAiModelModel = "gpt-3.5-turbo-0613"
	EvalOpenAiModelModelGpt4120250414Westus             EvalOpenAiModelModel = "gpt-4.1-2025-04-14:westus"
	EvalOpenAiModelModelGpt4120250414Eastus2            EvalOpenAiModelModel = "gpt-4.1-2025-04-14:eastus2"
	EvalOpenAiModelModelGpt4120250414Eastus             EvalOpenAiModelModel = "gpt-4.1-2025-04-14:eastus"
	EvalOpenAiModelModelGpt4120250414Westus3            EvalOpenAiModelModel = "gpt-4.1-2025-04-14:westus3"
	EvalOpenAiModelModelGpt4120250414Northcentralus     EvalOpenAiModelModel = "gpt-4.1-2025-04-14:northcentralus"
	EvalOpenAiModelModelGpt4120250414Southcentralus     EvalOpenAiModelModel = "gpt-4.1-2025-04-14:southcentralus"
	EvalOpenAiModelModelGpt41Mini20250414Westus         EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:westus"
	EvalOpenAiModelModelGpt41Mini20250414Eastus2        EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:eastus2"
	EvalOpenAiModelModelGpt41Mini20250414Eastus         EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:eastus"
	EvalOpenAiModelModelGpt41Mini20250414Westus3        EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:westus3"
	EvalOpenAiModelModelGpt41Mini20250414Northcentralus EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:northcentralus"
	EvalOpenAiModelModelGpt41Mini20250414Southcentralus EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:southcentralus"
	EvalOpenAiModelModelGpt41Nano20250414Westus         EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14:westus"
	EvalOpenAiModelModelGpt41Nano20250414Eastus2        EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14:eastus2"
	EvalOpenAiModelModelGpt41Nano20250414Westus3        EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14:westus3"
	EvalOpenAiModelModelGpt41Nano20250414Northcentralus EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14:northcentralus"
	EvalOpenAiModelModelGpt41Nano20250414Southcentralus EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14:southcentralus"
	EvalOpenAiModelModelGpt4O20241120Swedencentral      EvalOpenAiModelModel = "gpt-4o-2024-11-20:swedencentral"
	EvalOpenAiModelModelGpt4O20241120Westus             EvalOpenAiModelModel = "gpt-4o-2024-11-20:westus"
	EvalOpenAiModelModelGpt4O20241120Eastus2            EvalOpenAiModelModel = "gpt-4o-2024-11-20:eastus2"
	EvalOpenAiModelModelGpt4O20241120Eastus             EvalOpenAiModelModel = "gpt-4o-2024-11-20:eastus"
	EvalOpenAiModelModelGpt4O20241120Westus3            EvalOpenAiModelModel = "gpt-4o-2024-11-20:westus3"
	EvalOpenAiModelModelGpt4O20241120Southcentralus     EvalOpenAiModelModel = "gpt-4o-2024-11-20:southcentralus"
	EvalOpenAiModelModelGpt4O20240806Westus             EvalOpenAiModelModel = "gpt-4o-2024-08-06:westus"
	EvalOpenAiModelModelGpt4O20240806Westus3            EvalOpenAiModelModel = "gpt-4o-2024-08-06:westus3"
	EvalOpenAiModelModelGpt4O20240806Eastus             EvalOpenAiModelModel = "gpt-4o-2024-08-06:eastus"
	EvalOpenAiModelModelGpt4O20240806Eastus2            EvalOpenAiModelModel = "gpt-4o-2024-08-06:eastus2"
	EvalOpenAiModelModelGpt4O20240806Northcentralus     EvalOpenAiModelModel = "gpt-4o-2024-08-06:northcentralus"
	EvalOpenAiModelModelGpt4O20240806Southcentralus     EvalOpenAiModelModel = "gpt-4o-2024-08-06:southcentralus"
	EvalOpenAiModelModelGpt4OMini20240718Westus         EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:westus"
	EvalOpenAiModelModelGpt4OMini20240718Westus3        EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:westus3"
	EvalOpenAiModelModelGpt4OMini20240718Eastus         EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:eastus"
	EvalOpenAiModelModelGpt4OMini20240718Eastus2        EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:eastus2"
	EvalOpenAiModelModelGpt4OMini20240718Northcentralus EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:northcentralus"
	EvalOpenAiModelModelGpt4OMini20240718Southcentralus EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:southcentralus"
	EvalOpenAiModelModelGpt4O20240513Eastus2            EvalOpenAiModelModel = "gpt-4o-2024-05-13:eastus2"
	EvalOpenAiModelModelGpt4O20240513Eastus             EvalOpenAiModelModel = "gpt-4o-2024-05-13:eastus"
	EvalOpenAiModelModelGpt4O20240513Northcentralus     EvalOpenAiModelModel = "gpt-4o-2024-05-13:northcentralus"
	EvalOpenAiModelModelGpt4O20240513Southcentralus     EvalOpenAiModelModel = "gpt-4o-2024-05-13:southcentralus"
	EvalOpenAiModelModelGpt4O20240513Westus3            EvalOpenAiModelModel = "gpt-4o-2024-05-13:westus3"
	EvalOpenAiModelModelGpt4O20240513Westus             EvalOpenAiModelModel = "gpt-4o-2024-05-13:westus"
	EvalOpenAiModelModelGpt4Turbo20240409Eastus2        EvalOpenAiModelModel = "gpt-4-turbo-2024-04-09:eastus2"
	EvalOpenAiModelModelGpt40125PreviewEastus           EvalOpenAiModelModel = "gpt-4-0125-preview:eastus"
	EvalOpenAiModelModelGpt40125PreviewNorthcentralus   EvalOpenAiModelModel = "gpt-4-0125-preview:northcentralus"
	EvalOpenAiModelModelGpt40125PreviewSouthcentralus   EvalOpenAiModelModel = "gpt-4-0125-preview:southcentralus"
	EvalOpenAiModelModelGpt41106PreviewAustralia        EvalOpenAiModelModel = "gpt-4-1106-preview:australia"
	EvalOpenAiModelModelGpt41106PreviewCanadaeast       EvalOpenAiModelModel = "gpt-4-1106-preview:canadaeast"
	EvalOpenAiModelModelGpt41106PreviewFrance           EvalOpenAiModelModel = "gpt-4-1106-preview:france"
	EvalOpenAiModelModelGpt41106PreviewIndia            EvalOpenAiModelModel = "gpt-4-1106-preview:india"
	EvalOpenAiModelModelGpt41106PreviewNorway           EvalOpenAiModelModel = "gpt-4-1106-preview:norway"
	EvalOpenAiModelModelGpt41106PreviewSwedencentral    EvalOpenAiModelModel = "gpt-4-1106-preview:swedencentral"
	EvalOpenAiModelModelGpt41106PreviewUk               EvalOpenAiModelModel = "gpt-4-1106-preview:uk"
	EvalOpenAiModelModelGpt41106PreviewWestus           EvalOpenAiModelModel = "gpt-4-1106-preview:westus"
	EvalOpenAiModelModelGpt41106PreviewWestus3          EvalOpenAiModelModel = "gpt-4-1106-preview:westus3"
	EvalOpenAiModelModelGpt40613Canadaeast              EvalOpenAiModelModel = "gpt-4-0613:canadaeast"
	EvalOpenAiModelModelGpt35Turbo0125Canadaeast        EvalOpenAiModelModel = "gpt-3.5-turbo-0125:canadaeast"
	EvalOpenAiModelModelGpt35Turbo0125Northcentralus    EvalOpenAiModelModel = "gpt-3.5-turbo-0125:northcentralus"
	EvalOpenAiModelModelGpt35Turbo0125Southcentralus    EvalOpenAiModelModel = "gpt-3.5-turbo-0125:southcentralus"
	EvalOpenAiModelModelGpt35Turbo1106Canadaeast        EvalOpenAiModelModel = "gpt-3.5-turbo-1106:canadaeast"
	EvalOpenAiModelModelGpt35Turbo1106Westus            EvalOpenAiModelModel = "gpt-3.5-turbo-1106:westus"
)

func NewEvalOpenAiModelModelFromString(s string) (EvalOpenAiModelModel, error) {
	switch s {
	case "gpt-5.1":
		return EvalOpenAiModelModelGpt51, nil
	case "gpt-5.1-chat-latest":
		return EvalOpenAiModelModelGpt51ChatLatest, nil
	case "gpt-5":
		return EvalOpenAiModelModelGpt5, nil
	case "gpt-5-mini":
		return EvalOpenAiModelModelGpt5Mini, nil
	case "gpt-5-nano":
		return EvalOpenAiModelModelGpt5Nano, nil
	case "gpt-4.1-2025-04-14":
		return EvalOpenAiModelModelGpt4120250414, nil
	case "gpt-4.1-mini-2025-04-14":
		return EvalOpenAiModelModelGpt41Mini20250414, nil
	case "gpt-4.1-nano-2025-04-14":
		return EvalOpenAiModelModelGpt41Nano20250414, nil
	case "gpt-4.1":
		return EvalOpenAiModelModelGpt41, nil
	case "gpt-4.1-mini":
		return EvalOpenAiModelModelGpt41Mini, nil
	case "gpt-4.1-nano":
		return EvalOpenAiModelModelGpt41Nano, nil
	case "chatgpt-4o-latest":
		return EvalOpenAiModelModelChatgpt4OLatest, nil
	case "o3":
		return EvalOpenAiModelModelO3, nil
	case "o3-mini":
		return EvalOpenAiModelModelO3Mini, nil
	case "o4-mini":
		return EvalOpenAiModelModelO4Mini, nil
	case "o1-mini":
		return EvalOpenAiModelModelO1Mini, nil
	case "o1-mini-2024-09-12":
		return EvalOpenAiModelModelO1Mini20240912, nil
	case "gpt-4o-mini-2024-07-18":
		return EvalOpenAiModelModelGpt4OMini20240718, nil
	case "gpt-4o-mini":
		return EvalOpenAiModelModelGpt4OMini, nil
	case "gpt-4o":
		return EvalOpenAiModelModelGpt4O, nil
	case "gpt-4o-2024-05-13":
		return EvalOpenAiModelModelGpt4O20240513, nil
	case "gpt-4o-2024-08-06":
		return EvalOpenAiModelModelGpt4O20240806, nil
	case "gpt-4o-2024-11-20":
		return EvalOpenAiModelModelGpt4O20241120, nil
	case "gpt-4-turbo":
		return EvalOpenAiModelModelGpt4Turbo, nil
	case "gpt-4-turbo-2024-04-09":
		return EvalOpenAiModelModelGpt4Turbo20240409, nil
	case "gpt-4-turbo-preview":
		return EvalOpenAiModelModelGpt4TurboPreview, nil
	case "gpt-4-0125-preview":
		return EvalOpenAiModelModelGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return EvalOpenAiModelModelGpt41106Preview, nil
	case "gpt-4":
		return EvalOpenAiModelModelGpt4, nil
	case "gpt-4-0613":
		return EvalOpenAiModelModelGpt40613, nil
	case "gpt-3.5-turbo":
		return EvalOpenAiModelModelGpt35Turbo, nil
	case "gpt-3.5-turbo-0125":
		return EvalOpenAiModelModelGpt35Turbo0125, nil
	case "gpt-3.5-turbo-1106":
		return EvalOpenAiModelModelGpt35Turbo1106, nil
	case "gpt-3.5-turbo-16k":
		return EvalOpenAiModelModelGpt35Turbo16K, nil
	case "gpt-3.5-turbo-0613":
		return EvalOpenAiModelModelGpt35Turbo0613, nil
	case "gpt-4.1-2025-04-14:westus":
		return EvalOpenAiModelModelGpt4120250414Westus, nil
	case "gpt-4.1-2025-04-14:eastus2":
		return EvalOpenAiModelModelGpt4120250414Eastus2, nil
	case "gpt-4.1-2025-04-14:eastus":
		return EvalOpenAiModelModelGpt4120250414Eastus, nil
	case "gpt-4.1-2025-04-14:westus3":
		return EvalOpenAiModelModelGpt4120250414Westus3, nil
	case "gpt-4.1-2025-04-14:northcentralus":
		return EvalOpenAiModelModelGpt4120250414Northcentralus, nil
	case "gpt-4.1-2025-04-14:southcentralus":
		return EvalOpenAiModelModelGpt4120250414Southcentralus, nil
	case "gpt-4.1-mini-2025-04-14:westus":
		return EvalOpenAiModelModelGpt41Mini20250414Westus, nil
	case "gpt-4.1-mini-2025-04-14:eastus2":
		return EvalOpenAiModelModelGpt41Mini20250414Eastus2, nil
	case "gpt-4.1-mini-2025-04-14:eastus":
		return EvalOpenAiModelModelGpt41Mini20250414Eastus, nil
	case "gpt-4.1-mini-2025-04-14:westus3":
		return EvalOpenAiModelModelGpt41Mini20250414Westus3, nil
	case "gpt-4.1-mini-2025-04-14:northcentralus":
		return EvalOpenAiModelModelGpt41Mini20250414Northcentralus, nil
	case "gpt-4.1-mini-2025-04-14:southcentralus":
		return EvalOpenAiModelModelGpt41Mini20250414Southcentralus, nil
	case "gpt-4.1-nano-2025-04-14:westus":
		return EvalOpenAiModelModelGpt41Nano20250414Westus, nil
	case "gpt-4.1-nano-2025-04-14:eastus2":
		return EvalOpenAiModelModelGpt41Nano20250414Eastus2, nil
	case "gpt-4.1-nano-2025-04-14:westus3":
		return EvalOpenAiModelModelGpt41Nano20250414Westus3, nil
	case "gpt-4.1-nano-2025-04-14:northcentralus":
		return EvalOpenAiModelModelGpt41Nano20250414Northcentralus, nil
	case "gpt-4.1-nano-2025-04-14:southcentralus":
		return EvalOpenAiModelModelGpt41Nano20250414Southcentralus, nil
	case "gpt-4o-2024-11-20:swedencentral":
		return EvalOpenAiModelModelGpt4O20241120Swedencentral, nil
	case "gpt-4o-2024-11-20:westus":
		return EvalOpenAiModelModelGpt4O20241120Westus, nil
	case "gpt-4o-2024-11-20:eastus2":
		return EvalOpenAiModelModelGpt4O20241120Eastus2, nil
	case "gpt-4o-2024-11-20:eastus":
		return EvalOpenAiModelModelGpt4O20241120Eastus, nil
	case "gpt-4o-2024-11-20:westus3":
		return EvalOpenAiModelModelGpt4O20241120Westus3, nil
	case "gpt-4o-2024-11-20:southcentralus":
		return EvalOpenAiModelModelGpt4O20241120Southcentralus, nil
	case "gpt-4o-2024-08-06:westus":
		return EvalOpenAiModelModelGpt4O20240806Westus, nil
	case "gpt-4o-2024-08-06:westus3":
		return EvalOpenAiModelModelGpt4O20240806Westus3, nil
	case "gpt-4o-2024-08-06:eastus":
		return EvalOpenAiModelModelGpt4O20240806Eastus, nil
	case "gpt-4o-2024-08-06:eastus2":
		return EvalOpenAiModelModelGpt4O20240806Eastus2, nil
	case "gpt-4o-2024-08-06:northcentralus":
		return EvalOpenAiModelModelGpt4O20240806Northcentralus, nil
	case "gpt-4o-2024-08-06:southcentralus":
		return EvalOpenAiModelModelGpt4O20240806Southcentralus, nil
	case "gpt-4o-mini-2024-07-18:westus":
		return EvalOpenAiModelModelGpt4OMini20240718Westus, nil
	case "gpt-4o-mini-2024-07-18:westus3":
		return EvalOpenAiModelModelGpt4OMini20240718Westus3, nil
	case "gpt-4o-mini-2024-07-18:eastus":
		return EvalOpenAiModelModelGpt4OMini20240718Eastus, nil
	case "gpt-4o-mini-2024-07-18:eastus2":
		return EvalOpenAiModelModelGpt4OMini20240718Eastus2, nil
	case "gpt-4o-mini-2024-07-18:northcentralus":
		return EvalOpenAiModelModelGpt4OMini20240718Northcentralus, nil
	case "gpt-4o-mini-2024-07-18:southcentralus":
		return EvalOpenAiModelModelGpt4OMini20240718Southcentralus, nil
	case "gpt-4o-2024-05-13:eastus2":
		return EvalOpenAiModelModelGpt4O20240513Eastus2, nil
	case "gpt-4o-2024-05-13:eastus":
		return EvalOpenAiModelModelGpt4O20240513Eastus, nil
	case "gpt-4o-2024-05-13:northcentralus":
		return EvalOpenAiModelModelGpt4O20240513Northcentralus, nil
	case "gpt-4o-2024-05-13:southcentralus":
		return EvalOpenAiModelModelGpt4O20240513Southcentralus, nil
	case "gpt-4o-2024-05-13:westus3":
		return EvalOpenAiModelModelGpt4O20240513Westus3, nil
	case "gpt-4o-2024-05-13:westus":
		return EvalOpenAiModelModelGpt4O20240513Westus, nil
	case "gpt-4-turbo-2024-04-09:eastus2":
		return EvalOpenAiModelModelGpt4Turbo20240409Eastus2, nil
	case "gpt-4-0125-preview:eastus":
		return EvalOpenAiModelModelGpt40125PreviewEastus, nil
	case "gpt-4-0125-preview:northcentralus":
		return EvalOpenAiModelModelGpt40125PreviewNorthcentralus, nil
	case "gpt-4-0125-preview:southcentralus":
		return EvalOpenAiModelModelGpt40125PreviewSouthcentralus, nil
	case "gpt-4-1106-preview:australia":
		return EvalOpenAiModelModelGpt41106PreviewAustralia, nil
	case "gpt-4-1106-preview:canadaeast":
		return EvalOpenAiModelModelGpt41106PreviewCanadaeast, nil
	case "gpt-4-1106-preview:france":
		return EvalOpenAiModelModelGpt41106PreviewFrance, nil
	case "gpt-4-1106-preview:india":
		return EvalOpenAiModelModelGpt41106PreviewIndia, nil
	case "gpt-4-1106-preview:norway":
		return EvalOpenAiModelModelGpt41106PreviewNorway, nil
	case "gpt-4-1106-preview:swedencentral":
		return EvalOpenAiModelModelGpt41106PreviewSwedencentral, nil
	case "gpt-4-1106-preview:uk":
		return EvalOpenAiModelModelGpt41106PreviewUk, nil
	case "gpt-4-1106-preview:westus":
		return EvalOpenAiModelModelGpt41106PreviewWestus, nil
	case "gpt-4-1106-preview:westus3":
		return EvalOpenAiModelModelGpt41106PreviewWestus3, nil
	case "gpt-4-0613:canadaeast":
		return EvalOpenAiModelModelGpt40613Canadaeast, nil
	case "gpt-3.5-turbo-0125:canadaeast":
		return EvalOpenAiModelModelGpt35Turbo0125Canadaeast, nil
	case "gpt-3.5-turbo-0125:northcentralus":
		return EvalOpenAiModelModelGpt35Turbo0125Northcentralus, nil
	case "gpt-3.5-turbo-0125:southcentralus":
		return EvalOpenAiModelModelGpt35Turbo0125Southcentralus, nil
	case "gpt-3.5-turbo-1106:canadaeast":
		return EvalOpenAiModelModelGpt35Turbo1106Canadaeast, nil
	case "gpt-3.5-turbo-1106:westus":
		return EvalOpenAiModelModelGpt35Turbo1106Westus, nil
	}
	var t EvalOpenAiModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalOpenAiModelModel) Ptr() *EvalOpenAiModelModel {
	return &e
}

// This is the provider of the model (`openai`).
type EvalOpenAiModelProvider string

const (
	EvalOpenAiModelProviderOpenai EvalOpenAiModelProvider = "openai"
)

func NewEvalOpenAiModelProviderFromString(s string) (EvalOpenAiModelProvider, error) {
	switch s {
	case "openai":
		return EvalOpenAiModelProviderOpenai, nil
	}
	var t EvalOpenAiModelProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalOpenAiModelProvider) Ptr() *EvalOpenAiModelProvider {
	return &e
}

var (
	evalPaginatedResponseFieldResults  = big.NewInt(1 << 0)
	evalPaginatedResponseFieldMetadata = big.NewInt(1 << 1)
)

type EvalPaginatedResponse struct {
	Results  []*Eval         `json:"results" url:"results"`
	Metadata *PaginationMeta `json:"metadata" url:"metadata"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalPaginatedResponse) GetResults() []*Eval {
	if e == nil {
		return nil
	}
	return e.Results
}

func (e *EvalPaginatedResponse) GetMetadata() *PaginationMeta {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EvalPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalPaginatedResponse) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalPaginatedResponse) SetResults(results []*Eval) {
	e.Results = results
	e.require(evalPaginatedResponseFieldResults)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalPaginatedResponse) SetMetadata(metadata *PaginationMeta) {
	e.Metadata = metadata
	e.require(evalPaginatedResponseFieldMetadata)
}

func (e *EvalPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EvalPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EvalPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalPaginatedResponse) MarshalJSON() ([]byte, error) {
	type embed EvalPaginatedResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalPaginatedResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	evalRunFieldStatus       = big.NewInt(1 << 0)
	evalRunFieldEndedReason  = big.NewInt(1 << 1)
	evalRunFieldEval         = big.NewInt(1 << 2)
	evalRunFieldTarget       = big.NewInt(1 << 3)
	evalRunFieldId           = big.NewInt(1 << 4)
	evalRunFieldOrgId        = big.NewInt(1 << 5)
	evalRunFieldCreatedAt    = big.NewInt(1 << 6)
	evalRunFieldStartedAt    = big.NewInt(1 << 7)
	evalRunFieldEndedAt      = big.NewInt(1 << 8)
	evalRunFieldEndedMessage = big.NewInt(1 << 9)
	evalRunFieldResults      = big.NewInt(1 << 10)
	evalRunFieldCost         = big.NewInt(1 << 11)
	evalRunFieldCosts        = big.NewInt(1 << 12)
	evalRunFieldType         = big.NewInt(1 << 13)
	evalRunFieldEvalId       = big.NewInt(1 << 14)
)

type EvalRun struct {
	// This is the status of the eval run. When an eval run is created, the status is 'running'.
	// When the eval run is completed, the status is 'ended'.
	Status EvalRunStatus `json:"status" url:"status"`
	// This is the reason for the eval run to end.
	// When the eval run is completed normally i.e end of mock conversation, the status is 'mockConversation.done'.
	// When the eval fails due to an error like Chat error or incorrect configuration, the status is 'error'.
	// When the eval runs for too long, due to model issues or tool call issues, the status is 'timeout'.
	// When the eval run is cancelled by the user, the status is 'cancelled'.
	// When the eval run is cancelled by Vapi for any reason, the status is 'aborted'.
	EndedReason EvalRunEndedReason `json:"endedReason" url:"endedReason"`
	// This is the transient eval that will be run
	Eval *CreateEvalDto `json:"eval,omitempty" url:"eval,omitempty"`
	// This is the target that will be run against the eval
	Target    *EvalRunTarget `json:"target" url:"target"`
	Id        string         `json:"id" url:"id"`
	OrgId     string         `json:"orgId" url:"orgId"`
	CreatedAt time.Time      `json:"createdAt" url:"createdAt"`
	StartedAt time.Time      `json:"startedAt" url:"startedAt"`
	EndedAt   time.Time      `json:"endedAt" url:"endedAt"`
	// This is the ended message when the eval run ended for any reason apart from mockConversation.done
	EndedMessage *string `json:"endedMessage,omitempty" url:"endedMessage,omitempty"`
	// This is the results of the eval or suite run.
	// The array will have a single item for an eval run, and multiple items each corresponding to the an eval in a suite run in the same order as the evals in the suite.
	Results []*EvalRunResult `json:"results" url:"results"`
	// This is the cost of the eval or suite run in USD.
	Cost float64 `json:"cost" url:"cost"`
	// This is the break up of costs of the eval or suite run.
	Costs []map[string]interface{} `json:"costs" url:"costs"`
	// This is the type of the run.
	// Currently it is fixed to `eval`.
	Type EvalRunType `json:"type" url:"type"`
	// This is the id of the eval that will be run.
	EvalId *string `json:"evalId,omitempty" url:"evalId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalRun) GetStatus() EvalRunStatus {
	if e == nil {
		return ""
	}
	return e.Status
}

func (e *EvalRun) GetEndedReason() EvalRunEndedReason {
	if e == nil {
		return ""
	}
	return e.EndedReason
}

func (e *EvalRun) GetEval() *CreateEvalDto {
	if e == nil {
		return nil
	}
	return e.Eval
}

func (e *EvalRun) GetTarget() *EvalRunTarget {
	if e == nil {
		return nil
	}
	return e.Target
}

func (e *EvalRun) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EvalRun) GetOrgId() string {
	if e == nil {
		return ""
	}
	return e.OrgId
}

func (e *EvalRun) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *EvalRun) GetStartedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.StartedAt
}

func (e *EvalRun) GetEndedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.EndedAt
}

func (e *EvalRun) GetEndedMessage() *string {
	if e == nil {
		return nil
	}
	return e.EndedMessage
}

func (e *EvalRun) GetResults() []*EvalRunResult {
	if e == nil {
		return nil
	}
	return e.Results
}

func (e *EvalRun) GetCost() float64 {
	if e == nil {
		return 0
	}
	return e.Cost
}

func (e *EvalRun) GetCosts() []map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Costs
}

func (e *EvalRun) GetType() EvalRunType {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EvalRun) GetEvalId() *string {
	if e == nil {
		return nil
	}
	return e.EvalId
}

func (e *EvalRun) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalRun) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetStatus(status EvalRunStatus) {
	e.Status = status
	e.require(evalRunFieldStatus)
}

// SetEndedReason sets the EndedReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetEndedReason(endedReason EvalRunEndedReason) {
	e.EndedReason = endedReason
	e.require(evalRunFieldEndedReason)
}

// SetEval sets the Eval field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetEval(eval *CreateEvalDto) {
	e.Eval = eval
	e.require(evalRunFieldEval)
}

// SetTarget sets the Target field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetTarget(target *EvalRunTarget) {
	e.Target = target
	e.require(evalRunFieldTarget)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetId(id string) {
	e.Id = id
	e.require(evalRunFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetOrgId(orgId string) {
	e.OrgId = orgId
	e.require(evalRunFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetCreatedAt(createdAt time.Time) {
	e.CreatedAt = createdAt
	e.require(evalRunFieldCreatedAt)
}

// SetStartedAt sets the StartedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetStartedAt(startedAt time.Time) {
	e.StartedAt = startedAt
	e.require(evalRunFieldStartedAt)
}

// SetEndedAt sets the EndedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetEndedAt(endedAt time.Time) {
	e.EndedAt = endedAt
	e.require(evalRunFieldEndedAt)
}

// SetEndedMessage sets the EndedMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetEndedMessage(endedMessage *string) {
	e.EndedMessage = endedMessage
	e.require(evalRunFieldEndedMessage)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetResults(results []*EvalRunResult) {
	e.Results = results
	e.require(evalRunFieldResults)
}

// SetCost sets the Cost field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetCost(cost float64) {
	e.Cost = cost
	e.require(evalRunFieldCost)
}

// SetCosts sets the Costs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetCosts(costs []map[string]interface{}) {
	e.Costs = costs
	e.require(evalRunFieldCosts)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetType(type_ EvalRunType) {
	e.Type = type_
	e.require(evalRunFieldType)
}

// SetEvalId sets the EvalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetEvalId(evalId *string) {
	e.EvalId = evalId
	e.require(evalRunFieldEvalId)
}

func (e *EvalRun) UnmarshalJSON(data []byte) error {
	type embed EvalRun
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		StartedAt *internal.DateTime `json:"startedAt"`
		EndedAt   *internal.DateTime `json:"endedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EvalRun(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.StartedAt = unmarshaler.StartedAt.Time()
	e.EndedAt = unmarshaler.EndedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalRun) MarshalJSON() ([]byte, error) {
	type embed EvalRun
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		StartedAt *internal.DateTime `json:"startedAt"`
		EndedAt   *internal.DateTime `json:"endedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		StartedAt: internal.NewDateTime(e.StartedAt),
		EndedAt:   internal.NewDateTime(e.EndedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalRun) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the reason for the eval run to end.
// When the eval run is completed normally i.e end of mock conversation, the status is 'mockConversation.done'.
// When the eval fails due to an error like Chat error or incorrect configuration, the status is 'error'.
// When the eval runs for too long, due to model issues or tool call issues, the status is 'timeout'.
// When the eval run is cancelled by the user, the status is 'cancelled'.
// When the eval run is cancelled by Vapi for any reason, the status is 'aborted'.
type EvalRunEndedReason string

const (
	EvalRunEndedReasonMockConversationDone EvalRunEndedReason = "mockConversation.done"
	EvalRunEndedReasonError                EvalRunEndedReason = "error"
	EvalRunEndedReasonTimeout              EvalRunEndedReason = "timeout"
	EvalRunEndedReasonCancelled            EvalRunEndedReason = "cancelled"
	EvalRunEndedReasonAborted              EvalRunEndedReason = "aborted"
)

func NewEvalRunEndedReasonFromString(s string) (EvalRunEndedReason, error) {
	switch s {
	case "mockConversation.done":
		return EvalRunEndedReasonMockConversationDone, nil
	case "error":
		return EvalRunEndedReasonError, nil
	case "timeout":
		return EvalRunEndedReasonTimeout, nil
	case "cancelled":
		return EvalRunEndedReasonCancelled, nil
	case "aborted":
		return EvalRunEndedReasonAborted, nil
	}
	var t EvalRunEndedReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalRunEndedReason) Ptr() *EvalRunEndedReason {
	return &e
}

var (
	evalRunPaginatedResponseFieldResults  = big.NewInt(1 << 0)
	evalRunPaginatedResponseFieldMetadata = big.NewInt(1 << 1)
)

type EvalRunPaginatedResponse struct {
	Results  []*EvalRun      `json:"results" url:"results"`
	Metadata *PaginationMeta `json:"metadata" url:"metadata"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalRunPaginatedResponse) GetResults() []*EvalRun {
	if e == nil {
		return nil
	}
	return e.Results
}

func (e *EvalRunPaginatedResponse) GetMetadata() *PaginationMeta {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EvalRunPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalRunPaginatedResponse) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunPaginatedResponse) SetResults(results []*EvalRun) {
	e.Results = results
	e.require(evalRunPaginatedResponseFieldResults)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunPaginatedResponse) SetMetadata(metadata *PaginationMeta) {
	e.Metadata = metadata
	e.require(evalRunPaginatedResponseFieldMetadata)
}

func (e *EvalRunPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EvalRunPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EvalRunPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalRunPaginatedResponse) MarshalJSON() ([]byte, error) {
	type embed EvalRunPaginatedResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalRunPaginatedResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	evalRunResultFieldStatus    = big.NewInt(1 << 0)
	evalRunResultFieldMessages  = big.NewInt(1 << 1)
	evalRunResultFieldStartedAt = big.NewInt(1 << 2)
	evalRunResultFieldEndedAt   = big.NewInt(1 << 3)
)

type EvalRunResult struct {
	// This is the status of the eval run result.
	// The status is only 'pass' or 'fail' for an eval run result.
	// Currently, An eval is considered `pass` only if all the Assistant Judge messages are evaluated to pass.
	Status EvalRunResultStatus `json:"status" url:"status"`
	// This is the messages of the eval run result.
	// It contains the user/system messages
	Messages []*EvalRunResultMessagesItem `json:"messages" url:"messages"`
	// This is the start time of the eval run result.
	StartedAt time.Time `json:"startedAt" url:"startedAt"`
	// This is the end time of the eval run result.
	EndedAt time.Time `json:"endedAt" url:"endedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalRunResult) GetStatus() EvalRunResultStatus {
	if e == nil {
		return ""
	}
	return e.Status
}

func (e *EvalRunResult) GetMessages() []*EvalRunResultMessagesItem {
	if e == nil {
		return nil
	}
	return e.Messages
}

func (e *EvalRunResult) GetStartedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.StartedAt
}

func (e *EvalRunResult) GetEndedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.EndedAt
}

func (e *EvalRunResult) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalRunResult) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunResult) SetStatus(status EvalRunResultStatus) {
	e.Status = status
	e.require(evalRunResultFieldStatus)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunResult) SetMessages(messages []*EvalRunResultMessagesItem) {
	e.Messages = messages
	e.require(evalRunResultFieldMessages)
}

// SetStartedAt sets the StartedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunResult) SetStartedAt(startedAt time.Time) {
	e.StartedAt = startedAt
	e.require(evalRunResultFieldStartedAt)
}

// SetEndedAt sets the EndedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunResult) SetEndedAt(endedAt time.Time) {
	e.EndedAt = endedAt
	e.require(evalRunResultFieldEndedAt)
}

func (e *EvalRunResult) UnmarshalJSON(data []byte) error {
	type embed EvalRunResult
	var unmarshaler = struct {
		embed
		StartedAt *internal.DateTime `json:"startedAt"`
		EndedAt   *internal.DateTime `json:"endedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EvalRunResult(unmarshaler.embed)
	e.StartedAt = unmarshaler.StartedAt.Time()
	e.EndedAt = unmarshaler.EndedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalRunResult) MarshalJSON() ([]byte, error) {
	type embed EvalRunResult
	var marshaler = struct {
		embed
		StartedAt *internal.DateTime `json:"startedAt"`
		EndedAt   *internal.DateTime `json:"endedAt"`
	}{
		embed:     embed(*e),
		StartedAt: internal.NewDateTime(e.StartedAt),
		EndedAt:   internal.NewDateTime(e.EndedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalRunResult) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EvalRunResultMessagesItem struct {
	ChatEvalUserMessageMock         *ChatEvalUserMessageMock
	ChatEvalSystemMessageMock       *ChatEvalSystemMessageMock
	ChatEvalToolResponseMessageMock *ChatEvalToolResponseMessageMock
	ChatEvalAssistantMessageMock    *ChatEvalAssistantMessageMock

	typ string
}

func (e *EvalRunResultMessagesItem) GetChatEvalUserMessageMock() *ChatEvalUserMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalUserMessageMock
}

func (e *EvalRunResultMessagesItem) GetChatEvalSystemMessageMock() *ChatEvalSystemMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalSystemMessageMock
}

func (e *EvalRunResultMessagesItem) GetChatEvalToolResponseMessageMock() *ChatEvalToolResponseMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalToolResponseMessageMock
}

func (e *EvalRunResultMessagesItem) GetChatEvalAssistantMessageMock() *ChatEvalAssistantMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalAssistantMessageMock
}

func (e *EvalRunResultMessagesItem) UnmarshalJSON(data []byte) error {
	valueChatEvalUserMessageMock := new(ChatEvalUserMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalUserMessageMock); err == nil {
		e.typ = "ChatEvalUserMessageMock"
		e.ChatEvalUserMessageMock = valueChatEvalUserMessageMock
		return nil
	}
	valueChatEvalSystemMessageMock := new(ChatEvalSystemMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalSystemMessageMock); err == nil {
		e.typ = "ChatEvalSystemMessageMock"
		e.ChatEvalSystemMessageMock = valueChatEvalSystemMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageMock := new(ChatEvalToolResponseMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageMock); err == nil {
		e.typ = "ChatEvalToolResponseMessageMock"
		e.ChatEvalToolResponseMessageMock = valueChatEvalToolResponseMessageMock
		return nil
	}
	valueChatEvalAssistantMessageMock := new(ChatEvalAssistantMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageMock); err == nil {
		e.typ = "ChatEvalAssistantMessageMock"
		e.ChatEvalAssistantMessageMock = valueChatEvalAssistantMessageMock
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EvalRunResultMessagesItem) MarshalJSON() ([]byte, error) {
	if e.typ == "ChatEvalUserMessageMock" || e.ChatEvalUserMessageMock != nil {
		return json.Marshal(e.ChatEvalUserMessageMock)
	}
	if e.typ == "ChatEvalSystemMessageMock" || e.ChatEvalSystemMessageMock != nil {
		return json.Marshal(e.ChatEvalSystemMessageMock)
	}
	if e.typ == "ChatEvalToolResponseMessageMock" || e.ChatEvalToolResponseMessageMock != nil {
		return json.Marshal(e.ChatEvalToolResponseMessageMock)
	}
	if e.typ == "ChatEvalAssistantMessageMock" || e.ChatEvalAssistantMessageMock != nil {
		return json.Marshal(e.ChatEvalAssistantMessageMock)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EvalRunResultMessagesItemVisitor interface {
	VisitChatEvalUserMessageMock(*ChatEvalUserMessageMock) error
	VisitChatEvalSystemMessageMock(*ChatEvalSystemMessageMock) error
	VisitChatEvalToolResponseMessageMock(*ChatEvalToolResponseMessageMock) error
	VisitChatEvalAssistantMessageMock(*ChatEvalAssistantMessageMock) error
}

func (e *EvalRunResultMessagesItem) Accept(visitor EvalRunResultMessagesItemVisitor) error {
	if e.typ == "ChatEvalUserMessageMock" || e.ChatEvalUserMessageMock != nil {
		return visitor.VisitChatEvalUserMessageMock(e.ChatEvalUserMessageMock)
	}
	if e.typ == "ChatEvalSystemMessageMock" || e.ChatEvalSystemMessageMock != nil {
		return visitor.VisitChatEvalSystemMessageMock(e.ChatEvalSystemMessageMock)
	}
	if e.typ == "ChatEvalToolResponseMessageMock" || e.ChatEvalToolResponseMessageMock != nil {
		return visitor.VisitChatEvalToolResponseMessageMock(e.ChatEvalToolResponseMessageMock)
	}
	if e.typ == "ChatEvalAssistantMessageMock" || e.ChatEvalAssistantMessageMock != nil {
		return visitor.VisitChatEvalAssistantMessageMock(e.ChatEvalAssistantMessageMock)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// This is the status of the eval run result.
// The status is only 'pass' or 'fail' for an eval run result.
// Currently, An eval is considered `pass` only if all the Assistant Judge messages are evaluated to pass.
type EvalRunResultStatus string

const (
	EvalRunResultStatusPass EvalRunResultStatus = "pass"
	EvalRunResultStatusFail EvalRunResultStatus = "fail"
)

func NewEvalRunResultStatusFromString(s string) (EvalRunResultStatus, error) {
	switch s {
	case "pass":
		return EvalRunResultStatusPass, nil
	case "fail":
		return EvalRunResultStatusFail, nil
	}
	var t EvalRunResultStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalRunResultStatus) Ptr() *EvalRunResultStatus {
	return &e
}

// This is the status of the eval run. When an eval run is created, the status is 'running'.
// When the eval run is completed, the status is 'ended'.
type EvalRunStatus string

const (
	EvalRunStatusRunning EvalRunStatus = "running"
	EvalRunStatusEnded   EvalRunStatus = "ended"
	EvalRunStatusQueued  EvalRunStatus = "queued"
)

func NewEvalRunStatusFromString(s string) (EvalRunStatus, error) {
	switch s {
	case "running":
		return EvalRunStatusRunning, nil
	case "ended":
		return EvalRunStatusEnded, nil
	case "queued":
		return EvalRunStatusQueued, nil
	}
	var t EvalRunStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalRunStatus) Ptr() *EvalRunStatus {
	return &e
}

// This is the target that will be run against the eval
type EvalRunTarget struct {
	EvalRunTargetAssistant *EvalRunTargetAssistant
	EvalRunTargetSquad     *EvalRunTargetSquad

	typ string
}

func (e *EvalRunTarget) GetEvalRunTargetAssistant() *EvalRunTargetAssistant {
	if e == nil {
		return nil
	}
	return e.EvalRunTargetAssistant
}

func (e *EvalRunTarget) GetEvalRunTargetSquad() *EvalRunTargetSquad {
	if e == nil {
		return nil
	}
	return e.EvalRunTargetSquad
}

func (e *EvalRunTarget) UnmarshalJSON(data []byte) error {
	valueEvalRunTargetAssistant := new(EvalRunTargetAssistant)
	if err := json.Unmarshal(data, &valueEvalRunTargetAssistant); err == nil {
		e.typ = "EvalRunTargetAssistant"
		e.EvalRunTargetAssistant = valueEvalRunTargetAssistant
		return nil
	}
	valueEvalRunTargetSquad := new(EvalRunTargetSquad)
	if err := json.Unmarshal(data, &valueEvalRunTargetSquad); err == nil {
		e.typ = "EvalRunTargetSquad"
		e.EvalRunTargetSquad = valueEvalRunTargetSquad
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EvalRunTarget) MarshalJSON() ([]byte, error) {
	if e.typ == "EvalRunTargetAssistant" || e.EvalRunTargetAssistant != nil {
		return json.Marshal(e.EvalRunTargetAssistant)
	}
	if e.typ == "EvalRunTargetSquad" || e.EvalRunTargetSquad != nil {
		return json.Marshal(e.EvalRunTargetSquad)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EvalRunTargetVisitor interface {
	VisitEvalRunTargetAssistant(*EvalRunTargetAssistant) error
	VisitEvalRunTargetSquad(*EvalRunTargetSquad) error
}

func (e *EvalRunTarget) Accept(visitor EvalRunTargetVisitor) error {
	if e.typ == "EvalRunTargetAssistant" || e.EvalRunTargetAssistant != nil {
		return visitor.VisitEvalRunTargetAssistant(e.EvalRunTargetAssistant)
	}
	if e.typ == "EvalRunTargetSquad" || e.EvalRunTargetSquad != nil {
		return visitor.VisitEvalRunTargetSquad(e.EvalRunTargetSquad)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

var (
	evalRunTargetAssistantFieldAssistant          = big.NewInt(1 << 0)
	evalRunTargetAssistantFieldAssistantOverrides = big.NewInt(1 << 1)
	evalRunTargetAssistantFieldType               = big.NewInt(1 << 2)
	evalRunTargetAssistantFieldAssistantId        = big.NewInt(1 << 3)
)

type EvalRunTargetAssistant struct {
	// This is the transient assistant that will be run against the eval
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the overrides that will be applied to the assistant.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the type of the target.
	// Currently it is fixed to `assistant`.
	Type EvalRunTargetAssistantType `json:"type" url:"type"`
	// This is the id of the assistant that will be run against the eval
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalRunTargetAssistant) GetAssistant() *CreateAssistantDto {
	if e == nil {
		return nil
	}
	return e.Assistant
}

func (e *EvalRunTargetAssistant) GetAssistantOverrides() *AssistantOverrides {
	if e == nil {
		return nil
	}
	return e.AssistantOverrides
}

func (e *EvalRunTargetAssistant) GetType() EvalRunTargetAssistantType {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EvalRunTargetAssistant) GetAssistantId() *string {
	if e == nil {
		return nil
	}
	return e.AssistantId
}

func (e *EvalRunTargetAssistant) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalRunTargetAssistant) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetAssistant sets the Assistant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetAssistant) SetAssistant(assistant *CreateAssistantDto) {
	e.Assistant = assistant
	e.require(evalRunTargetAssistantFieldAssistant)
}

// SetAssistantOverrides sets the AssistantOverrides field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetAssistant) SetAssistantOverrides(assistantOverrides *AssistantOverrides) {
	e.AssistantOverrides = assistantOverrides
	e.require(evalRunTargetAssistantFieldAssistantOverrides)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetAssistant) SetType(type_ EvalRunTargetAssistantType) {
	e.Type = type_
	e.require(evalRunTargetAssistantFieldType)
}

// SetAssistantId sets the AssistantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetAssistant) SetAssistantId(assistantId *string) {
	e.AssistantId = assistantId
	e.require(evalRunTargetAssistantFieldAssistantId)
}

func (e *EvalRunTargetAssistant) UnmarshalJSON(data []byte) error {
	type unmarshaler EvalRunTargetAssistant
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EvalRunTargetAssistant(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalRunTargetAssistant) MarshalJSON() ([]byte, error) {
	type embed EvalRunTargetAssistant
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalRunTargetAssistant) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the type of the target.
// Currently it is fixed to `assistant`.
type EvalRunTargetAssistantType string

const (
	EvalRunTargetAssistantTypeAssistant EvalRunTargetAssistantType = "assistant"
)

func NewEvalRunTargetAssistantTypeFromString(s string) (EvalRunTargetAssistantType, error) {
	switch s {
	case "assistant":
		return EvalRunTargetAssistantTypeAssistant, nil
	}
	var t EvalRunTargetAssistantType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalRunTargetAssistantType) Ptr() *EvalRunTargetAssistantType {
	return &e
}

var (
	evalRunTargetSquadFieldSquad              = big.NewInt(1 << 0)
	evalRunTargetSquadFieldAssistantOverrides = big.NewInt(1 << 1)
	evalRunTargetSquadFieldType               = big.NewInt(1 << 2)
	evalRunTargetSquadFieldSquadId            = big.NewInt(1 << 3)
)

type EvalRunTargetSquad struct {
	// This is the transient squad that will be run against the eval
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// This is the overrides that will be applied to the assistants.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the type of the target.
	// Currently it is fixed to `squad`.
	Type EvalRunTargetSquadType `json:"type" url:"type"`
	// This is the id of the squad that will be run against the eval
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalRunTargetSquad) GetSquad() *CreateSquadDto {
	if e == nil {
		return nil
	}
	return e.Squad
}

func (e *EvalRunTargetSquad) GetAssistantOverrides() *AssistantOverrides {
	if e == nil {
		return nil
	}
	return e.AssistantOverrides
}

func (e *EvalRunTargetSquad) GetType() EvalRunTargetSquadType {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EvalRunTargetSquad) GetSquadId() *string {
	if e == nil {
		return nil
	}
	return e.SquadId
}

func (e *EvalRunTargetSquad) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalRunTargetSquad) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetSquad sets the Squad field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetSquad) SetSquad(squad *CreateSquadDto) {
	e.Squad = squad
	e.require(evalRunTargetSquadFieldSquad)
}

// SetAssistantOverrides sets the AssistantOverrides field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetSquad) SetAssistantOverrides(assistantOverrides *AssistantOverrides) {
	e.AssistantOverrides = assistantOverrides
	e.require(evalRunTargetSquadFieldAssistantOverrides)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetSquad) SetType(type_ EvalRunTargetSquadType) {
	e.Type = type_
	e.require(evalRunTargetSquadFieldType)
}

// SetSquadId sets the SquadId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetSquad) SetSquadId(squadId *string) {
	e.SquadId = squadId
	e.require(evalRunTargetSquadFieldSquadId)
}

func (e *EvalRunTargetSquad) UnmarshalJSON(data []byte) error {
	type unmarshaler EvalRunTargetSquad
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EvalRunTargetSquad(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalRunTargetSquad) MarshalJSON() ([]byte, error) {
	type embed EvalRunTargetSquad
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalRunTargetSquad) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the type of the target.
// Currently it is fixed to `squad`.
type EvalRunTargetSquadType string

const (
	EvalRunTargetSquadTypeSquad EvalRunTargetSquadType = "squad"
)

func NewEvalRunTargetSquadTypeFromString(s string) (EvalRunTargetSquadType, error) {
	switch s {
	case "squad":
		return EvalRunTargetSquadTypeSquad, nil
	}
	var t EvalRunTargetSquadType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalRunTargetSquadType) Ptr() *EvalRunTargetSquadType {
	return &e
}

// This is the type of the run.
// Currently it is fixed to `eval`.
type EvalRunType string

const (
	EvalRunTypeEval EvalRunType = "eval"
)

func NewEvalRunTypeFromString(s string) (EvalRunType, error) {
	switch s {
	case "eval":
		return EvalRunTypeEval, nil
	}
	var t EvalRunType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalRunType) Ptr() *EvalRunType {
	return &e
}

// This is the type of the eval.
// Currently it is fixed to `chat.mockConversation`.
type EvalType string

const (
	EvalTypeChatMockConversation EvalType = "chat.mockConversation"
)

func NewEvalTypeFromString(s string) (EvalType, error) {
	switch s {
	case "chat.mockConversation":
		return EvalTypeChatMockConversation, nil
	}
	var t EvalType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalType) Ptr() *EvalType {
	return &e
}

// This is the target that will be run against the eval
type CreateEvalRunDtoTarget struct {
	EvalRunTargetAssistant *EvalRunTargetAssistant
	EvalRunTargetSquad     *EvalRunTargetSquad

	typ string
}

func (c *CreateEvalRunDtoTarget) GetEvalRunTargetAssistant() *EvalRunTargetAssistant {
	if c == nil {
		return nil
	}
	return c.EvalRunTargetAssistant
}

func (c *CreateEvalRunDtoTarget) GetEvalRunTargetSquad() *EvalRunTargetSquad {
	if c == nil {
		return nil
	}
	return c.EvalRunTargetSquad
}

func (c *CreateEvalRunDtoTarget) UnmarshalJSON(data []byte) error {
	valueEvalRunTargetAssistant := new(EvalRunTargetAssistant)
	if err := json.Unmarshal(data, &valueEvalRunTargetAssistant); err == nil {
		c.typ = "EvalRunTargetAssistant"
		c.EvalRunTargetAssistant = valueEvalRunTargetAssistant
		return nil
	}
	valueEvalRunTargetSquad := new(EvalRunTargetSquad)
	if err := json.Unmarshal(data, &valueEvalRunTargetSquad); err == nil {
		c.typ = "EvalRunTargetSquad"
		c.EvalRunTargetSquad = valueEvalRunTargetSquad
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEvalRunDtoTarget) MarshalJSON() ([]byte, error) {
	if c.typ == "EvalRunTargetAssistant" || c.EvalRunTargetAssistant != nil {
		return json.Marshal(c.EvalRunTargetAssistant)
	}
	if c.typ == "EvalRunTargetSquad" || c.EvalRunTargetSquad != nil {
		return json.Marshal(c.EvalRunTargetSquad)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateEvalRunDtoTargetVisitor interface {
	VisitEvalRunTargetAssistant(*EvalRunTargetAssistant) error
	VisitEvalRunTargetSquad(*EvalRunTargetSquad) error
}

func (c *CreateEvalRunDtoTarget) Accept(visitor CreateEvalRunDtoTargetVisitor) error {
	if c.typ == "EvalRunTargetAssistant" || c.EvalRunTargetAssistant != nil {
		return visitor.VisitEvalRunTargetAssistant(c.EvalRunTargetAssistant)
	}
	if c.typ == "EvalRunTargetSquad" || c.EvalRunTargetSquad != nil {
		return visitor.VisitEvalRunTargetSquad(c.EvalRunTargetSquad)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the type of the run.
// Currently it is fixed to `eval`.
type CreateEvalRunDtoType string

const (
	CreateEvalRunDtoTypeEval CreateEvalRunDtoType = "eval"
)

func NewCreateEvalRunDtoTypeFromString(s string) (CreateEvalRunDtoType, error) {
	switch s {
	case "eval":
		return CreateEvalRunDtoTypeEval, nil
	}
	var t CreateEvalRunDtoType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateEvalRunDtoType) Ptr() *CreateEvalRunDtoType {
	return &c
}

type EvalControllerGetPaginatedRequestSortOrder string

const (
	EvalControllerGetPaginatedRequestSortOrderAsc  EvalControllerGetPaginatedRequestSortOrder = "ASC"
	EvalControllerGetPaginatedRequestSortOrderDesc EvalControllerGetPaginatedRequestSortOrder = "DESC"
)

func NewEvalControllerGetPaginatedRequestSortOrderFromString(s string) (EvalControllerGetPaginatedRequestSortOrder, error) {
	switch s {
	case "ASC":
		return EvalControllerGetPaginatedRequestSortOrderAsc, nil
	case "DESC":
		return EvalControllerGetPaginatedRequestSortOrderDesc, nil
	}
	var t EvalControllerGetPaginatedRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalControllerGetPaginatedRequestSortOrder) Ptr() *EvalControllerGetPaginatedRequestSortOrder {
	return &e
}

type EvalControllerGetRunsPaginatedRequestSortOrder string

const (
	EvalControllerGetRunsPaginatedRequestSortOrderAsc  EvalControllerGetRunsPaginatedRequestSortOrder = "ASC"
	EvalControllerGetRunsPaginatedRequestSortOrderDesc EvalControllerGetRunsPaginatedRequestSortOrder = "DESC"
)

func NewEvalControllerGetRunsPaginatedRequestSortOrderFromString(s string) (EvalControllerGetRunsPaginatedRequestSortOrder, error) {
	switch s {
	case "ASC":
		return EvalControllerGetRunsPaginatedRequestSortOrderAsc, nil
	case "DESC":
		return EvalControllerGetRunsPaginatedRequestSortOrderDesc, nil
	}
	var t EvalControllerGetRunsPaginatedRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalControllerGetRunsPaginatedRequestSortOrder) Ptr() *EvalControllerGetRunsPaginatedRequestSortOrder {
	return &e
}

type UpdateEvalDtoMessagesItem struct {
	ChatEvalAssistantMessageMock          *ChatEvalAssistantMessageMock
	ChatEvalSystemMessageMock             *ChatEvalSystemMessageMock
	ChatEvalToolResponseMessageMock       *ChatEvalToolResponseMessageMock
	ChatEvalToolResponseMessageEvaluation *ChatEvalToolResponseMessageEvaluation
	ChatEvalUserMessageMock               *ChatEvalUserMessageMock
	ChatEvalAssistantMessageEvaluation    *ChatEvalAssistantMessageEvaluation

	typ string
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalAssistantMessageMock() *ChatEvalAssistantMessageMock {
	if u == nil {
		return nil
	}
	return u.ChatEvalAssistantMessageMock
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalSystemMessageMock() *ChatEvalSystemMessageMock {
	if u == nil {
		return nil
	}
	return u.ChatEvalSystemMessageMock
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalToolResponseMessageMock() *ChatEvalToolResponseMessageMock {
	if u == nil {
		return nil
	}
	return u.ChatEvalToolResponseMessageMock
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalToolResponseMessageEvaluation() *ChatEvalToolResponseMessageEvaluation {
	if u == nil {
		return nil
	}
	return u.ChatEvalToolResponseMessageEvaluation
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalUserMessageMock() *ChatEvalUserMessageMock {
	if u == nil {
		return nil
	}
	return u.ChatEvalUserMessageMock
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalAssistantMessageEvaluation() *ChatEvalAssistantMessageEvaluation {
	if u == nil {
		return nil
	}
	return u.ChatEvalAssistantMessageEvaluation
}

func (u *UpdateEvalDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueChatEvalAssistantMessageMock := new(ChatEvalAssistantMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageMock); err == nil {
		u.typ = "ChatEvalAssistantMessageMock"
		u.ChatEvalAssistantMessageMock = valueChatEvalAssistantMessageMock
		return nil
	}
	valueChatEvalSystemMessageMock := new(ChatEvalSystemMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalSystemMessageMock); err == nil {
		u.typ = "ChatEvalSystemMessageMock"
		u.ChatEvalSystemMessageMock = valueChatEvalSystemMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageMock := new(ChatEvalToolResponseMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageMock); err == nil {
		u.typ = "ChatEvalToolResponseMessageMock"
		u.ChatEvalToolResponseMessageMock = valueChatEvalToolResponseMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageEvaluation := new(ChatEvalToolResponseMessageEvaluation)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageEvaluation); err == nil {
		u.typ = "ChatEvalToolResponseMessageEvaluation"
		u.ChatEvalToolResponseMessageEvaluation = valueChatEvalToolResponseMessageEvaluation
		return nil
	}
	valueChatEvalUserMessageMock := new(ChatEvalUserMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalUserMessageMock); err == nil {
		u.typ = "ChatEvalUserMessageMock"
		u.ChatEvalUserMessageMock = valueChatEvalUserMessageMock
		return nil
	}
	valueChatEvalAssistantMessageEvaluation := new(ChatEvalAssistantMessageEvaluation)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageEvaluation); err == nil {
		u.typ = "ChatEvalAssistantMessageEvaluation"
		u.ChatEvalAssistantMessageEvaluation = valueChatEvalAssistantMessageEvaluation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateEvalDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ChatEvalAssistantMessageMock" || u.ChatEvalAssistantMessageMock != nil {
		return json.Marshal(u.ChatEvalAssistantMessageMock)
	}
	if u.typ == "ChatEvalSystemMessageMock" || u.ChatEvalSystemMessageMock != nil {
		return json.Marshal(u.ChatEvalSystemMessageMock)
	}
	if u.typ == "ChatEvalToolResponseMessageMock" || u.ChatEvalToolResponseMessageMock != nil {
		return json.Marshal(u.ChatEvalToolResponseMessageMock)
	}
	if u.typ == "ChatEvalToolResponseMessageEvaluation" || u.ChatEvalToolResponseMessageEvaluation != nil {
		return json.Marshal(u.ChatEvalToolResponseMessageEvaluation)
	}
	if u.typ == "ChatEvalUserMessageMock" || u.ChatEvalUserMessageMock != nil {
		return json.Marshal(u.ChatEvalUserMessageMock)
	}
	if u.typ == "ChatEvalAssistantMessageEvaluation" || u.ChatEvalAssistantMessageEvaluation != nil {
		return json.Marshal(u.ChatEvalAssistantMessageEvaluation)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateEvalDtoMessagesItemVisitor interface {
	VisitChatEvalAssistantMessageMock(*ChatEvalAssistantMessageMock) error
	VisitChatEvalSystemMessageMock(*ChatEvalSystemMessageMock) error
	VisitChatEvalToolResponseMessageMock(*ChatEvalToolResponseMessageMock) error
	VisitChatEvalToolResponseMessageEvaluation(*ChatEvalToolResponseMessageEvaluation) error
	VisitChatEvalUserMessageMock(*ChatEvalUserMessageMock) error
	VisitChatEvalAssistantMessageEvaluation(*ChatEvalAssistantMessageEvaluation) error
}

func (u *UpdateEvalDtoMessagesItem) Accept(visitor UpdateEvalDtoMessagesItemVisitor) error {
	if u.typ == "ChatEvalAssistantMessageMock" || u.ChatEvalAssistantMessageMock != nil {
		return visitor.VisitChatEvalAssistantMessageMock(u.ChatEvalAssistantMessageMock)
	}
	if u.typ == "ChatEvalSystemMessageMock" || u.ChatEvalSystemMessageMock != nil {
		return visitor.VisitChatEvalSystemMessageMock(u.ChatEvalSystemMessageMock)
	}
	if u.typ == "ChatEvalToolResponseMessageMock" || u.ChatEvalToolResponseMessageMock != nil {
		return visitor.VisitChatEvalToolResponseMessageMock(u.ChatEvalToolResponseMessageMock)
	}
	if u.typ == "ChatEvalToolResponseMessageEvaluation" || u.ChatEvalToolResponseMessageEvaluation != nil {
		return visitor.VisitChatEvalToolResponseMessageEvaluation(u.ChatEvalToolResponseMessageEvaluation)
	}
	if u.typ == "ChatEvalUserMessageMock" || u.ChatEvalUserMessageMock != nil {
		return visitor.VisitChatEvalUserMessageMock(u.ChatEvalUserMessageMock)
	}
	if u.typ == "ChatEvalAssistantMessageEvaluation" || u.ChatEvalAssistantMessageEvaluation != nil {
		return visitor.VisitChatEvalAssistantMessageEvaluation(u.ChatEvalAssistantMessageEvaluation)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// This is the type of the eval.
// Currently it is fixed to `chat.mockConversation`.
type UpdateEvalDtoType string

const (
	UpdateEvalDtoTypeChatMockConversation UpdateEvalDtoType = "chat.mockConversation"
)

func NewUpdateEvalDtoTypeFromString(s string) (UpdateEvalDtoType, error) {
	switch s {
	case "chat.mockConversation":
		return UpdateEvalDtoTypeChatMockConversation, nil
	}
	var t UpdateEvalDtoType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateEvalDtoType) Ptr() *UpdateEvalDtoType {
	return &u
}
