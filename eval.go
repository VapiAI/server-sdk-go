// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/VapiAI/server-sdk-go/internal"
	big "math/big"
	time "time"
)

var (
	evalControllerGetPaginatedRequestFieldId          = big.NewInt(1 << 0)
	evalControllerGetPaginatedRequestFieldPage        = big.NewInt(1 << 1)
	evalControllerGetPaginatedRequestFieldSortOrder   = big.NewInt(1 << 2)
	evalControllerGetPaginatedRequestFieldLimit       = big.NewInt(1 << 3)
	evalControllerGetPaginatedRequestFieldCreatedAtGt = big.NewInt(1 << 4)
	evalControllerGetPaginatedRequestFieldCreatedAtLt = big.NewInt(1 << 5)
	evalControllerGetPaginatedRequestFieldCreatedAtGe = big.NewInt(1 << 6)
	evalControllerGetPaginatedRequestFieldCreatedAtLe = big.NewInt(1 << 7)
	evalControllerGetPaginatedRequestFieldUpdatedAtGt = big.NewInt(1 << 8)
	evalControllerGetPaginatedRequestFieldUpdatedAtLt = big.NewInt(1 << 9)
	evalControllerGetPaginatedRequestFieldUpdatedAtGe = big.NewInt(1 << 10)
	evalControllerGetPaginatedRequestFieldUpdatedAtLe = big.NewInt(1 << 11)
)

type EvalControllerGetPaginatedRequest struct {
	Id *string `json:"-" url:"id,omitempty"`
	// This is the page number to return. Defaults to 1.
	Page *float64 `json:"-" url:"page,omitempty"`
	// This is the sort order for pagination. Defaults to 'DESC'.
	SortOrder *EvalControllerGetPaginatedRequestSortOrder `json:"-" url:"sortOrder,omitempty"`
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EvalControllerGetPaginatedRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetId(id *string) {
	e.Id = id
	e.require(evalControllerGetPaginatedRequestFieldId)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetPage(page *float64) {
	e.Page = page
	e.require(evalControllerGetPaginatedRequestFieldPage)
}

// SetSortOrder sets the SortOrder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetSortOrder(sortOrder *EvalControllerGetPaginatedRequestSortOrder) {
	e.SortOrder = sortOrder
	e.require(evalControllerGetPaginatedRequestFieldSortOrder)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetLimit(limit *float64) {
	e.Limit = limit
	e.require(evalControllerGetPaginatedRequestFieldLimit)
}

// SetCreatedAtGt sets the CreatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetCreatedAtGt(createdAtGt *time.Time) {
	e.CreatedAtGt = createdAtGt
	e.require(evalControllerGetPaginatedRequestFieldCreatedAtGt)
}

// SetCreatedAtLt sets the CreatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetCreatedAtLt(createdAtLt *time.Time) {
	e.CreatedAtLt = createdAtLt
	e.require(evalControllerGetPaginatedRequestFieldCreatedAtLt)
}

// SetCreatedAtGe sets the CreatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetCreatedAtGe(createdAtGe *time.Time) {
	e.CreatedAtGe = createdAtGe
	e.require(evalControllerGetPaginatedRequestFieldCreatedAtGe)
}

// SetCreatedAtLe sets the CreatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetCreatedAtLe(createdAtLe *time.Time) {
	e.CreatedAtLe = createdAtLe
	e.require(evalControllerGetPaginatedRequestFieldCreatedAtLe)
}

// SetUpdatedAtGt sets the UpdatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetUpdatedAtGt(updatedAtGt *time.Time) {
	e.UpdatedAtGt = updatedAtGt
	e.require(evalControllerGetPaginatedRequestFieldUpdatedAtGt)
}

// SetUpdatedAtLt sets the UpdatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetUpdatedAtLt(updatedAtLt *time.Time) {
	e.UpdatedAtLt = updatedAtLt
	e.require(evalControllerGetPaginatedRequestFieldUpdatedAtLt)
}

// SetUpdatedAtGe sets the UpdatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetUpdatedAtGe(updatedAtGe *time.Time) {
	e.UpdatedAtGe = updatedAtGe
	e.require(evalControllerGetPaginatedRequestFieldUpdatedAtGe)
}

// SetUpdatedAtLe sets the UpdatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetPaginatedRequest) SetUpdatedAtLe(updatedAtLe *time.Time) {
	e.UpdatedAtLe = updatedAtLe
	e.require(evalControllerGetPaginatedRequestFieldUpdatedAtLe)
}

var (
	evalControllerGetRunsPaginatedRequestFieldId          = big.NewInt(1 << 0)
	evalControllerGetRunsPaginatedRequestFieldPage        = big.NewInt(1 << 1)
	evalControllerGetRunsPaginatedRequestFieldSortOrder   = big.NewInt(1 << 2)
	evalControllerGetRunsPaginatedRequestFieldLimit       = big.NewInt(1 << 3)
	evalControllerGetRunsPaginatedRequestFieldCreatedAtGt = big.NewInt(1 << 4)
	evalControllerGetRunsPaginatedRequestFieldCreatedAtLt = big.NewInt(1 << 5)
	evalControllerGetRunsPaginatedRequestFieldCreatedAtGe = big.NewInt(1 << 6)
	evalControllerGetRunsPaginatedRequestFieldCreatedAtLe = big.NewInt(1 << 7)
	evalControllerGetRunsPaginatedRequestFieldUpdatedAtGt = big.NewInt(1 << 8)
	evalControllerGetRunsPaginatedRequestFieldUpdatedAtLt = big.NewInt(1 << 9)
	evalControllerGetRunsPaginatedRequestFieldUpdatedAtGe = big.NewInt(1 << 10)
	evalControllerGetRunsPaginatedRequestFieldUpdatedAtLe = big.NewInt(1 << 11)
)

type EvalControllerGetRunsPaginatedRequest struct {
	Id *string `json:"-" url:"id,omitempty"`
	// This is the page number to return. Defaults to 1.
	Page *float64 `json:"-" url:"page,omitempty"`
	// This is the sort order for pagination. Defaults to 'DESC'.
	SortOrder *EvalControllerGetRunsPaginatedRequestSortOrder `json:"-" url:"sortOrder,omitempty"`
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EvalControllerGetRunsPaginatedRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetId(id *string) {
	e.Id = id
	e.require(evalControllerGetRunsPaginatedRequestFieldId)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetPage(page *float64) {
	e.Page = page
	e.require(evalControllerGetRunsPaginatedRequestFieldPage)
}

// SetSortOrder sets the SortOrder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetSortOrder(sortOrder *EvalControllerGetRunsPaginatedRequestSortOrder) {
	e.SortOrder = sortOrder
	e.require(evalControllerGetRunsPaginatedRequestFieldSortOrder)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetLimit(limit *float64) {
	e.Limit = limit
	e.require(evalControllerGetRunsPaginatedRequestFieldLimit)
}

// SetCreatedAtGt sets the CreatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetCreatedAtGt(createdAtGt *time.Time) {
	e.CreatedAtGt = createdAtGt
	e.require(evalControllerGetRunsPaginatedRequestFieldCreatedAtGt)
}

// SetCreatedAtLt sets the CreatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetCreatedAtLt(createdAtLt *time.Time) {
	e.CreatedAtLt = createdAtLt
	e.require(evalControllerGetRunsPaginatedRequestFieldCreatedAtLt)
}

// SetCreatedAtGe sets the CreatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetCreatedAtGe(createdAtGe *time.Time) {
	e.CreatedAtGe = createdAtGe
	e.require(evalControllerGetRunsPaginatedRequestFieldCreatedAtGe)
}

// SetCreatedAtLe sets the CreatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetCreatedAtLe(createdAtLe *time.Time) {
	e.CreatedAtLe = createdAtLe
	e.require(evalControllerGetRunsPaginatedRequestFieldCreatedAtLe)
}

// SetUpdatedAtGt sets the UpdatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetUpdatedAtGt(updatedAtGt *time.Time) {
	e.UpdatedAtGt = updatedAtGt
	e.require(evalControllerGetRunsPaginatedRequestFieldUpdatedAtGt)
}

// SetUpdatedAtLt sets the UpdatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetUpdatedAtLt(updatedAtLt *time.Time) {
	e.UpdatedAtLt = updatedAtLt
	e.require(evalControllerGetRunsPaginatedRequestFieldUpdatedAtLt)
}

// SetUpdatedAtGe sets the UpdatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetUpdatedAtGe(updatedAtGe *time.Time) {
	e.UpdatedAtGe = updatedAtGe
	e.require(evalControllerGetRunsPaginatedRequestFieldUpdatedAtGe)
}

// SetUpdatedAtLe sets the UpdatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalControllerGetRunsPaginatedRequest) SetUpdatedAtLe(updatedAtLe *time.Time) {
	e.UpdatedAtLe = updatedAtLe
	e.require(evalControllerGetRunsPaginatedRequestFieldUpdatedAtLe)
}

var (
	createEvalRunDtoFieldEval   = big.NewInt(1 << 0)
	createEvalRunDtoFieldTarget = big.NewInt(1 << 1)
	createEvalRunDtoFieldEvalId = big.NewInt(1 << 2)
)

type CreateEvalRunDto struct {
	// This is the transient eval that will be run
	Eval *CreateEvalDto `json:"eval,omitempty" url:"-"`
	// This is the target that will be run against the eval
	Target *CreateEvalRunDtoTarget `json:"target,omitempty" url:"-"`
	// This is the type of the run.
	// Currently it is fixed to `eval`.
	// This is the id of the eval that will be run.
	EvalId *string `json:"evalId,omitempty" url:"-"`
	type_  string

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CreateEvalRunDto) Type() string {
	return c.type_
}

func (c *CreateEvalRunDto) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetEval sets the Eval field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalRunDto) SetEval(eval *CreateEvalDto) {
	c.Eval = eval
	c.require(createEvalRunDtoFieldEval)
}

// SetTarget sets the Target field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalRunDto) SetTarget(target *CreateEvalRunDtoTarget) {
	c.Target = target
	c.require(createEvalRunDtoFieldTarget)
}

// SetEvalId sets the EvalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalRunDto) SetEvalId(evalId *string) {
	c.EvalId = evalId
	c.require(createEvalRunDtoFieldEvalId)
}

func (c *CreateEvalRunDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateEvalRunDto
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*c = CreateEvalRunDto(body)
	c.type_ = "eval"
	return nil
}

func (c *CreateEvalRunDto) MarshalJSON() ([]byte, error) {
	type embed CreateEvalRunDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "eval",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

var (
	updateEvalDtoFieldMessages    = big.NewInt(1 << 0)
	updateEvalDtoFieldName        = big.NewInt(1 << 1)
	updateEvalDtoFieldDescription = big.NewInt(1 << 2)
	updateEvalDtoFieldType        = big.NewInt(1 << 3)
)

type UpdateEvalDto struct {
	// This is the mock conversation that will be used to evaluate the flow of the conversation.
	//
	// # Mock Messages are used to simulate the flow of the conversation
	//
	// Evaluation Messages are used as checkpoints in the flow where the model's response to previous conversation needs to be evaluated to check the content and tool calls
	Messages []*UpdateEvalDtoMessagesItem `json:"messages,omitempty" url:"-"`
	// This is the name of the eval.
	// It helps identify what the eval is checking for.
	Name *string `json:"name,omitempty" url:"-"`
	// This is the description of the eval.
	// This helps describe the eval and its purpose in detail. It will not be used to evaluate the flow of the conversation.
	Description *string `json:"description,omitempty" url:"-"`
	// This is the type of the eval.
	// Currently it is fixed to `chat.mockConversation`.
	Type *string `json:"type,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UpdateEvalDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEvalDto) SetMessages(messages []*UpdateEvalDtoMessagesItem) {
	u.Messages = messages
	u.require(updateEvalDtoFieldMessages)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEvalDto) SetName(name *string) {
	u.Name = name
	u.require(updateEvalDtoFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEvalDto) SetDescription(description *string) {
	u.Description = description
	u.require(updateEvalDtoFieldDescription)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEvalDto) SetType(type_ *string) {
	u.Type = type_
	u.require(updateEvalDtoFieldType)
}

var (
	assistantMessageEvaluationContinuePlanFieldExitOnFailureEnabled = big.NewInt(1 << 0)
	assistantMessageEvaluationContinuePlanFieldContentOverride      = big.NewInt(1 << 1)
	assistantMessageEvaluationContinuePlanFieldToolCallsOverride    = big.NewInt(1 << 2)
)

type AssistantMessageEvaluationContinuePlan struct {
	// This is whether the evaluation should exit if the assistant message evaluates to false.
	// By default, it is false and the evaluation will continue.
	// @default false
	ExitOnFailureEnabled *bool `json:"exitOnFailureEnabled,omitempty" url:"exitOnFailureEnabled,omitempty"`
	// This is the content that will be used in the conversation for this assistant turn moving forward if provided.
	// It will override the content received from the model.
	ContentOverride *string `json:"contentOverride,omitempty" url:"contentOverride,omitempty"`
	// This is the tool calls that will be used in the conversation for this assistant turn moving forward if provided.
	// It will override the tool calls received from the model.
	ToolCallsOverride []*ChatEvalAssistantMessageMockToolCall `json:"toolCallsOverride,omitempty" url:"toolCallsOverride,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessageEvaluationContinuePlan) GetExitOnFailureEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.ExitOnFailureEnabled
}

func (a *AssistantMessageEvaluationContinuePlan) GetContentOverride() *string {
	if a == nil {
		return nil
	}
	return a.ContentOverride
}

func (a *AssistantMessageEvaluationContinuePlan) GetToolCallsOverride() []*ChatEvalAssistantMessageMockToolCall {
	if a == nil {
		return nil
	}
	return a.ToolCallsOverride
}

func (a *AssistantMessageEvaluationContinuePlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessageEvaluationContinuePlan) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetExitOnFailureEnabled sets the ExitOnFailureEnabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageEvaluationContinuePlan) SetExitOnFailureEnabled(exitOnFailureEnabled *bool) {
	a.ExitOnFailureEnabled = exitOnFailureEnabled
	a.require(assistantMessageEvaluationContinuePlanFieldExitOnFailureEnabled)
}

// SetContentOverride sets the ContentOverride field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageEvaluationContinuePlan) SetContentOverride(contentOverride *string) {
	a.ContentOverride = contentOverride
	a.require(assistantMessageEvaluationContinuePlanFieldContentOverride)
}

// SetToolCallsOverride sets the ToolCallsOverride field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageEvaluationContinuePlan) SetToolCallsOverride(toolCallsOverride []*ChatEvalAssistantMessageMockToolCall) {
	a.ToolCallsOverride = toolCallsOverride
	a.require(assistantMessageEvaluationContinuePlanFieldToolCallsOverride)
}

func (a *AssistantMessageEvaluationContinuePlan) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantMessageEvaluationContinuePlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantMessageEvaluationContinuePlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessageEvaluationContinuePlan) MarshalJSON() ([]byte, error) {
	type embed AssistantMessageEvaluationContinuePlan
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AssistantMessageEvaluationContinuePlan) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	assistantMessageJudgePlanAiFieldModel = big.NewInt(1 << 0)
)

type AssistantMessageJudgePlanAi struct {
	// This is the model to use for the LLM-as-a-judge.
	// If not provided, will default to the assistant's model.
	//
	// The instructions on how to evaluate the model output with this LLM-Judge must be passed as a system message in the messages array of the model.
	//
	// The Mock conversation can be passed to the LLM-Judge to evaluate using the prompt {{messages}} and will be evaluated as a LiquidJS Variable. To access and judge only the last message, use {{messages[-1]}}
	//
	// The LLM-Judge must respond with "pass" or "fail" and only those two responses are allowed.
	Model *AssistantMessageJudgePlanAiModel `json:"model" url:"model"`
	// This is the type of the judge plan.
	// Use 'ai' to evaluate the assistant message content using LLM-as-a-judge.
	// @default 'ai'

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessageJudgePlanAi) GetModel() *AssistantMessageJudgePlanAiModel {
	if a == nil {
		return nil
	}
	return a.Model
}

func (a *AssistantMessageJudgePlanAi) Type() string {
	return a.type_
}

func (a *AssistantMessageJudgePlanAi) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessageJudgePlanAi) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanAi) SetModel(model *AssistantMessageJudgePlanAiModel) {
	a.Model = model
	a.require(assistantMessageJudgePlanAiFieldModel)
}

func (a *AssistantMessageJudgePlanAi) UnmarshalJSON(data []byte) error {
	type embed AssistantMessageJudgePlanAi
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantMessageJudgePlanAi(unmarshaler.embed)
	if unmarshaler.Type != "ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "ai", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessageJudgePlanAi) MarshalJSON() ([]byte, error) {
	type embed AssistantMessageJudgePlanAi
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "ai",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AssistantMessageJudgePlanAi) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the model to use for the LLM-as-a-judge.
// If not provided, will default to the assistant's model.
//
// The instructions on how to evaluate the model output with this LLM-Judge must be passed as a system message in the messages array of the model.
//
// The Mock conversation can be passed to the LLM-Judge to evaluate using the prompt {{messages}} and will be evaluated as a LiquidJS Variable. To access and judge only the last message, use {{messages[-1]}}
//
// The LLM-Judge must respond with "pass" or "fail" and only those two responses are allowed.
type AssistantMessageJudgePlanAiModel struct {
	EvalOpenAiModel    *EvalOpenAiModel
	EvalAnthropicModel *EvalAnthropicModel
	EvalGoogleModel    *EvalGoogleModel
	EvalCustomModel    *EvalCustomModel

	typ string
}

func (a *AssistantMessageJudgePlanAiModel) GetEvalOpenAiModel() *EvalOpenAiModel {
	if a == nil {
		return nil
	}
	return a.EvalOpenAiModel
}

func (a *AssistantMessageJudgePlanAiModel) GetEvalAnthropicModel() *EvalAnthropicModel {
	if a == nil {
		return nil
	}
	return a.EvalAnthropicModel
}

func (a *AssistantMessageJudgePlanAiModel) GetEvalGoogleModel() *EvalGoogleModel {
	if a == nil {
		return nil
	}
	return a.EvalGoogleModel
}

func (a *AssistantMessageJudgePlanAiModel) GetEvalCustomModel() *EvalCustomModel {
	if a == nil {
		return nil
	}
	return a.EvalCustomModel
}

func (a *AssistantMessageJudgePlanAiModel) UnmarshalJSON(data []byte) error {
	valueEvalOpenAiModel := new(EvalOpenAiModel)
	if err := json.Unmarshal(data, &valueEvalOpenAiModel); err == nil {
		a.typ = "EvalOpenAiModel"
		a.EvalOpenAiModel = valueEvalOpenAiModel
		return nil
	}
	valueEvalAnthropicModel := new(EvalAnthropicModel)
	if err := json.Unmarshal(data, &valueEvalAnthropicModel); err == nil {
		a.typ = "EvalAnthropicModel"
		a.EvalAnthropicModel = valueEvalAnthropicModel
		return nil
	}
	valueEvalGoogleModel := new(EvalGoogleModel)
	if err := json.Unmarshal(data, &valueEvalGoogleModel); err == nil {
		a.typ = "EvalGoogleModel"
		a.EvalGoogleModel = valueEvalGoogleModel
		return nil
	}
	valueEvalCustomModel := new(EvalCustomModel)
	if err := json.Unmarshal(data, &valueEvalCustomModel); err == nil {
		a.typ = "EvalCustomModel"
		a.EvalCustomModel = valueEvalCustomModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantMessageJudgePlanAiModel) MarshalJSON() ([]byte, error) {
	if a.typ == "EvalOpenAiModel" || a.EvalOpenAiModel != nil {
		return json.Marshal(a.EvalOpenAiModel)
	}
	if a.typ == "EvalAnthropicModel" || a.EvalAnthropicModel != nil {
		return json.Marshal(a.EvalAnthropicModel)
	}
	if a.typ == "EvalGoogleModel" || a.EvalGoogleModel != nil {
		return json.Marshal(a.EvalGoogleModel)
	}
	if a.typ == "EvalCustomModel" || a.EvalCustomModel != nil {
		return json.Marshal(a.EvalCustomModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantMessageJudgePlanAiModelVisitor interface {
	VisitEvalOpenAiModel(*EvalOpenAiModel) error
	VisitEvalAnthropicModel(*EvalAnthropicModel) error
	VisitEvalGoogleModel(*EvalGoogleModel) error
	VisitEvalCustomModel(*EvalCustomModel) error
}

func (a *AssistantMessageJudgePlanAiModel) Accept(visitor AssistantMessageJudgePlanAiModelVisitor) error {
	if a.typ == "EvalOpenAiModel" || a.EvalOpenAiModel != nil {
		return visitor.VisitEvalOpenAiModel(a.EvalOpenAiModel)
	}
	if a.typ == "EvalAnthropicModel" || a.EvalAnthropicModel != nil {
		return visitor.VisitEvalAnthropicModel(a.EvalAnthropicModel)
	}
	if a.typ == "EvalGoogleModel" || a.EvalGoogleModel != nil {
		return visitor.VisitEvalGoogleModel(a.EvalGoogleModel)
	}
	if a.typ == "EvalCustomModel" || a.EvalCustomModel != nil {
		return visitor.VisitEvalCustomModel(a.EvalCustomModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

var (
	assistantMessageJudgePlanExactFieldContent   = big.NewInt(1 << 0)
	assistantMessageJudgePlanExactFieldToolCalls = big.NewInt(1 << 1)
)

type AssistantMessageJudgePlanExact struct {
	// This is the type of the judge plan.
	// Use 'exact' for an exact match on the content and tool calls - without using LLM-as-a-judge.
	// @default 'exact'
	// This is what that will be used to evaluate the model's message content.
	// If you provide a string, the assistant message content will be evaluated against it as an exact match, case-insensitive.
	Content string `json:"content" url:"content"`
	// This is the tool calls that will be used to evaluate the model's message content.
	// The tool name must be a valid tool that the assistant is allowed to call.
	//
	// For the Query tool, the arguments for the tool call are in the format - {knowledgeBaseNames: ['kb_name', 'kb_name_2']}
	//
	// For the DTMF tool, the arguments for the tool call are in the format - {dtmf: "1234*"}
	//
	// For the Handoff tool, the arguments for the tool call are in the format - {destination: "assistant_id"}
	//
	// For the Transfer Call tool, the arguments for the tool call are in the format - {destination: "phone_number_or_assistant_id"}
	//
	// For all other tools, they are called without arguments or with user-defined arguments
	ToolCalls []*ChatEvalAssistantMessageMockToolCall `json:"toolCalls,omitempty" url:"toolCalls,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessageJudgePlanExact) GetContent() string {
	if a == nil {
		return ""
	}
	return a.Content
}

func (a *AssistantMessageJudgePlanExact) GetToolCalls() []*ChatEvalAssistantMessageMockToolCall {
	if a == nil {
		return nil
	}
	return a.ToolCalls
}

func (a *AssistantMessageJudgePlanExact) Type() string {
	return a.type_
}

func (a *AssistantMessageJudgePlanExact) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessageJudgePlanExact) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanExact) SetContent(content string) {
	a.Content = content
	a.require(assistantMessageJudgePlanExactFieldContent)
}

// SetToolCalls sets the ToolCalls field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanExact) SetToolCalls(toolCalls []*ChatEvalAssistantMessageMockToolCall) {
	a.ToolCalls = toolCalls
	a.require(assistantMessageJudgePlanExactFieldToolCalls)
}

func (a *AssistantMessageJudgePlanExact) UnmarshalJSON(data []byte) error {
	type embed AssistantMessageJudgePlanExact
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantMessageJudgePlanExact(unmarshaler.embed)
	if unmarshaler.Type != "exact" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "exact", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessageJudgePlanExact) MarshalJSON() ([]byte, error) {
	type embed AssistantMessageJudgePlanExact
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "exact",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AssistantMessageJudgePlanExact) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	assistantMessageJudgePlanRegexFieldContent   = big.NewInt(1 << 0)
	assistantMessageJudgePlanRegexFieldToolCalls = big.NewInt(1 << 1)
)

type AssistantMessageJudgePlanRegex struct {
	// This is the type of the judge plan.
	// Use 'regex' for a regex match on the content and tool calls - without using LLM-as-a-judge.
	// @default 'regex'
	// This is what that will be used to evaluate the model's message content.
	// The content will be evaluated against the regex pattern provided in the Judge Plan content field.
	// Evaluation is considered successful if the regex pattern matches any part of the assistant message content.
	Content string `json:"content" url:"content"`
	// This is the tool calls that will be used to evaluate the model's message content.
	// The tool name must be a valid tool that the assistant is allowed to call.
	// The values to the arguments for the tool call should be a Regular Expression.
	// Evaluation is considered successful if the regex pattern matches any part of each tool call argument.
	//
	// For the Query tool, the arguments for the tool call are in the format - {knowledgeBaseNames: ['kb_name', 'kb_name_2']}
	//
	// For the DTMF tool, the arguments for the tool call are in the format - {dtmf: "1234*"}
	//
	// For the Handoff tool, the arguments for the tool call are in the format - {destination: "assistant_id"}
	//
	// For the Transfer Call tool, the arguments for the tool call are in the format - {destination: "phone_number_or_assistant_id"}
	//
	// For all other tools, they are called without arguments or with user-defined arguments
	ToolCalls []*ChatEvalAssistantMessageMockToolCall `json:"toolCalls,omitempty" url:"toolCalls,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessageJudgePlanRegex) GetContent() string {
	if a == nil {
		return ""
	}
	return a.Content
}

func (a *AssistantMessageJudgePlanRegex) GetToolCalls() []*ChatEvalAssistantMessageMockToolCall {
	if a == nil {
		return nil
	}
	return a.ToolCalls
}

func (a *AssistantMessageJudgePlanRegex) Type() string {
	return a.type_
}

func (a *AssistantMessageJudgePlanRegex) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessageJudgePlanRegex) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanRegex) SetContent(content string) {
	a.Content = content
	a.require(assistantMessageJudgePlanRegexFieldContent)
}

// SetToolCalls sets the ToolCalls field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AssistantMessageJudgePlanRegex) SetToolCalls(toolCalls []*ChatEvalAssistantMessageMockToolCall) {
	a.ToolCalls = toolCalls
	a.require(assistantMessageJudgePlanRegexFieldToolCalls)
}

func (a *AssistantMessageJudgePlanRegex) UnmarshalJSON(data []byte) error {
	type embed AssistantMessageJudgePlanRegex
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantMessageJudgePlanRegex(unmarshaler.embed)
	if unmarshaler.Type != "regex" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "regex", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessageJudgePlanRegex) MarshalJSON() ([]byte, error) {
	type embed AssistantMessageJudgePlanRegex
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "regex",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AssistantMessageJudgePlanRegex) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	chatEvalAssistantMessageEvaluationFieldJudgePlan    = big.NewInt(1 << 0)
	chatEvalAssistantMessageEvaluationFieldContinuePlan = big.NewInt(1 << 1)
)

type ChatEvalAssistantMessageEvaluation struct {
	// This is the role of the message author.
	// For an assistant message evaluation, the role is always 'assistant'
	// @default 'assistant'
	// This is the judge plan that instructs how to evaluate the assistant message.
	// The assistant message can be evaluated against fixed content (exact match or RegEx) or with an LLM-as-judge by defining the evaluation criteria in a prompt.
	JudgePlan *ChatEvalAssistantMessageEvaluationJudgePlan `json:"judgePlan" url:"judgePlan"`
	// This is the plan for how the overall evaluation will proceed after the assistant message is evaluated.
	// This lets you configure whether to stop the evaluation if this message fails, and whether to override any content for future turns
	ContinuePlan *AssistantMessageEvaluationContinuePlan `json:"continuePlan,omitempty" url:"continuePlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	role           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalAssistantMessageEvaluation) GetJudgePlan() *ChatEvalAssistantMessageEvaluationJudgePlan {
	if c == nil {
		return nil
	}
	return c.JudgePlan
}

func (c *ChatEvalAssistantMessageEvaluation) GetContinuePlan() *AssistantMessageEvaluationContinuePlan {
	if c == nil {
		return nil
	}
	return c.ContinuePlan
}

func (c *ChatEvalAssistantMessageEvaluation) Role() string {
	return c.role
}

func (c *ChatEvalAssistantMessageEvaluation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalAssistantMessageEvaluation) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetJudgePlan sets the JudgePlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageEvaluation) SetJudgePlan(judgePlan *ChatEvalAssistantMessageEvaluationJudgePlan) {
	c.JudgePlan = judgePlan
	c.require(chatEvalAssistantMessageEvaluationFieldJudgePlan)
}

// SetContinuePlan sets the ContinuePlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageEvaluation) SetContinuePlan(continuePlan *AssistantMessageEvaluationContinuePlan) {
	c.ContinuePlan = continuePlan
	c.require(chatEvalAssistantMessageEvaluationFieldContinuePlan)
}

func (c *ChatEvalAssistantMessageEvaluation) UnmarshalJSON(data []byte) error {
	type embed ChatEvalAssistantMessageEvaluation
	var unmarshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ChatEvalAssistantMessageEvaluation(unmarshaler.embed)
	if unmarshaler.Role != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "assistant", unmarshaler.Role)
	}
	c.role = unmarshaler.Role
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "role")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalAssistantMessageEvaluation) MarshalJSON() ([]byte, error) {
	type embed ChatEvalAssistantMessageEvaluation
	var marshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*c),
		Role:  "assistant",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalAssistantMessageEvaluation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the judge plan that instructs how to evaluate the assistant message.
// The assistant message can be evaluated against fixed content (exact match or RegEx) or with an LLM-as-judge by defining the evaluation criteria in a prompt.
type ChatEvalAssistantMessageEvaluationJudgePlan struct {
	AssistantMessageJudgePlanExact *AssistantMessageJudgePlanExact
	AssistantMessageJudgePlanRegex *AssistantMessageJudgePlanRegex
	AssistantMessageJudgePlanAi    *AssistantMessageJudgePlanAi

	typ string
}

func (c *ChatEvalAssistantMessageEvaluationJudgePlan) GetAssistantMessageJudgePlanExact() *AssistantMessageJudgePlanExact {
	if c == nil {
		return nil
	}
	return c.AssistantMessageJudgePlanExact
}

func (c *ChatEvalAssistantMessageEvaluationJudgePlan) GetAssistantMessageJudgePlanRegex() *AssistantMessageJudgePlanRegex {
	if c == nil {
		return nil
	}
	return c.AssistantMessageJudgePlanRegex
}

func (c *ChatEvalAssistantMessageEvaluationJudgePlan) GetAssistantMessageJudgePlanAi() *AssistantMessageJudgePlanAi {
	if c == nil {
		return nil
	}
	return c.AssistantMessageJudgePlanAi
}

func (c *ChatEvalAssistantMessageEvaluationJudgePlan) UnmarshalJSON(data []byte) error {
	valueAssistantMessageJudgePlanExact := new(AssistantMessageJudgePlanExact)
	if err := json.Unmarshal(data, &valueAssistantMessageJudgePlanExact); err == nil {
		c.typ = "AssistantMessageJudgePlanExact"
		c.AssistantMessageJudgePlanExact = valueAssistantMessageJudgePlanExact
		return nil
	}
	valueAssistantMessageJudgePlanRegex := new(AssistantMessageJudgePlanRegex)
	if err := json.Unmarshal(data, &valueAssistantMessageJudgePlanRegex); err == nil {
		c.typ = "AssistantMessageJudgePlanRegex"
		c.AssistantMessageJudgePlanRegex = valueAssistantMessageJudgePlanRegex
		return nil
	}
	valueAssistantMessageJudgePlanAi := new(AssistantMessageJudgePlanAi)
	if err := json.Unmarshal(data, &valueAssistantMessageJudgePlanAi); err == nil {
		c.typ = "AssistantMessageJudgePlanAi"
		c.AssistantMessageJudgePlanAi = valueAssistantMessageJudgePlanAi
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatEvalAssistantMessageEvaluationJudgePlan) MarshalJSON() ([]byte, error) {
	if c.typ == "AssistantMessageJudgePlanExact" || c.AssistantMessageJudgePlanExact != nil {
		return json.Marshal(c.AssistantMessageJudgePlanExact)
	}
	if c.typ == "AssistantMessageJudgePlanRegex" || c.AssistantMessageJudgePlanRegex != nil {
		return json.Marshal(c.AssistantMessageJudgePlanRegex)
	}
	if c.typ == "AssistantMessageJudgePlanAi" || c.AssistantMessageJudgePlanAi != nil {
		return json.Marshal(c.AssistantMessageJudgePlanAi)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatEvalAssistantMessageEvaluationJudgePlanVisitor interface {
	VisitAssistantMessageJudgePlanExact(*AssistantMessageJudgePlanExact) error
	VisitAssistantMessageJudgePlanRegex(*AssistantMessageJudgePlanRegex) error
	VisitAssistantMessageJudgePlanAi(*AssistantMessageJudgePlanAi) error
}

func (c *ChatEvalAssistantMessageEvaluationJudgePlan) Accept(visitor ChatEvalAssistantMessageEvaluationJudgePlanVisitor) error {
	if c.typ == "AssistantMessageJudgePlanExact" || c.AssistantMessageJudgePlanExact != nil {
		return visitor.VisitAssistantMessageJudgePlanExact(c.AssistantMessageJudgePlanExact)
	}
	if c.typ == "AssistantMessageJudgePlanRegex" || c.AssistantMessageJudgePlanRegex != nil {
		return visitor.VisitAssistantMessageJudgePlanRegex(c.AssistantMessageJudgePlanRegex)
	}
	if c.typ == "AssistantMessageJudgePlanAi" || c.AssistantMessageJudgePlanAi != nil {
		return visitor.VisitAssistantMessageJudgePlanAi(c.AssistantMessageJudgePlanAi)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

var (
	chatEvalAssistantMessageMockFieldContent   = big.NewInt(1 << 0)
	chatEvalAssistantMessageMockFieldToolCalls = big.NewInt(1 << 1)
)

type ChatEvalAssistantMessageMock struct {
	// This is the role of the message author.
	// For a mock assistant message, the role is always 'assistant'
	// @default 'assistant'
	// This is the content of the assistant message.
	// This is the message that the assistant would have sent.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is the tool calls that will be made by the assistant.
	ToolCalls []*ChatEvalAssistantMessageMockToolCall `json:"toolCalls,omitempty" url:"toolCalls,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	role           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalAssistantMessageMock) GetContent() *string {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *ChatEvalAssistantMessageMock) GetToolCalls() []*ChatEvalAssistantMessageMockToolCall {
	if c == nil {
		return nil
	}
	return c.ToolCalls
}

func (c *ChatEvalAssistantMessageMock) Role() string {
	return c.role
}

func (c *ChatEvalAssistantMessageMock) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalAssistantMessageMock) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageMock) SetContent(content *string) {
	c.Content = content
	c.require(chatEvalAssistantMessageMockFieldContent)
}

// SetToolCalls sets the ToolCalls field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageMock) SetToolCalls(toolCalls []*ChatEvalAssistantMessageMockToolCall) {
	c.ToolCalls = toolCalls
	c.require(chatEvalAssistantMessageMockFieldToolCalls)
}

func (c *ChatEvalAssistantMessageMock) UnmarshalJSON(data []byte) error {
	type embed ChatEvalAssistantMessageMock
	var unmarshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ChatEvalAssistantMessageMock(unmarshaler.embed)
	if unmarshaler.Role != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "assistant", unmarshaler.Role)
	}
	c.role = unmarshaler.Role
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "role")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalAssistantMessageMock) MarshalJSON() ([]byte, error) {
	type embed ChatEvalAssistantMessageMock
	var marshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*c),
		Role:  "assistant",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalAssistantMessageMock) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	chatEvalAssistantMessageMockToolCallFieldName      = big.NewInt(1 << 0)
	chatEvalAssistantMessageMockToolCallFieldArguments = big.NewInt(1 << 1)
)

type ChatEvalAssistantMessageMockToolCall struct {
	// This is the name of the tool that will be called.
	// It should be one of the tools created in the organization.
	Name string `json:"name" url:"name"`
	// This is the arguments that will be passed to the tool call.
	Arguments map[string]interface{} `json:"arguments,omitempty" url:"arguments,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalAssistantMessageMockToolCall) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *ChatEvalAssistantMessageMockToolCall) GetArguments() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Arguments
}

func (c *ChatEvalAssistantMessageMockToolCall) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalAssistantMessageMockToolCall) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageMockToolCall) SetName(name string) {
	c.Name = name
	c.require(chatEvalAssistantMessageMockToolCallFieldName)
}

// SetArguments sets the Arguments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalAssistantMessageMockToolCall) SetArguments(arguments map[string]interface{}) {
	c.Arguments = arguments
	c.require(chatEvalAssistantMessageMockToolCallFieldArguments)
}

func (c *ChatEvalAssistantMessageMockToolCall) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatEvalAssistantMessageMockToolCall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatEvalAssistantMessageMockToolCall(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalAssistantMessageMockToolCall) MarshalJSON() ([]byte, error) {
	type embed ChatEvalAssistantMessageMockToolCall
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalAssistantMessageMockToolCall) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	chatEvalSystemMessageMockFieldContent = big.NewInt(1 << 0)
)

type ChatEvalSystemMessageMock struct {
	// This is the role of the message author.
	// For a mock system message, the role is always 'system'
	// @default 'system'
	// This is the content of the system message that would have been added in the middle of the conversation.
	// Do not include the assistant prompt as a part of this message. It will automatically be fetched during runtime.
	Content string `json:"content" url:"content"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	role           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalSystemMessageMock) GetContent() string {
	if c == nil {
		return ""
	}
	return c.Content
}

func (c *ChatEvalSystemMessageMock) Role() string {
	return c.role
}

func (c *ChatEvalSystemMessageMock) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalSystemMessageMock) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalSystemMessageMock) SetContent(content string) {
	c.Content = content
	c.require(chatEvalSystemMessageMockFieldContent)
}

func (c *ChatEvalSystemMessageMock) UnmarshalJSON(data []byte) error {
	type embed ChatEvalSystemMessageMock
	var unmarshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ChatEvalSystemMessageMock(unmarshaler.embed)
	if unmarshaler.Role != "system" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "system", unmarshaler.Role)
	}
	c.role = unmarshaler.Role
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "role")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalSystemMessageMock) MarshalJSON() ([]byte, error) {
	type embed ChatEvalSystemMessageMock
	var marshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*c),
		Role:  "system",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalSystemMessageMock) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	chatEvalToolResponseMessageMockFieldContent = big.NewInt(1 << 0)
)

type ChatEvalToolResponseMessageMock struct {
	// This is the role of the message author.
	// For a mock tool response message, the role is always 'tool'
	// @default 'tool'
	// This is the content of the tool response message. JSON Objects should be stringified.
	Content string `json:"content" url:"content"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	role           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalToolResponseMessageMock) GetContent() string {
	if c == nil {
		return ""
	}
	return c.Content
}

func (c *ChatEvalToolResponseMessageMock) Role() string {
	return c.role
}

func (c *ChatEvalToolResponseMessageMock) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalToolResponseMessageMock) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalToolResponseMessageMock) SetContent(content string) {
	c.Content = content
	c.require(chatEvalToolResponseMessageMockFieldContent)
}

func (c *ChatEvalToolResponseMessageMock) UnmarshalJSON(data []byte) error {
	type embed ChatEvalToolResponseMessageMock
	var unmarshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ChatEvalToolResponseMessageMock(unmarshaler.embed)
	if unmarshaler.Role != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tool", unmarshaler.Role)
	}
	c.role = unmarshaler.Role
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "role")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalToolResponseMessageMock) MarshalJSON() ([]byte, error) {
	type embed ChatEvalToolResponseMessageMock
	var marshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*c),
		Role:  "tool",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalToolResponseMessageMock) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	chatEvalUserMessageMockFieldContent = big.NewInt(1 << 0)
)

type ChatEvalUserMessageMock struct {
	// This is the role of the message author.
	// For a mock user message, the role is always 'user'
	// @default 'user'
	// This is the content of the user message.
	// This is the message that the user would have sent.
	Content string `json:"content" url:"content"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	role           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatEvalUserMessageMock) GetContent() string {
	if c == nil {
		return ""
	}
	return c.Content
}

func (c *ChatEvalUserMessageMock) Role() string {
	return c.role
}

func (c *ChatEvalUserMessageMock) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatEvalUserMessageMock) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatEvalUserMessageMock) SetContent(content string) {
	c.Content = content
	c.require(chatEvalUserMessageMockFieldContent)
}

func (c *ChatEvalUserMessageMock) UnmarshalJSON(data []byte) error {
	type embed ChatEvalUserMessageMock
	var unmarshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ChatEvalUserMessageMock(unmarshaler.embed)
	if unmarshaler.Role != "user" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "user", unmarshaler.Role)
	}
	c.role = unmarshaler.Role
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "role")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatEvalUserMessageMock) MarshalJSON() ([]byte, error) {
	type embed ChatEvalUserMessageMock
	var marshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*c),
		Role:  "user",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatEvalUserMessageMock) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	createEvalDtoFieldMessages    = big.NewInt(1 << 0)
	createEvalDtoFieldName        = big.NewInt(1 << 1)
	createEvalDtoFieldDescription = big.NewInt(1 << 2)
)

type CreateEvalDto struct {
	// This is the mock conversation that will be used to evaluate the flow of the conversation.
	//
	// # Mock Messages are used to simulate the flow of the conversation
	//
	// Evaluation Messages are used as checkpoints in the flow where the model's response to previous conversation needs to be evaluated to check the content and tool calls
	Messages []*CreateEvalDtoMessagesItem `json:"messages" url:"messages"`
	// This is the name of the eval.
	// It helps identify what the eval is checking for.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the description of the eval.
	// This helps describe the eval and its purpose in detail. It will not be used to evaluate the flow of the conversation.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is the type of the eval.
	// Currently it is fixed to `chat.mockConversation`.

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateEvalDto) GetMessages() []*CreateEvalDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateEvalDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateEvalDto) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateEvalDto) Type() string {
	return c.type_
}

func (c *CreateEvalDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateEvalDto) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalDto) SetMessages(messages []*CreateEvalDtoMessagesItem) {
	c.Messages = messages
	c.require(createEvalDtoFieldMessages)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalDto) SetName(name *string) {
	c.Name = name
	c.require(createEvalDtoFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateEvalDto) SetDescription(description *string) {
	c.Description = description
	c.require(createEvalDtoFieldDescription)
}

func (c *CreateEvalDto) UnmarshalJSON(data []byte) error {
	type embed CreateEvalDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateEvalDto(unmarshaler.embed)
	if unmarshaler.Type != "chat.mockConversation" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "chat.mockConversation", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEvalDto) MarshalJSON() ([]byte, error) {
	type embed CreateEvalDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "chat.mockConversation",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateEvalDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEvalDtoMessagesItem struct {
	ChatEvalAssistantMessageMock       *ChatEvalAssistantMessageMock
	ChatEvalSystemMessageMock          *ChatEvalSystemMessageMock
	ChatEvalToolResponseMessageMock    *ChatEvalToolResponseMessageMock
	ChatEvalUserMessageMock            *ChatEvalUserMessageMock
	ChatEvalAssistantMessageEvaluation *ChatEvalAssistantMessageEvaluation

	typ string
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalAssistantMessageMock() *ChatEvalAssistantMessageMock {
	if c == nil {
		return nil
	}
	return c.ChatEvalAssistantMessageMock
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalSystemMessageMock() *ChatEvalSystemMessageMock {
	if c == nil {
		return nil
	}
	return c.ChatEvalSystemMessageMock
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalToolResponseMessageMock() *ChatEvalToolResponseMessageMock {
	if c == nil {
		return nil
	}
	return c.ChatEvalToolResponseMessageMock
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalUserMessageMock() *ChatEvalUserMessageMock {
	if c == nil {
		return nil
	}
	return c.ChatEvalUserMessageMock
}

func (c *CreateEvalDtoMessagesItem) GetChatEvalAssistantMessageEvaluation() *ChatEvalAssistantMessageEvaluation {
	if c == nil {
		return nil
	}
	return c.ChatEvalAssistantMessageEvaluation
}

func (c *CreateEvalDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueChatEvalAssistantMessageMock := new(ChatEvalAssistantMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageMock); err == nil {
		c.typ = "ChatEvalAssistantMessageMock"
		c.ChatEvalAssistantMessageMock = valueChatEvalAssistantMessageMock
		return nil
	}
	valueChatEvalSystemMessageMock := new(ChatEvalSystemMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalSystemMessageMock); err == nil {
		c.typ = "ChatEvalSystemMessageMock"
		c.ChatEvalSystemMessageMock = valueChatEvalSystemMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageMock := new(ChatEvalToolResponseMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageMock); err == nil {
		c.typ = "ChatEvalToolResponseMessageMock"
		c.ChatEvalToolResponseMessageMock = valueChatEvalToolResponseMessageMock
		return nil
	}
	valueChatEvalUserMessageMock := new(ChatEvalUserMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalUserMessageMock); err == nil {
		c.typ = "ChatEvalUserMessageMock"
		c.ChatEvalUserMessageMock = valueChatEvalUserMessageMock
		return nil
	}
	valueChatEvalAssistantMessageEvaluation := new(ChatEvalAssistantMessageEvaluation)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageEvaluation); err == nil {
		c.typ = "ChatEvalAssistantMessageEvaluation"
		c.ChatEvalAssistantMessageEvaluation = valueChatEvalAssistantMessageEvaluation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEvalDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ChatEvalAssistantMessageMock" || c.ChatEvalAssistantMessageMock != nil {
		return json.Marshal(c.ChatEvalAssistantMessageMock)
	}
	if c.typ == "ChatEvalSystemMessageMock" || c.ChatEvalSystemMessageMock != nil {
		return json.Marshal(c.ChatEvalSystemMessageMock)
	}
	if c.typ == "ChatEvalToolResponseMessageMock" || c.ChatEvalToolResponseMessageMock != nil {
		return json.Marshal(c.ChatEvalToolResponseMessageMock)
	}
	if c.typ == "ChatEvalUserMessageMock" || c.ChatEvalUserMessageMock != nil {
		return json.Marshal(c.ChatEvalUserMessageMock)
	}
	if c.typ == "ChatEvalAssistantMessageEvaluation" || c.ChatEvalAssistantMessageEvaluation != nil {
		return json.Marshal(c.ChatEvalAssistantMessageEvaluation)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateEvalDtoMessagesItemVisitor interface {
	VisitChatEvalAssistantMessageMock(*ChatEvalAssistantMessageMock) error
	VisitChatEvalSystemMessageMock(*ChatEvalSystemMessageMock) error
	VisitChatEvalToolResponseMessageMock(*ChatEvalToolResponseMessageMock) error
	VisitChatEvalUserMessageMock(*ChatEvalUserMessageMock) error
	VisitChatEvalAssistantMessageEvaluation(*ChatEvalAssistantMessageEvaluation) error
}

func (c *CreateEvalDtoMessagesItem) Accept(visitor CreateEvalDtoMessagesItemVisitor) error {
	if c.typ == "ChatEvalAssistantMessageMock" || c.ChatEvalAssistantMessageMock != nil {
		return visitor.VisitChatEvalAssistantMessageMock(c.ChatEvalAssistantMessageMock)
	}
	if c.typ == "ChatEvalSystemMessageMock" || c.ChatEvalSystemMessageMock != nil {
		return visitor.VisitChatEvalSystemMessageMock(c.ChatEvalSystemMessageMock)
	}
	if c.typ == "ChatEvalToolResponseMessageMock" || c.ChatEvalToolResponseMessageMock != nil {
		return visitor.VisitChatEvalToolResponseMessageMock(c.ChatEvalToolResponseMessageMock)
	}
	if c.typ == "ChatEvalUserMessageMock" || c.ChatEvalUserMessageMock != nil {
		return visitor.VisitChatEvalUserMessageMock(c.ChatEvalUserMessageMock)
	}
	if c.typ == "ChatEvalAssistantMessageEvaluation" || c.ChatEvalAssistantMessageEvaluation != nil {
		return visitor.VisitChatEvalAssistantMessageEvaluation(c.ChatEvalAssistantMessageEvaluation)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

var (
	evalFieldMessages    = big.NewInt(1 << 0)
	evalFieldId          = big.NewInt(1 << 1)
	evalFieldOrgId       = big.NewInt(1 << 2)
	evalFieldCreatedAt   = big.NewInt(1 << 3)
	evalFieldUpdatedAt   = big.NewInt(1 << 4)
	evalFieldName        = big.NewInt(1 << 5)
	evalFieldDescription = big.NewInt(1 << 6)
)

type Eval struct {
	// This is the mock conversation that will be used to evaluate the flow of the conversation.
	//
	// # Mock Messages are used to simulate the flow of the conversation
	//
	// Evaluation Messages are used as checkpoints in the flow where the model's response to previous conversation needs to be evaluated to check the content and tool calls
	Messages  []*EvalMessagesItem `json:"messages" url:"messages"`
	Id        string              `json:"id" url:"id"`
	OrgId     string              `json:"orgId" url:"orgId"`
	CreatedAt time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time           `json:"updatedAt" url:"updatedAt"`
	// This is the name of the eval.
	// It helps identify what the eval is checking for.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the description of the eval.
	// This helps describe the eval and its purpose in detail. It will not be used to evaluate the flow of the conversation.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is the type of the eval.
	// Currently it is fixed to `chat.mockConversation`.

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Eval) GetMessages() []*EvalMessagesItem {
	if e == nil {
		return nil
	}
	return e.Messages
}

func (e *Eval) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *Eval) GetOrgId() string {
	if e == nil {
		return ""
	}
	return e.OrgId
}

func (e *Eval) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *Eval) GetUpdatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.UpdatedAt
}

func (e *Eval) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *Eval) GetDescription() *string {
	if e == nil {
		return nil
	}
	return e.Description
}

func (e *Eval) Type() string {
	return e.type_
}

func (e *Eval) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Eval) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetMessages(messages []*EvalMessagesItem) {
	e.Messages = messages
	e.require(evalFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetId(id string) {
	e.Id = id
	e.require(evalFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetOrgId(orgId string) {
	e.OrgId = orgId
	e.require(evalFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetCreatedAt(createdAt time.Time) {
	e.CreatedAt = createdAt
	e.require(evalFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetUpdatedAt(updatedAt time.Time) {
	e.UpdatedAt = updatedAt
	e.require(evalFieldUpdatedAt)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetName(name *string) {
	e.Name = name
	e.require(evalFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Eval) SetDescription(description *string) {
	e.Description = description
	e.require(evalFieldDescription)
}

func (e *Eval) UnmarshalJSON(data []byte) error {
	type embed Eval
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Eval(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "chat.mockConversation" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "chat.mockConversation", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Eval) MarshalJSON() ([]byte, error) {
	type embed Eval
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		UpdatedAt: internal.NewDateTime(e.UpdatedAt),
		Type:      "chat.mockConversation",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *Eval) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	evalAnthropicModelFieldModel       = big.NewInt(1 << 0)
	evalAnthropicModelFieldThinking    = big.NewInt(1 << 1)
	evalAnthropicModelFieldTemperature = big.NewInt(1 << 2)
	evalAnthropicModelFieldMaxTokens   = big.NewInt(1 << 3)
)

type EvalAnthropicModel struct {
	// This is the provider of the model (`anthropic`).
	// This is the specific model that will be used.
	Model EvalAnthropicModelModel `json:"model" url:"model"`
	// This is the optional configuration for Anthropic's thinking feature.
	//
	// - Only applicable for `claude-3-7-sonnet-20250219` model.
	// - If provided, `maxTokens` must be greater than `thinking.budgetTokens`.
	Thinking *AnthropicThinkingConfig `json:"thinking,omitempty" url:"thinking,omitempty"`
	// This is the temperature of the model. For LLM-as-a-judge, it's recommended to set it between 0 - 0.3 to avoid hallucinations and ensure the model judges the output correctly based on the instructions.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max tokens of the model.
	// If your Judge instructions return `true` or `false` takes only 1 token (as per the OpenAI Tokenizer), and therefore is recommended to set it to a low number to force the model to return a short response.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	provider       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalAnthropicModel) GetModel() EvalAnthropicModelModel {
	if e == nil {
		return ""
	}
	return e.Model
}

func (e *EvalAnthropicModel) GetThinking() *AnthropicThinkingConfig {
	if e == nil {
		return nil
	}
	return e.Thinking
}

func (e *EvalAnthropicModel) GetTemperature() *float64 {
	if e == nil {
		return nil
	}
	return e.Temperature
}

func (e *EvalAnthropicModel) GetMaxTokens() *float64 {
	if e == nil {
		return nil
	}
	return e.MaxTokens
}

func (e *EvalAnthropicModel) Provider() string {
	return e.provider
}

func (e *EvalAnthropicModel) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalAnthropicModel) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalAnthropicModel) SetModel(model EvalAnthropicModelModel) {
	e.Model = model
	e.require(evalAnthropicModelFieldModel)
}

// SetThinking sets the Thinking field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalAnthropicModel) SetThinking(thinking *AnthropicThinkingConfig) {
	e.Thinking = thinking
	e.require(evalAnthropicModelFieldThinking)
}

// SetTemperature sets the Temperature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalAnthropicModel) SetTemperature(temperature *float64) {
	e.Temperature = temperature
	e.require(evalAnthropicModelFieldTemperature)
}

// SetMaxTokens sets the MaxTokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalAnthropicModel) SetMaxTokens(maxTokens *float64) {
	e.MaxTokens = maxTokens
	e.require(evalAnthropicModelFieldMaxTokens)
}

func (e *EvalAnthropicModel) UnmarshalJSON(data []byte) error {
	type embed EvalAnthropicModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EvalAnthropicModel(unmarshaler.embed)
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "anthropic", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalAnthropicModel) MarshalJSON() ([]byte, error) {
	type embed EvalAnthropicModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*e),
		Provider: "anthropic",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalAnthropicModel) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the specific model that will be used.
type EvalAnthropicModelModel string

const (
	EvalAnthropicModelModelClaude3Opus20240229    EvalAnthropicModelModel = "claude-3-opus-20240229"
	EvalAnthropicModelModelClaude3Sonnet20240229  EvalAnthropicModelModel = "claude-3-sonnet-20240229"
	EvalAnthropicModelModelClaude3Haiku20240307   EvalAnthropicModelModel = "claude-3-haiku-20240307"
	EvalAnthropicModelModelClaude35Sonnet20240620 EvalAnthropicModelModel = "claude-3-5-sonnet-20240620"
	EvalAnthropicModelModelClaude35Sonnet20241022 EvalAnthropicModelModel = "claude-3-5-sonnet-20241022"
	EvalAnthropicModelModelClaude35Haiku20241022  EvalAnthropicModelModel = "claude-3-5-haiku-20241022"
	EvalAnthropicModelModelClaude37Sonnet20250219 EvalAnthropicModelModel = "claude-3-7-sonnet-20250219"
	EvalAnthropicModelModelClaudeOpus420250514    EvalAnthropicModelModel = "claude-opus-4-20250514"
	EvalAnthropicModelModelClaudeSonnet420250514  EvalAnthropicModelModel = "claude-sonnet-4-20250514"
	EvalAnthropicModelModelClaudeSonnet4520250929 EvalAnthropicModelModel = "claude-sonnet-4-5-20250929"
	EvalAnthropicModelModelClaudeHaiku4520251001  EvalAnthropicModelModel = "claude-haiku-4-5-20251001"
)

func NewEvalAnthropicModelModelFromString(s string) (EvalAnthropicModelModel, error) {
	switch s {
	case "claude-3-opus-20240229":
		return EvalAnthropicModelModelClaude3Opus20240229, nil
	case "claude-3-sonnet-20240229":
		return EvalAnthropicModelModelClaude3Sonnet20240229, nil
	case "claude-3-haiku-20240307":
		return EvalAnthropicModelModelClaude3Haiku20240307, nil
	case "claude-3-5-sonnet-20240620":
		return EvalAnthropicModelModelClaude35Sonnet20240620, nil
	case "claude-3-5-sonnet-20241022":
		return EvalAnthropicModelModelClaude35Sonnet20241022, nil
	case "claude-3-5-haiku-20241022":
		return EvalAnthropicModelModelClaude35Haiku20241022, nil
	case "claude-3-7-sonnet-20250219":
		return EvalAnthropicModelModelClaude37Sonnet20250219, nil
	case "claude-opus-4-20250514":
		return EvalAnthropicModelModelClaudeOpus420250514, nil
	case "claude-sonnet-4-20250514":
		return EvalAnthropicModelModelClaudeSonnet420250514, nil
	case "claude-sonnet-4-5-20250929":
		return EvalAnthropicModelModelClaudeSonnet4520250929, nil
	case "claude-haiku-4-5-20251001":
		return EvalAnthropicModelModelClaudeHaiku4520251001, nil
	}
	var t EvalAnthropicModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalAnthropicModelModel) Ptr() *EvalAnthropicModelModel {
	return &e
}

var (
	evalCustomModelFieldUrl            = big.NewInt(1 << 0)
	evalCustomModelFieldHeaders        = big.NewInt(1 << 1)
	evalCustomModelFieldTimeoutSeconds = big.NewInt(1 << 2)
	evalCustomModelFieldModel          = big.NewInt(1 << 3)
	evalCustomModelFieldTemperature    = big.NewInt(1 << 4)
	evalCustomModelFieldMaxTokens      = big.NewInt(1 << 5)
)

type EvalCustomModel struct {
	// This is the provider of the model (`custom-llm`).
	// These is the URL we'll use for the OpenAI client's `baseURL`. Ex. https://openrouter.ai/api/v1
	Url string `json:"url" url:"url"`
	// These are the headers we'll use for the OpenAI client's `headers`.
	Headers map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`
	// This sets the timeout for the connection to the custom provider without needing to stream any tokens back. Default is 20 seconds.
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`
	// This is the name of the model. Ex. gpt-4o
	Model string `json:"model" url:"model"`
	// This is the temperature of the model. For LLM-as-a-judge, it's recommended to set it between 0 - 0.3 to avoid hallucinations and ensure the model judges the output correctly based on the instructions.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max tokens of the model.
	// If your Judge instructions return `true` or `false` takes only 1 token (as per the OpenAI Tokenizer), and therefore is recommended to set it to a low number to force the model to return a short response.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	provider       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalCustomModel) GetUrl() string {
	if e == nil {
		return ""
	}
	return e.Url
}

func (e *EvalCustomModel) GetHeaders() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Headers
}

func (e *EvalCustomModel) GetTimeoutSeconds() *float64 {
	if e == nil {
		return nil
	}
	return e.TimeoutSeconds
}

func (e *EvalCustomModel) GetModel() string {
	if e == nil {
		return ""
	}
	return e.Model
}

func (e *EvalCustomModel) GetTemperature() *float64 {
	if e == nil {
		return nil
	}
	return e.Temperature
}

func (e *EvalCustomModel) GetMaxTokens() *float64 {
	if e == nil {
		return nil
	}
	return e.MaxTokens
}

func (e *EvalCustomModel) Provider() string {
	return e.provider
}

func (e *EvalCustomModel) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalCustomModel) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetUrl(url string) {
	e.Url = url
	e.require(evalCustomModelFieldUrl)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetHeaders(headers map[string]interface{}) {
	e.Headers = headers
	e.require(evalCustomModelFieldHeaders)
}

// SetTimeoutSeconds sets the TimeoutSeconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetTimeoutSeconds(timeoutSeconds *float64) {
	e.TimeoutSeconds = timeoutSeconds
	e.require(evalCustomModelFieldTimeoutSeconds)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetModel(model string) {
	e.Model = model
	e.require(evalCustomModelFieldModel)
}

// SetTemperature sets the Temperature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetTemperature(temperature *float64) {
	e.Temperature = temperature
	e.require(evalCustomModelFieldTemperature)
}

// SetMaxTokens sets the MaxTokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalCustomModel) SetMaxTokens(maxTokens *float64) {
	e.MaxTokens = maxTokens
	e.require(evalCustomModelFieldMaxTokens)
}

func (e *EvalCustomModel) UnmarshalJSON(data []byte) error {
	type embed EvalCustomModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EvalCustomModel(unmarshaler.embed)
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "custom-llm", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalCustomModel) MarshalJSON() ([]byte, error) {
	type embed EvalCustomModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*e),
		Provider: "custom-llm",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalCustomModel) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	evalGoogleModelFieldModel       = big.NewInt(1 << 0)
	evalGoogleModelFieldTemperature = big.NewInt(1 << 1)
	evalGoogleModelFieldMaxTokens   = big.NewInt(1 << 2)
)

type EvalGoogleModel struct {
	// This is the provider of the model (`google`).
	// This is the name of the model. Ex. gpt-4o
	Model EvalGoogleModelModel `json:"model" url:"model"`
	// This is the temperature of the model. For LLM-as-a-judge, it's recommended to set it between 0 - 0.3 to avoid hallucinations and ensure the model judges the output correctly based on the instructions.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max tokens of the model.
	// If your Judge instructions return `true` or `false` takes only 1 token (as per the OpenAI Tokenizer), and therefore is recommended to set it to a low number to force the model to return a short response.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	provider       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalGoogleModel) GetModel() EvalGoogleModelModel {
	if e == nil {
		return ""
	}
	return e.Model
}

func (e *EvalGoogleModel) GetTemperature() *float64 {
	if e == nil {
		return nil
	}
	return e.Temperature
}

func (e *EvalGoogleModel) GetMaxTokens() *float64 {
	if e == nil {
		return nil
	}
	return e.MaxTokens
}

func (e *EvalGoogleModel) Provider() string {
	return e.provider
}

func (e *EvalGoogleModel) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalGoogleModel) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalGoogleModel) SetModel(model EvalGoogleModelModel) {
	e.Model = model
	e.require(evalGoogleModelFieldModel)
}

// SetTemperature sets the Temperature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalGoogleModel) SetTemperature(temperature *float64) {
	e.Temperature = temperature
	e.require(evalGoogleModelFieldTemperature)
}

// SetMaxTokens sets the MaxTokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalGoogleModel) SetMaxTokens(maxTokens *float64) {
	e.MaxTokens = maxTokens
	e.require(evalGoogleModelFieldMaxTokens)
}

func (e *EvalGoogleModel) UnmarshalJSON(data []byte) error {
	type embed EvalGoogleModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EvalGoogleModel(unmarshaler.embed)
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "google", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalGoogleModel) MarshalJSON() ([]byte, error) {
	type embed EvalGoogleModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*e),
		Provider: "google",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalGoogleModel) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the name of the model. Ex. gpt-4o
type EvalGoogleModelModel string

const (
	EvalGoogleModelModelGemini25Pro              EvalGoogleModelModel = "gemini-2.5-pro"
	EvalGoogleModelModelGemini25Flash            EvalGoogleModelModel = "gemini-2.5-flash"
	EvalGoogleModelModelGemini25FlashLite        EvalGoogleModelModel = "gemini-2.5-flash-lite"
	EvalGoogleModelModelGemini20FlashThinkingExp EvalGoogleModelModel = "gemini-2.0-flash-thinking-exp"
	EvalGoogleModelModelGemini20ProExp0205       EvalGoogleModelModel = "gemini-2.0-pro-exp-02-05"
	EvalGoogleModelModelGemini20Flash            EvalGoogleModelModel = "gemini-2.0-flash"
	EvalGoogleModelModelGemini20FlashLite        EvalGoogleModelModel = "gemini-2.0-flash-lite"
	EvalGoogleModelModelGemini20FlashExp         EvalGoogleModelModel = "gemini-2.0-flash-exp"
	EvalGoogleModelModelGemini20FlashRealtimeExp EvalGoogleModelModel = "gemini-2.0-flash-realtime-exp"
	EvalGoogleModelModelGemini15Flash            EvalGoogleModelModel = "gemini-1.5-flash"
	EvalGoogleModelModelGemini15Flash002         EvalGoogleModelModel = "gemini-1.5-flash-002"
	EvalGoogleModelModelGemini15Pro              EvalGoogleModelModel = "gemini-1.5-pro"
	EvalGoogleModelModelGemini15Pro002           EvalGoogleModelModel = "gemini-1.5-pro-002"
	EvalGoogleModelModelGemini10Pro              EvalGoogleModelModel = "gemini-1.0-pro"
)

func NewEvalGoogleModelModelFromString(s string) (EvalGoogleModelModel, error) {
	switch s {
	case "gemini-2.5-pro":
		return EvalGoogleModelModelGemini25Pro, nil
	case "gemini-2.5-flash":
		return EvalGoogleModelModelGemini25Flash, nil
	case "gemini-2.5-flash-lite":
		return EvalGoogleModelModelGemini25FlashLite, nil
	case "gemini-2.0-flash-thinking-exp":
		return EvalGoogleModelModelGemini20FlashThinkingExp, nil
	case "gemini-2.0-pro-exp-02-05":
		return EvalGoogleModelModelGemini20ProExp0205, nil
	case "gemini-2.0-flash":
		return EvalGoogleModelModelGemini20Flash, nil
	case "gemini-2.0-flash-lite":
		return EvalGoogleModelModelGemini20FlashLite, nil
	case "gemini-2.0-flash-exp":
		return EvalGoogleModelModelGemini20FlashExp, nil
	case "gemini-2.0-flash-realtime-exp":
		return EvalGoogleModelModelGemini20FlashRealtimeExp, nil
	case "gemini-1.5-flash":
		return EvalGoogleModelModelGemini15Flash, nil
	case "gemini-1.5-flash-002":
		return EvalGoogleModelModelGemini15Flash002, nil
	case "gemini-1.5-pro":
		return EvalGoogleModelModelGemini15Pro, nil
	case "gemini-1.5-pro-002":
		return EvalGoogleModelModelGemini15Pro002, nil
	case "gemini-1.0-pro":
		return EvalGoogleModelModelGemini10Pro, nil
	}
	var t EvalGoogleModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalGoogleModelModel) Ptr() *EvalGoogleModelModel {
	return &e
}

type EvalMessagesItem struct {
	ChatEvalAssistantMessageMock       *ChatEvalAssistantMessageMock
	ChatEvalSystemMessageMock          *ChatEvalSystemMessageMock
	ChatEvalToolResponseMessageMock    *ChatEvalToolResponseMessageMock
	ChatEvalUserMessageMock            *ChatEvalUserMessageMock
	ChatEvalAssistantMessageEvaluation *ChatEvalAssistantMessageEvaluation

	typ string
}

func (e *EvalMessagesItem) GetChatEvalAssistantMessageMock() *ChatEvalAssistantMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalAssistantMessageMock
}

func (e *EvalMessagesItem) GetChatEvalSystemMessageMock() *ChatEvalSystemMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalSystemMessageMock
}

func (e *EvalMessagesItem) GetChatEvalToolResponseMessageMock() *ChatEvalToolResponseMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalToolResponseMessageMock
}

func (e *EvalMessagesItem) GetChatEvalUserMessageMock() *ChatEvalUserMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalUserMessageMock
}

func (e *EvalMessagesItem) GetChatEvalAssistantMessageEvaluation() *ChatEvalAssistantMessageEvaluation {
	if e == nil {
		return nil
	}
	return e.ChatEvalAssistantMessageEvaluation
}

func (e *EvalMessagesItem) UnmarshalJSON(data []byte) error {
	valueChatEvalAssistantMessageMock := new(ChatEvalAssistantMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageMock); err == nil {
		e.typ = "ChatEvalAssistantMessageMock"
		e.ChatEvalAssistantMessageMock = valueChatEvalAssistantMessageMock
		return nil
	}
	valueChatEvalSystemMessageMock := new(ChatEvalSystemMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalSystemMessageMock); err == nil {
		e.typ = "ChatEvalSystemMessageMock"
		e.ChatEvalSystemMessageMock = valueChatEvalSystemMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageMock := new(ChatEvalToolResponseMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageMock); err == nil {
		e.typ = "ChatEvalToolResponseMessageMock"
		e.ChatEvalToolResponseMessageMock = valueChatEvalToolResponseMessageMock
		return nil
	}
	valueChatEvalUserMessageMock := new(ChatEvalUserMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalUserMessageMock); err == nil {
		e.typ = "ChatEvalUserMessageMock"
		e.ChatEvalUserMessageMock = valueChatEvalUserMessageMock
		return nil
	}
	valueChatEvalAssistantMessageEvaluation := new(ChatEvalAssistantMessageEvaluation)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageEvaluation); err == nil {
		e.typ = "ChatEvalAssistantMessageEvaluation"
		e.ChatEvalAssistantMessageEvaluation = valueChatEvalAssistantMessageEvaluation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EvalMessagesItem) MarshalJSON() ([]byte, error) {
	if e.typ == "ChatEvalAssistantMessageMock" || e.ChatEvalAssistantMessageMock != nil {
		return json.Marshal(e.ChatEvalAssistantMessageMock)
	}
	if e.typ == "ChatEvalSystemMessageMock" || e.ChatEvalSystemMessageMock != nil {
		return json.Marshal(e.ChatEvalSystemMessageMock)
	}
	if e.typ == "ChatEvalToolResponseMessageMock" || e.ChatEvalToolResponseMessageMock != nil {
		return json.Marshal(e.ChatEvalToolResponseMessageMock)
	}
	if e.typ == "ChatEvalUserMessageMock" || e.ChatEvalUserMessageMock != nil {
		return json.Marshal(e.ChatEvalUserMessageMock)
	}
	if e.typ == "ChatEvalAssistantMessageEvaluation" || e.ChatEvalAssistantMessageEvaluation != nil {
		return json.Marshal(e.ChatEvalAssistantMessageEvaluation)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EvalMessagesItemVisitor interface {
	VisitChatEvalAssistantMessageMock(*ChatEvalAssistantMessageMock) error
	VisitChatEvalSystemMessageMock(*ChatEvalSystemMessageMock) error
	VisitChatEvalToolResponseMessageMock(*ChatEvalToolResponseMessageMock) error
	VisitChatEvalUserMessageMock(*ChatEvalUserMessageMock) error
	VisitChatEvalAssistantMessageEvaluation(*ChatEvalAssistantMessageEvaluation) error
}

func (e *EvalMessagesItem) Accept(visitor EvalMessagesItemVisitor) error {
	if e.typ == "ChatEvalAssistantMessageMock" || e.ChatEvalAssistantMessageMock != nil {
		return visitor.VisitChatEvalAssistantMessageMock(e.ChatEvalAssistantMessageMock)
	}
	if e.typ == "ChatEvalSystemMessageMock" || e.ChatEvalSystemMessageMock != nil {
		return visitor.VisitChatEvalSystemMessageMock(e.ChatEvalSystemMessageMock)
	}
	if e.typ == "ChatEvalToolResponseMessageMock" || e.ChatEvalToolResponseMessageMock != nil {
		return visitor.VisitChatEvalToolResponseMessageMock(e.ChatEvalToolResponseMessageMock)
	}
	if e.typ == "ChatEvalUserMessageMock" || e.ChatEvalUserMessageMock != nil {
		return visitor.VisitChatEvalUserMessageMock(e.ChatEvalUserMessageMock)
	}
	if e.typ == "ChatEvalAssistantMessageEvaluation" || e.ChatEvalAssistantMessageEvaluation != nil {
		return visitor.VisitChatEvalAssistantMessageEvaluation(e.ChatEvalAssistantMessageEvaluation)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

var (
	evalOpenAiModelFieldModel       = big.NewInt(1 << 0)
	evalOpenAiModelFieldTemperature = big.NewInt(1 << 1)
	evalOpenAiModelFieldMaxTokens   = big.NewInt(1 << 2)
)

type EvalOpenAiModel struct {
	// This is the provider of the model (`openai`).
	// This is the OpenAI model that will be used.
	//
	// When using Vapi OpenAI or your own Azure Credentials, you have the option to specify the region for the selected model. This shouldn't be specified unless you have a specific reason to do so. Vapi will automatically find the fastest region that make sense.
	// This is helpful when you are required to comply with Data Residency rules. Learn more about Azure regions here https://azure.microsoft.com/en-us/explore/global-infrastructure/data-residency/.
	Model EvalOpenAiModelModel `json:"model" url:"model"`
	// This is the temperature of the model. For LLM-as-a-judge, it's recommended to set it between 0 - 0.3 to avoid hallucinations and ensure the model judges the output correctly based on the instructions.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max tokens of the model.
	// If your Judge instructions return `true` or `false` takes only 1 token (as per the OpenAI Tokenizer), and therefore is recommended to set it to a low number to force the model to return a short response.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	provider       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalOpenAiModel) GetModel() EvalOpenAiModelModel {
	if e == nil {
		return ""
	}
	return e.Model
}

func (e *EvalOpenAiModel) GetTemperature() *float64 {
	if e == nil {
		return nil
	}
	return e.Temperature
}

func (e *EvalOpenAiModel) GetMaxTokens() *float64 {
	if e == nil {
		return nil
	}
	return e.MaxTokens
}

func (e *EvalOpenAiModel) Provider() string {
	return e.provider
}

func (e *EvalOpenAiModel) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalOpenAiModel) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalOpenAiModel) SetModel(model EvalOpenAiModelModel) {
	e.Model = model
	e.require(evalOpenAiModelFieldModel)
}

// SetTemperature sets the Temperature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalOpenAiModel) SetTemperature(temperature *float64) {
	e.Temperature = temperature
	e.require(evalOpenAiModelFieldTemperature)
}

// SetMaxTokens sets the MaxTokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalOpenAiModel) SetMaxTokens(maxTokens *float64) {
	e.MaxTokens = maxTokens
	e.require(evalOpenAiModelFieldMaxTokens)
}

func (e *EvalOpenAiModel) UnmarshalJSON(data []byte) error {
	type embed EvalOpenAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EvalOpenAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "openai", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalOpenAiModel) MarshalJSON() ([]byte, error) {
	type embed EvalOpenAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*e),
		Provider: "openai",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalOpenAiModel) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the OpenAI model that will be used.
//
// When using Vapi OpenAI or your own Azure Credentials, you have the option to specify the region for the selected model. This shouldn't be specified unless you have a specific reason to do so. Vapi will automatically find the fastest region that make sense.
// This is helpful when you are required to comply with Data Residency rules. Learn more about Azure regions here https://azure.microsoft.com/en-us/explore/global-infrastructure/data-residency/.
type EvalOpenAiModelModel string

const (
	EvalOpenAiModelModelGpt5                            EvalOpenAiModelModel = "gpt-5"
	EvalOpenAiModelModelGpt5Mini                        EvalOpenAiModelModel = "gpt-5-mini"
	EvalOpenAiModelModelGpt5Nano                        EvalOpenAiModelModel = "gpt-5-nano"
	EvalOpenAiModelModelGpt4120250414                   EvalOpenAiModelModel = "gpt-4.1-2025-04-14"
	EvalOpenAiModelModelGpt41Mini20250414               EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14"
	EvalOpenAiModelModelGpt41Nano20250414               EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14"
	EvalOpenAiModelModelGpt41                           EvalOpenAiModelModel = "gpt-4.1"
	EvalOpenAiModelModelGpt41Mini                       EvalOpenAiModelModel = "gpt-4.1-mini"
	EvalOpenAiModelModelGpt41Nano                       EvalOpenAiModelModel = "gpt-4.1-nano"
	EvalOpenAiModelModelChatgpt4OLatest                 EvalOpenAiModelModel = "chatgpt-4o-latest"
	EvalOpenAiModelModelO3                              EvalOpenAiModelModel = "o3"
	EvalOpenAiModelModelO3Mini                          EvalOpenAiModelModel = "o3-mini"
	EvalOpenAiModelModelO4Mini                          EvalOpenAiModelModel = "o4-mini"
	EvalOpenAiModelModelO1Mini                          EvalOpenAiModelModel = "o1-mini"
	EvalOpenAiModelModelO1Mini20240912                  EvalOpenAiModelModel = "o1-mini-2024-09-12"
	EvalOpenAiModelModelGpt4OMini20240718               EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18"
	EvalOpenAiModelModelGpt4OMini                       EvalOpenAiModelModel = "gpt-4o-mini"
	EvalOpenAiModelModelGpt4O                           EvalOpenAiModelModel = "gpt-4o"
	EvalOpenAiModelModelGpt4O20240513                   EvalOpenAiModelModel = "gpt-4o-2024-05-13"
	EvalOpenAiModelModelGpt4O20240806                   EvalOpenAiModelModel = "gpt-4o-2024-08-06"
	EvalOpenAiModelModelGpt4O20241120                   EvalOpenAiModelModel = "gpt-4o-2024-11-20"
	EvalOpenAiModelModelGpt4Turbo                       EvalOpenAiModelModel = "gpt-4-turbo"
	EvalOpenAiModelModelGpt4Turbo20240409               EvalOpenAiModelModel = "gpt-4-turbo-2024-04-09"
	EvalOpenAiModelModelGpt4TurboPreview                EvalOpenAiModelModel = "gpt-4-turbo-preview"
	EvalOpenAiModelModelGpt40125Preview                 EvalOpenAiModelModel = "gpt-4-0125-preview"
	EvalOpenAiModelModelGpt41106Preview                 EvalOpenAiModelModel = "gpt-4-1106-preview"
	EvalOpenAiModelModelGpt4                            EvalOpenAiModelModel = "gpt-4"
	EvalOpenAiModelModelGpt40613                        EvalOpenAiModelModel = "gpt-4-0613"
	EvalOpenAiModelModelGpt35Turbo                      EvalOpenAiModelModel = "gpt-3.5-turbo"
	EvalOpenAiModelModelGpt35Turbo0125                  EvalOpenAiModelModel = "gpt-3.5-turbo-0125"
	EvalOpenAiModelModelGpt35Turbo1106                  EvalOpenAiModelModel = "gpt-3.5-turbo-1106"
	EvalOpenAiModelModelGpt35Turbo16K                   EvalOpenAiModelModel = "gpt-3.5-turbo-16k"
	EvalOpenAiModelModelGpt35Turbo0613                  EvalOpenAiModelModel = "gpt-3.5-turbo-0613"
	EvalOpenAiModelModelGpt4120250414Westus             EvalOpenAiModelModel = "gpt-4.1-2025-04-14:westus"
	EvalOpenAiModelModelGpt4120250414Eastus2            EvalOpenAiModelModel = "gpt-4.1-2025-04-14:eastus2"
	EvalOpenAiModelModelGpt4120250414Eastus             EvalOpenAiModelModel = "gpt-4.1-2025-04-14:eastus"
	EvalOpenAiModelModelGpt4120250414Westus3            EvalOpenAiModelModel = "gpt-4.1-2025-04-14:westus3"
	EvalOpenAiModelModelGpt4120250414Northcentralus     EvalOpenAiModelModel = "gpt-4.1-2025-04-14:northcentralus"
	EvalOpenAiModelModelGpt4120250414Southcentralus     EvalOpenAiModelModel = "gpt-4.1-2025-04-14:southcentralus"
	EvalOpenAiModelModelGpt41Mini20250414Westus         EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:westus"
	EvalOpenAiModelModelGpt41Mini20250414Eastus2        EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:eastus2"
	EvalOpenAiModelModelGpt41Mini20250414Eastus         EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:eastus"
	EvalOpenAiModelModelGpt41Mini20250414Westus3        EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:westus3"
	EvalOpenAiModelModelGpt41Mini20250414Northcentralus EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:northcentralus"
	EvalOpenAiModelModelGpt41Mini20250414Southcentralus EvalOpenAiModelModel = "gpt-4.1-mini-2025-04-14:southcentralus"
	EvalOpenAiModelModelGpt41Nano20250414Westus         EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14:westus"
	EvalOpenAiModelModelGpt41Nano20250414Eastus2        EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14:eastus2"
	EvalOpenAiModelModelGpt41Nano20250414Westus3        EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14:westus3"
	EvalOpenAiModelModelGpt41Nano20250414Northcentralus EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14:northcentralus"
	EvalOpenAiModelModelGpt41Nano20250414Southcentralus EvalOpenAiModelModel = "gpt-4.1-nano-2025-04-14:southcentralus"
	EvalOpenAiModelModelGpt4O20241120Swedencentral      EvalOpenAiModelModel = "gpt-4o-2024-11-20:swedencentral"
	EvalOpenAiModelModelGpt4O20241120Westus             EvalOpenAiModelModel = "gpt-4o-2024-11-20:westus"
	EvalOpenAiModelModelGpt4O20241120Eastus2            EvalOpenAiModelModel = "gpt-4o-2024-11-20:eastus2"
	EvalOpenAiModelModelGpt4O20241120Eastus             EvalOpenAiModelModel = "gpt-4o-2024-11-20:eastus"
	EvalOpenAiModelModelGpt4O20241120Westus3            EvalOpenAiModelModel = "gpt-4o-2024-11-20:westus3"
	EvalOpenAiModelModelGpt4O20241120Southcentralus     EvalOpenAiModelModel = "gpt-4o-2024-11-20:southcentralus"
	EvalOpenAiModelModelGpt4O20240806Westus             EvalOpenAiModelModel = "gpt-4o-2024-08-06:westus"
	EvalOpenAiModelModelGpt4O20240806Westus3            EvalOpenAiModelModel = "gpt-4o-2024-08-06:westus3"
	EvalOpenAiModelModelGpt4O20240806Eastus             EvalOpenAiModelModel = "gpt-4o-2024-08-06:eastus"
	EvalOpenAiModelModelGpt4O20240806Eastus2            EvalOpenAiModelModel = "gpt-4o-2024-08-06:eastus2"
	EvalOpenAiModelModelGpt4O20240806Northcentralus     EvalOpenAiModelModel = "gpt-4o-2024-08-06:northcentralus"
	EvalOpenAiModelModelGpt4O20240806Southcentralus     EvalOpenAiModelModel = "gpt-4o-2024-08-06:southcentralus"
	EvalOpenAiModelModelGpt4OMini20240718Westus         EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:westus"
	EvalOpenAiModelModelGpt4OMini20240718Westus3        EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:westus3"
	EvalOpenAiModelModelGpt4OMini20240718Eastus         EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:eastus"
	EvalOpenAiModelModelGpt4OMini20240718Eastus2        EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:eastus2"
	EvalOpenAiModelModelGpt4OMini20240718Northcentralus EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:northcentralus"
	EvalOpenAiModelModelGpt4OMini20240718Southcentralus EvalOpenAiModelModel = "gpt-4o-mini-2024-07-18:southcentralus"
	EvalOpenAiModelModelGpt4O20240513Eastus2            EvalOpenAiModelModel = "gpt-4o-2024-05-13:eastus2"
	EvalOpenAiModelModelGpt4O20240513Eastus             EvalOpenAiModelModel = "gpt-4o-2024-05-13:eastus"
	EvalOpenAiModelModelGpt4O20240513Northcentralus     EvalOpenAiModelModel = "gpt-4o-2024-05-13:northcentralus"
	EvalOpenAiModelModelGpt4O20240513Southcentralus     EvalOpenAiModelModel = "gpt-4o-2024-05-13:southcentralus"
	EvalOpenAiModelModelGpt4O20240513Westus3            EvalOpenAiModelModel = "gpt-4o-2024-05-13:westus3"
	EvalOpenAiModelModelGpt4O20240513Westus             EvalOpenAiModelModel = "gpt-4o-2024-05-13:westus"
	EvalOpenAiModelModelGpt4Turbo20240409Eastus2        EvalOpenAiModelModel = "gpt-4-turbo-2024-04-09:eastus2"
	EvalOpenAiModelModelGpt40125PreviewEastus           EvalOpenAiModelModel = "gpt-4-0125-preview:eastus"
	EvalOpenAiModelModelGpt40125PreviewNorthcentralus   EvalOpenAiModelModel = "gpt-4-0125-preview:northcentralus"
	EvalOpenAiModelModelGpt40125PreviewSouthcentralus   EvalOpenAiModelModel = "gpt-4-0125-preview:southcentralus"
	EvalOpenAiModelModelGpt41106PreviewAustralia        EvalOpenAiModelModel = "gpt-4-1106-preview:australia"
	EvalOpenAiModelModelGpt41106PreviewCanadaeast       EvalOpenAiModelModel = "gpt-4-1106-preview:canadaeast"
	EvalOpenAiModelModelGpt41106PreviewFrance           EvalOpenAiModelModel = "gpt-4-1106-preview:france"
	EvalOpenAiModelModelGpt41106PreviewIndia            EvalOpenAiModelModel = "gpt-4-1106-preview:india"
	EvalOpenAiModelModelGpt41106PreviewNorway           EvalOpenAiModelModel = "gpt-4-1106-preview:norway"
	EvalOpenAiModelModelGpt41106PreviewSwedencentral    EvalOpenAiModelModel = "gpt-4-1106-preview:swedencentral"
	EvalOpenAiModelModelGpt41106PreviewUk               EvalOpenAiModelModel = "gpt-4-1106-preview:uk"
	EvalOpenAiModelModelGpt41106PreviewWestus           EvalOpenAiModelModel = "gpt-4-1106-preview:westus"
	EvalOpenAiModelModelGpt41106PreviewWestus3          EvalOpenAiModelModel = "gpt-4-1106-preview:westus3"
	EvalOpenAiModelModelGpt40613Canadaeast              EvalOpenAiModelModel = "gpt-4-0613:canadaeast"
	EvalOpenAiModelModelGpt35Turbo0125Canadaeast        EvalOpenAiModelModel = "gpt-3.5-turbo-0125:canadaeast"
	EvalOpenAiModelModelGpt35Turbo0125Northcentralus    EvalOpenAiModelModel = "gpt-3.5-turbo-0125:northcentralus"
	EvalOpenAiModelModelGpt35Turbo0125Southcentralus    EvalOpenAiModelModel = "gpt-3.5-turbo-0125:southcentralus"
	EvalOpenAiModelModelGpt35Turbo1106Canadaeast        EvalOpenAiModelModel = "gpt-3.5-turbo-1106:canadaeast"
	EvalOpenAiModelModelGpt35Turbo1106Westus            EvalOpenAiModelModel = "gpt-3.5-turbo-1106:westus"
)

func NewEvalOpenAiModelModelFromString(s string) (EvalOpenAiModelModel, error) {
	switch s {
	case "gpt-5":
		return EvalOpenAiModelModelGpt5, nil
	case "gpt-5-mini":
		return EvalOpenAiModelModelGpt5Mini, nil
	case "gpt-5-nano":
		return EvalOpenAiModelModelGpt5Nano, nil
	case "gpt-4.1-2025-04-14":
		return EvalOpenAiModelModelGpt4120250414, nil
	case "gpt-4.1-mini-2025-04-14":
		return EvalOpenAiModelModelGpt41Mini20250414, nil
	case "gpt-4.1-nano-2025-04-14":
		return EvalOpenAiModelModelGpt41Nano20250414, nil
	case "gpt-4.1":
		return EvalOpenAiModelModelGpt41, nil
	case "gpt-4.1-mini":
		return EvalOpenAiModelModelGpt41Mini, nil
	case "gpt-4.1-nano":
		return EvalOpenAiModelModelGpt41Nano, nil
	case "chatgpt-4o-latest":
		return EvalOpenAiModelModelChatgpt4OLatest, nil
	case "o3":
		return EvalOpenAiModelModelO3, nil
	case "o3-mini":
		return EvalOpenAiModelModelO3Mini, nil
	case "o4-mini":
		return EvalOpenAiModelModelO4Mini, nil
	case "o1-mini":
		return EvalOpenAiModelModelO1Mini, nil
	case "o1-mini-2024-09-12":
		return EvalOpenAiModelModelO1Mini20240912, nil
	case "gpt-4o-mini-2024-07-18":
		return EvalOpenAiModelModelGpt4OMini20240718, nil
	case "gpt-4o-mini":
		return EvalOpenAiModelModelGpt4OMini, nil
	case "gpt-4o":
		return EvalOpenAiModelModelGpt4O, nil
	case "gpt-4o-2024-05-13":
		return EvalOpenAiModelModelGpt4O20240513, nil
	case "gpt-4o-2024-08-06":
		return EvalOpenAiModelModelGpt4O20240806, nil
	case "gpt-4o-2024-11-20":
		return EvalOpenAiModelModelGpt4O20241120, nil
	case "gpt-4-turbo":
		return EvalOpenAiModelModelGpt4Turbo, nil
	case "gpt-4-turbo-2024-04-09":
		return EvalOpenAiModelModelGpt4Turbo20240409, nil
	case "gpt-4-turbo-preview":
		return EvalOpenAiModelModelGpt4TurboPreview, nil
	case "gpt-4-0125-preview":
		return EvalOpenAiModelModelGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return EvalOpenAiModelModelGpt41106Preview, nil
	case "gpt-4":
		return EvalOpenAiModelModelGpt4, nil
	case "gpt-4-0613":
		return EvalOpenAiModelModelGpt40613, nil
	case "gpt-3.5-turbo":
		return EvalOpenAiModelModelGpt35Turbo, nil
	case "gpt-3.5-turbo-0125":
		return EvalOpenAiModelModelGpt35Turbo0125, nil
	case "gpt-3.5-turbo-1106":
		return EvalOpenAiModelModelGpt35Turbo1106, nil
	case "gpt-3.5-turbo-16k":
		return EvalOpenAiModelModelGpt35Turbo16K, nil
	case "gpt-3.5-turbo-0613":
		return EvalOpenAiModelModelGpt35Turbo0613, nil
	case "gpt-4.1-2025-04-14:westus":
		return EvalOpenAiModelModelGpt4120250414Westus, nil
	case "gpt-4.1-2025-04-14:eastus2":
		return EvalOpenAiModelModelGpt4120250414Eastus2, nil
	case "gpt-4.1-2025-04-14:eastus":
		return EvalOpenAiModelModelGpt4120250414Eastus, nil
	case "gpt-4.1-2025-04-14:westus3":
		return EvalOpenAiModelModelGpt4120250414Westus3, nil
	case "gpt-4.1-2025-04-14:northcentralus":
		return EvalOpenAiModelModelGpt4120250414Northcentralus, nil
	case "gpt-4.1-2025-04-14:southcentralus":
		return EvalOpenAiModelModelGpt4120250414Southcentralus, nil
	case "gpt-4.1-mini-2025-04-14:westus":
		return EvalOpenAiModelModelGpt41Mini20250414Westus, nil
	case "gpt-4.1-mini-2025-04-14:eastus2":
		return EvalOpenAiModelModelGpt41Mini20250414Eastus2, nil
	case "gpt-4.1-mini-2025-04-14:eastus":
		return EvalOpenAiModelModelGpt41Mini20250414Eastus, nil
	case "gpt-4.1-mini-2025-04-14:westus3":
		return EvalOpenAiModelModelGpt41Mini20250414Westus3, nil
	case "gpt-4.1-mini-2025-04-14:northcentralus":
		return EvalOpenAiModelModelGpt41Mini20250414Northcentralus, nil
	case "gpt-4.1-mini-2025-04-14:southcentralus":
		return EvalOpenAiModelModelGpt41Mini20250414Southcentralus, nil
	case "gpt-4.1-nano-2025-04-14:westus":
		return EvalOpenAiModelModelGpt41Nano20250414Westus, nil
	case "gpt-4.1-nano-2025-04-14:eastus2":
		return EvalOpenAiModelModelGpt41Nano20250414Eastus2, nil
	case "gpt-4.1-nano-2025-04-14:westus3":
		return EvalOpenAiModelModelGpt41Nano20250414Westus3, nil
	case "gpt-4.1-nano-2025-04-14:northcentralus":
		return EvalOpenAiModelModelGpt41Nano20250414Northcentralus, nil
	case "gpt-4.1-nano-2025-04-14:southcentralus":
		return EvalOpenAiModelModelGpt41Nano20250414Southcentralus, nil
	case "gpt-4o-2024-11-20:swedencentral":
		return EvalOpenAiModelModelGpt4O20241120Swedencentral, nil
	case "gpt-4o-2024-11-20:westus":
		return EvalOpenAiModelModelGpt4O20241120Westus, nil
	case "gpt-4o-2024-11-20:eastus2":
		return EvalOpenAiModelModelGpt4O20241120Eastus2, nil
	case "gpt-4o-2024-11-20:eastus":
		return EvalOpenAiModelModelGpt4O20241120Eastus, nil
	case "gpt-4o-2024-11-20:westus3":
		return EvalOpenAiModelModelGpt4O20241120Westus3, nil
	case "gpt-4o-2024-11-20:southcentralus":
		return EvalOpenAiModelModelGpt4O20241120Southcentralus, nil
	case "gpt-4o-2024-08-06:westus":
		return EvalOpenAiModelModelGpt4O20240806Westus, nil
	case "gpt-4o-2024-08-06:westus3":
		return EvalOpenAiModelModelGpt4O20240806Westus3, nil
	case "gpt-4o-2024-08-06:eastus":
		return EvalOpenAiModelModelGpt4O20240806Eastus, nil
	case "gpt-4o-2024-08-06:eastus2":
		return EvalOpenAiModelModelGpt4O20240806Eastus2, nil
	case "gpt-4o-2024-08-06:northcentralus":
		return EvalOpenAiModelModelGpt4O20240806Northcentralus, nil
	case "gpt-4o-2024-08-06:southcentralus":
		return EvalOpenAiModelModelGpt4O20240806Southcentralus, nil
	case "gpt-4o-mini-2024-07-18:westus":
		return EvalOpenAiModelModelGpt4OMini20240718Westus, nil
	case "gpt-4o-mini-2024-07-18:westus3":
		return EvalOpenAiModelModelGpt4OMini20240718Westus3, nil
	case "gpt-4o-mini-2024-07-18:eastus":
		return EvalOpenAiModelModelGpt4OMini20240718Eastus, nil
	case "gpt-4o-mini-2024-07-18:eastus2":
		return EvalOpenAiModelModelGpt4OMini20240718Eastus2, nil
	case "gpt-4o-mini-2024-07-18:northcentralus":
		return EvalOpenAiModelModelGpt4OMini20240718Northcentralus, nil
	case "gpt-4o-mini-2024-07-18:southcentralus":
		return EvalOpenAiModelModelGpt4OMini20240718Southcentralus, nil
	case "gpt-4o-2024-05-13:eastus2":
		return EvalOpenAiModelModelGpt4O20240513Eastus2, nil
	case "gpt-4o-2024-05-13:eastus":
		return EvalOpenAiModelModelGpt4O20240513Eastus, nil
	case "gpt-4o-2024-05-13:northcentralus":
		return EvalOpenAiModelModelGpt4O20240513Northcentralus, nil
	case "gpt-4o-2024-05-13:southcentralus":
		return EvalOpenAiModelModelGpt4O20240513Southcentralus, nil
	case "gpt-4o-2024-05-13:westus3":
		return EvalOpenAiModelModelGpt4O20240513Westus3, nil
	case "gpt-4o-2024-05-13:westus":
		return EvalOpenAiModelModelGpt4O20240513Westus, nil
	case "gpt-4-turbo-2024-04-09:eastus2":
		return EvalOpenAiModelModelGpt4Turbo20240409Eastus2, nil
	case "gpt-4-0125-preview:eastus":
		return EvalOpenAiModelModelGpt40125PreviewEastus, nil
	case "gpt-4-0125-preview:northcentralus":
		return EvalOpenAiModelModelGpt40125PreviewNorthcentralus, nil
	case "gpt-4-0125-preview:southcentralus":
		return EvalOpenAiModelModelGpt40125PreviewSouthcentralus, nil
	case "gpt-4-1106-preview:australia":
		return EvalOpenAiModelModelGpt41106PreviewAustralia, nil
	case "gpt-4-1106-preview:canadaeast":
		return EvalOpenAiModelModelGpt41106PreviewCanadaeast, nil
	case "gpt-4-1106-preview:france":
		return EvalOpenAiModelModelGpt41106PreviewFrance, nil
	case "gpt-4-1106-preview:india":
		return EvalOpenAiModelModelGpt41106PreviewIndia, nil
	case "gpt-4-1106-preview:norway":
		return EvalOpenAiModelModelGpt41106PreviewNorway, nil
	case "gpt-4-1106-preview:swedencentral":
		return EvalOpenAiModelModelGpt41106PreviewSwedencentral, nil
	case "gpt-4-1106-preview:uk":
		return EvalOpenAiModelModelGpt41106PreviewUk, nil
	case "gpt-4-1106-preview:westus":
		return EvalOpenAiModelModelGpt41106PreviewWestus, nil
	case "gpt-4-1106-preview:westus3":
		return EvalOpenAiModelModelGpt41106PreviewWestus3, nil
	case "gpt-4-0613:canadaeast":
		return EvalOpenAiModelModelGpt40613Canadaeast, nil
	case "gpt-3.5-turbo-0125:canadaeast":
		return EvalOpenAiModelModelGpt35Turbo0125Canadaeast, nil
	case "gpt-3.5-turbo-0125:northcentralus":
		return EvalOpenAiModelModelGpt35Turbo0125Northcentralus, nil
	case "gpt-3.5-turbo-0125:southcentralus":
		return EvalOpenAiModelModelGpt35Turbo0125Southcentralus, nil
	case "gpt-3.5-turbo-1106:canadaeast":
		return EvalOpenAiModelModelGpt35Turbo1106Canadaeast, nil
	case "gpt-3.5-turbo-1106:westus":
		return EvalOpenAiModelModelGpt35Turbo1106Westus, nil
	}
	var t EvalOpenAiModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalOpenAiModelModel) Ptr() *EvalOpenAiModelModel {
	return &e
}

var (
	evalPaginatedResponseFieldResults  = big.NewInt(1 << 0)
	evalPaginatedResponseFieldMetadata = big.NewInt(1 << 1)
)

type EvalPaginatedResponse struct {
	Results  []*Eval         `json:"results" url:"results"`
	Metadata *PaginationMeta `json:"metadata" url:"metadata"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalPaginatedResponse) GetResults() []*Eval {
	if e == nil {
		return nil
	}
	return e.Results
}

func (e *EvalPaginatedResponse) GetMetadata() *PaginationMeta {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EvalPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalPaginatedResponse) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalPaginatedResponse) SetResults(results []*Eval) {
	e.Results = results
	e.require(evalPaginatedResponseFieldResults)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalPaginatedResponse) SetMetadata(metadata *PaginationMeta) {
	e.Metadata = metadata
	e.require(evalPaginatedResponseFieldMetadata)
}

func (e *EvalPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EvalPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EvalPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalPaginatedResponse) MarshalJSON() ([]byte, error) {
	type embed EvalPaginatedResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalPaginatedResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	evalRunFieldStatus       = big.NewInt(1 << 0)
	evalRunFieldEndedReason  = big.NewInt(1 << 1)
	evalRunFieldEval         = big.NewInt(1 << 2)
	evalRunFieldTarget       = big.NewInt(1 << 3)
	evalRunFieldId           = big.NewInt(1 << 4)
	evalRunFieldOrgId        = big.NewInt(1 << 5)
	evalRunFieldCreatedAt    = big.NewInt(1 << 6)
	evalRunFieldStartedAt    = big.NewInt(1 << 7)
	evalRunFieldEndedAt      = big.NewInt(1 << 8)
	evalRunFieldEndedMessage = big.NewInt(1 << 9)
	evalRunFieldResults      = big.NewInt(1 << 10)
	evalRunFieldEvalId       = big.NewInt(1 << 11)
)

type EvalRun struct {
	// This is the status of the eval run. When an eval run is created, the status is 'running'.
	// When the eval run is completed, the status is 'ended'.
	Status EvalRunStatus `json:"status" url:"status"`
	// This is the reason for the eval run to end.
	// When the eval run is completed normally i.e end of mock conversation, the status is 'mockConversation.done'.
	// When the eval fails due to an error like Chat error or incorrect configuration, the status is 'error'.
	// When the eval runs for too long, due to model issues or tool call issues, the status is 'timeout'.
	// When the eval run is cancelled by the user, the status is 'cancelled'.
	// When the eval run is cancelled by Vapi for any reason, the status is 'aborted'.
	EndedReason EvalRunEndedReason `json:"endedReason" url:"endedReason"`
	// This is the transient eval that will be run
	Eval *CreateEvalDto `json:"eval,omitempty" url:"eval,omitempty"`
	// This is the target that will be run against the eval
	Target    *EvalRunTarget `json:"target" url:"target"`
	Id        string         `json:"id" url:"id"`
	OrgId     string         `json:"orgId" url:"orgId"`
	CreatedAt time.Time      `json:"createdAt" url:"createdAt"`
	StartedAt time.Time      `json:"startedAt" url:"startedAt"`
	EndedAt   time.Time      `json:"endedAt" url:"endedAt"`
	// This is the ended message when the eval run ended for any reason apart from mockConversation.done
	EndedMessage *string `json:"endedMessage,omitempty" url:"endedMessage,omitempty"`
	// This is the results of the eval or suite run.
	// The array will have a single item for an eval run, and multiple items each corresponding to the an eval in a suite run in the same order as the evals in the suite.
	Results []*EvalRunResult `json:"results" url:"results"`
	// This is the type of the run.
	// Currently it is fixed to `eval`.
	// This is the id of the eval that will be run.
	EvalId *string `json:"evalId,omitempty" url:"evalId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalRun) GetStatus() EvalRunStatus {
	if e == nil {
		return ""
	}
	return e.Status
}

func (e *EvalRun) GetEndedReason() EvalRunEndedReason {
	if e == nil {
		return ""
	}
	return e.EndedReason
}

func (e *EvalRun) GetEval() *CreateEvalDto {
	if e == nil {
		return nil
	}
	return e.Eval
}

func (e *EvalRun) GetTarget() *EvalRunTarget {
	if e == nil {
		return nil
	}
	return e.Target
}

func (e *EvalRun) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EvalRun) GetOrgId() string {
	if e == nil {
		return ""
	}
	return e.OrgId
}

func (e *EvalRun) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *EvalRun) GetStartedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.StartedAt
}

func (e *EvalRun) GetEndedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.EndedAt
}

func (e *EvalRun) GetEndedMessage() *string {
	if e == nil {
		return nil
	}
	return e.EndedMessage
}

func (e *EvalRun) GetResults() []*EvalRunResult {
	if e == nil {
		return nil
	}
	return e.Results
}

func (e *EvalRun) GetEvalId() *string {
	if e == nil {
		return nil
	}
	return e.EvalId
}

func (e *EvalRun) Type() string {
	return e.type_
}

func (e *EvalRun) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalRun) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetStatus(status EvalRunStatus) {
	e.Status = status
	e.require(evalRunFieldStatus)
}

// SetEndedReason sets the EndedReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetEndedReason(endedReason EvalRunEndedReason) {
	e.EndedReason = endedReason
	e.require(evalRunFieldEndedReason)
}

// SetEval sets the Eval field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetEval(eval *CreateEvalDto) {
	e.Eval = eval
	e.require(evalRunFieldEval)
}

// SetTarget sets the Target field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetTarget(target *EvalRunTarget) {
	e.Target = target
	e.require(evalRunFieldTarget)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetId(id string) {
	e.Id = id
	e.require(evalRunFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetOrgId(orgId string) {
	e.OrgId = orgId
	e.require(evalRunFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetCreatedAt(createdAt time.Time) {
	e.CreatedAt = createdAt
	e.require(evalRunFieldCreatedAt)
}

// SetStartedAt sets the StartedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetStartedAt(startedAt time.Time) {
	e.StartedAt = startedAt
	e.require(evalRunFieldStartedAt)
}

// SetEndedAt sets the EndedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetEndedAt(endedAt time.Time) {
	e.EndedAt = endedAt
	e.require(evalRunFieldEndedAt)
}

// SetEndedMessage sets the EndedMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetEndedMessage(endedMessage *string) {
	e.EndedMessage = endedMessage
	e.require(evalRunFieldEndedMessage)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetResults(results []*EvalRunResult) {
	e.Results = results
	e.require(evalRunFieldResults)
}

// SetEvalId sets the EvalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRun) SetEvalId(evalId *string) {
	e.EvalId = evalId
	e.require(evalRunFieldEvalId)
}

func (e *EvalRun) UnmarshalJSON(data []byte) error {
	type embed EvalRun
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		StartedAt *internal.DateTime `json:"startedAt"`
		EndedAt   *internal.DateTime `json:"endedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EvalRun(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.StartedAt = unmarshaler.StartedAt.Time()
	e.EndedAt = unmarshaler.EndedAt.Time()
	if unmarshaler.Type != "eval" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "eval", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalRun) MarshalJSON() ([]byte, error) {
	type embed EvalRun
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		StartedAt *internal.DateTime `json:"startedAt"`
		EndedAt   *internal.DateTime `json:"endedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		StartedAt: internal.NewDateTime(e.StartedAt),
		EndedAt:   internal.NewDateTime(e.EndedAt),
		Type:      "eval",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalRun) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the reason for the eval run to end.
// When the eval run is completed normally i.e end of mock conversation, the status is 'mockConversation.done'.
// When the eval fails due to an error like Chat error or incorrect configuration, the status is 'error'.
// When the eval runs for too long, due to model issues or tool call issues, the status is 'timeout'.
// When the eval run is cancelled by the user, the status is 'cancelled'.
// When the eval run is cancelled by Vapi for any reason, the status is 'aborted'.
type EvalRunEndedReason string

const (
	EvalRunEndedReasonMockConversationDone EvalRunEndedReason = "mockConversation.done"
	EvalRunEndedReasonError                EvalRunEndedReason = "error"
	EvalRunEndedReasonTimeout              EvalRunEndedReason = "timeout"
	EvalRunEndedReasonCancelled            EvalRunEndedReason = "cancelled"
	EvalRunEndedReasonAborted              EvalRunEndedReason = "aborted"
)

func NewEvalRunEndedReasonFromString(s string) (EvalRunEndedReason, error) {
	switch s {
	case "mockConversation.done":
		return EvalRunEndedReasonMockConversationDone, nil
	case "error":
		return EvalRunEndedReasonError, nil
	case "timeout":
		return EvalRunEndedReasonTimeout, nil
	case "cancelled":
		return EvalRunEndedReasonCancelled, nil
	case "aborted":
		return EvalRunEndedReasonAborted, nil
	}
	var t EvalRunEndedReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalRunEndedReason) Ptr() *EvalRunEndedReason {
	return &e
}

var (
	evalRunPaginatedResponseFieldResults  = big.NewInt(1 << 0)
	evalRunPaginatedResponseFieldMetadata = big.NewInt(1 << 1)
)

type EvalRunPaginatedResponse struct {
	Results  []*EvalRun      `json:"results" url:"results"`
	Metadata *PaginationMeta `json:"metadata" url:"metadata"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalRunPaginatedResponse) GetResults() []*EvalRun {
	if e == nil {
		return nil
	}
	return e.Results
}

func (e *EvalRunPaginatedResponse) GetMetadata() *PaginationMeta {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EvalRunPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalRunPaginatedResponse) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunPaginatedResponse) SetResults(results []*EvalRun) {
	e.Results = results
	e.require(evalRunPaginatedResponseFieldResults)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunPaginatedResponse) SetMetadata(metadata *PaginationMeta) {
	e.Metadata = metadata
	e.require(evalRunPaginatedResponseFieldMetadata)
}

func (e *EvalRunPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EvalRunPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EvalRunPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalRunPaginatedResponse) MarshalJSON() ([]byte, error) {
	type embed EvalRunPaginatedResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalRunPaginatedResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	evalRunResultFieldStatus    = big.NewInt(1 << 0)
	evalRunResultFieldMessages  = big.NewInt(1 << 1)
	evalRunResultFieldStartedAt = big.NewInt(1 << 2)
	evalRunResultFieldEndedAt   = big.NewInt(1 << 3)
)

type EvalRunResult struct {
	// This is the status of the eval run result.
	// The status is only 'pass' or 'fail' for an eval run result.
	// Currently, An eval is considered `pass` only if all the Assistant Judge messages are evaluated to pass.
	Status EvalRunResultStatus `json:"status" url:"status"`
	// This is the messages of the eval run result.
	// It contains the user/system messages
	Messages []*EvalRunResultMessagesItem `json:"messages" url:"messages"`
	// This is the start time of the eval run result.
	StartedAt time.Time `json:"startedAt" url:"startedAt"`
	// This is the end time of the eval run result.
	EndedAt time.Time `json:"endedAt" url:"endedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalRunResult) GetStatus() EvalRunResultStatus {
	if e == nil {
		return ""
	}
	return e.Status
}

func (e *EvalRunResult) GetMessages() []*EvalRunResultMessagesItem {
	if e == nil {
		return nil
	}
	return e.Messages
}

func (e *EvalRunResult) GetStartedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.StartedAt
}

func (e *EvalRunResult) GetEndedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.EndedAt
}

func (e *EvalRunResult) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalRunResult) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunResult) SetStatus(status EvalRunResultStatus) {
	e.Status = status
	e.require(evalRunResultFieldStatus)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunResult) SetMessages(messages []*EvalRunResultMessagesItem) {
	e.Messages = messages
	e.require(evalRunResultFieldMessages)
}

// SetStartedAt sets the StartedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunResult) SetStartedAt(startedAt time.Time) {
	e.StartedAt = startedAt
	e.require(evalRunResultFieldStartedAt)
}

// SetEndedAt sets the EndedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunResult) SetEndedAt(endedAt time.Time) {
	e.EndedAt = endedAt
	e.require(evalRunResultFieldEndedAt)
}

func (e *EvalRunResult) UnmarshalJSON(data []byte) error {
	type embed EvalRunResult
	var unmarshaler = struct {
		embed
		StartedAt *internal.DateTime `json:"startedAt"`
		EndedAt   *internal.DateTime `json:"endedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EvalRunResult(unmarshaler.embed)
	e.StartedAt = unmarshaler.StartedAt.Time()
	e.EndedAt = unmarshaler.EndedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalRunResult) MarshalJSON() ([]byte, error) {
	type embed EvalRunResult
	var marshaler = struct {
		embed
		StartedAt *internal.DateTime `json:"startedAt"`
		EndedAt   *internal.DateTime `json:"endedAt"`
	}{
		embed:     embed(*e),
		StartedAt: internal.NewDateTime(e.StartedAt),
		EndedAt:   internal.NewDateTime(e.EndedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalRunResult) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EvalRunResultMessagesItem struct {
	ChatEvalUserMessageMock         *ChatEvalUserMessageMock
	ChatEvalSystemMessageMock       *ChatEvalSystemMessageMock
	ChatEvalToolResponseMessageMock *ChatEvalToolResponseMessageMock
	ChatEvalAssistantMessageMock    *ChatEvalAssistantMessageMock

	typ string
}

func (e *EvalRunResultMessagesItem) GetChatEvalUserMessageMock() *ChatEvalUserMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalUserMessageMock
}

func (e *EvalRunResultMessagesItem) GetChatEvalSystemMessageMock() *ChatEvalSystemMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalSystemMessageMock
}

func (e *EvalRunResultMessagesItem) GetChatEvalToolResponseMessageMock() *ChatEvalToolResponseMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalToolResponseMessageMock
}

func (e *EvalRunResultMessagesItem) GetChatEvalAssistantMessageMock() *ChatEvalAssistantMessageMock {
	if e == nil {
		return nil
	}
	return e.ChatEvalAssistantMessageMock
}

func (e *EvalRunResultMessagesItem) UnmarshalJSON(data []byte) error {
	valueChatEvalUserMessageMock := new(ChatEvalUserMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalUserMessageMock); err == nil {
		e.typ = "ChatEvalUserMessageMock"
		e.ChatEvalUserMessageMock = valueChatEvalUserMessageMock
		return nil
	}
	valueChatEvalSystemMessageMock := new(ChatEvalSystemMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalSystemMessageMock); err == nil {
		e.typ = "ChatEvalSystemMessageMock"
		e.ChatEvalSystemMessageMock = valueChatEvalSystemMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageMock := new(ChatEvalToolResponseMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageMock); err == nil {
		e.typ = "ChatEvalToolResponseMessageMock"
		e.ChatEvalToolResponseMessageMock = valueChatEvalToolResponseMessageMock
		return nil
	}
	valueChatEvalAssistantMessageMock := new(ChatEvalAssistantMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageMock); err == nil {
		e.typ = "ChatEvalAssistantMessageMock"
		e.ChatEvalAssistantMessageMock = valueChatEvalAssistantMessageMock
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EvalRunResultMessagesItem) MarshalJSON() ([]byte, error) {
	if e.typ == "ChatEvalUserMessageMock" || e.ChatEvalUserMessageMock != nil {
		return json.Marshal(e.ChatEvalUserMessageMock)
	}
	if e.typ == "ChatEvalSystemMessageMock" || e.ChatEvalSystemMessageMock != nil {
		return json.Marshal(e.ChatEvalSystemMessageMock)
	}
	if e.typ == "ChatEvalToolResponseMessageMock" || e.ChatEvalToolResponseMessageMock != nil {
		return json.Marshal(e.ChatEvalToolResponseMessageMock)
	}
	if e.typ == "ChatEvalAssistantMessageMock" || e.ChatEvalAssistantMessageMock != nil {
		return json.Marshal(e.ChatEvalAssistantMessageMock)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EvalRunResultMessagesItemVisitor interface {
	VisitChatEvalUserMessageMock(*ChatEvalUserMessageMock) error
	VisitChatEvalSystemMessageMock(*ChatEvalSystemMessageMock) error
	VisitChatEvalToolResponseMessageMock(*ChatEvalToolResponseMessageMock) error
	VisitChatEvalAssistantMessageMock(*ChatEvalAssistantMessageMock) error
}

func (e *EvalRunResultMessagesItem) Accept(visitor EvalRunResultMessagesItemVisitor) error {
	if e.typ == "ChatEvalUserMessageMock" || e.ChatEvalUserMessageMock != nil {
		return visitor.VisitChatEvalUserMessageMock(e.ChatEvalUserMessageMock)
	}
	if e.typ == "ChatEvalSystemMessageMock" || e.ChatEvalSystemMessageMock != nil {
		return visitor.VisitChatEvalSystemMessageMock(e.ChatEvalSystemMessageMock)
	}
	if e.typ == "ChatEvalToolResponseMessageMock" || e.ChatEvalToolResponseMessageMock != nil {
		return visitor.VisitChatEvalToolResponseMessageMock(e.ChatEvalToolResponseMessageMock)
	}
	if e.typ == "ChatEvalAssistantMessageMock" || e.ChatEvalAssistantMessageMock != nil {
		return visitor.VisitChatEvalAssistantMessageMock(e.ChatEvalAssistantMessageMock)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// This is the status of the eval run result.
// The status is only 'pass' or 'fail' for an eval run result.
// Currently, An eval is considered `pass` only if all the Assistant Judge messages are evaluated to pass.
type EvalRunResultStatus string

const (
	EvalRunResultStatusPass EvalRunResultStatus = "pass"
	EvalRunResultStatusFail EvalRunResultStatus = "fail"
)

func NewEvalRunResultStatusFromString(s string) (EvalRunResultStatus, error) {
	switch s {
	case "pass":
		return EvalRunResultStatusPass, nil
	case "fail":
		return EvalRunResultStatusFail, nil
	}
	var t EvalRunResultStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalRunResultStatus) Ptr() *EvalRunResultStatus {
	return &e
}

// This is the status of the eval run. When an eval run is created, the status is 'running'.
// When the eval run is completed, the status is 'ended'.
type EvalRunStatus string

const (
	EvalRunStatusRunning EvalRunStatus = "running"
	EvalRunStatusEnded   EvalRunStatus = "ended"
	EvalRunStatusQueued  EvalRunStatus = "queued"
)

func NewEvalRunStatusFromString(s string) (EvalRunStatus, error) {
	switch s {
	case "running":
		return EvalRunStatusRunning, nil
	case "ended":
		return EvalRunStatusEnded, nil
	case "queued":
		return EvalRunStatusQueued, nil
	}
	var t EvalRunStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalRunStatus) Ptr() *EvalRunStatus {
	return &e
}

// This is the target that will be run against the eval
type EvalRunTarget struct {
	EvalRunTargetAssistant *EvalRunTargetAssistant
	EvalRunTargetSquad     *EvalRunTargetSquad

	typ string
}

func (e *EvalRunTarget) GetEvalRunTargetAssistant() *EvalRunTargetAssistant {
	if e == nil {
		return nil
	}
	return e.EvalRunTargetAssistant
}

func (e *EvalRunTarget) GetEvalRunTargetSquad() *EvalRunTargetSquad {
	if e == nil {
		return nil
	}
	return e.EvalRunTargetSquad
}

func (e *EvalRunTarget) UnmarshalJSON(data []byte) error {
	valueEvalRunTargetAssistant := new(EvalRunTargetAssistant)
	if err := json.Unmarshal(data, &valueEvalRunTargetAssistant); err == nil {
		e.typ = "EvalRunTargetAssistant"
		e.EvalRunTargetAssistant = valueEvalRunTargetAssistant
		return nil
	}
	valueEvalRunTargetSquad := new(EvalRunTargetSquad)
	if err := json.Unmarshal(data, &valueEvalRunTargetSquad); err == nil {
		e.typ = "EvalRunTargetSquad"
		e.EvalRunTargetSquad = valueEvalRunTargetSquad
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EvalRunTarget) MarshalJSON() ([]byte, error) {
	if e.typ == "EvalRunTargetAssistant" || e.EvalRunTargetAssistant != nil {
		return json.Marshal(e.EvalRunTargetAssistant)
	}
	if e.typ == "EvalRunTargetSquad" || e.EvalRunTargetSquad != nil {
		return json.Marshal(e.EvalRunTargetSquad)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EvalRunTargetVisitor interface {
	VisitEvalRunTargetAssistant(*EvalRunTargetAssistant) error
	VisitEvalRunTargetSquad(*EvalRunTargetSquad) error
}

func (e *EvalRunTarget) Accept(visitor EvalRunTargetVisitor) error {
	if e.typ == "EvalRunTargetAssistant" || e.EvalRunTargetAssistant != nil {
		return visitor.VisitEvalRunTargetAssistant(e.EvalRunTargetAssistant)
	}
	if e.typ == "EvalRunTargetSquad" || e.EvalRunTargetSquad != nil {
		return visitor.VisitEvalRunTargetSquad(e.EvalRunTargetSquad)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

var (
	evalRunTargetAssistantFieldAssistant          = big.NewInt(1 << 0)
	evalRunTargetAssistantFieldAssistantOverrides = big.NewInt(1 << 1)
	evalRunTargetAssistantFieldAssistantId        = big.NewInt(1 << 2)
)

type EvalRunTargetAssistant struct {
	// This is the transient assistant that will be run against the eval
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the overrides that will be applied to the assistant.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the type of the target.
	// Currently it is fixed to `assistant`.
	// This is the id of the assistant that will be run against the eval
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalRunTargetAssistant) GetAssistant() *CreateAssistantDto {
	if e == nil {
		return nil
	}
	return e.Assistant
}

func (e *EvalRunTargetAssistant) GetAssistantOverrides() *AssistantOverrides {
	if e == nil {
		return nil
	}
	return e.AssistantOverrides
}

func (e *EvalRunTargetAssistant) GetAssistantId() *string {
	if e == nil {
		return nil
	}
	return e.AssistantId
}

func (e *EvalRunTargetAssistant) Type() string {
	return e.type_
}

func (e *EvalRunTargetAssistant) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalRunTargetAssistant) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetAssistant sets the Assistant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetAssistant) SetAssistant(assistant *CreateAssistantDto) {
	e.Assistant = assistant
	e.require(evalRunTargetAssistantFieldAssistant)
}

// SetAssistantOverrides sets the AssistantOverrides field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetAssistant) SetAssistantOverrides(assistantOverrides *AssistantOverrides) {
	e.AssistantOverrides = assistantOverrides
	e.require(evalRunTargetAssistantFieldAssistantOverrides)
}

// SetAssistantId sets the AssistantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetAssistant) SetAssistantId(assistantId *string) {
	e.AssistantId = assistantId
	e.require(evalRunTargetAssistantFieldAssistantId)
}

func (e *EvalRunTargetAssistant) UnmarshalJSON(data []byte) error {
	type embed EvalRunTargetAssistant
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EvalRunTargetAssistant(unmarshaler.embed)
	if unmarshaler.Type != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "assistant", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalRunTargetAssistant) MarshalJSON() ([]byte, error) {
	type embed EvalRunTargetAssistant
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
		Type:  "assistant",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalRunTargetAssistant) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	evalRunTargetSquadFieldSquad              = big.NewInt(1 << 0)
	evalRunTargetSquadFieldAssistantOverrides = big.NewInt(1 << 1)
	evalRunTargetSquadFieldSquadId            = big.NewInt(1 << 2)
)

type EvalRunTargetSquad struct {
	// This is the transient squad that will be run against the eval
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// This is the overrides that will be applied to the assistants.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the type of the target.
	// Currently it is fixed to `squad`.
	// This is the id of the squad that will be run against the eval
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EvalRunTargetSquad) GetSquad() *CreateSquadDto {
	if e == nil {
		return nil
	}
	return e.Squad
}

func (e *EvalRunTargetSquad) GetAssistantOverrides() *AssistantOverrides {
	if e == nil {
		return nil
	}
	return e.AssistantOverrides
}

func (e *EvalRunTargetSquad) GetSquadId() *string {
	if e == nil {
		return nil
	}
	return e.SquadId
}

func (e *EvalRunTargetSquad) Type() string {
	return e.type_
}

func (e *EvalRunTargetSquad) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EvalRunTargetSquad) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetSquad sets the Squad field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetSquad) SetSquad(squad *CreateSquadDto) {
	e.Squad = squad
	e.require(evalRunTargetSquadFieldSquad)
}

// SetAssistantOverrides sets the AssistantOverrides field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetSquad) SetAssistantOverrides(assistantOverrides *AssistantOverrides) {
	e.AssistantOverrides = assistantOverrides
	e.require(evalRunTargetSquadFieldAssistantOverrides)
}

// SetSquadId sets the SquadId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EvalRunTargetSquad) SetSquadId(squadId *string) {
	e.SquadId = squadId
	e.require(evalRunTargetSquadFieldSquadId)
}

func (e *EvalRunTargetSquad) UnmarshalJSON(data []byte) error {
	type embed EvalRunTargetSquad
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EvalRunTargetSquad(unmarshaler.embed)
	if unmarshaler.Type != "squad" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "squad", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EvalRunTargetSquad) MarshalJSON() ([]byte, error) {
	type embed EvalRunTargetSquad
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
		Type:  "squad",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EvalRunTargetSquad) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the target that will be run against the eval
type CreateEvalRunDtoTarget struct {
	EvalRunTargetAssistant *EvalRunTargetAssistant
	EvalRunTargetSquad     *EvalRunTargetSquad

	typ string
}

func (c *CreateEvalRunDtoTarget) GetEvalRunTargetAssistant() *EvalRunTargetAssistant {
	if c == nil {
		return nil
	}
	return c.EvalRunTargetAssistant
}

func (c *CreateEvalRunDtoTarget) GetEvalRunTargetSquad() *EvalRunTargetSquad {
	if c == nil {
		return nil
	}
	return c.EvalRunTargetSquad
}

func (c *CreateEvalRunDtoTarget) UnmarshalJSON(data []byte) error {
	valueEvalRunTargetAssistant := new(EvalRunTargetAssistant)
	if err := json.Unmarshal(data, &valueEvalRunTargetAssistant); err == nil {
		c.typ = "EvalRunTargetAssistant"
		c.EvalRunTargetAssistant = valueEvalRunTargetAssistant
		return nil
	}
	valueEvalRunTargetSquad := new(EvalRunTargetSquad)
	if err := json.Unmarshal(data, &valueEvalRunTargetSquad); err == nil {
		c.typ = "EvalRunTargetSquad"
		c.EvalRunTargetSquad = valueEvalRunTargetSquad
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEvalRunDtoTarget) MarshalJSON() ([]byte, error) {
	if c.typ == "EvalRunTargetAssistant" || c.EvalRunTargetAssistant != nil {
		return json.Marshal(c.EvalRunTargetAssistant)
	}
	if c.typ == "EvalRunTargetSquad" || c.EvalRunTargetSquad != nil {
		return json.Marshal(c.EvalRunTargetSquad)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateEvalRunDtoTargetVisitor interface {
	VisitEvalRunTargetAssistant(*EvalRunTargetAssistant) error
	VisitEvalRunTargetSquad(*EvalRunTargetSquad) error
}

func (c *CreateEvalRunDtoTarget) Accept(visitor CreateEvalRunDtoTargetVisitor) error {
	if c.typ == "EvalRunTargetAssistant" || c.EvalRunTargetAssistant != nil {
		return visitor.VisitEvalRunTargetAssistant(c.EvalRunTargetAssistant)
	}
	if c.typ == "EvalRunTargetSquad" || c.EvalRunTargetSquad != nil {
		return visitor.VisitEvalRunTargetSquad(c.EvalRunTargetSquad)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type EvalControllerGetPaginatedRequestSortOrder string

const (
	EvalControllerGetPaginatedRequestSortOrderAsc  EvalControllerGetPaginatedRequestSortOrder = "ASC"
	EvalControllerGetPaginatedRequestSortOrderDesc EvalControllerGetPaginatedRequestSortOrder = "DESC"
)

func NewEvalControllerGetPaginatedRequestSortOrderFromString(s string) (EvalControllerGetPaginatedRequestSortOrder, error) {
	switch s {
	case "ASC":
		return EvalControllerGetPaginatedRequestSortOrderAsc, nil
	case "DESC":
		return EvalControllerGetPaginatedRequestSortOrderDesc, nil
	}
	var t EvalControllerGetPaginatedRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalControllerGetPaginatedRequestSortOrder) Ptr() *EvalControllerGetPaginatedRequestSortOrder {
	return &e
}

type EvalControllerGetRunsPaginatedRequestSortOrder string

const (
	EvalControllerGetRunsPaginatedRequestSortOrderAsc  EvalControllerGetRunsPaginatedRequestSortOrder = "ASC"
	EvalControllerGetRunsPaginatedRequestSortOrderDesc EvalControllerGetRunsPaginatedRequestSortOrder = "DESC"
)

func NewEvalControllerGetRunsPaginatedRequestSortOrderFromString(s string) (EvalControllerGetRunsPaginatedRequestSortOrder, error) {
	switch s {
	case "ASC":
		return EvalControllerGetRunsPaginatedRequestSortOrderAsc, nil
	case "DESC":
		return EvalControllerGetRunsPaginatedRequestSortOrderDesc, nil
	}
	var t EvalControllerGetRunsPaginatedRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EvalControllerGetRunsPaginatedRequestSortOrder) Ptr() *EvalControllerGetRunsPaginatedRequestSortOrder {
	return &e
}

type UpdateEvalDtoMessagesItem struct {
	ChatEvalAssistantMessageMock       *ChatEvalAssistantMessageMock
	ChatEvalSystemMessageMock          *ChatEvalSystemMessageMock
	ChatEvalToolResponseMessageMock    *ChatEvalToolResponseMessageMock
	ChatEvalUserMessageMock            *ChatEvalUserMessageMock
	ChatEvalAssistantMessageEvaluation *ChatEvalAssistantMessageEvaluation

	typ string
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalAssistantMessageMock() *ChatEvalAssistantMessageMock {
	if u == nil {
		return nil
	}
	return u.ChatEvalAssistantMessageMock
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalSystemMessageMock() *ChatEvalSystemMessageMock {
	if u == nil {
		return nil
	}
	return u.ChatEvalSystemMessageMock
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalToolResponseMessageMock() *ChatEvalToolResponseMessageMock {
	if u == nil {
		return nil
	}
	return u.ChatEvalToolResponseMessageMock
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalUserMessageMock() *ChatEvalUserMessageMock {
	if u == nil {
		return nil
	}
	return u.ChatEvalUserMessageMock
}

func (u *UpdateEvalDtoMessagesItem) GetChatEvalAssistantMessageEvaluation() *ChatEvalAssistantMessageEvaluation {
	if u == nil {
		return nil
	}
	return u.ChatEvalAssistantMessageEvaluation
}

func (u *UpdateEvalDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueChatEvalAssistantMessageMock := new(ChatEvalAssistantMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageMock); err == nil {
		u.typ = "ChatEvalAssistantMessageMock"
		u.ChatEvalAssistantMessageMock = valueChatEvalAssistantMessageMock
		return nil
	}
	valueChatEvalSystemMessageMock := new(ChatEvalSystemMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalSystemMessageMock); err == nil {
		u.typ = "ChatEvalSystemMessageMock"
		u.ChatEvalSystemMessageMock = valueChatEvalSystemMessageMock
		return nil
	}
	valueChatEvalToolResponseMessageMock := new(ChatEvalToolResponseMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalToolResponseMessageMock); err == nil {
		u.typ = "ChatEvalToolResponseMessageMock"
		u.ChatEvalToolResponseMessageMock = valueChatEvalToolResponseMessageMock
		return nil
	}
	valueChatEvalUserMessageMock := new(ChatEvalUserMessageMock)
	if err := json.Unmarshal(data, &valueChatEvalUserMessageMock); err == nil {
		u.typ = "ChatEvalUserMessageMock"
		u.ChatEvalUserMessageMock = valueChatEvalUserMessageMock
		return nil
	}
	valueChatEvalAssistantMessageEvaluation := new(ChatEvalAssistantMessageEvaluation)
	if err := json.Unmarshal(data, &valueChatEvalAssistantMessageEvaluation); err == nil {
		u.typ = "ChatEvalAssistantMessageEvaluation"
		u.ChatEvalAssistantMessageEvaluation = valueChatEvalAssistantMessageEvaluation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateEvalDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ChatEvalAssistantMessageMock" || u.ChatEvalAssistantMessageMock != nil {
		return json.Marshal(u.ChatEvalAssistantMessageMock)
	}
	if u.typ == "ChatEvalSystemMessageMock" || u.ChatEvalSystemMessageMock != nil {
		return json.Marshal(u.ChatEvalSystemMessageMock)
	}
	if u.typ == "ChatEvalToolResponseMessageMock" || u.ChatEvalToolResponseMessageMock != nil {
		return json.Marshal(u.ChatEvalToolResponseMessageMock)
	}
	if u.typ == "ChatEvalUserMessageMock" || u.ChatEvalUserMessageMock != nil {
		return json.Marshal(u.ChatEvalUserMessageMock)
	}
	if u.typ == "ChatEvalAssistantMessageEvaluation" || u.ChatEvalAssistantMessageEvaluation != nil {
		return json.Marshal(u.ChatEvalAssistantMessageEvaluation)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateEvalDtoMessagesItemVisitor interface {
	VisitChatEvalAssistantMessageMock(*ChatEvalAssistantMessageMock) error
	VisitChatEvalSystemMessageMock(*ChatEvalSystemMessageMock) error
	VisitChatEvalToolResponseMessageMock(*ChatEvalToolResponseMessageMock) error
	VisitChatEvalUserMessageMock(*ChatEvalUserMessageMock) error
	VisitChatEvalAssistantMessageEvaluation(*ChatEvalAssistantMessageEvaluation) error
}

func (u *UpdateEvalDtoMessagesItem) Accept(visitor UpdateEvalDtoMessagesItemVisitor) error {
	if u.typ == "ChatEvalAssistantMessageMock" || u.ChatEvalAssistantMessageMock != nil {
		return visitor.VisitChatEvalAssistantMessageMock(u.ChatEvalAssistantMessageMock)
	}
	if u.typ == "ChatEvalSystemMessageMock" || u.ChatEvalSystemMessageMock != nil {
		return visitor.VisitChatEvalSystemMessageMock(u.ChatEvalSystemMessageMock)
	}
	if u.typ == "ChatEvalToolResponseMessageMock" || u.ChatEvalToolResponseMessageMock != nil {
		return visitor.VisitChatEvalToolResponseMessageMock(u.ChatEvalToolResponseMessageMock)
	}
	if u.typ == "ChatEvalUserMessageMock" || u.ChatEvalUserMessageMock != nil {
		return visitor.VisitChatEvalUserMessageMock(u.ChatEvalUserMessageMock)
	}
	if u.typ == "ChatEvalAssistantMessageEvaluation" || u.ChatEvalAssistantMessageEvaluation != nil {
		return visitor.VisitChatEvalAssistantMessageEvaluation(u.ChatEvalAssistantMessageEvaluation)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}
