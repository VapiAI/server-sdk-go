// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/VapiAI/server-sdk-go/internal"
	big "math/big"
	time "time"
)

var (
	createChatDtoFieldAssistantId        = big.NewInt(1 << 0)
	createChatDtoFieldAssistant          = big.NewInt(1 << 1)
	createChatDtoFieldAssistantOverrides = big.NewInt(1 << 2)
	createChatDtoFieldSquadId            = big.NewInt(1 << 3)
	createChatDtoFieldSquad              = big.NewInt(1 << 4)
	createChatDtoFieldName               = big.NewInt(1 << 5)
	createChatDtoFieldSessionId          = big.NewInt(1 << 6)
	createChatDtoFieldInput              = big.NewInt(1 << 7)
	createChatDtoFieldStream             = big.NewInt(1 << 8)
	createChatDtoFieldPreviousChatId     = big.NewInt(1 << 9)
	createChatDtoFieldTransport          = big.NewInt(1 << 10)
)

type CreateChatDto struct {
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"-"`
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"-"`
	// These are the variable values that will be used to replace template variables in the assistant messages.
	// Only variable substitution is supported in chat contexts - other assistant properties cannot be overridden.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"-"`
	// This is the squad that will be used for the chat. To use a transient squad, use `squad` instead.
	SquadId *string `json:"squadId,omitempty" url:"-"`
	// This is the squad that will be used for the chat. To use an existing squad, use `squadId` instead.
	Squad *CreateSquadDto `json:"squad,omitempty" url:"-"`
	// This is the name of the chat. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"-"`
	// This is the ID of the session that will be used for the chat.
	// Mutually exclusive with previousChatId.
	SessionId *string `json:"sessionId,omitempty" url:"-"`
	// This is the input text for the chat.
	// Can be a string or an array of chat messages.
	// This field is REQUIRED for chat creation.
	Input *CreateChatDtoInput `json:"input,omitempty" url:"-"`
	// This is a flag that determines whether the response should be streamed.
	// When true, the response will be sent as chunks of text.
	Stream *bool `json:"stream,omitempty" url:"-"`
	// This is the ID of the chat that will be used as context for the new chat.
	// The messages from the previous chat will be used as context.
	// Mutually exclusive with sessionId.
	PreviousChatId *string `json:"previousChatId,omitempty" url:"-"`
	// This is used to send the chat through a transport like SMS.
	// If transport.phoneNumberId and transport.customer are provided, creates a new session.
	// If sessionId is provided without transport fields, uses existing session data.
	// Cannot specify both sessionId and transport fields (phoneNumberId/customer) together.
	Transport *TwilioSmsChatTransport `json:"transport,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CreateChatDto) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetAssistantId sets the AssistantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetAssistantId(assistantId *string) {
	c.AssistantId = assistantId
	c.require(createChatDtoFieldAssistantId)
}

// SetAssistant sets the Assistant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetAssistant(assistant *CreateAssistantDto) {
	c.Assistant = assistant
	c.require(createChatDtoFieldAssistant)
}

// SetAssistantOverrides sets the AssistantOverrides field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetAssistantOverrides(assistantOverrides *AssistantOverrides) {
	c.AssistantOverrides = assistantOverrides
	c.require(createChatDtoFieldAssistantOverrides)
}

// SetSquadId sets the SquadId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetSquadId(squadId *string) {
	c.SquadId = squadId
	c.require(createChatDtoFieldSquadId)
}

// SetSquad sets the Squad field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetSquad(squad *CreateSquadDto) {
	c.Squad = squad
	c.require(createChatDtoFieldSquad)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetName(name *string) {
	c.Name = name
	c.require(createChatDtoFieldName)
}

// SetSessionId sets the SessionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetSessionId(sessionId *string) {
	c.SessionId = sessionId
	c.require(createChatDtoFieldSessionId)
}

// SetInput sets the Input field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetInput(input *CreateChatDtoInput) {
	c.Input = input
	c.require(createChatDtoFieldInput)
}

// SetStream sets the Stream field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetStream(stream *bool) {
	c.Stream = stream
	c.require(createChatDtoFieldStream)
}

// SetPreviousChatId sets the PreviousChatId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetPreviousChatId(previousChatId *string) {
	c.PreviousChatId = previousChatId
	c.require(createChatDtoFieldPreviousChatId)
}

// SetTransport sets the Transport field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatDto) SetTransport(transport *TwilioSmsChatTransport) {
	c.Transport = transport
	c.require(createChatDtoFieldTransport)
}

var (
	openAiResponsesRequestFieldAssistantId        = big.NewInt(1 << 0)
	openAiResponsesRequestFieldAssistant          = big.NewInt(1 << 1)
	openAiResponsesRequestFieldAssistantOverrides = big.NewInt(1 << 2)
	openAiResponsesRequestFieldSquadId            = big.NewInt(1 << 3)
	openAiResponsesRequestFieldSquad              = big.NewInt(1 << 4)
	openAiResponsesRequestFieldName               = big.NewInt(1 << 5)
	openAiResponsesRequestFieldSessionId          = big.NewInt(1 << 6)
	openAiResponsesRequestFieldInput              = big.NewInt(1 << 7)
	openAiResponsesRequestFieldStream             = big.NewInt(1 << 8)
	openAiResponsesRequestFieldPreviousChatId     = big.NewInt(1 << 9)
	openAiResponsesRequestFieldTransport          = big.NewInt(1 << 10)
)

type OpenAiResponsesRequest struct {
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"-"`
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"-"`
	// These are the variable values that will be used to replace template variables in the assistant messages.
	// Only variable substitution is supported in chat contexts - other assistant properties cannot be overridden.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"-"`
	// This is the squad that will be used for the chat. To use a transient squad, use `squad` instead.
	SquadId *string `json:"squadId,omitempty" url:"-"`
	// This is the squad that will be used for the chat. To use an existing squad, use `squadId` instead.
	Squad *CreateSquadDto `json:"squad,omitempty" url:"-"`
	// This is the name of the chat. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"-"`
	// This is the ID of the session that will be used for the chat.
	// Mutually exclusive with previousChatId.
	SessionId *string `json:"sessionId,omitempty" url:"-"`
	// This is the input text for the chat.
	// Can be a string or an array of chat messages.
	// This field is REQUIRED for chat creation.
	Input *OpenAiResponsesRequestInput `json:"input,omitempty" url:"-"`
	// Whether to stream the response or not.
	Stream *bool `json:"stream,omitempty" url:"-"`
	// This is the ID of the chat that will be used as context for the new chat.
	// The messages from the previous chat will be used as context.
	// Mutually exclusive with sessionId.
	PreviousChatId *string `json:"previousChatId,omitempty" url:"-"`
	// This is used to send the chat through a transport like SMS.
	// If transport.phoneNumberId and transport.customer are provided, creates a new session.
	// If sessionId is provided without transport fields, uses existing session data.
	// Cannot specify both sessionId and transport fields (phoneNumberId/customer) together.
	Transport *TwilioSmsChatTransport `json:"transport,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (o *OpenAiResponsesRequest) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetAssistantId sets the AssistantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetAssistantId(assistantId *string) {
	o.AssistantId = assistantId
	o.require(openAiResponsesRequestFieldAssistantId)
}

// SetAssistant sets the Assistant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetAssistant(assistant *CreateAssistantDto) {
	o.Assistant = assistant
	o.require(openAiResponsesRequestFieldAssistant)
}

// SetAssistantOverrides sets the AssistantOverrides field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetAssistantOverrides(assistantOverrides *AssistantOverrides) {
	o.AssistantOverrides = assistantOverrides
	o.require(openAiResponsesRequestFieldAssistantOverrides)
}

// SetSquadId sets the SquadId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetSquadId(squadId *string) {
	o.SquadId = squadId
	o.require(openAiResponsesRequestFieldSquadId)
}

// SetSquad sets the Squad field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetSquad(squad *CreateSquadDto) {
	o.Squad = squad
	o.require(openAiResponsesRequestFieldSquad)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetName(name *string) {
	o.Name = name
	o.require(openAiResponsesRequestFieldName)
}

// SetSessionId sets the SessionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetSessionId(sessionId *string) {
	o.SessionId = sessionId
	o.require(openAiResponsesRequestFieldSessionId)
}

// SetInput sets the Input field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetInput(input *OpenAiResponsesRequestInput) {
	o.Input = input
	o.require(openAiResponsesRequestFieldInput)
}

// SetStream sets the Stream field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetStream(stream *bool) {
	o.Stream = stream
	o.require(openAiResponsesRequestFieldStream)
}

// SetPreviousChatId sets the PreviousChatId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetPreviousChatId(previousChatId *string) {
	o.PreviousChatId = previousChatId
	o.require(openAiResponsesRequestFieldPreviousChatId)
}

// SetTransport sets the Transport field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OpenAiResponsesRequest) SetTransport(transport *TwilioSmsChatTransport) {
	o.Transport = transport
	o.require(openAiResponsesRequestFieldTransport)
}

var (
	deleteChatsRequestFieldId = big.NewInt(1 << 0)
)

type DeleteChatsRequest struct {
	Id string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DeleteChatsRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteChatsRequest) SetId(id string) {
	d.Id = id
	d.require(deleteChatsRequestFieldId)
}

var (
	getChatsRequestFieldId = big.NewInt(1 << 0)
)

type GetChatsRequest struct {
	Id string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetChatsRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetChatsRequest) SetId(id string) {
	g.Id = id
	g.require(getChatsRequestFieldId)
}

var (
	listChatsRequestFieldAssistantId    = big.NewInt(1 << 0)
	listChatsRequestFieldSquadId        = big.NewInt(1 << 1)
	listChatsRequestFieldSessionId      = big.NewInt(1 << 2)
	listChatsRequestFieldPreviousChatId = big.NewInt(1 << 3)
	listChatsRequestFieldPage           = big.NewInt(1 << 4)
	listChatsRequestFieldSortOrder      = big.NewInt(1 << 5)
	listChatsRequestFieldLimit          = big.NewInt(1 << 6)
	listChatsRequestFieldCreatedAtGt    = big.NewInt(1 << 7)
	listChatsRequestFieldCreatedAtLt    = big.NewInt(1 << 8)
	listChatsRequestFieldCreatedAtGe    = big.NewInt(1 << 9)
	listChatsRequestFieldCreatedAtLe    = big.NewInt(1 << 10)
	listChatsRequestFieldUpdatedAtGt    = big.NewInt(1 << 11)
	listChatsRequestFieldUpdatedAtLt    = big.NewInt(1 << 12)
	listChatsRequestFieldUpdatedAtGe    = big.NewInt(1 << 13)
	listChatsRequestFieldUpdatedAtLe    = big.NewInt(1 << 14)
)

type ListChatsRequest struct {
	// This is the unique identifier for the assistant that will be used for the chat.
	AssistantId *string `json:"-" url:"assistantId,omitempty"`
	// This is the unique identifier for the squad that will be used for the chat.
	SquadId *string `json:"-" url:"squadId,omitempty"`
	// This is the unique identifier for the session that will be used for the chat.
	SessionId *string `json:"-" url:"sessionId,omitempty"`
	// This is the unique identifier for the previous chat to filter by.
	PreviousChatId *string `json:"-" url:"previousChatId,omitempty"`
	// This is the page number to return. Defaults to 1.
	Page *float64 `json:"-" url:"page,omitempty"`
	// This is the sort order for pagination. Defaults to 'DESC'.
	SortOrder *ListChatsRequestSortOrder `json:"-" url:"sortOrder,omitempty"`
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListChatsRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetAssistantId sets the AssistantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetAssistantId(assistantId *string) {
	l.AssistantId = assistantId
	l.require(listChatsRequestFieldAssistantId)
}

// SetSquadId sets the SquadId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetSquadId(squadId *string) {
	l.SquadId = squadId
	l.require(listChatsRequestFieldSquadId)
}

// SetSessionId sets the SessionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetSessionId(sessionId *string) {
	l.SessionId = sessionId
	l.require(listChatsRequestFieldSessionId)
}

// SetPreviousChatId sets the PreviousChatId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetPreviousChatId(previousChatId *string) {
	l.PreviousChatId = previousChatId
	l.require(listChatsRequestFieldPreviousChatId)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetPage(page *float64) {
	l.Page = page
	l.require(listChatsRequestFieldPage)
}

// SetSortOrder sets the SortOrder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetSortOrder(sortOrder *ListChatsRequestSortOrder) {
	l.SortOrder = sortOrder
	l.require(listChatsRequestFieldSortOrder)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetLimit(limit *float64) {
	l.Limit = limit
	l.require(listChatsRequestFieldLimit)
}

// SetCreatedAtGt sets the CreatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetCreatedAtGt(createdAtGt *time.Time) {
	l.CreatedAtGt = createdAtGt
	l.require(listChatsRequestFieldCreatedAtGt)
}

// SetCreatedAtLt sets the CreatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetCreatedAtLt(createdAtLt *time.Time) {
	l.CreatedAtLt = createdAtLt
	l.require(listChatsRequestFieldCreatedAtLt)
}

// SetCreatedAtGe sets the CreatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetCreatedAtGe(createdAtGe *time.Time) {
	l.CreatedAtGe = createdAtGe
	l.require(listChatsRequestFieldCreatedAtGe)
}

// SetCreatedAtLe sets the CreatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetCreatedAtLe(createdAtLe *time.Time) {
	l.CreatedAtLe = createdAtLe
	l.require(listChatsRequestFieldCreatedAtLe)
}

// SetUpdatedAtGt sets the UpdatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetUpdatedAtGt(updatedAtGt *time.Time) {
	l.UpdatedAtGt = updatedAtGt
	l.require(listChatsRequestFieldUpdatedAtGt)
}

// SetUpdatedAtLt sets the UpdatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetUpdatedAtLt(updatedAtLt *time.Time) {
	l.UpdatedAtLt = updatedAtLt
	l.require(listChatsRequestFieldUpdatedAtLt)
}

// SetUpdatedAtGe sets the UpdatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetUpdatedAtGe(updatedAtGe *time.Time) {
	l.UpdatedAtGe = updatedAtGe
	l.require(listChatsRequestFieldUpdatedAtGe)
}

// SetUpdatedAtLe sets the UpdatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListChatsRequest) SetUpdatedAtLe(updatedAtLe *time.Time) {
	l.UpdatedAtLe = updatedAtLe
	l.require(listChatsRequestFieldUpdatedAtLe)
}

var (
	chatFieldAssistantId        = big.NewInt(1 << 0)
	chatFieldAssistant          = big.NewInt(1 << 1)
	chatFieldAssistantOverrides = big.NewInt(1 << 2)
	chatFieldSquadId            = big.NewInt(1 << 3)
	chatFieldSquad              = big.NewInt(1 << 4)
	chatFieldName               = big.NewInt(1 << 5)
	chatFieldSessionId          = big.NewInt(1 << 6)
	chatFieldInput              = big.NewInt(1 << 7)
	chatFieldStream             = big.NewInt(1 << 8)
	chatFieldPreviousChatId     = big.NewInt(1 << 9)
	chatFieldId                 = big.NewInt(1 << 10)
	chatFieldOrgId              = big.NewInt(1 << 11)
	chatFieldMessages           = big.NewInt(1 << 12)
	chatFieldOutput             = big.NewInt(1 << 13)
	chatFieldCreatedAt          = big.NewInt(1 << 14)
	chatFieldUpdatedAt          = big.NewInt(1 << 15)
	chatFieldCosts              = big.NewInt(1 << 16)
	chatFieldCost               = big.NewInt(1 << 17)
)

type Chat struct {
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the variable values that will be used to replace template variables in the assistant messages.
	// Only variable substitution is supported in chat contexts - other assistant properties cannot be overridden.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the chat. To use a transient squad, use `squad` instead.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is the squad that will be used for the chat. To use an existing squad, use `squadId` instead.
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// This is the name of the chat. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the ID of the session that will be used for the chat.
	// Mutually exclusive with previousChatId.
	SessionId *string `json:"sessionId,omitempty" url:"sessionId,omitempty"`
	// This is the input text for the chat.
	// Can be a string or an array of chat messages.
	Input *ChatInput `json:"input,omitempty" url:"input,omitempty"`
	// This is a flag that determines whether the response should be streamed.
	// When true, the response will be sent as chunks of text.
	Stream *bool `json:"stream,omitempty" url:"stream,omitempty"`
	// This is the ID of the chat that will be used as context for the new chat.
	// The messages from the previous chat will be used as context.
	// Mutually exclusive with sessionId.
	PreviousChatId *string `json:"previousChatId,omitempty" url:"previousChatId,omitempty"`
	// This is the unique identifier for the chat.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this chat belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is an array of messages used as context for the chat.
	// Used to provide message history for multi-turn conversations.
	Messages []*ChatMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the output messages generated by the system in response to the input.
	Output []*ChatOutputItem `json:"output,omitempty" url:"output,omitempty"`
	// This is the ISO 8601 date-time string of when the chat was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the chat was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// These are the costs of individual components of the chat in USD.
	Costs []*ChatCostsItem `json:"costs,omitempty" url:"costs,omitempty"`
	// This is the cost of the chat in USD.
	Cost *float64 `json:"cost,omitempty" url:"cost,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Chat) GetAssistantId() *string {
	if c == nil {
		return nil
	}
	return c.AssistantId
}

func (c *Chat) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *Chat) GetAssistantOverrides() *AssistantOverrides {
	if c == nil {
		return nil
	}
	return c.AssistantOverrides
}

func (c *Chat) GetSquadId() *string {
	if c == nil {
		return nil
	}
	return c.SquadId
}

func (c *Chat) GetSquad() *CreateSquadDto {
	if c == nil {
		return nil
	}
	return c.Squad
}

func (c *Chat) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *Chat) GetSessionId() *string {
	if c == nil {
		return nil
	}
	return c.SessionId
}

func (c *Chat) GetInput() *ChatInput {
	if c == nil {
		return nil
	}
	return c.Input
}

func (c *Chat) GetStream() *bool {
	if c == nil {
		return nil
	}
	return c.Stream
}

func (c *Chat) GetPreviousChatId() *string {
	if c == nil {
		return nil
	}
	return c.PreviousChatId
}

func (c *Chat) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *Chat) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *Chat) GetMessages() []*ChatMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *Chat) GetOutput() []*ChatOutputItem {
	if c == nil {
		return nil
	}
	return c.Output
}

func (c *Chat) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *Chat) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *Chat) GetCosts() []*ChatCostsItem {
	if c == nil {
		return nil
	}
	return c.Costs
}

func (c *Chat) GetCost() *float64 {
	if c == nil {
		return nil
	}
	return c.Cost
}

func (c *Chat) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Chat) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetAssistantId sets the AssistantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetAssistantId(assistantId *string) {
	c.AssistantId = assistantId
	c.require(chatFieldAssistantId)
}

// SetAssistant sets the Assistant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetAssistant(assistant *CreateAssistantDto) {
	c.Assistant = assistant
	c.require(chatFieldAssistant)
}

// SetAssistantOverrides sets the AssistantOverrides field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetAssistantOverrides(assistantOverrides *AssistantOverrides) {
	c.AssistantOverrides = assistantOverrides
	c.require(chatFieldAssistantOverrides)
}

// SetSquadId sets the SquadId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetSquadId(squadId *string) {
	c.SquadId = squadId
	c.require(chatFieldSquadId)
}

// SetSquad sets the Squad field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetSquad(squad *CreateSquadDto) {
	c.Squad = squad
	c.require(chatFieldSquad)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetName(name *string) {
	c.Name = name
	c.require(chatFieldName)
}

// SetSessionId sets the SessionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetSessionId(sessionId *string) {
	c.SessionId = sessionId
	c.require(chatFieldSessionId)
}

// SetInput sets the Input field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetInput(input *ChatInput) {
	c.Input = input
	c.require(chatFieldInput)
}

// SetStream sets the Stream field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetStream(stream *bool) {
	c.Stream = stream
	c.require(chatFieldStream)
}

// SetPreviousChatId sets the PreviousChatId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetPreviousChatId(previousChatId *string) {
	c.PreviousChatId = previousChatId
	c.require(chatFieldPreviousChatId)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetId(id string) {
	c.Id = id
	c.require(chatFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetOrgId(orgId string) {
	c.OrgId = orgId
	c.require(chatFieldOrgId)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetMessages(messages []*ChatMessagesItem) {
	c.Messages = messages
	c.require(chatFieldMessages)
}

// SetOutput sets the Output field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetOutput(output []*ChatOutputItem) {
	c.Output = output
	c.require(chatFieldOutput)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetCreatedAt(createdAt time.Time) {
	c.CreatedAt = createdAt
	c.require(chatFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetUpdatedAt(updatedAt time.Time) {
	c.UpdatedAt = updatedAt
	c.require(chatFieldUpdatedAt)
}

// SetCosts sets the Costs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetCosts(costs []*ChatCostsItem) {
	c.Costs = costs
	c.require(chatFieldCosts)
}

// SetCost sets the Cost field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Chat) SetCost(cost *float64) {
	c.Cost = cost
	c.require(chatFieldCost)
}

func (c *Chat) UnmarshalJSON(data []byte) error {
	type embed Chat
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Chat(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Chat) MarshalJSON() ([]byte, error) {
	type embed Chat
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *Chat) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	chatCostFieldType = big.NewInt(1 << 0)
	chatCostFieldCost = big.NewInt(1 << 1)
)

type ChatCost struct {
	// This is the type of cost, always 'chat' for this class.
	Type ChatCostType `json:"type" url:"type"`
	// This is the cost of the component in USD.
	Cost float64 `json:"cost" url:"cost"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatCost) GetType() ChatCostType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ChatCost) GetCost() float64 {
	if c == nil {
		return 0
	}
	return c.Cost
}

func (c *ChatCost) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatCost) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatCost) SetType(type_ ChatCostType) {
	c.Type = type_
	c.require(chatCostFieldType)
}

// SetCost sets the Cost field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatCost) SetCost(cost float64) {
	c.Cost = cost
	c.require(chatCostFieldCost)
}

func (c *ChatCost) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatCost
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatCost(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCost) MarshalJSON() ([]byte, error) {
	type embed ChatCost
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatCost) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the type of cost, always 'chat' for this class.
type ChatCostType string

const (
	ChatCostTypeChat ChatCostType = "chat"
)

func NewChatCostTypeFromString(s string) (ChatCostType, error) {
	switch s {
	case "chat":
		return ChatCostTypeChat, nil
	}
	var t ChatCostType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatCostType) Ptr() *ChatCostType {
	return &c
}

type ChatCostsItem struct {
	ModelCost *ModelCost
	ChatCost  *ChatCost

	typ string
}

func (c *ChatCostsItem) GetModelCost() *ModelCost {
	if c == nil {
		return nil
	}
	return c.ModelCost
}

func (c *ChatCostsItem) GetChatCost() *ChatCost {
	if c == nil {
		return nil
	}
	return c.ChatCost
}

func (c *ChatCostsItem) UnmarshalJSON(data []byte) error {
	valueModelCost := new(ModelCost)
	if err := json.Unmarshal(data, &valueModelCost); err == nil {
		c.typ = "ModelCost"
		c.ModelCost = valueModelCost
		return nil
	}
	valueChatCost := new(ChatCost)
	if err := json.Unmarshal(data, &valueChatCost); err == nil {
		c.typ = "ChatCost"
		c.ChatCost = valueChatCost
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatCostsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ModelCost" || c.ModelCost != nil {
		return json.Marshal(c.ModelCost)
	}
	if c.typ == "ChatCost" || c.ChatCost != nil {
		return json.Marshal(c.ChatCost)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatCostsItemVisitor interface {
	VisitModelCost(*ModelCost) error
	VisitChatCost(*ChatCost) error
}

func (c *ChatCostsItem) Accept(visitor ChatCostsItemVisitor) error {
	if c.typ == "ModelCost" || c.ModelCost != nil {
		return visitor.VisitModelCost(c.ModelCost)
	}
	if c.typ == "ChatCost" || c.ChatCost != nil {
		return visitor.VisitChatCost(c.ChatCost)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the input text for the chat.
// Can be a string or an array of chat messages.
type ChatInput struct {
	String               string
	ChatInputOneItemList []*ChatInputOneItem

	typ string
}

func (c *ChatInput) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *ChatInput) GetChatInputOneItemList() []*ChatInputOneItem {
	if c == nil {
		return nil
	}
	return c.ChatInputOneItemList
}

func (c *ChatInput) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	var valueChatInputOneItemList []*ChatInputOneItem
	if err := json.Unmarshal(data, &valueChatInputOneItemList); err == nil {
		c.typ = "ChatInputOneItemList"
		c.ChatInputOneItemList = valueChatInputOneItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatInput) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "ChatInputOneItemList" || c.ChatInputOneItemList != nil {
		return json.Marshal(c.ChatInputOneItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatInputVisitor interface {
	VisitString(string) error
	VisitChatInputOneItemList([]*ChatInputOneItem) error
}

func (c *ChatInput) Accept(visitor ChatInputVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "ChatInputOneItemList" || c.ChatInputOneItemList != nil {
		return visitor.VisitChatInputOneItemList(c.ChatInputOneItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatInputOneItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (c *ChatInputOneItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *ChatInputOneItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *ChatInputOneItem) GetAssistantMessage() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.AssistantMessage
}

func (c *ChatInputOneItem) GetToolMessage() *ToolMessage {
	if c == nil {
		return nil
	}
	return c.ToolMessage
}

func (c *ChatInputOneItem) GetDeveloperMessage() *DeveloperMessage {
	if c == nil {
		return nil
	}
	return c.DeveloperMessage
}

func (c *ChatInputOneItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		c.typ = "AssistantMessage"
		c.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		c.typ = "ToolMessage"
		c.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		c.typ = "DeveloperMessage"
		c.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatInputOneItem) MarshalJSON() ([]byte, error) {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return json.Marshal(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return json.Marshal(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return json.Marshal(c.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatInputOneItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (c *ChatInputOneItem) Accept(visitor ChatInputOneItemVisitor) error {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return visitor.VisitToolMessage(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(c.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatMessagesItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (c *ChatMessagesItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *ChatMessagesItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *ChatMessagesItem) GetAssistantMessage() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.AssistantMessage
}

func (c *ChatMessagesItem) GetToolMessage() *ToolMessage {
	if c == nil {
		return nil
	}
	return c.ToolMessage
}

func (c *ChatMessagesItem) GetDeveloperMessage() *DeveloperMessage {
	if c == nil {
		return nil
	}
	return c.DeveloperMessage
}

func (c *ChatMessagesItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		c.typ = "AssistantMessage"
		c.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		c.typ = "ToolMessage"
		c.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		c.typ = "DeveloperMessage"
		c.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return json.Marshal(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return json.Marshal(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return json.Marshal(c.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatMessagesItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (c *ChatMessagesItem) Accept(visitor ChatMessagesItemVisitor) error {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return visitor.VisitToolMessage(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(c.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatOutputItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (c *ChatOutputItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *ChatOutputItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *ChatOutputItem) GetAssistantMessage() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.AssistantMessage
}

func (c *ChatOutputItem) GetToolMessage() *ToolMessage {
	if c == nil {
		return nil
	}
	return c.ToolMessage
}

func (c *ChatOutputItem) GetDeveloperMessage() *DeveloperMessage {
	if c == nil {
		return nil
	}
	return c.DeveloperMessage
}

func (c *ChatOutputItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		c.typ = "AssistantMessage"
		c.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		c.typ = "ToolMessage"
		c.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		c.typ = "DeveloperMessage"
		c.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatOutputItem) MarshalJSON() ([]byte, error) {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return json.Marshal(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return json.Marshal(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return json.Marshal(c.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatOutputItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (c *ChatOutputItem) Accept(visitor ChatOutputItemVisitor) error {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return visitor.VisitToolMessage(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(c.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

var (
	chatPaginatedResponseFieldResults  = big.NewInt(1 << 0)
	chatPaginatedResponseFieldMetadata = big.NewInt(1 << 1)
)

type ChatPaginatedResponse struct {
	Results  []*Chat         `json:"results" url:"results"`
	Metadata *PaginationMeta `json:"metadata" url:"metadata"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatPaginatedResponse) GetResults() []*Chat {
	if c == nil {
		return nil
	}
	return c.Results
}

func (c *ChatPaginatedResponse) GetMetadata() *PaginationMeta {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ChatPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatPaginatedResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatPaginatedResponse) SetResults(results []*Chat) {
	c.Results = results
	c.require(chatPaginatedResponseFieldResults)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChatPaginatedResponse) SetMetadata(metadata *PaginationMeta) {
	c.Metadata = metadata
	c.require(chatPaginatedResponseFieldMetadata)
}

func (c *ChatPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatPaginatedResponse) MarshalJSON() ([]byte, error) {
	type embed ChatPaginatedResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChatPaginatedResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	createChatStreamResponseFieldId        = big.NewInt(1 << 0)
	createChatStreamResponseFieldSessionId = big.NewInt(1 << 1)
	createChatStreamResponseFieldPath      = big.NewInt(1 << 2)
	createChatStreamResponseFieldDelta     = big.NewInt(1 << 3)
)

type CreateChatStreamResponse struct {
	// This is the unique identifier for the streaming response.
	Id string `json:"id" url:"id"`
	// This is the ID of the session that will be used for the chat.
	// Helps track conversation context across multiple messages.
	SessionId *string `json:"sessionId,omitempty" url:"sessionId,omitempty"`
	// This is the path to the content being updated.
	// Format: `chat.output[{contentIndex}].content` where contentIndex identifies the specific content item.
	Path string `json:"path" url:"path"`
	// This is the incremental content chunk being streamed.
	Delta string `json:"delta" url:"delta"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateChatStreamResponse) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CreateChatStreamResponse) GetSessionId() *string {
	if c == nil {
		return nil
	}
	return c.SessionId
}

func (c *CreateChatStreamResponse) GetPath() string {
	if c == nil {
		return ""
	}
	return c.Path
}

func (c *CreateChatStreamResponse) GetDelta() string {
	if c == nil {
		return ""
	}
	return c.Delta
}

func (c *CreateChatStreamResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateChatStreamResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatStreamResponse) SetId(id string) {
	c.Id = id
	c.require(createChatStreamResponseFieldId)
}

// SetSessionId sets the SessionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatStreamResponse) SetSessionId(sessionId *string) {
	c.SessionId = sessionId
	c.require(createChatStreamResponseFieldSessionId)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatStreamResponse) SetPath(path string) {
	c.Path = path
	c.require(createChatStreamResponseFieldPath)
}

// SetDelta sets the Delta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateChatStreamResponse) SetDelta(delta string) {
	c.Delta = delta
	c.require(createChatStreamResponseFieldDelta)
}

func (c *CreateChatStreamResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateChatStreamResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateChatStreamResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateChatStreamResponse) MarshalJSON() ([]byte, error) {
	type embed CreateChatStreamResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateChatStreamResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	responseCompletedEventFieldResponse = big.NewInt(1 << 0)
	responseCompletedEventFieldType     = big.NewInt(1 << 1)
)

type ResponseCompletedEvent struct {
	// The completed response
	Response *ResponseObject `json:"response" url:"response"`
	// Event type
	Type ResponseCompletedEventType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseCompletedEvent) GetResponse() *ResponseObject {
	if r == nil {
		return nil
	}
	return r.Response
}

func (r *ResponseCompletedEvent) GetType() ResponseCompletedEventType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResponseCompletedEvent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseCompletedEvent) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetResponse sets the Response field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCompletedEvent) SetResponse(response *ResponseObject) {
	r.Response = response
	r.require(responseCompletedEventFieldResponse)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCompletedEvent) SetType(type_ ResponseCompletedEventType) {
	r.Type = type_
	r.require(responseCompletedEventFieldType)
}

func (r *ResponseCompletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseCompletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseCompletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseCompletedEvent) MarshalJSON() ([]byte, error) {
	type embed ResponseCompletedEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseCompletedEvent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Event type
type ResponseCompletedEventType string

const (
	ResponseCompletedEventTypeResponseCompleted ResponseCompletedEventType = "response.completed"
)

func NewResponseCompletedEventTypeFromString(s string) (ResponseCompletedEventType, error) {
	switch s {
	case "response.completed":
		return ResponseCompletedEventTypeResponseCompleted, nil
	}
	var t ResponseCompletedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseCompletedEventType) Ptr() *ResponseCompletedEventType {
	return &r
}

var (
	responseErrorEventFieldType           = big.NewInt(1 << 0)
	responseErrorEventFieldCode           = big.NewInt(1 << 1)
	responseErrorEventFieldMessage        = big.NewInt(1 << 2)
	responseErrorEventFieldParam          = big.NewInt(1 << 3)
	responseErrorEventFieldSequenceNumber = big.NewInt(1 << 4)
)

type ResponseErrorEvent struct {
	// Event type
	Type ResponseErrorEventType `json:"type" url:"type"`
	// Error code
	Code string `json:"code" url:"code"`
	// Error message
	Message string `json:"message" url:"message"`
	// Parameter that caused the error
	Param *string `json:"param,omitempty" url:"param,omitempty"`
	// Sequence number of the event
	SequenceNumber float64 `json:"sequence_number" url:"sequence_number"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseErrorEvent) GetType() ResponseErrorEventType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResponseErrorEvent) GetCode() string {
	if r == nil {
		return ""
	}
	return r.Code
}

func (r *ResponseErrorEvent) GetMessage() string {
	if r == nil {
		return ""
	}
	return r.Message
}

func (r *ResponseErrorEvent) GetParam() *string {
	if r == nil {
		return nil
	}
	return r.Param
}

func (r *ResponseErrorEvent) GetSequenceNumber() float64 {
	if r == nil {
		return 0
	}
	return r.SequenceNumber
}

func (r *ResponseErrorEvent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseErrorEvent) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseErrorEvent) SetType(type_ ResponseErrorEventType) {
	r.Type = type_
	r.require(responseErrorEventFieldType)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseErrorEvent) SetCode(code string) {
	r.Code = code
	r.require(responseErrorEventFieldCode)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseErrorEvent) SetMessage(message string) {
	r.Message = message
	r.require(responseErrorEventFieldMessage)
}

// SetParam sets the Param field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseErrorEvent) SetParam(param *string) {
	r.Param = param
	r.require(responseErrorEventFieldParam)
}

// SetSequenceNumber sets the SequenceNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseErrorEvent) SetSequenceNumber(sequenceNumber float64) {
	r.SequenceNumber = sequenceNumber
	r.require(responseErrorEventFieldSequenceNumber)
}

func (r *ResponseErrorEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseErrorEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseErrorEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseErrorEvent) MarshalJSON() ([]byte, error) {
	type embed ResponseErrorEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseErrorEvent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Event type
type ResponseErrorEventType string

const (
	ResponseErrorEventTypeError ResponseErrorEventType = "error"
)

func NewResponseErrorEventTypeFromString(s string) (ResponseErrorEventType, error) {
	switch s {
	case "error":
		return ResponseErrorEventTypeError, nil
	}
	var t ResponseErrorEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseErrorEventType) Ptr() *ResponseErrorEventType {
	return &r
}

var (
	responseObjectFieldId        = big.NewInt(1 << 0)
	responseObjectFieldObject    = big.NewInt(1 << 1)
	responseObjectFieldCreatedAt = big.NewInt(1 << 2)
	responseObjectFieldStatus    = big.NewInt(1 << 3)
	responseObjectFieldError     = big.NewInt(1 << 4)
	responseObjectFieldOutput    = big.NewInt(1 << 5)
)

type ResponseObject struct {
	// Unique identifier for this Response
	Id string `json:"id" url:"id"`
	// The object type
	Object ResponseObjectObject `json:"object" url:"object"`
	// Unix timestamp (in seconds) of when this Response was created
	CreatedAt float64 `json:"created_at" url:"created_at"`
	// Status of the response
	Status ResponseObjectStatus `json:"status" url:"status"`
	// Error message if the response failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Output messages from the model
	Output []*ResponseOutputMessage `json:"output" url:"output"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseObject) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *ResponseObject) GetObject() ResponseObjectObject {
	if r == nil {
		return ""
	}
	return r.Object
}

func (r *ResponseObject) GetCreatedAt() float64 {
	if r == nil {
		return 0
	}
	return r.CreatedAt
}

func (r *ResponseObject) GetStatus() ResponseObjectStatus {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *ResponseObject) GetError() *string {
	if r == nil {
		return nil
	}
	return r.Error
}

func (r *ResponseObject) GetOutput() []*ResponseOutputMessage {
	if r == nil {
		return nil
	}
	return r.Output
}

func (r *ResponseObject) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseObject) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseObject) SetId(id string) {
	r.Id = id
	r.require(responseObjectFieldId)
}

// SetObject sets the Object field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseObject) SetObject(object ResponseObjectObject) {
	r.Object = object
	r.require(responseObjectFieldObject)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseObject) SetCreatedAt(createdAt float64) {
	r.CreatedAt = createdAt
	r.require(responseObjectFieldCreatedAt)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseObject) SetStatus(status ResponseObjectStatus) {
	r.Status = status
	r.require(responseObjectFieldStatus)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseObject) SetError(error_ *string) {
	r.Error = error_
	r.require(responseObjectFieldError)
}

// SetOutput sets the Output field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseObject) SetOutput(output []*ResponseOutputMessage) {
	r.Output = output
	r.require(responseObjectFieldOutput)
}

func (r *ResponseObject) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseObject) MarshalJSON() ([]byte, error) {
	type embed ResponseObject
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseObject) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The object type
type ResponseObjectObject string

const (
	ResponseObjectObjectResponse ResponseObjectObject = "response"
)

func NewResponseObjectObjectFromString(s string) (ResponseObjectObject, error) {
	switch s {
	case "response":
		return ResponseObjectObjectResponse, nil
	}
	var t ResponseObjectObject
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseObjectObject) Ptr() *ResponseObjectObject {
	return &r
}

// Status of the response
type ResponseObjectStatus string

const (
	ResponseObjectStatusCompleted  ResponseObjectStatus = "completed"
	ResponseObjectStatusFailed     ResponseObjectStatus = "failed"
	ResponseObjectStatusInProgress ResponseObjectStatus = "in_progress"
	ResponseObjectStatusIncomplete ResponseObjectStatus = "incomplete"
)

func NewResponseObjectStatusFromString(s string) (ResponseObjectStatus, error) {
	switch s {
	case "completed":
		return ResponseObjectStatusCompleted, nil
	case "failed":
		return ResponseObjectStatusFailed, nil
	case "in_progress":
		return ResponseObjectStatusInProgress, nil
	case "incomplete":
		return ResponseObjectStatusIncomplete, nil
	}
	var t ResponseObjectStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseObjectStatus) Ptr() *ResponseObjectStatus {
	return &r
}

var (
	responseOutputMessageFieldId      = big.NewInt(1 << 0)
	responseOutputMessageFieldContent = big.NewInt(1 << 1)
	responseOutputMessageFieldRole    = big.NewInt(1 << 2)
	responseOutputMessageFieldStatus  = big.NewInt(1 << 3)
	responseOutputMessageFieldType    = big.NewInt(1 << 4)
)

type ResponseOutputMessage struct {
	// The unique ID of the output message
	Id string `json:"id" url:"id"`
	// Content of the output message
	Content []*ResponseOutputText `json:"content" url:"content"`
	// The role of the output message
	Role ResponseOutputMessageRole `json:"role" url:"role"`
	// The status of the message
	Status ResponseOutputMessageStatus `json:"status" url:"status"`
	// The type of the output message
	Type ResponseOutputMessageType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseOutputMessage) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *ResponseOutputMessage) GetContent() []*ResponseOutputText {
	if r == nil {
		return nil
	}
	return r.Content
}

func (r *ResponseOutputMessage) GetRole() ResponseOutputMessageRole {
	if r == nil {
		return ""
	}
	return r.Role
}

func (r *ResponseOutputMessage) GetStatus() ResponseOutputMessageStatus {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *ResponseOutputMessage) GetType() ResponseOutputMessageType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResponseOutputMessage) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseOutputMessage) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseOutputMessage) SetId(id string) {
	r.Id = id
	r.require(responseOutputMessageFieldId)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseOutputMessage) SetContent(content []*ResponseOutputText) {
	r.Content = content
	r.require(responseOutputMessageFieldContent)
}

// SetRole sets the Role field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseOutputMessage) SetRole(role ResponseOutputMessageRole) {
	r.Role = role
	r.require(responseOutputMessageFieldRole)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseOutputMessage) SetStatus(status ResponseOutputMessageStatus) {
	r.Status = status
	r.require(responseOutputMessageFieldStatus)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseOutputMessage) SetType(type_ ResponseOutputMessageType) {
	r.Type = type_
	r.require(responseOutputMessageFieldType)
}

func (r *ResponseOutputMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseOutputMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseOutputMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseOutputMessage) MarshalJSON() ([]byte, error) {
	type embed ResponseOutputMessage
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseOutputMessage) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The role of the output message
type ResponseOutputMessageRole string

const (
	ResponseOutputMessageRoleAssistant ResponseOutputMessageRole = "assistant"
)

func NewResponseOutputMessageRoleFromString(s string) (ResponseOutputMessageRole, error) {
	switch s {
	case "assistant":
		return ResponseOutputMessageRoleAssistant, nil
	}
	var t ResponseOutputMessageRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseOutputMessageRole) Ptr() *ResponseOutputMessageRole {
	return &r
}

// The status of the message
type ResponseOutputMessageStatus string

const (
	ResponseOutputMessageStatusInProgress ResponseOutputMessageStatus = "in_progress"
	ResponseOutputMessageStatusCompleted  ResponseOutputMessageStatus = "completed"
	ResponseOutputMessageStatusIncomplete ResponseOutputMessageStatus = "incomplete"
)

func NewResponseOutputMessageStatusFromString(s string) (ResponseOutputMessageStatus, error) {
	switch s {
	case "in_progress":
		return ResponseOutputMessageStatusInProgress, nil
	case "completed":
		return ResponseOutputMessageStatusCompleted, nil
	case "incomplete":
		return ResponseOutputMessageStatusIncomplete, nil
	}
	var t ResponseOutputMessageStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseOutputMessageStatus) Ptr() *ResponseOutputMessageStatus {
	return &r
}

// The type of the output message
type ResponseOutputMessageType string

const (
	ResponseOutputMessageTypeMessage ResponseOutputMessageType = "message"
)

func NewResponseOutputMessageTypeFromString(s string) (ResponseOutputMessageType, error) {
	switch s {
	case "message":
		return ResponseOutputMessageTypeMessage, nil
	}
	var t ResponseOutputMessageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseOutputMessageType) Ptr() *ResponseOutputMessageType {
	return &r
}

var (
	responseOutputTextFieldAnnotations = big.NewInt(1 << 0)
	responseOutputTextFieldText        = big.NewInt(1 << 1)
	responseOutputTextFieldType        = big.NewInt(1 << 2)
)

type ResponseOutputText struct {
	// Annotations in the text output
	Annotations []map[string]interface{} `json:"annotations" url:"annotations"`
	// The text output from the model
	Text string `json:"text" url:"text"`
	// The type of the output text
	Type ResponseOutputTextType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseOutputText) GetAnnotations() []map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Annotations
}

func (r *ResponseOutputText) GetText() string {
	if r == nil {
		return ""
	}
	return r.Text
}

func (r *ResponseOutputText) GetType() ResponseOutputTextType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResponseOutputText) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseOutputText) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetAnnotations sets the Annotations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseOutputText) SetAnnotations(annotations []map[string]interface{}) {
	r.Annotations = annotations
	r.require(responseOutputTextFieldAnnotations)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseOutputText) SetText(text string) {
	r.Text = text
	r.require(responseOutputTextFieldText)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseOutputText) SetType(type_ ResponseOutputTextType) {
	r.Type = type_
	r.require(responseOutputTextFieldType)
}

func (r *ResponseOutputText) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseOutputText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseOutputText(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseOutputText) MarshalJSON() ([]byte, error) {
	type embed ResponseOutputText
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseOutputText) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The type of the output text
type ResponseOutputTextType string

const (
	ResponseOutputTextTypeOutputText ResponseOutputTextType = "output_text"
)

func NewResponseOutputTextTypeFromString(s string) (ResponseOutputTextType, error) {
	switch s {
	case "output_text":
		return ResponseOutputTextTypeOutputText, nil
	}
	var t ResponseOutputTextType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseOutputTextType) Ptr() *ResponseOutputTextType {
	return &r
}

var (
	responseTextDeltaEventFieldContentIndex = big.NewInt(1 << 0)
	responseTextDeltaEventFieldDelta        = big.NewInt(1 << 1)
	responseTextDeltaEventFieldItemId       = big.NewInt(1 << 2)
	responseTextDeltaEventFieldOutputIndex  = big.NewInt(1 << 3)
	responseTextDeltaEventFieldType         = big.NewInt(1 << 4)
)

type ResponseTextDeltaEvent struct {
	// Index of the content part
	ContentIndex float64 `json:"content_index" url:"content_index"`
	// Text delta being added
	Delta string `json:"delta" url:"delta"`
	// ID of the output item
	ItemId string `json:"item_id" url:"item_id"`
	// Index of the output item
	OutputIndex float64 `json:"output_index" url:"output_index"`
	// Event type
	Type ResponseTextDeltaEventType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseTextDeltaEvent) GetContentIndex() float64 {
	if r == nil {
		return 0
	}
	return r.ContentIndex
}

func (r *ResponseTextDeltaEvent) GetDelta() string {
	if r == nil {
		return ""
	}
	return r.Delta
}

func (r *ResponseTextDeltaEvent) GetItemId() string {
	if r == nil {
		return ""
	}
	return r.ItemId
}

func (r *ResponseTextDeltaEvent) GetOutputIndex() float64 {
	if r == nil {
		return 0
	}
	return r.OutputIndex
}

func (r *ResponseTextDeltaEvent) GetType() ResponseTextDeltaEventType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResponseTextDeltaEvent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseTextDeltaEvent) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetContentIndex sets the ContentIndex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseTextDeltaEvent) SetContentIndex(contentIndex float64) {
	r.ContentIndex = contentIndex
	r.require(responseTextDeltaEventFieldContentIndex)
}

// SetDelta sets the Delta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseTextDeltaEvent) SetDelta(delta string) {
	r.Delta = delta
	r.require(responseTextDeltaEventFieldDelta)
}

// SetItemId sets the ItemId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseTextDeltaEvent) SetItemId(itemId string) {
	r.ItemId = itemId
	r.require(responseTextDeltaEventFieldItemId)
}

// SetOutputIndex sets the OutputIndex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseTextDeltaEvent) SetOutputIndex(outputIndex float64) {
	r.OutputIndex = outputIndex
	r.require(responseTextDeltaEventFieldOutputIndex)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseTextDeltaEvent) SetType(type_ ResponseTextDeltaEventType) {
	r.Type = type_
	r.require(responseTextDeltaEventFieldType)
}

func (r *ResponseTextDeltaEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseTextDeltaEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseTextDeltaEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseTextDeltaEvent) MarshalJSON() ([]byte, error) {
	type embed ResponseTextDeltaEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseTextDeltaEvent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Event type
type ResponseTextDeltaEventType string

const (
	ResponseTextDeltaEventTypeResponseOutputTextDelta ResponseTextDeltaEventType = "response.output_text.delta"
)

func NewResponseTextDeltaEventTypeFromString(s string) (ResponseTextDeltaEventType, error) {
	switch s {
	case "response.output_text.delta":
		return ResponseTextDeltaEventTypeResponseOutputTextDelta, nil
	}
	var t ResponseTextDeltaEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseTextDeltaEventType) Ptr() *ResponseTextDeltaEventType {
	return &r
}

var (
	responseTextDoneEventFieldContentIndex = big.NewInt(1 << 0)
	responseTextDoneEventFieldItemId       = big.NewInt(1 << 1)
	responseTextDoneEventFieldOutputIndex  = big.NewInt(1 << 2)
	responseTextDoneEventFieldText         = big.NewInt(1 << 3)
	responseTextDoneEventFieldType         = big.NewInt(1 << 4)
)

type ResponseTextDoneEvent struct {
	// Index of the content part
	ContentIndex float64 `json:"content_index" url:"content_index"`
	// ID of the output item
	ItemId string `json:"item_id" url:"item_id"`
	// Index of the output item
	OutputIndex float64 `json:"output_index" url:"output_index"`
	// Complete text content
	Text string `json:"text" url:"text"`
	// Event type
	Type ResponseTextDoneEventType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseTextDoneEvent) GetContentIndex() float64 {
	if r == nil {
		return 0
	}
	return r.ContentIndex
}

func (r *ResponseTextDoneEvent) GetItemId() string {
	if r == nil {
		return ""
	}
	return r.ItemId
}

func (r *ResponseTextDoneEvent) GetOutputIndex() float64 {
	if r == nil {
		return 0
	}
	return r.OutputIndex
}

func (r *ResponseTextDoneEvent) GetText() string {
	if r == nil {
		return ""
	}
	return r.Text
}

func (r *ResponseTextDoneEvent) GetType() ResponseTextDoneEventType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResponseTextDoneEvent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseTextDoneEvent) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetContentIndex sets the ContentIndex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseTextDoneEvent) SetContentIndex(contentIndex float64) {
	r.ContentIndex = contentIndex
	r.require(responseTextDoneEventFieldContentIndex)
}

// SetItemId sets the ItemId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseTextDoneEvent) SetItemId(itemId string) {
	r.ItemId = itemId
	r.require(responseTextDoneEventFieldItemId)
}

// SetOutputIndex sets the OutputIndex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseTextDoneEvent) SetOutputIndex(outputIndex float64) {
	r.OutputIndex = outputIndex
	r.require(responseTextDoneEventFieldOutputIndex)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseTextDoneEvent) SetText(text string) {
	r.Text = text
	r.require(responseTextDoneEventFieldText)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseTextDoneEvent) SetType(type_ ResponseTextDoneEventType) {
	r.Type = type_
	r.require(responseTextDoneEventFieldType)
}

func (r *ResponseTextDoneEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseTextDoneEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseTextDoneEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseTextDoneEvent) MarshalJSON() ([]byte, error) {
	type embed ResponseTextDoneEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseTextDoneEvent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Event type
type ResponseTextDoneEventType string

const (
	ResponseTextDoneEventTypeResponseOutputTextDone ResponseTextDoneEventType = "response.output_text.done"
)

func NewResponseTextDoneEventTypeFromString(s string) (ResponseTextDoneEventType, error) {
	switch s {
	case "response.output_text.done":
		return ResponseTextDoneEventTypeResponseOutputTextDone, nil
	}
	var t ResponseTextDoneEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseTextDoneEventType) Ptr() *ResponseTextDoneEventType {
	return &r
}

var (
	twilioSmsChatTransportFieldPhoneNumberId                     = big.NewInt(1 << 0)
	twilioSmsChatTransportFieldCustomer                          = big.NewInt(1 << 1)
	twilioSmsChatTransportFieldUseLlmGeneratedMessageForOutbound = big.NewInt(1 << 2)
	twilioSmsChatTransportFieldType                              = big.NewInt(1 << 3)
)

type TwilioSmsChatTransport struct {
	// This is the phone number that will be used to send the SMS.
	// If provided, will create a new session. If not provided, uses existing session's phoneNumberId.
	// The phone number must have SMS enabled and belong to your organization.
	PhoneNumberId *string `json:"phoneNumberId,omitempty" url:"phoneNumberId,omitempty"`
	// This is the customer who will receive the SMS.
	// If provided, will create a new session. If not provided, uses existing session's customer.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// Whether to use LLM-generated messages for outbound SMS.
	// When true (default), input is processed by the assistant for a response.
	// When false, the input text is forwarded directly as the SMS message without LLM processing.
	// Useful for sending pre-defined messages or notifications.
	UseLlmGeneratedMessageForOutbound *bool `json:"useLLMGeneratedMessageForOutbound,omitempty" url:"useLLMGeneratedMessageForOutbound,omitempty"`
	// The type of transport to use for sending the chat response.
	// Currently supports 'twilio.sms' for SMS delivery via Twilio.
	Type TwilioSmsChatTransportType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TwilioSmsChatTransport) GetPhoneNumberId() *string {
	if t == nil {
		return nil
	}
	return t.PhoneNumberId
}

func (t *TwilioSmsChatTransport) GetCustomer() *CreateCustomerDto {
	if t == nil {
		return nil
	}
	return t.Customer
}

func (t *TwilioSmsChatTransport) GetUseLlmGeneratedMessageForOutbound() *bool {
	if t == nil {
		return nil
	}
	return t.UseLlmGeneratedMessageForOutbound
}

func (t *TwilioSmsChatTransport) GetType() TwilioSmsChatTransportType {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TwilioSmsChatTransport) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TwilioSmsChatTransport) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetPhoneNumberId sets the PhoneNumberId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TwilioSmsChatTransport) SetPhoneNumberId(phoneNumberId *string) {
	t.PhoneNumberId = phoneNumberId
	t.require(twilioSmsChatTransportFieldPhoneNumberId)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TwilioSmsChatTransport) SetCustomer(customer *CreateCustomerDto) {
	t.Customer = customer
	t.require(twilioSmsChatTransportFieldCustomer)
}

// SetUseLlmGeneratedMessageForOutbound sets the UseLlmGeneratedMessageForOutbound field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TwilioSmsChatTransport) SetUseLlmGeneratedMessageForOutbound(useLlmGeneratedMessageForOutbound *bool) {
	t.UseLlmGeneratedMessageForOutbound = useLlmGeneratedMessageForOutbound
	t.require(twilioSmsChatTransportFieldUseLlmGeneratedMessageForOutbound)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TwilioSmsChatTransport) SetType(type_ TwilioSmsChatTransportType) {
	t.Type = type_
	t.require(twilioSmsChatTransportFieldType)
}

func (t *TwilioSmsChatTransport) UnmarshalJSON(data []byte) error {
	type unmarshaler TwilioSmsChatTransport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TwilioSmsChatTransport(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TwilioSmsChatTransport) MarshalJSON() ([]byte, error) {
	type embed TwilioSmsChatTransport
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TwilioSmsChatTransport) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The type of transport to use for sending the chat response.
// Currently supports 'twilio.sms' for SMS delivery via Twilio.
type TwilioSmsChatTransportType string

const (
	TwilioSmsChatTransportTypeTwilioSms TwilioSmsChatTransportType = "twilio.sms"
)

func NewTwilioSmsChatTransportTypeFromString(s string) (TwilioSmsChatTransportType, error) {
	switch s {
	case "twilio.sms":
		return TwilioSmsChatTransportTypeTwilioSms, nil
	}
	var t TwilioSmsChatTransportType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TwilioSmsChatTransportType) Ptr() *TwilioSmsChatTransportType {
	return &t
}

// This is the input text for the chat.
// Can be a string or an array of chat messages.
// This field is REQUIRED for chat creation.
type CreateChatDtoInput struct {
	String                        string
	CreateChatDtoInputOneItemList []*CreateChatDtoInputOneItem

	typ string
}

func (c *CreateChatDtoInput) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreateChatDtoInput) GetCreateChatDtoInputOneItemList() []*CreateChatDtoInputOneItem {
	if c == nil {
		return nil
	}
	return c.CreateChatDtoInputOneItemList
}

func (c *CreateChatDtoInput) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	var valueCreateChatDtoInputOneItemList []*CreateChatDtoInputOneItem
	if err := json.Unmarshal(data, &valueCreateChatDtoInputOneItemList); err == nil {
		c.typ = "CreateChatDtoInputOneItemList"
		c.CreateChatDtoInputOneItemList = valueCreateChatDtoInputOneItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateChatDtoInput) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "CreateChatDtoInputOneItemList" || c.CreateChatDtoInputOneItemList != nil {
		return json.Marshal(c.CreateChatDtoInputOneItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateChatDtoInputVisitor interface {
	VisitString(string) error
	VisitCreateChatDtoInputOneItemList([]*CreateChatDtoInputOneItem) error
}

func (c *CreateChatDtoInput) Accept(visitor CreateChatDtoInputVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "CreateChatDtoInputOneItemList" || c.CreateChatDtoInputOneItemList != nil {
		return visitor.VisitCreateChatDtoInputOneItemList(c.CreateChatDtoInputOneItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateChatDtoInputOneItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (c *CreateChatDtoInputOneItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *CreateChatDtoInputOneItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *CreateChatDtoInputOneItem) GetAssistantMessage() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.AssistantMessage
}

func (c *CreateChatDtoInputOneItem) GetToolMessage() *ToolMessage {
	if c == nil {
		return nil
	}
	return c.ToolMessage
}

func (c *CreateChatDtoInputOneItem) GetDeveloperMessage() *DeveloperMessage {
	if c == nil {
		return nil
	}
	return c.DeveloperMessage
}

func (c *CreateChatDtoInputOneItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		c.typ = "AssistantMessage"
		c.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		c.typ = "ToolMessage"
		c.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		c.typ = "DeveloperMessage"
		c.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateChatDtoInputOneItem) MarshalJSON() ([]byte, error) {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return json.Marshal(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return json.Marshal(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return json.Marshal(c.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateChatDtoInputOneItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (c *CreateChatDtoInputOneItem) Accept(visitor CreateChatDtoInputOneItemVisitor) error {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return visitor.VisitToolMessage(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(c.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateChatsResponse struct {
	Chat                     *Chat
	CreateChatStreamResponse *CreateChatStreamResponse

	typ string
}

func (c *CreateChatsResponse) GetChat() *Chat {
	if c == nil {
		return nil
	}
	return c.Chat
}

func (c *CreateChatsResponse) GetCreateChatStreamResponse() *CreateChatStreamResponse {
	if c == nil {
		return nil
	}
	return c.CreateChatStreamResponse
}

func (c *CreateChatsResponse) UnmarshalJSON(data []byte) error {
	valueChat := new(Chat)
	if err := json.Unmarshal(data, &valueChat); err == nil {
		c.typ = "Chat"
		c.Chat = valueChat
		return nil
	}
	valueCreateChatStreamResponse := new(CreateChatStreamResponse)
	if err := json.Unmarshal(data, &valueCreateChatStreamResponse); err == nil {
		c.typ = "CreateChatStreamResponse"
		c.CreateChatStreamResponse = valueCreateChatStreamResponse
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateChatsResponse) MarshalJSON() ([]byte, error) {
	if c.typ == "Chat" || c.Chat != nil {
		return json.Marshal(c.Chat)
	}
	if c.typ == "CreateChatStreamResponse" || c.CreateChatStreamResponse != nil {
		return json.Marshal(c.CreateChatStreamResponse)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateChatsResponseVisitor interface {
	VisitChat(*Chat) error
	VisitCreateChatStreamResponse(*CreateChatStreamResponse) error
}

func (c *CreateChatsResponse) Accept(visitor CreateChatsResponseVisitor) error {
	if c.typ == "Chat" || c.Chat != nil {
		return visitor.VisitChat(c.Chat)
	}
	if c.typ == "CreateChatStreamResponse" || c.CreateChatStreamResponse != nil {
		return visitor.VisitCreateChatStreamResponse(c.CreateChatStreamResponse)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateResponseChatsResponse struct {
	ResponseObject         *ResponseObject
	ResponseTextDeltaEvent *ResponseTextDeltaEvent
	ResponseTextDoneEvent  *ResponseTextDoneEvent
	ResponseCompletedEvent *ResponseCompletedEvent
	ResponseErrorEvent     *ResponseErrorEvent

	typ string
}

func (c *CreateResponseChatsResponse) GetResponseObject() *ResponseObject {
	if c == nil {
		return nil
	}
	return c.ResponseObject
}

func (c *CreateResponseChatsResponse) GetResponseTextDeltaEvent() *ResponseTextDeltaEvent {
	if c == nil {
		return nil
	}
	return c.ResponseTextDeltaEvent
}

func (c *CreateResponseChatsResponse) GetResponseTextDoneEvent() *ResponseTextDoneEvent {
	if c == nil {
		return nil
	}
	return c.ResponseTextDoneEvent
}

func (c *CreateResponseChatsResponse) GetResponseCompletedEvent() *ResponseCompletedEvent {
	if c == nil {
		return nil
	}
	return c.ResponseCompletedEvent
}

func (c *CreateResponseChatsResponse) GetResponseErrorEvent() *ResponseErrorEvent {
	if c == nil {
		return nil
	}
	return c.ResponseErrorEvent
}

func (c *CreateResponseChatsResponse) UnmarshalJSON(data []byte) error {
	valueResponseObject := new(ResponseObject)
	if err := json.Unmarshal(data, &valueResponseObject); err == nil {
		c.typ = "ResponseObject"
		c.ResponseObject = valueResponseObject
		return nil
	}
	valueResponseTextDeltaEvent := new(ResponseTextDeltaEvent)
	if err := json.Unmarshal(data, &valueResponseTextDeltaEvent); err == nil {
		c.typ = "ResponseTextDeltaEvent"
		c.ResponseTextDeltaEvent = valueResponseTextDeltaEvent
		return nil
	}
	valueResponseTextDoneEvent := new(ResponseTextDoneEvent)
	if err := json.Unmarshal(data, &valueResponseTextDoneEvent); err == nil {
		c.typ = "ResponseTextDoneEvent"
		c.ResponseTextDoneEvent = valueResponseTextDoneEvent
		return nil
	}
	valueResponseCompletedEvent := new(ResponseCompletedEvent)
	if err := json.Unmarshal(data, &valueResponseCompletedEvent); err == nil {
		c.typ = "ResponseCompletedEvent"
		c.ResponseCompletedEvent = valueResponseCompletedEvent
		return nil
	}
	valueResponseErrorEvent := new(ResponseErrorEvent)
	if err := json.Unmarshal(data, &valueResponseErrorEvent); err == nil {
		c.typ = "ResponseErrorEvent"
		c.ResponseErrorEvent = valueResponseErrorEvent
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateResponseChatsResponse) MarshalJSON() ([]byte, error) {
	if c.typ == "ResponseObject" || c.ResponseObject != nil {
		return json.Marshal(c.ResponseObject)
	}
	if c.typ == "ResponseTextDeltaEvent" || c.ResponseTextDeltaEvent != nil {
		return json.Marshal(c.ResponseTextDeltaEvent)
	}
	if c.typ == "ResponseTextDoneEvent" || c.ResponseTextDoneEvent != nil {
		return json.Marshal(c.ResponseTextDoneEvent)
	}
	if c.typ == "ResponseCompletedEvent" || c.ResponseCompletedEvent != nil {
		return json.Marshal(c.ResponseCompletedEvent)
	}
	if c.typ == "ResponseErrorEvent" || c.ResponseErrorEvent != nil {
		return json.Marshal(c.ResponseErrorEvent)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateResponseChatsResponseVisitor interface {
	VisitResponseObject(*ResponseObject) error
	VisitResponseTextDeltaEvent(*ResponseTextDeltaEvent) error
	VisitResponseTextDoneEvent(*ResponseTextDoneEvent) error
	VisitResponseCompletedEvent(*ResponseCompletedEvent) error
	VisitResponseErrorEvent(*ResponseErrorEvent) error
}

func (c *CreateResponseChatsResponse) Accept(visitor CreateResponseChatsResponseVisitor) error {
	if c.typ == "ResponseObject" || c.ResponseObject != nil {
		return visitor.VisitResponseObject(c.ResponseObject)
	}
	if c.typ == "ResponseTextDeltaEvent" || c.ResponseTextDeltaEvent != nil {
		return visitor.VisitResponseTextDeltaEvent(c.ResponseTextDeltaEvent)
	}
	if c.typ == "ResponseTextDoneEvent" || c.ResponseTextDoneEvent != nil {
		return visitor.VisitResponseTextDoneEvent(c.ResponseTextDoneEvent)
	}
	if c.typ == "ResponseCompletedEvent" || c.ResponseCompletedEvent != nil {
		return visitor.VisitResponseCompletedEvent(c.ResponseCompletedEvent)
	}
	if c.typ == "ResponseErrorEvent" || c.ResponseErrorEvent != nil {
		return visitor.VisitResponseErrorEvent(c.ResponseErrorEvent)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ListChatsRequestSortOrder string

const (
	ListChatsRequestSortOrderAsc  ListChatsRequestSortOrder = "ASC"
	ListChatsRequestSortOrderDesc ListChatsRequestSortOrder = "DESC"
)

func NewListChatsRequestSortOrderFromString(s string) (ListChatsRequestSortOrder, error) {
	switch s {
	case "ASC":
		return ListChatsRequestSortOrderAsc, nil
	case "DESC":
		return ListChatsRequestSortOrderDesc, nil
	}
	var t ListChatsRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListChatsRequestSortOrder) Ptr() *ListChatsRequestSortOrder {
	return &l
}

// This is the input text for the chat.
// Can be a string or an array of chat messages.
// This field is REQUIRED for chat creation.
type OpenAiResponsesRequestInput struct {
	String                                 string
	OpenAiResponsesRequestInputOneItemList []*OpenAiResponsesRequestInputOneItem

	typ string
}

func (o *OpenAiResponsesRequestInput) GetString() string {
	if o == nil {
		return ""
	}
	return o.String
}

func (o *OpenAiResponsesRequestInput) GetOpenAiResponsesRequestInputOneItemList() []*OpenAiResponsesRequestInputOneItem {
	if o == nil {
		return nil
	}
	return o.OpenAiResponsesRequestInputOneItemList
}

func (o *OpenAiResponsesRequestInput) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typ = "String"
		o.String = valueString
		return nil
	}
	var valueOpenAiResponsesRequestInputOneItemList []*OpenAiResponsesRequestInputOneItem
	if err := json.Unmarshal(data, &valueOpenAiResponsesRequestInputOneItemList); err == nil {
		o.typ = "OpenAiResponsesRequestInputOneItemList"
		o.OpenAiResponsesRequestInputOneItemList = valueOpenAiResponsesRequestInputOneItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenAiResponsesRequestInput) MarshalJSON() ([]byte, error) {
	if o.typ == "String" || o.String != "" {
		return json.Marshal(o.String)
	}
	if o.typ == "OpenAiResponsesRequestInputOneItemList" || o.OpenAiResponsesRequestInputOneItemList != nil {
		return json.Marshal(o.OpenAiResponsesRequestInputOneItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiResponsesRequestInputVisitor interface {
	VisitString(string) error
	VisitOpenAiResponsesRequestInputOneItemList([]*OpenAiResponsesRequestInputOneItem) error
}

func (o *OpenAiResponsesRequestInput) Accept(visitor OpenAiResponsesRequestInputVisitor) error {
	if o.typ == "String" || o.String != "" {
		return visitor.VisitString(o.String)
	}
	if o.typ == "OpenAiResponsesRequestInputOneItemList" || o.OpenAiResponsesRequestInputOneItemList != nil {
		return visitor.VisitOpenAiResponsesRequestInputOneItemList(o.OpenAiResponsesRequestInputOneItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiResponsesRequestInputOneItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (o *OpenAiResponsesRequestInputOneItem) GetSystemMessage() *SystemMessage {
	if o == nil {
		return nil
	}
	return o.SystemMessage
}

func (o *OpenAiResponsesRequestInputOneItem) GetUserMessage() *UserMessage {
	if o == nil {
		return nil
	}
	return o.UserMessage
}

func (o *OpenAiResponsesRequestInputOneItem) GetAssistantMessage() *AssistantMessage {
	if o == nil {
		return nil
	}
	return o.AssistantMessage
}

func (o *OpenAiResponsesRequestInputOneItem) GetToolMessage() *ToolMessage {
	if o == nil {
		return nil
	}
	return o.ToolMessage
}

func (o *OpenAiResponsesRequestInputOneItem) GetDeveloperMessage() *DeveloperMessage {
	if o == nil {
		return nil
	}
	return o.DeveloperMessage
}

func (o *OpenAiResponsesRequestInputOneItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		o.typ = "SystemMessage"
		o.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		o.typ = "UserMessage"
		o.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		o.typ = "AssistantMessage"
		o.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		o.typ = "ToolMessage"
		o.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		o.typ = "DeveloperMessage"
		o.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenAiResponsesRequestInputOneItem) MarshalJSON() ([]byte, error) {
	if o.typ == "SystemMessage" || o.SystemMessage != nil {
		return json.Marshal(o.SystemMessage)
	}
	if o.typ == "UserMessage" || o.UserMessage != nil {
		return json.Marshal(o.UserMessage)
	}
	if o.typ == "AssistantMessage" || o.AssistantMessage != nil {
		return json.Marshal(o.AssistantMessage)
	}
	if o.typ == "ToolMessage" || o.ToolMessage != nil {
		return json.Marshal(o.ToolMessage)
	}
	if o.typ == "DeveloperMessage" || o.DeveloperMessage != nil {
		return json.Marshal(o.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiResponsesRequestInputOneItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (o *OpenAiResponsesRequestInputOneItem) Accept(visitor OpenAiResponsesRequestInputOneItemVisitor) error {
	if o.typ == "SystemMessage" || o.SystemMessage != nil {
		return visitor.VisitSystemMessage(o.SystemMessage)
	}
	if o.typ == "UserMessage" || o.UserMessage != nil {
		return visitor.VisitUserMessage(o.UserMessage)
	}
	if o.typ == "AssistantMessage" || o.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(o.AssistantMessage)
	}
	if o.typ == "ToolMessage" || o.ToolMessage != nil {
		return visitor.VisitToolMessage(o.ToolMessage)
	}
	if o.typ == "DeveloperMessage" || o.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(o.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}
