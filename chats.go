// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/VapiAI/server-sdk-go/internal"
	time "time"
)

type CreateChatDto struct {
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"-"`
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"-"`
	// This is the name of the chat. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"-"`
	// This is the ID of the session that will be used for the chat.
	// Mutually exclusive with previousChatId.
	SessionId *string `json:"sessionId,omitempty" url:"-"`
	// This is the input text for the chat.
	// Can be a string or an array of chat messages.
	// This field is REQUIRED for chat creation.
	Input *CreateChatDtoInput `json:"input,omitempty" url:"-"`
	// This is a flag that determines whether the response should be streamed.
	// When true, the response will be sent as chunks of text.
	Stream *bool `json:"stream,omitempty" url:"-"`
	// This is the ID of the chat that will be used as context for the new chat.
	// The messages from the previous chat will be used as context.
	// Mutually exclusive with sessionId.
	PreviousChatId *string `json:"previousChatId,omitempty" url:"-"`
}

type OpenAiResponsesRequest struct {
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"-"`
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"-"`
	// This is the name of the chat. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"-"`
	// This is the ID of the session that will be used for the chat.
	// Mutually exclusive with previousChatId.
	SessionId *string `json:"sessionId,omitempty" url:"-"`
	// This is the input text for the chat.
	// Can be a string or an array of chat messages.
	// This field is REQUIRED for chat creation.
	Input *OpenAiResponsesRequestInput `json:"input,omitempty" url:"-"`
	// Whether to stream the response or not.
	Stream *bool `json:"stream,omitempty" url:"-"`
	// This is the ID of the chat that will be used as context for the new chat.
	// The messages from the previous chat will be used as context.
	// Mutually exclusive with sessionId.
	PreviousChatId *string `json:"previousChatId,omitempty" url:"-"`
}

type ChatsListRequest struct {
	// This is the unique identifier for the assistant that will be used for the chat.
	AssistantId *string `json:"-" url:"assistantId,omitempty"`
	// This is the unique identifier for the workflow that will be used for the chat.
	WorkflowId *string `json:"-" url:"workflowId,omitempty"`
	// This is the unique identifier for the session that will be used for the chat.
	SessionId *string `json:"-" url:"sessionId,omitempty"`
	// This is the page number to return. Defaults to 1.
	Page *float64 `json:"-" url:"page,omitempty"`
	// This is the sort order for pagination. Defaults to 'DESC'.
	SortOrder *ChatsListRequestSortOrder `json:"-" url:"sortOrder,omitempty"`
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`
}

type Chat struct {
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the name of the chat. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the ID of the session that will be used for the chat.
	// Mutually exclusive with previousChatId.
	SessionId *string `json:"sessionId,omitempty" url:"sessionId,omitempty"`
	// This is the input text for the chat.
	// Can be a string or an array of chat messages.
	Input *ChatInput `json:"input,omitempty" url:"input,omitempty"`
	// This is a flag that determines whether the response should be streamed.
	// When true, the response will be sent as chunks of text.
	Stream *bool `json:"stream,omitempty" url:"stream,omitempty"`
	// This is the ID of the chat that will be used as context for the new chat.
	// The messages from the previous chat will be used as context.
	// Mutually exclusive with sessionId.
	PreviousChatId *string `json:"previousChatId,omitempty" url:"previousChatId,omitempty"`
	// This is the unique identifier for the chat.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this chat belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is an array of messages used as context for the chat.
	// Used to provide message history for multi-turn conversations.
	Messages []*ChatMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the output messages generated by the system in response to the input.
	Output []*ChatOutputItem `json:"output,omitempty" url:"output,omitempty"`
	// This is the ISO 8601 date-time string of when the chat was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the chat was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// These are the costs of individual components of the chat in USD.
	Costs []*ChatCostsItem `json:"costs,omitempty" url:"costs,omitempty"`
	// This is the cost of the chat in USD.
	Cost *float64 `json:"cost,omitempty" url:"cost,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Chat) GetAssistantId() *string {
	if c == nil {
		return nil
	}
	return c.AssistantId
}

func (c *Chat) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *Chat) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *Chat) GetSessionId() *string {
	if c == nil {
		return nil
	}
	return c.SessionId
}

func (c *Chat) GetInput() *ChatInput {
	if c == nil {
		return nil
	}
	return c.Input
}

func (c *Chat) GetStream() *bool {
	if c == nil {
		return nil
	}
	return c.Stream
}

func (c *Chat) GetPreviousChatId() *string {
	if c == nil {
		return nil
	}
	return c.PreviousChatId
}

func (c *Chat) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *Chat) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *Chat) GetMessages() []*ChatMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *Chat) GetOutput() []*ChatOutputItem {
	if c == nil {
		return nil
	}
	return c.Output
}

func (c *Chat) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *Chat) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *Chat) GetCosts() []*ChatCostsItem {
	if c == nil {
		return nil
	}
	return c.Costs
}

func (c *Chat) GetCost() *float64 {
	if c == nil {
		return nil
	}
	return c.Cost
}

func (c *Chat) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Chat) UnmarshalJSON(data []byte) error {
	type embed Chat
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Chat(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Chat) MarshalJSON() ([]byte, error) {
	type embed Chat
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Chat) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatCost struct {
	// This is the type of cost, always 'chat' for this class.
	// This is the cost of the component in USD.
	Cost  float64 `json:"cost" url:"cost"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatCost) GetCost() float64 {
	if c == nil {
		return 0
	}
	return c.Cost
}

func (c *ChatCost) Type() string {
	return c.type_
}

func (c *ChatCost) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatCost) UnmarshalJSON(data []byte) error {
	type embed ChatCost
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ChatCost(unmarshaler.embed)
	if unmarshaler.Type != "chat" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "chat", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCost) MarshalJSON() ([]byte, error) {
	type embed ChatCost
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "chat",
	}
	return json.Marshal(marshaler)
}

func (c *ChatCost) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatCostsItem struct {
	ModelCost *ModelCost
	ChatCost  *ChatCost

	typ string
}

func (c *ChatCostsItem) GetModelCost() *ModelCost {
	if c == nil {
		return nil
	}
	return c.ModelCost
}

func (c *ChatCostsItem) GetChatCost() *ChatCost {
	if c == nil {
		return nil
	}
	return c.ChatCost
}

func (c *ChatCostsItem) UnmarshalJSON(data []byte) error {
	valueModelCost := new(ModelCost)
	if err := json.Unmarshal(data, &valueModelCost); err == nil {
		c.typ = "ModelCost"
		c.ModelCost = valueModelCost
		return nil
	}
	valueChatCost := new(ChatCost)
	if err := json.Unmarshal(data, &valueChatCost); err == nil {
		c.typ = "ChatCost"
		c.ChatCost = valueChatCost
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatCostsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ModelCost" || c.ModelCost != nil {
		return json.Marshal(c.ModelCost)
	}
	if c.typ == "ChatCost" || c.ChatCost != nil {
		return json.Marshal(c.ChatCost)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatCostsItemVisitor interface {
	VisitModelCost(*ModelCost) error
	VisitChatCost(*ChatCost) error
}

func (c *ChatCostsItem) Accept(visitor ChatCostsItemVisitor) error {
	if c.typ == "ModelCost" || c.ModelCost != nil {
		return visitor.VisitModelCost(c.ModelCost)
	}
	if c.typ == "ChatCost" || c.ChatCost != nil {
		return visitor.VisitChatCost(c.ChatCost)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the input text for the chat.
// Can be a string or an array of chat messages.
type ChatInput struct {
	String            string
	ChatInputItemList []*ChatInputItem

	typ string
}

func (c *ChatInput) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *ChatInput) GetChatInputItemList() []*ChatInputItem {
	if c == nil {
		return nil
	}
	return c.ChatInputItemList
}

func (c *ChatInput) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	var valueChatInputItemList []*ChatInputItem
	if err := json.Unmarshal(data, &valueChatInputItemList); err == nil {
		c.typ = "ChatInputItemList"
		c.ChatInputItemList = valueChatInputItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatInput) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "ChatInputItemList" || c.ChatInputItemList != nil {
		return json.Marshal(c.ChatInputItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatInputVisitor interface {
	VisitString(string) error
	VisitChatInputItemList([]*ChatInputItem) error
}

func (c *ChatInput) Accept(visitor ChatInputVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "ChatInputItemList" || c.ChatInputItemList != nil {
		return visitor.VisitChatInputItemList(c.ChatInputItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatInputItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (c *ChatInputItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *ChatInputItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *ChatInputItem) GetAssistantMessage() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.AssistantMessage
}

func (c *ChatInputItem) GetToolMessage() *ToolMessage {
	if c == nil {
		return nil
	}
	return c.ToolMessage
}

func (c *ChatInputItem) GetDeveloperMessage() *DeveloperMessage {
	if c == nil {
		return nil
	}
	return c.DeveloperMessage
}

func (c *ChatInputItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		c.typ = "AssistantMessage"
		c.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		c.typ = "ToolMessage"
		c.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		c.typ = "DeveloperMessage"
		c.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatInputItem) MarshalJSON() ([]byte, error) {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return json.Marshal(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return json.Marshal(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return json.Marshal(c.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatInputItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (c *ChatInputItem) Accept(visitor ChatInputItemVisitor) error {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return visitor.VisitToolMessage(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(c.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatMessagesItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (c *ChatMessagesItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *ChatMessagesItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *ChatMessagesItem) GetAssistantMessage() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.AssistantMessage
}

func (c *ChatMessagesItem) GetToolMessage() *ToolMessage {
	if c == nil {
		return nil
	}
	return c.ToolMessage
}

func (c *ChatMessagesItem) GetDeveloperMessage() *DeveloperMessage {
	if c == nil {
		return nil
	}
	return c.DeveloperMessage
}

func (c *ChatMessagesItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		c.typ = "AssistantMessage"
		c.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		c.typ = "ToolMessage"
		c.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		c.typ = "DeveloperMessage"
		c.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return json.Marshal(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return json.Marshal(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return json.Marshal(c.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatMessagesItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (c *ChatMessagesItem) Accept(visitor ChatMessagesItemVisitor) error {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return visitor.VisitToolMessage(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(c.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatOutputItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (c *ChatOutputItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *ChatOutputItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *ChatOutputItem) GetAssistantMessage() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.AssistantMessage
}

func (c *ChatOutputItem) GetToolMessage() *ToolMessage {
	if c == nil {
		return nil
	}
	return c.ToolMessage
}

func (c *ChatOutputItem) GetDeveloperMessage() *DeveloperMessage {
	if c == nil {
		return nil
	}
	return c.DeveloperMessage
}

func (c *ChatOutputItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		c.typ = "AssistantMessage"
		c.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		c.typ = "ToolMessage"
		c.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		c.typ = "DeveloperMessage"
		c.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatOutputItem) MarshalJSON() ([]byte, error) {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return json.Marshal(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return json.Marshal(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return json.Marshal(c.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatOutputItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (c *ChatOutputItem) Accept(visitor ChatOutputItemVisitor) error {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return visitor.VisitToolMessage(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(c.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatPaginatedResponse struct {
	Results  []*Chat         `json:"results,omitempty" url:"results,omitempty"`
	Metadata *PaginationMeta `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatPaginatedResponse) GetResults() []*Chat {
	if c == nil {
		return nil
	}
	return c.Results
}

func (c *ChatPaginatedResponse) GetMetadata() *PaginationMeta {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ChatPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatPaginatedResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateChatStreamResponse struct {
	// This is the unique identifier for the streaming response.
	Id string `json:"id" url:"id"`
	// This is the path to the content being updated.
	// Format: `chat.output[{contentIndex}].content` where contentIndex identifies the specific content item.
	Path string `json:"path" url:"path"`
	// This is the incremental content chunk being streamed.
	Delta string `json:"delta" url:"delta"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateChatStreamResponse) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CreateChatStreamResponse) GetPath() string {
	if c == nil {
		return ""
	}
	return c.Path
}

func (c *CreateChatStreamResponse) GetDelta() string {
	if c == nil {
		return ""
	}
	return c.Delta
}

func (c *CreateChatStreamResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateChatStreamResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateChatStreamResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateChatStreamResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateChatStreamResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ResponseCompletedEvent struct {
	// The completed response
	Response *ResponseObject `json:"response,omitempty" url:"response,omitempty"`
	// Event type
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseCompletedEvent) GetResponse() *ResponseObject {
	if r == nil {
		return nil
	}
	return r.Response
}

func (r *ResponseCompletedEvent) Type() string {
	return r.type_
}

func (r *ResponseCompletedEvent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseCompletedEvent) UnmarshalJSON(data []byte) error {
	type embed ResponseCompletedEvent
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ResponseCompletedEvent(unmarshaler.embed)
	if unmarshaler.Type != "response.completed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "response.completed", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseCompletedEvent) MarshalJSON() ([]byte, error) {
	type embed ResponseCompletedEvent
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "response.completed",
	}
	return json.Marshal(marshaler)
}

func (r *ResponseCompletedEvent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseErrorEvent struct {
	// Event type
	// Error code
	Code string `json:"code" url:"code"`
	// Error message
	Message string `json:"message" url:"message"`
	// Parameter that caused the error
	Param *string `json:"param,omitempty" url:"param,omitempty"`
	// Sequence number of the event
	SequenceNumber float64 `json:"sequence_number" url:"sequence_number"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseErrorEvent) GetCode() string {
	if r == nil {
		return ""
	}
	return r.Code
}

func (r *ResponseErrorEvent) GetMessage() string {
	if r == nil {
		return ""
	}
	return r.Message
}

func (r *ResponseErrorEvent) GetParam() *string {
	if r == nil {
		return nil
	}
	return r.Param
}

func (r *ResponseErrorEvent) GetSequenceNumber() float64 {
	if r == nil {
		return 0
	}
	return r.SequenceNumber
}

func (r *ResponseErrorEvent) Type() string {
	return r.type_
}

func (r *ResponseErrorEvent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseErrorEvent) UnmarshalJSON(data []byte) error {
	type embed ResponseErrorEvent
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ResponseErrorEvent(unmarshaler.embed)
	if unmarshaler.Type != "error" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "error", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseErrorEvent) MarshalJSON() ([]byte, error) {
	type embed ResponseErrorEvent
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "error",
	}
	return json.Marshal(marshaler)
}

func (r *ResponseErrorEvent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseObject struct {
	// Unique identifier for this Response
	Id string `json:"id" url:"id"`
	// The object type
	// Unix timestamp (in seconds) of when this Response was created
	CreatedAt float64 `json:"created_at" url:"created_at"`
	// Status of the response
	Status ResponseObjectStatus `json:"status" url:"status"`
	// Error message if the response failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Output messages from the model
	Output []*ResponseOutputMessage `json:"output,omitempty" url:"output,omitempty"`
	object string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseObject) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *ResponseObject) GetCreatedAt() float64 {
	if r == nil {
		return 0
	}
	return r.CreatedAt
}

func (r *ResponseObject) GetStatus() ResponseObjectStatus {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *ResponseObject) GetError() *string {
	if r == nil {
		return nil
	}
	return r.Error
}

func (r *ResponseObject) GetOutput() []*ResponseOutputMessage {
	if r == nil {
		return nil
	}
	return r.Output
}

func (r *ResponseObject) Object() string {
	return r.object
}

func (r *ResponseObject) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseObject) UnmarshalJSON(data []byte) error {
	type embed ResponseObject
	var unmarshaler = struct {
		embed
		Object string `json:"object"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ResponseObject(unmarshaler.embed)
	if unmarshaler.Object != "response" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "response", unmarshaler.Object)
	}
	r.object = unmarshaler.Object
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "object")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseObject) MarshalJSON() ([]byte, error) {
	type embed ResponseObject
	var marshaler = struct {
		embed
		Object string `json:"object"`
	}{
		embed:  embed(*r),
		Object: "response",
	}
	return json.Marshal(marshaler)
}

func (r *ResponseObject) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Status of the response
type ResponseObjectStatus string

const (
	ResponseObjectStatusCompleted  ResponseObjectStatus = "completed"
	ResponseObjectStatusFailed     ResponseObjectStatus = "failed"
	ResponseObjectStatusInProgress ResponseObjectStatus = "in_progress"
	ResponseObjectStatusIncomplete ResponseObjectStatus = "incomplete"
)

func NewResponseObjectStatusFromString(s string) (ResponseObjectStatus, error) {
	switch s {
	case "completed":
		return ResponseObjectStatusCompleted, nil
	case "failed":
		return ResponseObjectStatusFailed, nil
	case "in_progress":
		return ResponseObjectStatusInProgress, nil
	case "incomplete":
		return ResponseObjectStatusIncomplete, nil
	}
	var t ResponseObjectStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseObjectStatus) Ptr() *ResponseObjectStatus {
	return &r
}

type ResponseOutputMessage struct {
	// The unique ID of the output message
	Id string `json:"id" url:"id"`
	// Content of the output message
	Content []*ResponseOutputText `json:"content,omitempty" url:"content,omitempty"`
	// The role of the output message
	// The status of the message
	Status ResponseOutputMessageStatus `json:"status" url:"status"`
	// The type of the output message
	role  string
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseOutputMessage) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *ResponseOutputMessage) GetContent() []*ResponseOutputText {
	if r == nil {
		return nil
	}
	return r.Content
}

func (r *ResponseOutputMessage) GetStatus() ResponseOutputMessageStatus {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *ResponseOutputMessage) Role() string {
	return r.role
}

func (r *ResponseOutputMessage) Type() string {
	return r.type_
}

func (r *ResponseOutputMessage) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseOutputMessage) UnmarshalJSON(data []byte) error {
	type embed ResponseOutputMessage
	var unmarshaler = struct {
		embed
		Role string `json:"role"`
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ResponseOutputMessage(unmarshaler.embed)
	if unmarshaler.Role != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "assistant", unmarshaler.Role)
	}
	r.role = unmarshaler.Role
	if unmarshaler.Type != "message" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "message", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "role", "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseOutputMessage) MarshalJSON() ([]byte, error) {
	type embed ResponseOutputMessage
	var marshaler = struct {
		embed
		Role string `json:"role"`
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Role:  "assistant",
		Type:  "message",
	}
	return json.Marshal(marshaler)
}

func (r *ResponseOutputMessage) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The status of the message
type ResponseOutputMessageStatus string

const (
	ResponseOutputMessageStatusInProgress ResponseOutputMessageStatus = "in_progress"
	ResponseOutputMessageStatusCompleted  ResponseOutputMessageStatus = "completed"
	ResponseOutputMessageStatusIncomplete ResponseOutputMessageStatus = "incomplete"
)

func NewResponseOutputMessageStatusFromString(s string) (ResponseOutputMessageStatus, error) {
	switch s {
	case "in_progress":
		return ResponseOutputMessageStatusInProgress, nil
	case "completed":
		return ResponseOutputMessageStatusCompleted, nil
	case "incomplete":
		return ResponseOutputMessageStatusIncomplete, nil
	}
	var t ResponseOutputMessageStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseOutputMessageStatus) Ptr() *ResponseOutputMessageStatus {
	return &r
}

type ResponseOutputText struct {
	// Annotations in the text output
	Annotations []map[string]interface{} `json:"annotations,omitempty" url:"annotations,omitempty"`
	// The text output from the model
	Text string `json:"text" url:"text"`
	// The type of the output text
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseOutputText) GetAnnotations() []map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Annotations
}

func (r *ResponseOutputText) GetText() string {
	if r == nil {
		return ""
	}
	return r.Text
}

func (r *ResponseOutputText) Type() string {
	return r.type_
}

func (r *ResponseOutputText) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseOutputText) UnmarshalJSON(data []byte) error {
	type embed ResponseOutputText
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ResponseOutputText(unmarshaler.embed)
	if unmarshaler.Type != "output_text" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "output_text", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseOutputText) MarshalJSON() ([]byte, error) {
	type embed ResponseOutputText
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "output_text",
	}
	return json.Marshal(marshaler)
}

func (r *ResponseOutputText) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseTextDeltaEvent struct {
	// Index of the content part
	ContentIndex float64 `json:"content_index" url:"content_index"`
	// Text delta being added
	Delta string `json:"delta" url:"delta"`
	// ID of the output item
	ItemId string `json:"item_id" url:"item_id"`
	// Index of the output item
	OutputIndex float64 `json:"output_index" url:"output_index"`
	// Event type
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseTextDeltaEvent) GetContentIndex() float64 {
	if r == nil {
		return 0
	}
	return r.ContentIndex
}

func (r *ResponseTextDeltaEvent) GetDelta() string {
	if r == nil {
		return ""
	}
	return r.Delta
}

func (r *ResponseTextDeltaEvent) GetItemId() string {
	if r == nil {
		return ""
	}
	return r.ItemId
}

func (r *ResponseTextDeltaEvent) GetOutputIndex() float64 {
	if r == nil {
		return 0
	}
	return r.OutputIndex
}

func (r *ResponseTextDeltaEvent) Type() string {
	return r.type_
}

func (r *ResponseTextDeltaEvent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseTextDeltaEvent) UnmarshalJSON(data []byte) error {
	type embed ResponseTextDeltaEvent
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ResponseTextDeltaEvent(unmarshaler.embed)
	if unmarshaler.Type != "response.output_text.delta" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "response.output_text.delta", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseTextDeltaEvent) MarshalJSON() ([]byte, error) {
	type embed ResponseTextDeltaEvent
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "response.output_text.delta",
	}
	return json.Marshal(marshaler)
}

func (r *ResponseTextDeltaEvent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseTextDoneEvent struct {
	// Index of the content part
	ContentIndex float64 `json:"content_index" url:"content_index"`
	// ID of the output item
	ItemId string `json:"item_id" url:"item_id"`
	// Index of the output item
	OutputIndex float64 `json:"output_index" url:"output_index"`
	// Complete text content
	Text string `json:"text" url:"text"`
	// Event type
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseTextDoneEvent) GetContentIndex() float64 {
	if r == nil {
		return 0
	}
	return r.ContentIndex
}

func (r *ResponseTextDoneEvent) GetItemId() string {
	if r == nil {
		return ""
	}
	return r.ItemId
}

func (r *ResponseTextDoneEvent) GetOutputIndex() float64 {
	if r == nil {
		return 0
	}
	return r.OutputIndex
}

func (r *ResponseTextDoneEvent) GetText() string {
	if r == nil {
		return ""
	}
	return r.Text
}

func (r *ResponseTextDoneEvent) Type() string {
	return r.type_
}

func (r *ResponseTextDoneEvent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseTextDoneEvent) UnmarshalJSON(data []byte) error {
	type embed ResponseTextDoneEvent
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ResponseTextDoneEvent(unmarshaler.embed)
	if unmarshaler.Type != "response.output_text.done" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "response.output_text.done", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseTextDoneEvent) MarshalJSON() ([]byte, error) {
	type embed ResponseTextDoneEvent
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "response.output_text.done",
	}
	return json.Marshal(marshaler)
}

func (r *ResponseTextDoneEvent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ChatsCreateResponse struct {
	Chat                     *Chat
	CreateChatStreamResponse *CreateChatStreamResponse

	typ string
}

func (c *ChatsCreateResponse) GetChat() *Chat {
	if c == nil {
		return nil
	}
	return c.Chat
}

func (c *ChatsCreateResponse) GetCreateChatStreamResponse() *CreateChatStreamResponse {
	if c == nil {
		return nil
	}
	return c.CreateChatStreamResponse
}

func (c *ChatsCreateResponse) UnmarshalJSON(data []byte) error {
	valueChat := new(Chat)
	if err := json.Unmarshal(data, &valueChat); err == nil {
		c.typ = "Chat"
		c.Chat = valueChat
		return nil
	}
	valueCreateChatStreamResponse := new(CreateChatStreamResponse)
	if err := json.Unmarshal(data, &valueCreateChatStreamResponse); err == nil {
		c.typ = "CreateChatStreamResponse"
		c.CreateChatStreamResponse = valueCreateChatStreamResponse
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatsCreateResponse) MarshalJSON() ([]byte, error) {
	if c.typ == "Chat" || c.Chat != nil {
		return json.Marshal(c.Chat)
	}
	if c.typ == "CreateChatStreamResponse" || c.CreateChatStreamResponse != nil {
		return json.Marshal(c.CreateChatStreamResponse)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatsCreateResponseVisitor interface {
	VisitChat(*Chat) error
	VisitCreateChatStreamResponse(*CreateChatStreamResponse) error
}

func (c *ChatsCreateResponse) Accept(visitor ChatsCreateResponseVisitor) error {
	if c.typ == "Chat" || c.Chat != nil {
		return visitor.VisitChat(c.Chat)
	}
	if c.typ == "CreateChatStreamResponse" || c.CreateChatStreamResponse != nil {
		return visitor.VisitCreateChatStreamResponse(c.CreateChatStreamResponse)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatsCreateResponseResponse struct {
	ResponseObject         *ResponseObject
	ResponseTextDeltaEvent *ResponseTextDeltaEvent
	ResponseTextDoneEvent  *ResponseTextDoneEvent
	ResponseCompletedEvent *ResponseCompletedEvent
	ResponseErrorEvent     *ResponseErrorEvent

	typ string
}

func (c *ChatsCreateResponseResponse) GetResponseObject() *ResponseObject {
	if c == nil {
		return nil
	}
	return c.ResponseObject
}

func (c *ChatsCreateResponseResponse) GetResponseTextDeltaEvent() *ResponseTextDeltaEvent {
	if c == nil {
		return nil
	}
	return c.ResponseTextDeltaEvent
}

func (c *ChatsCreateResponseResponse) GetResponseTextDoneEvent() *ResponseTextDoneEvent {
	if c == nil {
		return nil
	}
	return c.ResponseTextDoneEvent
}

func (c *ChatsCreateResponseResponse) GetResponseCompletedEvent() *ResponseCompletedEvent {
	if c == nil {
		return nil
	}
	return c.ResponseCompletedEvent
}

func (c *ChatsCreateResponseResponse) GetResponseErrorEvent() *ResponseErrorEvent {
	if c == nil {
		return nil
	}
	return c.ResponseErrorEvent
}

func (c *ChatsCreateResponseResponse) UnmarshalJSON(data []byte) error {
	valueResponseObject := new(ResponseObject)
	if err := json.Unmarshal(data, &valueResponseObject); err == nil {
		c.typ = "ResponseObject"
		c.ResponseObject = valueResponseObject
		return nil
	}
	valueResponseTextDeltaEvent := new(ResponseTextDeltaEvent)
	if err := json.Unmarshal(data, &valueResponseTextDeltaEvent); err == nil {
		c.typ = "ResponseTextDeltaEvent"
		c.ResponseTextDeltaEvent = valueResponseTextDeltaEvent
		return nil
	}
	valueResponseTextDoneEvent := new(ResponseTextDoneEvent)
	if err := json.Unmarshal(data, &valueResponseTextDoneEvent); err == nil {
		c.typ = "ResponseTextDoneEvent"
		c.ResponseTextDoneEvent = valueResponseTextDoneEvent
		return nil
	}
	valueResponseCompletedEvent := new(ResponseCompletedEvent)
	if err := json.Unmarshal(data, &valueResponseCompletedEvent); err == nil {
		c.typ = "ResponseCompletedEvent"
		c.ResponseCompletedEvent = valueResponseCompletedEvent
		return nil
	}
	valueResponseErrorEvent := new(ResponseErrorEvent)
	if err := json.Unmarshal(data, &valueResponseErrorEvent); err == nil {
		c.typ = "ResponseErrorEvent"
		c.ResponseErrorEvent = valueResponseErrorEvent
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatsCreateResponseResponse) MarshalJSON() ([]byte, error) {
	if c.typ == "ResponseObject" || c.ResponseObject != nil {
		return json.Marshal(c.ResponseObject)
	}
	if c.typ == "ResponseTextDeltaEvent" || c.ResponseTextDeltaEvent != nil {
		return json.Marshal(c.ResponseTextDeltaEvent)
	}
	if c.typ == "ResponseTextDoneEvent" || c.ResponseTextDoneEvent != nil {
		return json.Marshal(c.ResponseTextDoneEvent)
	}
	if c.typ == "ResponseCompletedEvent" || c.ResponseCompletedEvent != nil {
		return json.Marshal(c.ResponseCompletedEvent)
	}
	if c.typ == "ResponseErrorEvent" || c.ResponseErrorEvent != nil {
		return json.Marshal(c.ResponseErrorEvent)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatsCreateResponseResponseVisitor interface {
	VisitResponseObject(*ResponseObject) error
	VisitResponseTextDeltaEvent(*ResponseTextDeltaEvent) error
	VisitResponseTextDoneEvent(*ResponseTextDoneEvent) error
	VisitResponseCompletedEvent(*ResponseCompletedEvent) error
	VisitResponseErrorEvent(*ResponseErrorEvent) error
}

func (c *ChatsCreateResponseResponse) Accept(visitor ChatsCreateResponseResponseVisitor) error {
	if c.typ == "ResponseObject" || c.ResponseObject != nil {
		return visitor.VisitResponseObject(c.ResponseObject)
	}
	if c.typ == "ResponseTextDeltaEvent" || c.ResponseTextDeltaEvent != nil {
		return visitor.VisitResponseTextDeltaEvent(c.ResponseTextDeltaEvent)
	}
	if c.typ == "ResponseTextDoneEvent" || c.ResponseTextDoneEvent != nil {
		return visitor.VisitResponseTextDoneEvent(c.ResponseTextDoneEvent)
	}
	if c.typ == "ResponseCompletedEvent" || c.ResponseCompletedEvent != nil {
		return visitor.VisitResponseCompletedEvent(c.ResponseCompletedEvent)
	}
	if c.typ == "ResponseErrorEvent" || c.ResponseErrorEvent != nil {
		return visitor.VisitResponseErrorEvent(c.ResponseErrorEvent)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatsListRequestSortOrder string

const (
	ChatsListRequestSortOrderAsc  ChatsListRequestSortOrder = "ASC"
	ChatsListRequestSortOrderDesc ChatsListRequestSortOrder = "DESC"
)

func NewChatsListRequestSortOrderFromString(s string) (ChatsListRequestSortOrder, error) {
	switch s {
	case "ASC":
		return ChatsListRequestSortOrderAsc, nil
	case "DESC":
		return ChatsListRequestSortOrderDesc, nil
	}
	var t ChatsListRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatsListRequestSortOrder) Ptr() *ChatsListRequestSortOrder {
	return &c
}

// This is the input text for the chat.
// Can be a string or an array of chat messages.
// This field is REQUIRED for chat creation.
type CreateChatDtoInput struct {
	String                     string
	CreateChatDtoInputItemList []*CreateChatDtoInputItem

	typ string
}

func (c *CreateChatDtoInput) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreateChatDtoInput) GetCreateChatDtoInputItemList() []*CreateChatDtoInputItem {
	if c == nil {
		return nil
	}
	return c.CreateChatDtoInputItemList
}

func (c *CreateChatDtoInput) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	var valueCreateChatDtoInputItemList []*CreateChatDtoInputItem
	if err := json.Unmarshal(data, &valueCreateChatDtoInputItemList); err == nil {
		c.typ = "CreateChatDtoInputItemList"
		c.CreateChatDtoInputItemList = valueCreateChatDtoInputItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateChatDtoInput) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "CreateChatDtoInputItemList" || c.CreateChatDtoInputItemList != nil {
		return json.Marshal(c.CreateChatDtoInputItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateChatDtoInputVisitor interface {
	VisitString(string) error
	VisitCreateChatDtoInputItemList([]*CreateChatDtoInputItem) error
}

func (c *CreateChatDtoInput) Accept(visitor CreateChatDtoInputVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "CreateChatDtoInputItemList" || c.CreateChatDtoInputItemList != nil {
		return visitor.VisitCreateChatDtoInputItemList(c.CreateChatDtoInputItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateChatDtoInputItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (c *CreateChatDtoInputItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *CreateChatDtoInputItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *CreateChatDtoInputItem) GetAssistantMessage() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.AssistantMessage
}

func (c *CreateChatDtoInputItem) GetToolMessage() *ToolMessage {
	if c == nil {
		return nil
	}
	return c.ToolMessage
}

func (c *CreateChatDtoInputItem) GetDeveloperMessage() *DeveloperMessage {
	if c == nil {
		return nil
	}
	return c.DeveloperMessage
}

func (c *CreateChatDtoInputItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		c.typ = "AssistantMessage"
		c.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		c.typ = "ToolMessage"
		c.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		c.typ = "DeveloperMessage"
		c.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateChatDtoInputItem) MarshalJSON() ([]byte, error) {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return json.Marshal(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return json.Marshal(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return json.Marshal(c.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateChatDtoInputItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (c *CreateChatDtoInputItem) Accept(visitor CreateChatDtoInputItemVisitor) error {
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "AssistantMessage" || c.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(c.AssistantMessage)
	}
	if c.typ == "ToolMessage" || c.ToolMessage != nil {
		return visitor.VisitToolMessage(c.ToolMessage)
	}
	if c.typ == "DeveloperMessage" || c.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(c.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the input text for the chat.
// Can be a string or an array of chat messages.
// This field is REQUIRED for chat creation.
type OpenAiResponsesRequestInput struct {
	String                              string
	OpenAiResponsesRequestInputItemList []*OpenAiResponsesRequestInputItem

	typ string
}

func (o *OpenAiResponsesRequestInput) GetString() string {
	if o == nil {
		return ""
	}
	return o.String
}

func (o *OpenAiResponsesRequestInput) GetOpenAiResponsesRequestInputItemList() []*OpenAiResponsesRequestInputItem {
	if o == nil {
		return nil
	}
	return o.OpenAiResponsesRequestInputItemList
}

func (o *OpenAiResponsesRequestInput) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typ = "String"
		o.String = valueString
		return nil
	}
	var valueOpenAiResponsesRequestInputItemList []*OpenAiResponsesRequestInputItem
	if err := json.Unmarshal(data, &valueOpenAiResponsesRequestInputItemList); err == nil {
		o.typ = "OpenAiResponsesRequestInputItemList"
		o.OpenAiResponsesRequestInputItemList = valueOpenAiResponsesRequestInputItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenAiResponsesRequestInput) MarshalJSON() ([]byte, error) {
	if o.typ == "String" || o.String != "" {
		return json.Marshal(o.String)
	}
	if o.typ == "OpenAiResponsesRequestInputItemList" || o.OpenAiResponsesRequestInputItemList != nil {
		return json.Marshal(o.OpenAiResponsesRequestInputItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiResponsesRequestInputVisitor interface {
	VisitString(string) error
	VisitOpenAiResponsesRequestInputItemList([]*OpenAiResponsesRequestInputItem) error
}

func (o *OpenAiResponsesRequestInput) Accept(visitor OpenAiResponsesRequestInputVisitor) error {
	if o.typ == "String" || o.String != "" {
		return visitor.VisitString(o.String)
	}
	if o.typ == "OpenAiResponsesRequestInputItemList" || o.OpenAiResponsesRequestInputItemList != nil {
		return visitor.VisitOpenAiResponsesRequestInputItemList(o.OpenAiResponsesRequestInputItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiResponsesRequestInputItem struct {
	SystemMessage    *SystemMessage
	UserMessage      *UserMessage
	AssistantMessage *AssistantMessage
	ToolMessage      *ToolMessage
	DeveloperMessage *DeveloperMessage

	typ string
}

func (o *OpenAiResponsesRequestInputItem) GetSystemMessage() *SystemMessage {
	if o == nil {
		return nil
	}
	return o.SystemMessage
}

func (o *OpenAiResponsesRequestInputItem) GetUserMessage() *UserMessage {
	if o == nil {
		return nil
	}
	return o.UserMessage
}

func (o *OpenAiResponsesRequestInputItem) GetAssistantMessage() *AssistantMessage {
	if o == nil {
		return nil
	}
	return o.AssistantMessage
}

func (o *OpenAiResponsesRequestInputItem) GetToolMessage() *ToolMessage {
	if o == nil {
		return nil
	}
	return o.ToolMessage
}

func (o *OpenAiResponsesRequestInputItem) GetDeveloperMessage() *DeveloperMessage {
	if o == nil {
		return nil
	}
	return o.DeveloperMessage
}

func (o *OpenAiResponsesRequestInputItem) UnmarshalJSON(data []byte) error {
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		o.typ = "SystemMessage"
		o.SystemMessage = valueSystemMessage
		return nil
	}
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		o.typ = "UserMessage"
		o.UserMessage = valueUserMessage
		return nil
	}
	valueAssistantMessage := new(AssistantMessage)
	if err := json.Unmarshal(data, &valueAssistantMessage); err == nil {
		o.typ = "AssistantMessage"
		o.AssistantMessage = valueAssistantMessage
		return nil
	}
	valueToolMessage := new(ToolMessage)
	if err := json.Unmarshal(data, &valueToolMessage); err == nil {
		o.typ = "ToolMessage"
		o.ToolMessage = valueToolMessage
		return nil
	}
	valueDeveloperMessage := new(DeveloperMessage)
	if err := json.Unmarshal(data, &valueDeveloperMessage); err == nil {
		o.typ = "DeveloperMessage"
		o.DeveloperMessage = valueDeveloperMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenAiResponsesRequestInputItem) MarshalJSON() ([]byte, error) {
	if o.typ == "SystemMessage" || o.SystemMessage != nil {
		return json.Marshal(o.SystemMessage)
	}
	if o.typ == "UserMessage" || o.UserMessage != nil {
		return json.Marshal(o.UserMessage)
	}
	if o.typ == "AssistantMessage" || o.AssistantMessage != nil {
		return json.Marshal(o.AssistantMessage)
	}
	if o.typ == "ToolMessage" || o.ToolMessage != nil {
		return json.Marshal(o.ToolMessage)
	}
	if o.typ == "DeveloperMessage" || o.DeveloperMessage != nil {
		return json.Marshal(o.DeveloperMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiResponsesRequestInputItemVisitor interface {
	VisitSystemMessage(*SystemMessage) error
	VisitUserMessage(*UserMessage) error
	VisitAssistantMessage(*AssistantMessage) error
	VisitToolMessage(*ToolMessage) error
	VisitDeveloperMessage(*DeveloperMessage) error
}

func (o *OpenAiResponsesRequestInputItem) Accept(visitor OpenAiResponsesRequestInputItemVisitor) error {
	if o.typ == "SystemMessage" || o.SystemMessage != nil {
		return visitor.VisitSystemMessage(o.SystemMessage)
	}
	if o.typ == "UserMessage" || o.UserMessage != nil {
		return visitor.VisitUserMessage(o.UserMessage)
	}
	if o.typ == "AssistantMessage" || o.AssistantMessage != nil {
		return visitor.VisitAssistantMessage(o.AssistantMessage)
	}
	if o.typ == "ToolMessage" || o.ToolMessage != nil {
		return visitor.VisitToolMessage(o.ToolMessage)
	}
	if o.typ == "DeveloperMessage" || o.DeveloperMessage != nil {
		return visitor.VisitDeveloperMessage(o.DeveloperMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}
