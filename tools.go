// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/VapiAI/server-sdk-go/internal"
	big "math/big"
	time "time"
)

var (
	deleteToolsRequestFieldId = big.NewInt(1 << 0)
)

type DeleteToolsRequest struct {
	Id string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DeleteToolsRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteToolsRequest) SetId(id string) {
	d.Id = id
	d.require(deleteToolsRequestFieldId)
}

var (
	getToolsRequestFieldId = big.NewInt(1 << 0)
)

type GetToolsRequest struct {
	Id string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetToolsRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetToolsRequest) SetId(id string) {
	g.Id = id
	g.require(getToolsRequestFieldId)
}

var (
	listToolsRequestFieldLimit       = big.NewInt(1 << 0)
	listToolsRequestFieldCreatedAtGt = big.NewInt(1 << 1)
	listToolsRequestFieldCreatedAtLt = big.NewInt(1 << 2)
	listToolsRequestFieldCreatedAtGe = big.NewInt(1 << 3)
	listToolsRequestFieldCreatedAtLe = big.NewInt(1 << 4)
	listToolsRequestFieldUpdatedAtGt = big.NewInt(1 << 5)
	listToolsRequestFieldUpdatedAtLt = big.NewInt(1 << 6)
	listToolsRequestFieldUpdatedAtGe = big.NewInt(1 << 7)
	listToolsRequestFieldUpdatedAtLe = big.NewInt(1 << 8)
)

type ListToolsRequest struct {
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListToolsRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsRequest) SetLimit(limit *float64) {
	l.Limit = limit
	l.require(listToolsRequestFieldLimit)
}

// SetCreatedAtGt sets the CreatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsRequest) SetCreatedAtGt(createdAtGt *time.Time) {
	l.CreatedAtGt = createdAtGt
	l.require(listToolsRequestFieldCreatedAtGt)
}

// SetCreatedAtLt sets the CreatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsRequest) SetCreatedAtLt(createdAtLt *time.Time) {
	l.CreatedAtLt = createdAtLt
	l.require(listToolsRequestFieldCreatedAtLt)
}

// SetCreatedAtGe sets the CreatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsRequest) SetCreatedAtGe(createdAtGe *time.Time) {
	l.CreatedAtGe = createdAtGe
	l.require(listToolsRequestFieldCreatedAtGe)
}

// SetCreatedAtLe sets the CreatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsRequest) SetCreatedAtLe(createdAtLe *time.Time) {
	l.CreatedAtLe = createdAtLe
	l.require(listToolsRequestFieldCreatedAtLe)
}

// SetUpdatedAtGt sets the UpdatedAtGt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsRequest) SetUpdatedAtGt(updatedAtGt *time.Time) {
	l.UpdatedAtGt = updatedAtGt
	l.require(listToolsRequestFieldUpdatedAtGt)
}

// SetUpdatedAtLt sets the UpdatedAtLt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsRequest) SetUpdatedAtLt(updatedAtLt *time.Time) {
	l.UpdatedAtLt = updatedAtLt
	l.require(listToolsRequestFieldUpdatedAtLt)
}

// SetUpdatedAtGe sets the UpdatedAtGe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsRequest) SetUpdatedAtGe(updatedAtGe *time.Time) {
	l.UpdatedAtGe = updatedAtGe
	l.require(listToolsRequestFieldUpdatedAtGe)
}

// SetUpdatedAtLe sets the UpdatedAtLe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsRequest) SetUpdatedAtLe(updatedAtLe *time.Time) {
	l.UpdatedAtLe = updatedAtLe
	l.require(listToolsRequestFieldUpdatedAtLe)
}

var (
	apiRequestToolFieldMessages               = big.NewInt(1 << 0)
	apiRequestToolFieldMethod                 = big.NewInt(1 << 1)
	apiRequestToolFieldTimeoutSeconds         = big.NewInt(1 << 2)
	apiRequestToolFieldCredentialId           = big.NewInt(1 << 3)
	apiRequestToolFieldId                     = big.NewInt(1 << 4)
	apiRequestToolFieldOrgId                  = big.NewInt(1 << 5)
	apiRequestToolFieldCreatedAt              = big.NewInt(1 << 6)
	apiRequestToolFieldUpdatedAt              = big.NewInt(1 << 7)
	apiRequestToolFieldRejectionPlan          = big.NewInt(1 << 8)
	apiRequestToolFieldName                   = big.NewInt(1 << 9)
	apiRequestToolFieldDescription            = big.NewInt(1 << 10)
	apiRequestToolFieldUrl                    = big.NewInt(1 << 11)
	apiRequestToolFieldBody                   = big.NewInt(1 << 12)
	apiRequestToolFieldHeaders                = big.NewInt(1 << 13)
	apiRequestToolFieldBackoffPlan            = big.NewInt(1 << 14)
	apiRequestToolFieldVariableExtractionPlan = big.NewInt(1 << 15)
)

type ApiRequestTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*ApiRequestToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	Method   ApiRequestToolMethod          `json:"method" url:"method"`
	// This is the timeout in seconds for the request. Defaults to 20 seconds.
	//
	// @default 20
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`
	// The credential ID for API request authentication
	CredentialId *string `json:"credentialId,omitempty" url:"credentialId,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// This is the name of the tool. This will be passed to the model.
	//
	// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 40.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the description of the tool. This will be passed to the model.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is where the request will be sent.
	Url string `json:"url" url:"url"`
	// This is the body of the request.
	Body *JsonSchema `json:"body,omitempty" url:"body,omitempty"`
	// These are the headers to send with the request.
	Headers *JsonSchema `json:"headers,omitempty" url:"headers,omitempty"`
	// This is the backoff plan if the request fails. Defaults to undefined (the request will not be retried).
	//
	// @default undefined (the request will not be retried)
	BackoffPlan *BackoffPlan `json:"backoffPlan,omitempty" url:"backoffPlan,omitempty"`
	// This is the plan to extract variables from the tool's response. These will be accessible during the call and stored in `call.artifact.variableValues` after the call.
	//
	// Usage:
	// 1. Use `aliases` to extract variables from the tool's response body. (Most common case)
	//
	// ```json
	//
	//	{
	//	  "aliases": [
	//	    {
	//	      "key": "customerName",
	//	      "value": "{{customer.name}}"
	//	    },
	//	    {
	//	      "key": "customerAge",
	//	      "value": "{{customer.age}}"
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// The tool response body is made available to the liquid template.
	//
	// 2. Use `aliases` to extract variables from the tool's response body if the response is an array.
	//
	// ```json
	//
	//	{
	//	  "aliases": [
	//	    {
	//	      "key": "customerName",
	//	      "value": "{{$[0].name}}"
	//	    },
	//	    {
	//	      "key": "customerAge",
	//	      "value": "{{$[0].age}}"
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// $ is a shorthand for the tool's response body. `$[0]` is the first item in the array. `$[n]` is the nth item in the array. Note, $ is available regardless of the response body type (both object and array).
	//
	// 3. Use `aliases` to extract variables from the tool's response headers.
	//
	// ```json
	//
	//	{
	//	  "aliases": [
	//	    {
	//	      "key": "customerName",
	//	      "value": "{{tool.response.headers.customer-name}}"
	//	    },
	//	    {
	//	      "key": "customerAge",
	//	      "value": "{{tool.response.headers.customer-age}}"
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// `tool.response` is made available to the liquid template. Particularly, both `tool.response.headers` and `tool.response.body` are available. Note, `tool.response` is available regardless of the response body type (both object and array).
	//
	// 4. Use `schema` to extract a large portion of the tool's response body.
	//
	// 4.1. If you hit example.com and it returns `{"name": "John", "age": 30}`, then you can specify the schema as:
	//
	// ```json
	//
	//	{
	//	  "schema": {
	//	    "type": "object",
	//	    "properties": {
	//	      "name": {
	//	        "type": "string"
	//	      },
	//	      "age": {
	//	        "type": "number"
	//	      }
	//	    }
	//	  }
	//	}
	//
	// ```
	// These will be extracted as `{{ name }}` and `{{ age }}` respectively. To emphasize, object properties are extracted as direct global variables.
	//
	// 4.2. If you hit example.com and it returns `{"name": {"first": "John", "last": "Doe"}}`, then you can specify the schema as:
	//
	// ```json
	//
	//	{
	//	  "schema": {
	//	    "type": "object",
	//	    "properties": {
	//	      "name": {
	//	        "type": "object",
	//	        "properties": {
	//	          "first": {
	//	            "type": "string"
	//	          },
	//	          "last": {
	//	            "type": "string"
	//	          }
	//	        }
	//	      }
	//	    }
	//	  }
	//	}
	//
	// ```
	//
	// These will be extracted as `{{ name }}`. And, `{{ name.first }}` and `{{ name.last }}` will be accessible.
	//
	// 4.3. If you hit example.com and it returns `["94123", "94124"]`, then you can specify the schema as:
	//
	// ```json
	//
	//	{
	//	  "schema": {
	//	    "type": "array",
	//	    "title": "zipCodes",
	//	    "items": {
	//	      "type": "string"
	//	    }
	//	  }
	//	}
	//
	// ```
	//
	// This will be extracted as `{{ zipCodes }}`. To access the array items, you can use `{{ zipCodes[0] }}` and `{{ zipCodes[1] }}`.
	//
	// 4.4. If you hit example.com and it returns `[{"name": "John", "age": 30, "zipCodes": ["94123", "94124"]}, {"name": "Jane", "age": 25, "zipCodes": ["94125", "94126"]}]`, then you can specify the schema as:
	//
	// ```json
	//
	//	{
	//	  "schema": {
	//	    "type": "array",
	//	    "title": "people",
	//	    "items": {
	//	      "type": "object",
	//	      "properties": {
	//	        "name": {
	//	          "type": "string"
	//	        },
	//	        "age": {
	//	          "type": "number"
	//	        },
	//	        "zipCodes": {
	//	          "type": "array",
	//	          "items": {
	//	            "type": "string"
	//	          }
	//	        }
	//	      }
	//	    }
	//	  }
	//	}
	//
	// ```
	//
	// This will be extracted as `{{ people }}`. To access the array items, you can use `{{ people[n].name }}`, `{{ people[n].age }}`, `{{ people[n].zipCodes }}`, `{{ people[n].zipCodes[0] }}` and `{{ people[n].zipCodes[1] }}`.
	//
	// Note: Both `aliases` and `schema` can be used together.
	VariableExtractionPlan *VariableExtractionPlan `json:"variableExtractionPlan,omitempty" url:"variableExtractionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApiRequestTool) GetMessages() []*ApiRequestToolMessagesItem {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *ApiRequestTool) GetMethod() ApiRequestToolMethod {
	if a == nil {
		return ""
	}
	return a.Method
}

func (a *ApiRequestTool) GetTimeoutSeconds() *float64 {
	if a == nil {
		return nil
	}
	return a.TimeoutSeconds
}

func (a *ApiRequestTool) GetCredentialId() *string {
	if a == nil {
		return nil
	}
	return a.CredentialId
}

func (a *ApiRequestTool) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *ApiRequestTool) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *ApiRequestTool) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *ApiRequestTool) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *ApiRequestTool) GetRejectionPlan() *ToolRejectionPlan {
	if a == nil {
		return nil
	}
	return a.RejectionPlan
}

func (a *ApiRequestTool) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *ApiRequestTool) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *ApiRequestTool) GetUrl() string {
	if a == nil {
		return ""
	}
	return a.Url
}

func (a *ApiRequestTool) GetBody() *JsonSchema {
	if a == nil {
		return nil
	}
	return a.Body
}

func (a *ApiRequestTool) GetHeaders() *JsonSchema {
	if a == nil {
		return nil
	}
	return a.Headers
}

func (a *ApiRequestTool) GetBackoffPlan() *BackoffPlan {
	if a == nil {
		return nil
	}
	return a.BackoffPlan
}

func (a *ApiRequestTool) GetVariableExtractionPlan() *VariableExtractionPlan {
	if a == nil {
		return nil
	}
	return a.VariableExtractionPlan
}

func (a *ApiRequestTool) Type() string {
	return a.type_
}

func (a *ApiRequestTool) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiRequestTool) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetMessages(messages []*ApiRequestToolMessagesItem) {
	a.Messages = messages
	a.require(apiRequestToolFieldMessages)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetMethod(method ApiRequestToolMethod) {
	a.Method = method
	a.require(apiRequestToolFieldMethod)
}

// SetTimeoutSeconds sets the TimeoutSeconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetTimeoutSeconds(timeoutSeconds *float64) {
	a.TimeoutSeconds = timeoutSeconds
	a.require(apiRequestToolFieldTimeoutSeconds)
}

// SetCredentialId sets the CredentialId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetCredentialId(credentialId *string) {
	a.CredentialId = credentialId
	a.require(apiRequestToolFieldCredentialId)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetId(id string) {
	a.Id = id
	a.require(apiRequestToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetOrgId(orgId string) {
	a.OrgId = orgId
	a.require(apiRequestToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetCreatedAt(createdAt time.Time) {
	a.CreatedAt = createdAt
	a.require(apiRequestToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetUpdatedAt(updatedAt time.Time) {
	a.UpdatedAt = updatedAt
	a.require(apiRequestToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	a.RejectionPlan = rejectionPlan
	a.require(apiRequestToolFieldRejectionPlan)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetName(name *string) {
	a.Name = name
	a.require(apiRequestToolFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetDescription(description *string) {
	a.Description = description
	a.require(apiRequestToolFieldDescription)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetUrl(url string) {
	a.Url = url
	a.require(apiRequestToolFieldUrl)
}

// SetBody sets the Body field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetBody(body *JsonSchema) {
	a.Body = body
	a.require(apiRequestToolFieldBody)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetHeaders(headers *JsonSchema) {
	a.Headers = headers
	a.require(apiRequestToolFieldHeaders)
}

// SetBackoffPlan sets the BackoffPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetBackoffPlan(backoffPlan *BackoffPlan) {
	a.BackoffPlan = backoffPlan
	a.require(apiRequestToolFieldBackoffPlan)
}

// SetVariableExtractionPlan sets the VariableExtractionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ApiRequestTool) SetVariableExtractionPlan(variableExtractionPlan *VariableExtractionPlan) {
	a.VariableExtractionPlan = variableExtractionPlan
	a.require(apiRequestToolFieldVariableExtractionPlan)
}

func (a *ApiRequestTool) UnmarshalJSON(data []byte) error {
	type embed ApiRequestTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApiRequestTool(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "apiRequest" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "apiRequest", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiRequestTool) MarshalJSON() ([]byte, error) {
	type embed ApiRequestTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Type:      "apiRequest",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ApiRequestTool) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiRequestToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (a *ApiRequestToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if a == nil {
		return nil
	}
	return a.ToolMessageStart
}

func (a *ApiRequestToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if a == nil {
		return nil
	}
	return a.ToolMessageComplete
}

func (a *ApiRequestToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if a == nil {
		return nil
	}
	return a.ToolMessageFailed
}

func (a *ApiRequestToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if a == nil {
		return nil
	}
	return a.ToolMessageDelayed
}

func (a *ApiRequestToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		a.typ = "ToolMessageStart"
		a.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		a.typ = "ToolMessageComplete"
		a.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		a.typ = "ToolMessageFailed"
		a.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		a.typ = "ToolMessageDelayed"
		a.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApiRequestToolMessagesItem) MarshalJSON() ([]byte, error) {
	if a.typ == "ToolMessageStart" || a.ToolMessageStart != nil {
		return json.Marshal(a.ToolMessageStart)
	}
	if a.typ == "ToolMessageComplete" || a.ToolMessageComplete != nil {
		return json.Marshal(a.ToolMessageComplete)
	}
	if a.typ == "ToolMessageFailed" || a.ToolMessageFailed != nil {
		return json.Marshal(a.ToolMessageFailed)
	}
	if a.typ == "ToolMessageDelayed" || a.ToolMessageDelayed != nil {
		return json.Marshal(a.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApiRequestToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (a *ApiRequestToolMessagesItem) Accept(visitor ApiRequestToolMessagesItemVisitor) error {
	if a.typ == "ToolMessageStart" || a.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(a.ToolMessageStart)
	}
	if a.typ == "ToolMessageComplete" || a.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(a.ToolMessageComplete)
	}
	if a.typ == "ToolMessageFailed" || a.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(a.ToolMessageFailed)
	}
	if a.typ == "ToolMessageDelayed" || a.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(a.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApiRequestToolMethod string

const (
	ApiRequestToolMethodPost   ApiRequestToolMethod = "POST"
	ApiRequestToolMethodGet    ApiRequestToolMethod = "GET"
	ApiRequestToolMethodPut    ApiRequestToolMethod = "PUT"
	ApiRequestToolMethodPatch  ApiRequestToolMethod = "PATCH"
	ApiRequestToolMethodDelete ApiRequestToolMethod = "DELETE"
)

func NewApiRequestToolMethodFromString(s string) (ApiRequestToolMethod, error) {
	switch s {
	case "POST":
		return ApiRequestToolMethodPost, nil
	case "GET":
		return ApiRequestToolMethodGet, nil
	case "PUT":
		return ApiRequestToolMethodPut, nil
	case "PATCH":
		return ApiRequestToolMethodPatch, nil
	case "DELETE":
		return ApiRequestToolMethodDelete, nil
	}
	var t ApiRequestToolMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApiRequestToolMethod) Ptr() *ApiRequestToolMethod {
	return &a
}

var (
	bashToolFieldMessages      = big.NewInt(1 << 0)
	bashToolFieldSubType       = big.NewInt(1 << 1)
	bashToolFieldServer        = big.NewInt(1 << 2)
	bashToolFieldId            = big.NewInt(1 << 3)
	bashToolFieldOrgId         = big.NewInt(1 << 4)
	bashToolFieldCreatedAt     = big.NewInt(1 << 5)
	bashToolFieldUpdatedAt     = big.NewInt(1 << 6)
	bashToolFieldRejectionPlan = big.NewInt(1 << 7)
	bashToolFieldName          = big.NewInt(1 << 8)
)

type BashTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*BashToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	SubType BashToolSubType `json:"subType" url:"subType"`
	// This is the server where a `tool-calls` webhook will be sent.
	//
	// Notes:
	// - Webhook is sent to this server when a tool call is made.
	// - Webhook contains the call, assistant, and phone number objects.
	// - Webhook contains the variables set on the assistant.
	// - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
	// - Webhook expects a response with tool call result.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// The name of the tool, fixed to 'bash'
	Name BashToolName `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BashTool) GetMessages() []*BashToolMessagesItem {
	if b == nil {
		return nil
	}
	return b.Messages
}

func (b *BashTool) GetSubType() BashToolSubType {
	if b == nil {
		return ""
	}
	return b.SubType
}

func (b *BashTool) GetServer() *Server {
	if b == nil {
		return nil
	}
	return b.Server
}

func (b *BashTool) GetId() string {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *BashTool) GetOrgId() string {
	if b == nil {
		return ""
	}
	return b.OrgId
}

func (b *BashTool) GetCreatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.CreatedAt
}

func (b *BashTool) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *BashTool) GetRejectionPlan() *ToolRejectionPlan {
	if b == nil {
		return nil
	}
	return b.RejectionPlan
}

func (b *BashTool) GetName() BashToolName {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *BashTool) Type() string {
	return b.type_
}

func (b *BashTool) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BashTool) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BashTool) SetMessages(messages []*BashToolMessagesItem) {
	b.Messages = messages
	b.require(bashToolFieldMessages)
}

// SetSubType sets the SubType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BashTool) SetSubType(subType BashToolSubType) {
	b.SubType = subType
	b.require(bashToolFieldSubType)
}

// SetServer sets the Server field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BashTool) SetServer(server *Server) {
	b.Server = server
	b.require(bashToolFieldServer)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BashTool) SetId(id string) {
	b.Id = id
	b.require(bashToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BashTool) SetOrgId(orgId string) {
	b.OrgId = orgId
	b.require(bashToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BashTool) SetCreatedAt(createdAt time.Time) {
	b.CreatedAt = createdAt
	b.require(bashToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BashTool) SetUpdatedAt(updatedAt time.Time) {
	b.UpdatedAt = updatedAt
	b.require(bashToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BashTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	b.RejectionPlan = rejectionPlan
	b.require(bashToolFieldRejectionPlan)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BashTool) SetName(name BashToolName) {
	b.Name = name
	b.require(bashToolFieldName)
}

func (b *BashTool) UnmarshalJSON(data []byte) error {
	type embed BashTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BashTool(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "bash" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "bash", unmarshaler.Type)
	}
	b.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *b, "type")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BashTool) MarshalJSON() ([]byte, error) {
	type embed BashTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewDateTime(b.CreatedAt),
		UpdatedAt: internal.NewDateTime(b.UpdatedAt),
		Type:      "bash",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BashTool) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BashToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (b *BashToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if b == nil {
		return nil
	}
	return b.ToolMessageStart
}

func (b *BashToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if b == nil {
		return nil
	}
	return b.ToolMessageComplete
}

func (b *BashToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if b == nil {
		return nil
	}
	return b.ToolMessageFailed
}

func (b *BashToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if b == nil {
		return nil
	}
	return b.ToolMessageDelayed
}

func (b *BashToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		b.typ = "ToolMessageStart"
		b.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		b.typ = "ToolMessageComplete"
		b.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		b.typ = "ToolMessageFailed"
		b.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		b.typ = "ToolMessageDelayed"
		b.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BashToolMessagesItem) MarshalJSON() ([]byte, error) {
	if b.typ == "ToolMessageStart" || b.ToolMessageStart != nil {
		return json.Marshal(b.ToolMessageStart)
	}
	if b.typ == "ToolMessageComplete" || b.ToolMessageComplete != nil {
		return json.Marshal(b.ToolMessageComplete)
	}
	if b.typ == "ToolMessageFailed" || b.ToolMessageFailed != nil {
		return json.Marshal(b.ToolMessageFailed)
	}
	if b.typ == "ToolMessageDelayed" || b.ToolMessageDelayed != nil {
		return json.Marshal(b.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BashToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (b *BashToolMessagesItem) Accept(visitor BashToolMessagesItemVisitor) error {
	if b.typ == "ToolMessageStart" || b.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(b.ToolMessageStart)
	}
	if b.typ == "ToolMessageComplete" || b.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(b.ToolMessageComplete)
	}
	if b.typ == "ToolMessageFailed" || b.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(b.ToolMessageFailed)
	}
	if b.typ == "ToolMessageDelayed" || b.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(b.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

// The name of the tool, fixed to 'bash'
type BashToolName string

const (
	BashToolNameBash BashToolName = "bash"
)

func NewBashToolNameFromString(s string) (BashToolName, error) {
	switch s {
	case "bash":
		return BashToolNameBash, nil
	}
	var t BashToolName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BashToolName) Ptr() *BashToolName {
	return &b
}

// The sub type of tool.
type BashToolSubType string

const (
	BashToolSubTypeBash20241022 BashToolSubType = "bash_20241022"
)

func NewBashToolSubTypeFromString(s string) (BashToolSubType, error) {
	switch s {
	case "bash_20241022":
		return BashToolSubTypeBash20241022, nil
	}
	var t BashToolSubType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BashToolSubType) Ptr() *BashToolSubType {
	return &b
}

var (
	computerToolFieldMessages        = big.NewInt(1 << 0)
	computerToolFieldSubType         = big.NewInt(1 << 1)
	computerToolFieldServer          = big.NewInt(1 << 2)
	computerToolFieldId              = big.NewInt(1 << 3)
	computerToolFieldOrgId           = big.NewInt(1 << 4)
	computerToolFieldCreatedAt       = big.NewInt(1 << 5)
	computerToolFieldUpdatedAt       = big.NewInt(1 << 6)
	computerToolFieldRejectionPlan   = big.NewInt(1 << 7)
	computerToolFieldName            = big.NewInt(1 << 8)
	computerToolFieldDisplayWidthPx  = big.NewInt(1 << 9)
	computerToolFieldDisplayHeightPx = big.NewInt(1 << 10)
	computerToolFieldDisplayNumber   = big.NewInt(1 << 11)
)

type ComputerTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*ComputerToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	SubType ComputerToolSubType `json:"subType" url:"subType"`
	// This is the server where a `tool-calls` webhook will be sent.
	//
	// Notes:
	// - Webhook is sent to this server when a tool call is made.
	// - Webhook contains the call, assistant, and phone number objects.
	// - Webhook contains the variables set on the assistant.
	// - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
	// - Webhook expects a response with tool call result.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// The name of the tool, fixed to 'computer'
	Name ComputerToolName `json:"name" url:"name"`
	// The display width in pixels
	DisplayWidthPx float64 `json:"displayWidthPx" url:"displayWidthPx"`
	// The display height in pixels
	DisplayHeightPx float64 `json:"displayHeightPx" url:"displayHeightPx"`
	// Optional display number
	DisplayNumber *float64 `json:"displayNumber,omitempty" url:"displayNumber,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ComputerTool) GetMessages() []*ComputerToolMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ComputerTool) GetSubType() ComputerToolSubType {
	if c == nil {
		return ""
	}
	return c.SubType
}

func (c *ComputerTool) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *ComputerTool) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *ComputerTool) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *ComputerTool) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *ComputerTool) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *ComputerTool) GetRejectionPlan() *ToolRejectionPlan {
	if c == nil {
		return nil
	}
	return c.RejectionPlan
}

func (c *ComputerTool) GetName() ComputerToolName {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *ComputerTool) GetDisplayWidthPx() float64 {
	if c == nil {
		return 0
	}
	return c.DisplayWidthPx
}

func (c *ComputerTool) GetDisplayHeightPx() float64 {
	if c == nil {
		return 0
	}
	return c.DisplayHeightPx
}

func (c *ComputerTool) GetDisplayNumber() *float64 {
	if c == nil {
		return nil
	}
	return c.DisplayNumber
}

func (c *ComputerTool) Type() string {
	return c.type_
}

func (c *ComputerTool) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ComputerTool) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetMessages(messages []*ComputerToolMessagesItem) {
	c.Messages = messages
	c.require(computerToolFieldMessages)
}

// SetSubType sets the SubType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetSubType(subType ComputerToolSubType) {
	c.SubType = subType
	c.require(computerToolFieldSubType)
}

// SetServer sets the Server field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetServer(server *Server) {
	c.Server = server
	c.require(computerToolFieldServer)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetId(id string) {
	c.Id = id
	c.require(computerToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetOrgId(orgId string) {
	c.OrgId = orgId
	c.require(computerToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetCreatedAt(createdAt time.Time) {
	c.CreatedAt = createdAt
	c.require(computerToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetUpdatedAt(updatedAt time.Time) {
	c.UpdatedAt = updatedAt
	c.require(computerToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	c.RejectionPlan = rejectionPlan
	c.require(computerToolFieldRejectionPlan)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetName(name ComputerToolName) {
	c.Name = name
	c.require(computerToolFieldName)
}

// SetDisplayWidthPx sets the DisplayWidthPx field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetDisplayWidthPx(displayWidthPx float64) {
	c.DisplayWidthPx = displayWidthPx
	c.require(computerToolFieldDisplayWidthPx)
}

// SetDisplayHeightPx sets the DisplayHeightPx field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetDisplayHeightPx(displayHeightPx float64) {
	c.DisplayHeightPx = displayHeightPx
	c.require(computerToolFieldDisplayHeightPx)
}

// SetDisplayNumber sets the DisplayNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComputerTool) SetDisplayNumber(displayNumber *float64) {
	c.DisplayNumber = displayNumber
	c.require(computerToolFieldDisplayNumber)
}

func (c *ComputerTool) UnmarshalJSON(data []byte) error {
	type embed ComputerTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ComputerTool(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "computer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "computer", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ComputerTool) MarshalJSON() ([]byte, error) {
	type embed ComputerTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
		Type:      "computer",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ComputerTool) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ComputerToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *ComputerToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *ComputerToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *ComputerToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *ComputerToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *ComputerToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ComputerToolMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ComputerToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *ComputerToolMessagesItem) Accept(visitor ComputerToolMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// The name of the tool, fixed to 'computer'
type ComputerToolName string

const (
	ComputerToolNameComputer ComputerToolName = "computer"
)

func NewComputerToolNameFromString(s string) (ComputerToolName, error) {
	switch s {
	case "computer":
		return ComputerToolNameComputer, nil
	}
	var t ComputerToolName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComputerToolName) Ptr() *ComputerToolName {
	return &c
}

// The sub type of tool.
type ComputerToolSubType string

const (
	ComputerToolSubTypeComputer20241022 ComputerToolSubType = "computer_20241022"
)

func NewComputerToolSubTypeFromString(s string) (ComputerToolSubType, error) {
	switch s {
	case "computer_20241022":
		return ComputerToolSubTypeComputer20241022, nil
	}
	var t ComputerToolSubType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComputerToolSubType) Ptr() *ComputerToolSubType {
	return &c
}

var (
	dtmfToolFieldMessages      = big.NewInt(1 << 0)
	dtmfToolFieldId            = big.NewInt(1 << 1)
	dtmfToolFieldOrgId         = big.NewInt(1 << 2)
	dtmfToolFieldCreatedAt     = big.NewInt(1 << 3)
	dtmfToolFieldUpdatedAt     = big.NewInt(1 << 4)
	dtmfToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type DtmfTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*DtmfToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DtmfTool) GetMessages() []*DtmfToolMessagesItem {
	if d == nil {
		return nil
	}
	return d.Messages
}

func (d *DtmfTool) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DtmfTool) GetOrgId() string {
	if d == nil {
		return ""
	}
	return d.OrgId
}

func (d *DtmfTool) GetCreatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.CreatedAt
}

func (d *DtmfTool) GetUpdatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.UpdatedAt
}

func (d *DtmfTool) GetRejectionPlan() *ToolRejectionPlan {
	if d == nil {
		return nil
	}
	return d.RejectionPlan
}

func (d *DtmfTool) Type() string {
	return d.type_
}

func (d *DtmfTool) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DtmfTool) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DtmfTool) SetMessages(messages []*DtmfToolMessagesItem) {
	d.Messages = messages
	d.require(dtmfToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DtmfTool) SetId(id string) {
	d.Id = id
	d.require(dtmfToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DtmfTool) SetOrgId(orgId string) {
	d.OrgId = orgId
	d.require(dtmfToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DtmfTool) SetCreatedAt(createdAt time.Time) {
	d.CreatedAt = createdAt
	d.require(dtmfToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DtmfTool) SetUpdatedAt(updatedAt time.Time) {
	d.UpdatedAt = updatedAt
	d.require(dtmfToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DtmfTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	d.RejectionPlan = rejectionPlan
	d.require(dtmfToolFieldRejectionPlan)
}

func (d *DtmfTool) UnmarshalJSON(data []byte) error {
	type embed DtmfTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DtmfTool(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "dtmf" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "dtmf", unmarshaler.Type)
	}
	d.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "type")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DtmfTool) MarshalJSON() ([]byte, error) {
	type embed DtmfTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*d),
		CreatedAt: internal.NewDateTime(d.CreatedAt),
		UpdatedAt: internal.NewDateTime(d.UpdatedAt),
		Type:      "dtmf",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DtmfTool) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DtmfToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (d *DtmfToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if d == nil {
		return nil
	}
	return d.ToolMessageStart
}

func (d *DtmfToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if d == nil {
		return nil
	}
	return d.ToolMessageComplete
}

func (d *DtmfToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if d == nil {
		return nil
	}
	return d.ToolMessageFailed
}

func (d *DtmfToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if d == nil {
		return nil
	}
	return d.ToolMessageDelayed
}

func (d *DtmfToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		d.typ = "ToolMessageStart"
		d.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		d.typ = "ToolMessageComplete"
		d.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		d.typ = "ToolMessageFailed"
		d.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		d.typ = "ToolMessageDelayed"
		d.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DtmfToolMessagesItem) MarshalJSON() ([]byte, error) {
	if d.typ == "ToolMessageStart" || d.ToolMessageStart != nil {
		return json.Marshal(d.ToolMessageStart)
	}
	if d.typ == "ToolMessageComplete" || d.ToolMessageComplete != nil {
		return json.Marshal(d.ToolMessageComplete)
	}
	if d.typ == "ToolMessageFailed" || d.ToolMessageFailed != nil {
		return json.Marshal(d.ToolMessageFailed)
	}
	if d.typ == "ToolMessageDelayed" || d.ToolMessageDelayed != nil {
		return json.Marshal(d.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtmfToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (d *DtmfToolMessagesItem) Accept(visitor DtmfToolMessagesItemVisitor) error {
	if d.typ == "ToolMessageStart" || d.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(d.ToolMessageStart)
	}
	if d.typ == "ToolMessageComplete" || d.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(d.ToolMessageComplete)
	}
	if d.typ == "ToolMessageFailed" || d.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(d.ToolMessageFailed)
	}
	if d.typ == "ToolMessageDelayed" || d.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(d.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

var (
	endCallToolFieldMessages      = big.NewInt(1 << 0)
	endCallToolFieldId            = big.NewInt(1 << 1)
	endCallToolFieldOrgId         = big.NewInt(1 << 2)
	endCallToolFieldCreatedAt     = big.NewInt(1 << 3)
	endCallToolFieldUpdatedAt     = big.NewInt(1 << 4)
	endCallToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type EndCallTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*EndCallToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EndCallTool) GetMessages() []*EndCallToolMessagesItem {
	if e == nil {
		return nil
	}
	return e.Messages
}

func (e *EndCallTool) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EndCallTool) GetOrgId() string {
	if e == nil {
		return ""
	}
	return e.OrgId
}

func (e *EndCallTool) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *EndCallTool) GetUpdatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.UpdatedAt
}

func (e *EndCallTool) GetRejectionPlan() *ToolRejectionPlan {
	if e == nil {
		return nil
	}
	return e.RejectionPlan
}

func (e *EndCallTool) Type() string {
	return e.type_
}

func (e *EndCallTool) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndCallTool) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndCallTool) SetMessages(messages []*EndCallToolMessagesItem) {
	e.Messages = messages
	e.require(endCallToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndCallTool) SetId(id string) {
	e.Id = id
	e.require(endCallToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndCallTool) SetOrgId(orgId string) {
	e.OrgId = orgId
	e.require(endCallToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndCallTool) SetCreatedAt(createdAt time.Time) {
	e.CreatedAt = createdAt
	e.require(endCallToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndCallTool) SetUpdatedAt(updatedAt time.Time) {
	e.UpdatedAt = updatedAt
	e.require(endCallToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndCallTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	e.RejectionPlan = rejectionPlan
	e.require(endCallToolFieldRejectionPlan)
}

func (e *EndCallTool) UnmarshalJSON(data []byte) error {
	type embed EndCallTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EndCallTool(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "endCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "endCall", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EndCallTool) MarshalJSON() ([]byte, error) {
	type embed EndCallTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		UpdatedAt: internal.NewDateTime(e.UpdatedAt),
		Type:      "endCall",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EndCallTool) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EndCallToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (e *EndCallToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if e == nil {
		return nil
	}
	return e.ToolMessageStart
}

func (e *EndCallToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if e == nil {
		return nil
	}
	return e.ToolMessageComplete
}

func (e *EndCallToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if e == nil {
		return nil
	}
	return e.ToolMessageFailed
}

func (e *EndCallToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if e == nil {
		return nil
	}
	return e.ToolMessageDelayed
}

func (e *EndCallToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		e.typ = "ToolMessageStart"
		e.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		e.typ = "ToolMessageComplete"
		e.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		e.typ = "ToolMessageFailed"
		e.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		e.typ = "ToolMessageDelayed"
		e.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EndCallToolMessagesItem) MarshalJSON() ([]byte, error) {
	if e.typ == "ToolMessageStart" || e.ToolMessageStart != nil {
		return json.Marshal(e.ToolMessageStart)
	}
	if e.typ == "ToolMessageComplete" || e.ToolMessageComplete != nil {
		return json.Marshal(e.ToolMessageComplete)
	}
	if e.typ == "ToolMessageFailed" || e.ToolMessageFailed != nil {
		return json.Marshal(e.ToolMessageFailed)
	}
	if e.typ == "ToolMessageDelayed" || e.ToolMessageDelayed != nil {
		return json.Marshal(e.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EndCallToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (e *EndCallToolMessagesItem) Accept(visitor EndCallToolMessagesItemVisitor) error {
	if e.typ == "ToolMessageStart" || e.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(e.ToolMessageStart)
	}
	if e.typ == "ToolMessageComplete" || e.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(e.ToolMessageComplete)
	}
	if e.typ == "ToolMessageFailed" || e.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(e.ToolMessageFailed)
	}
	if e.typ == "ToolMessageDelayed" || e.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(e.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

var (
	functionToolFieldMessages      = big.NewInt(1 << 0)
	functionToolFieldAsync         = big.NewInt(1 << 1)
	functionToolFieldServer        = big.NewInt(1 << 2)
	functionToolFieldId            = big.NewInt(1 << 3)
	functionToolFieldOrgId         = big.NewInt(1 << 4)
	functionToolFieldCreatedAt     = big.NewInt(1 << 5)
	functionToolFieldUpdatedAt     = big.NewInt(1 << 6)
	functionToolFieldRejectionPlan = big.NewInt(1 << 7)
	functionToolFieldFunction      = big.NewInt(1 << 8)
)

type FunctionTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*FunctionToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines if the tool is async.
	//
	//	If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	//	If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	//	Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// This is the server where a `tool-calls` webhook will be sent.
	//
	// Notes:
	// - Webhook is sent to this server when a tool call is made.
	// - Webhook contains the call, assistant, and phone number objects.
	// - Webhook contains the variables set on the assistant.
	// - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
	// - Webhook expects a response with tool call result.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// This is the function definition of the tool.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FunctionTool) GetMessages() []*FunctionToolMessagesItem {
	if f == nil {
		return nil
	}
	return f.Messages
}

func (f *FunctionTool) GetAsync() *bool {
	if f == nil {
		return nil
	}
	return f.Async
}

func (f *FunctionTool) GetServer() *Server {
	if f == nil {
		return nil
	}
	return f.Server
}

func (f *FunctionTool) GetId() string {
	if f == nil {
		return ""
	}
	return f.Id
}

func (f *FunctionTool) GetOrgId() string {
	if f == nil {
		return ""
	}
	return f.OrgId
}

func (f *FunctionTool) GetCreatedAt() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.CreatedAt
}

func (f *FunctionTool) GetUpdatedAt() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.UpdatedAt
}

func (f *FunctionTool) GetRejectionPlan() *ToolRejectionPlan {
	if f == nil {
		return nil
	}
	return f.RejectionPlan
}

func (f *FunctionTool) GetFunction() *OpenAiFunction {
	if f == nil {
		return nil
	}
	return f.Function
}

func (f *FunctionTool) Type() string {
	return f.type_
}

func (f *FunctionTool) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FunctionTool) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FunctionTool) SetMessages(messages []*FunctionToolMessagesItem) {
	f.Messages = messages
	f.require(functionToolFieldMessages)
}

// SetAsync sets the Async field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FunctionTool) SetAsync(async *bool) {
	f.Async = async
	f.require(functionToolFieldAsync)
}

// SetServer sets the Server field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FunctionTool) SetServer(server *Server) {
	f.Server = server
	f.require(functionToolFieldServer)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FunctionTool) SetId(id string) {
	f.Id = id
	f.require(functionToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FunctionTool) SetOrgId(orgId string) {
	f.OrgId = orgId
	f.require(functionToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FunctionTool) SetCreatedAt(createdAt time.Time) {
	f.CreatedAt = createdAt
	f.require(functionToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FunctionTool) SetUpdatedAt(updatedAt time.Time) {
	f.UpdatedAt = updatedAt
	f.require(functionToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FunctionTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	f.RejectionPlan = rejectionPlan
	f.require(functionToolFieldRejectionPlan)
}

// SetFunction sets the Function field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FunctionTool) SetFunction(function *OpenAiFunction) {
	f.Function = function
	f.require(functionToolFieldFunction)
}

func (f *FunctionTool) UnmarshalJSON(data []byte) error {
	type embed FunctionTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FunctionTool(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.Time()
	f.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "function", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FunctionTool) MarshalJSON() ([]byte, error) {
	type embed FunctionTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*f),
		CreatedAt: internal.NewDateTime(f.CreatedAt),
		UpdatedAt: internal.NewDateTime(f.UpdatedAt),
		Type:      "function",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FunctionTool) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FunctionToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (f *FunctionToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if f == nil {
		return nil
	}
	return f.ToolMessageStart
}

func (f *FunctionToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if f == nil {
		return nil
	}
	return f.ToolMessageComplete
}

func (f *FunctionToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if f == nil {
		return nil
	}
	return f.ToolMessageFailed
}

func (f *FunctionToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if f == nil {
		return nil
	}
	return f.ToolMessageDelayed
}

func (f *FunctionToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		f.typ = "ToolMessageStart"
		f.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		f.typ = "ToolMessageComplete"
		f.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		f.typ = "ToolMessageFailed"
		f.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		f.typ = "ToolMessageDelayed"
		f.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FunctionToolMessagesItem) MarshalJSON() ([]byte, error) {
	if f.typ == "ToolMessageStart" || f.ToolMessageStart != nil {
		return json.Marshal(f.ToolMessageStart)
	}
	if f.typ == "ToolMessageComplete" || f.ToolMessageComplete != nil {
		return json.Marshal(f.ToolMessageComplete)
	}
	if f.typ == "ToolMessageFailed" || f.ToolMessageFailed != nil {
		return json.Marshal(f.ToolMessageFailed)
	}
	if f.typ == "ToolMessageDelayed" || f.ToolMessageDelayed != nil {
		return json.Marshal(f.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (f *FunctionToolMessagesItem) Accept(visitor FunctionToolMessagesItemVisitor) error {
	if f.typ == "ToolMessageStart" || f.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(f.ToolMessageStart)
	}
	if f.typ == "ToolMessageComplete" || f.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(f.ToolMessageComplete)
	}
	if f.typ == "ToolMessageFailed" || f.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(f.ToolMessageFailed)
	}
	if f.typ == "ToolMessageDelayed" || f.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(f.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

var (
	goHighLevelCalendarAvailabilityToolFieldMessages      = big.NewInt(1 << 0)
	goHighLevelCalendarAvailabilityToolFieldId            = big.NewInt(1 << 1)
	goHighLevelCalendarAvailabilityToolFieldOrgId         = big.NewInt(1 << 2)
	goHighLevelCalendarAvailabilityToolFieldCreatedAt     = big.NewInt(1 << 3)
	goHighLevelCalendarAvailabilityToolFieldUpdatedAt     = big.NewInt(1 << 4)
	goHighLevelCalendarAvailabilityToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type GoHighLevelCalendarAvailabilityTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelCalendarAvailabilityToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelCalendarAvailabilityTool) GetMessages() []*GoHighLevelCalendarAvailabilityToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelCalendarAvailabilityTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelCalendarAvailabilityTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelCalendarAvailabilityTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelCalendarAvailabilityTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelCalendarAvailabilityTool) GetRejectionPlan() *ToolRejectionPlan {
	if g == nil {
		return nil
	}
	return g.RejectionPlan
}

func (g *GoHighLevelCalendarAvailabilityTool) Type() string {
	return g.type_
}

func (g *GoHighLevelCalendarAvailabilityTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCalendarAvailabilityTool) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarAvailabilityTool) SetMessages(messages []*GoHighLevelCalendarAvailabilityToolMessagesItem) {
	g.Messages = messages
	g.require(goHighLevelCalendarAvailabilityToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarAvailabilityTool) SetId(id string) {
	g.Id = id
	g.require(goHighLevelCalendarAvailabilityToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarAvailabilityTool) SetOrgId(orgId string) {
	g.OrgId = orgId
	g.require(goHighLevelCalendarAvailabilityToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarAvailabilityTool) SetCreatedAt(createdAt time.Time) {
	g.CreatedAt = createdAt
	g.require(goHighLevelCalendarAvailabilityToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarAvailabilityTool) SetUpdatedAt(updatedAt time.Time) {
	g.UpdatedAt = updatedAt
	g.require(goHighLevelCalendarAvailabilityToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarAvailabilityTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	g.RejectionPlan = rejectionPlan
	g.require(goHighLevelCalendarAvailabilityToolFieldRejectionPlan)
}

func (g *GoHighLevelCalendarAvailabilityTool) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCalendarAvailabilityTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCalendarAvailabilityTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "gohighlevel.calendar.availability.check" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.calendar.availability.check", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCalendarAvailabilityTool) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCalendarAvailabilityTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "gohighlevel.calendar.availability.check",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GoHighLevelCalendarAvailabilityTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelCalendarAvailabilityToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelCalendarAvailabilityToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelCalendarAvailabilityToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) Accept(visitor GoHighLevelCalendarAvailabilityToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

var (
	goHighLevelCalendarEventCreateToolFieldMessages      = big.NewInt(1 << 0)
	goHighLevelCalendarEventCreateToolFieldId            = big.NewInt(1 << 1)
	goHighLevelCalendarEventCreateToolFieldOrgId         = big.NewInt(1 << 2)
	goHighLevelCalendarEventCreateToolFieldCreatedAt     = big.NewInt(1 << 3)
	goHighLevelCalendarEventCreateToolFieldUpdatedAt     = big.NewInt(1 << 4)
	goHighLevelCalendarEventCreateToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type GoHighLevelCalendarEventCreateTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelCalendarEventCreateToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelCalendarEventCreateTool) GetMessages() []*GoHighLevelCalendarEventCreateToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelCalendarEventCreateTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelCalendarEventCreateTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelCalendarEventCreateTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelCalendarEventCreateTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelCalendarEventCreateTool) GetRejectionPlan() *ToolRejectionPlan {
	if g == nil {
		return nil
	}
	return g.RejectionPlan
}

func (g *GoHighLevelCalendarEventCreateTool) Type() string {
	return g.type_
}

func (g *GoHighLevelCalendarEventCreateTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCalendarEventCreateTool) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarEventCreateTool) SetMessages(messages []*GoHighLevelCalendarEventCreateToolMessagesItem) {
	g.Messages = messages
	g.require(goHighLevelCalendarEventCreateToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarEventCreateTool) SetId(id string) {
	g.Id = id
	g.require(goHighLevelCalendarEventCreateToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarEventCreateTool) SetOrgId(orgId string) {
	g.OrgId = orgId
	g.require(goHighLevelCalendarEventCreateToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarEventCreateTool) SetCreatedAt(createdAt time.Time) {
	g.CreatedAt = createdAt
	g.require(goHighLevelCalendarEventCreateToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarEventCreateTool) SetUpdatedAt(updatedAt time.Time) {
	g.UpdatedAt = updatedAt
	g.require(goHighLevelCalendarEventCreateToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelCalendarEventCreateTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	g.RejectionPlan = rejectionPlan
	g.require(goHighLevelCalendarEventCreateToolFieldRejectionPlan)
}

func (g *GoHighLevelCalendarEventCreateTool) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCalendarEventCreateTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCalendarEventCreateTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "gohighlevel.calendar.event.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.calendar.event.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCalendarEventCreateTool) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCalendarEventCreateTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "gohighlevel.calendar.event.create",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GoHighLevelCalendarEventCreateTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelCalendarEventCreateToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelCalendarEventCreateToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelCalendarEventCreateToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) Accept(visitor GoHighLevelCalendarEventCreateToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

var (
	goHighLevelContactCreateToolFieldMessages      = big.NewInt(1 << 0)
	goHighLevelContactCreateToolFieldId            = big.NewInt(1 << 1)
	goHighLevelContactCreateToolFieldOrgId         = big.NewInt(1 << 2)
	goHighLevelContactCreateToolFieldCreatedAt     = big.NewInt(1 << 3)
	goHighLevelContactCreateToolFieldUpdatedAt     = big.NewInt(1 << 4)
	goHighLevelContactCreateToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type GoHighLevelContactCreateTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelContactCreateToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelContactCreateTool) GetMessages() []*GoHighLevelContactCreateToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelContactCreateTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelContactCreateTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelContactCreateTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelContactCreateTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelContactCreateTool) GetRejectionPlan() *ToolRejectionPlan {
	if g == nil {
		return nil
	}
	return g.RejectionPlan
}

func (g *GoHighLevelContactCreateTool) Type() string {
	return g.type_
}

func (g *GoHighLevelContactCreateTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelContactCreateTool) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactCreateTool) SetMessages(messages []*GoHighLevelContactCreateToolMessagesItem) {
	g.Messages = messages
	g.require(goHighLevelContactCreateToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactCreateTool) SetId(id string) {
	g.Id = id
	g.require(goHighLevelContactCreateToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactCreateTool) SetOrgId(orgId string) {
	g.OrgId = orgId
	g.require(goHighLevelContactCreateToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactCreateTool) SetCreatedAt(createdAt time.Time) {
	g.CreatedAt = createdAt
	g.require(goHighLevelContactCreateToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactCreateTool) SetUpdatedAt(updatedAt time.Time) {
	g.UpdatedAt = updatedAt
	g.require(goHighLevelContactCreateToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactCreateTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	g.RejectionPlan = rejectionPlan
	g.require(goHighLevelContactCreateToolFieldRejectionPlan)
}

func (g *GoHighLevelContactCreateTool) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelContactCreateTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelContactCreateTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "gohighlevel.contact.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.contact.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelContactCreateTool) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelContactCreateTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "gohighlevel.contact.create",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GoHighLevelContactCreateTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelContactCreateToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelContactCreateToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelContactCreateToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelContactCreateToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelContactCreateToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelContactCreateToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelContactCreateToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelContactCreateToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelContactCreateToolMessagesItem) Accept(visitor GoHighLevelContactCreateToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

var (
	goHighLevelContactGetToolFieldMessages      = big.NewInt(1 << 0)
	goHighLevelContactGetToolFieldId            = big.NewInt(1 << 1)
	goHighLevelContactGetToolFieldOrgId         = big.NewInt(1 << 2)
	goHighLevelContactGetToolFieldCreatedAt     = big.NewInt(1 << 3)
	goHighLevelContactGetToolFieldUpdatedAt     = big.NewInt(1 << 4)
	goHighLevelContactGetToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type GoHighLevelContactGetTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelContactGetToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelContactGetTool) GetMessages() []*GoHighLevelContactGetToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelContactGetTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelContactGetTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelContactGetTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelContactGetTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelContactGetTool) GetRejectionPlan() *ToolRejectionPlan {
	if g == nil {
		return nil
	}
	return g.RejectionPlan
}

func (g *GoHighLevelContactGetTool) Type() string {
	return g.type_
}

func (g *GoHighLevelContactGetTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelContactGetTool) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactGetTool) SetMessages(messages []*GoHighLevelContactGetToolMessagesItem) {
	g.Messages = messages
	g.require(goHighLevelContactGetToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactGetTool) SetId(id string) {
	g.Id = id
	g.require(goHighLevelContactGetToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactGetTool) SetOrgId(orgId string) {
	g.OrgId = orgId
	g.require(goHighLevelContactGetToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactGetTool) SetCreatedAt(createdAt time.Time) {
	g.CreatedAt = createdAt
	g.require(goHighLevelContactGetToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactGetTool) SetUpdatedAt(updatedAt time.Time) {
	g.UpdatedAt = updatedAt
	g.require(goHighLevelContactGetToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoHighLevelContactGetTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	g.RejectionPlan = rejectionPlan
	g.require(goHighLevelContactGetToolFieldRejectionPlan)
}

func (g *GoHighLevelContactGetTool) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelContactGetTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelContactGetTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "gohighlevel.contact.get" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.contact.get", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelContactGetTool) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelContactGetTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "gohighlevel.contact.get",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GoHighLevelContactGetTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelContactGetToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelContactGetToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelContactGetToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelContactGetToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelContactGetToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelContactGetToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelContactGetToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelContactGetToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelContactGetToolMessagesItem) Accept(visitor GoHighLevelContactGetToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

var (
	googleCalendarCheckAvailabilityToolFieldMessages      = big.NewInt(1 << 0)
	googleCalendarCheckAvailabilityToolFieldId            = big.NewInt(1 << 1)
	googleCalendarCheckAvailabilityToolFieldOrgId         = big.NewInt(1 << 2)
	googleCalendarCheckAvailabilityToolFieldCreatedAt     = big.NewInt(1 << 3)
	googleCalendarCheckAvailabilityToolFieldUpdatedAt     = big.NewInt(1 << 4)
	googleCalendarCheckAvailabilityToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type GoogleCalendarCheckAvailabilityTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoogleCalendarCheckAvailabilityToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleCalendarCheckAvailabilityTool) GetMessages() []*GoogleCalendarCheckAvailabilityToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoogleCalendarCheckAvailabilityTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleCalendarCheckAvailabilityTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleCalendarCheckAvailabilityTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleCalendarCheckAvailabilityTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleCalendarCheckAvailabilityTool) GetRejectionPlan() *ToolRejectionPlan {
	if g == nil {
		return nil
	}
	return g.RejectionPlan
}

func (g *GoogleCalendarCheckAvailabilityTool) Type() string {
	return g.type_
}

func (g *GoogleCalendarCheckAvailabilityTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleCalendarCheckAvailabilityTool) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCheckAvailabilityTool) SetMessages(messages []*GoogleCalendarCheckAvailabilityToolMessagesItem) {
	g.Messages = messages
	g.require(googleCalendarCheckAvailabilityToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCheckAvailabilityTool) SetId(id string) {
	g.Id = id
	g.require(googleCalendarCheckAvailabilityToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCheckAvailabilityTool) SetOrgId(orgId string) {
	g.OrgId = orgId
	g.require(googleCalendarCheckAvailabilityToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCheckAvailabilityTool) SetCreatedAt(createdAt time.Time) {
	g.CreatedAt = createdAt
	g.require(googleCalendarCheckAvailabilityToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCheckAvailabilityTool) SetUpdatedAt(updatedAt time.Time) {
	g.UpdatedAt = updatedAt
	g.require(googleCalendarCheckAvailabilityToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCheckAvailabilityTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	g.RejectionPlan = rejectionPlan
	g.require(googleCalendarCheckAvailabilityToolFieldRejectionPlan)
}

func (g *GoogleCalendarCheckAvailabilityTool) UnmarshalJSON(data []byte) error {
	type embed GoogleCalendarCheckAvailabilityTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleCalendarCheckAvailabilityTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "google.calendar.availability.check" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.calendar.availability.check", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleCalendarCheckAvailabilityTool) MarshalJSON() ([]byte, error) {
	type embed GoogleCalendarCheckAvailabilityTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "google.calendar.availability.check",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GoogleCalendarCheckAvailabilityTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleCalendarCheckAvailabilityToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoogleCalendarCheckAvailabilityToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleCalendarCheckAvailabilityToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) Accept(visitor GoogleCalendarCheckAvailabilityToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

var (
	googleCalendarCreateEventToolFieldMessages      = big.NewInt(1 << 0)
	googleCalendarCreateEventToolFieldId            = big.NewInt(1 << 1)
	googleCalendarCreateEventToolFieldOrgId         = big.NewInt(1 << 2)
	googleCalendarCreateEventToolFieldCreatedAt     = big.NewInt(1 << 3)
	googleCalendarCreateEventToolFieldUpdatedAt     = big.NewInt(1 << 4)
	googleCalendarCreateEventToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type GoogleCalendarCreateEventTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoogleCalendarCreateEventToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleCalendarCreateEventTool) GetMessages() []*GoogleCalendarCreateEventToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoogleCalendarCreateEventTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleCalendarCreateEventTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleCalendarCreateEventTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleCalendarCreateEventTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleCalendarCreateEventTool) GetRejectionPlan() *ToolRejectionPlan {
	if g == nil {
		return nil
	}
	return g.RejectionPlan
}

func (g *GoogleCalendarCreateEventTool) Type() string {
	return g.type_
}

func (g *GoogleCalendarCreateEventTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleCalendarCreateEventTool) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCreateEventTool) SetMessages(messages []*GoogleCalendarCreateEventToolMessagesItem) {
	g.Messages = messages
	g.require(googleCalendarCreateEventToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCreateEventTool) SetId(id string) {
	g.Id = id
	g.require(googleCalendarCreateEventToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCreateEventTool) SetOrgId(orgId string) {
	g.OrgId = orgId
	g.require(googleCalendarCreateEventToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCreateEventTool) SetCreatedAt(createdAt time.Time) {
	g.CreatedAt = createdAt
	g.require(googleCalendarCreateEventToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCreateEventTool) SetUpdatedAt(updatedAt time.Time) {
	g.UpdatedAt = updatedAt
	g.require(googleCalendarCreateEventToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleCalendarCreateEventTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	g.RejectionPlan = rejectionPlan
	g.require(googleCalendarCreateEventToolFieldRejectionPlan)
}

func (g *GoogleCalendarCreateEventTool) UnmarshalJSON(data []byte) error {
	type embed GoogleCalendarCreateEventTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleCalendarCreateEventTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "google.calendar.event.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.calendar.event.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleCalendarCreateEventTool) MarshalJSON() ([]byte, error) {
	type embed GoogleCalendarCreateEventTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "google.calendar.event.create",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GoogleCalendarCreateEventTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleCalendarCreateEventToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoogleCalendarCreateEventToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoogleCalendarCreateEventToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoogleCalendarCreateEventToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoogleCalendarCreateEventToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoogleCalendarCreateEventToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoogleCalendarCreateEventToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleCalendarCreateEventToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoogleCalendarCreateEventToolMessagesItem) Accept(visitor GoogleCalendarCreateEventToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

var (
	googleSheetsRowAppendToolFieldMessages      = big.NewInt(1 << 0)
	googleSheetsRowAppendToolFieldId            = big.NewInt(1 << 1)
	googleSheetsRowAppendToolFieldOrgId         = big.NewInt(1 << 2)
	googleSheetsRowAppendToolFieldCreatedAt     = big.NewInt(1 << 3)
	googleSheetsRowAppendToolFieldUpdatedAt     = big.NewInt(1 << 4)
	googleSheetsRowAppendToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type GoogleSheetsRowAppendTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoogleSheetsRowAppendToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleSheetsRowAppendTool) GetMessages() []*GoogleSheetsRowAppendToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoogleSheetsRowAppendTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleSheetsRowAppendTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleSheetsRowAppendTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleSheetsRowAppendTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleSheetsRowAppendTool) GetRejectionPlan() *ToolRejectionPlan {
	if g == nil {
		return nil
	}
	return g.RejectionPlan
}

func (g *GoogleSheetsRowAppendTool) Type() string {
	return g.type_
}

func (g *GoogleSheetsRowAppendTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleSheetsRowAppendTool) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleSheetsRowAppendTool) SetMessages(messages []*GoogleSheetsRowAppendToolMessagesItem) {
	g.Messages = messages
	g.require(googleSheetsRowAppendToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleSheetsRowAppendTool) SetId(id string) {
	g.Id = id
	g.require(googleSheetsRowAppendToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleSheetsRowAppendTool) SetOrgId(orgId string) {
	g.OrgId = orgId
	g.require(googleSheetsRowAppendToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleSheetsRowAppendTool) SetCreatedAt(createdAt time.Time) {
	g.CreatedAt = createdAt
	g.require(googleSheetsRowAppendToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleSheetsRowAppendTool) SetUpdatedAt(updatedAt time.Time) {
	g.UpdatedAt = updatedAt
	g.require(googleSheetsRowAppendToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoogleSheetsRowAppendTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	g.RejectionPlan = rejectionPlan
	g.require(googleSheetsRowAppendToolFieldRejectionPlan)
}

func (g *GoogleSheetsRowAppendTool) UnmarshalJSON(data []byte) error {
	type embed GoogleSheetsRowAppendTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleSheetsRowAppendTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "google.sheets.row.append" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.sheets.row.append", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleSheetsRowAppendTool) MarshalJSON() ([]byte, error) {
	type embed GoogleSheetsRowAppendTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "google.sheets.row.append",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GoogleSheetsRowAppendTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleSheetsRowAppendToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoogleSheetsRowAppendToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoogleSheetsRowAppendToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoogleSheetsRowAppendToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoogleSheetsRowAppendToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoogleSheetsRowAppendToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoogleSheetsRowAppendToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleSheetsRowAppendToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoogleSheetsRowAppendToolMessagesItem) Accept(visitor GoogleSheetsRowAppendToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

var (
	handoffToolFieldMessages      = big.NewInt(1 << 0)
	handoffToolFieldDestinations  = big.NewInt(1 << 1)
	handoffToolFieldId            = big.NewInt(1 << 2)
	handoffToolFieldOrgId         = big.NewInt(1 << 3)
	handoffToolFieldCreatedAt     = big.NewInt(1 << 4)
	handoffToolFieldUpdatedAt     = big.NewInt(1 << 5)
	handoffToolFieldRejectionPlan = big.NewInt(1 << 6)
	handoffToolFieldFunction      = big.NewInt(1 << 7)
)

type HandoffTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*HandoffToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the destinations that the call can be handed off to.
	//
	// Usage:
	// 1. Single destination
	//
	// Use `assistantId` to handoff the call to a saved assistant, or `assistantName` to handoff the call to an assistant in the same squad.
	//
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-123", // or "assistantName": "Assistant123"
	//	          "description": "customer wants to be handed off to assistant-123",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        }
	//	      ],
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// 2. Multiple destinations
	//
	// 2.1. Multiple Tools, Each With One Destination (OpenAI recommended)
	//
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-123",
	//	          "description": "customer wants to be handed off to assistant-123",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        },
	//	      ],
	//	    },
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-456",
	//	          "description": "customer wants to be handed off to assistant-456",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        }
	//	      ],
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// 2.2. One Tool, Multiple Destinations (Anthropic recommended)
	//
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-123",
	//	          "description": "customer wants to be handed off to assistant-123",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        },
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-456",
	//	          "description": "customer wants to be handed off to assistant-456",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        }
	//	      ],
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// 3. Dynamic destination
	//
	// 3.1 To determine the destination dynamically, supply a `dynamic` handoff destination type and a `server` object.
	//
	//	VAPI will send a handoff-destination-request webhook to the `server.url`.
	//	The response from the server will be used as the destination (if valid).
	//
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "dynamic",
	//	          "server": {
	//	            "url": "https://example.com"
	//	          }
	//	        }
	//	      ],
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// 3.2. To pass custom parameters to the server, you can use the `function` object.
	//
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "dynamic",
	//	          "server": {
	//	            "url": "https://example.com"
	//	          },
	//	        }
	//	      ],
	//	      "function": {
	//	        "name": "handoff",
	//	        "description": "Call this function when the customer is ready to be handed off to the next assistant",
	//	        "parameters": {
	//	          "type": "object",
	//	          "properties": {
	//	            "destination": {
	//	              "type": "string",
	//	              "description": "Use dynamic when customer is ready to be handed off to the next assistant",
	//	              "enum": ["dynamic"]
	//	            },
	//	            "customerAreaCode": {
	//	              "type": "number",
	//	              "description": "Area code of the customer"
	//	            },
	//	            "customerIntent": {
	//	              "type": "string",
	//	              "enum": ["new-customer", "existing-customer"],
	//	              "description": "Use new-customer when customer is a new customer, existing-customer when customer is an existing customer"
	//	            },
	//	            "customerSentiment": {
	//	              "type": "string",
	//	              "enum": ["positive", "negative", "neutral"],
	//	              "description": "Use positive when customer is happy, negative when customer is unhappy, neutral when customer is neutral"
	//	            }
	//	          }
	//	        }
	//	      }
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// The properties `customerAreaCode`, `customerIntent`, and `customerSentiment` will be passed to the server in the webhook request body.
	Destinations []*HandoffToolDestinationsItem `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// This is the optional function definition that will be passed to the LLM.
	// If this is not defined, we will construct this based on the other properties.
	//
	// For example, given the following tools definition:
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-123",
	//	          "description": "customer wants to be handed off to assistant-123",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        },
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-456",
	//	          "description": "customer wants to be handed off to assistant-456",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        }
	//	      ],
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// We will construct the following function definition:
	// ```json
	//
	//	{
	//	  "function": {
	//	    "name": "handoff_to_assistant-123",
	//	    "description": "
	//	         Use this function to handoff the call to the next assistant.
	//	         Only use it when instructions explicitly ask you to use the handoff_to_assistant function.
	//	         DO NOT call this function unless you are instructed to do so.
	//	         Here are the destinations you can handoff the call to:
	//	         1. assistant-123. When: customer wants to be handed off to assistant-123
	//	         2. assistant-456. When: customer wants to be handed off to assistant-456
	//	    ",
	//	    "parameters": {
	//	      "type": "object",
	//	      "properties": {
	//	        "destination": {
	//	          "type": "string",
	//	          "description": "Options: assistant-123 (customer wants to be handed off to assistant-123), assistant-456 (customer wants to be handed off to assistant-456)",
	//	          "enum": ["assistant-123", "assistant-456"]
	//	        },
	//	      },
	//	      "required": ["destination"]
	//	    }
	//	  }
	//	}
	//
	// ```
	//
	// To override this function, please provide an OpenAI function definition and refer to it in the system prompt.
	// You may override parts of the function definition (i.e. you may only want to change the function name for your prompt).
	// If you choose to override the function parameters, it must include `destination` as a required parameter, and it must evaluate to either an assistantId, assistantName, or a the string literal `dynamic`.
	//
	// To pass custom parameters to the server in a dynamic handoff, you can use the function parameters, with `dynamic` as the destination.
	// ```json
	//
	//	{
	//	  "function": {
	//	    "name": "dynamic_handoff",
	//	    "description": "
	//	         Call this function when the customer is ready to be handed off to the next assistant
	//	    ",
	//	    "parameters": {
	//	      "type": "object",
	//	      "properties": {
	//	        "destination": {
	//	          "type": "string",
	//	          "enum": ["dynamic"]
	//	        },
	//	        "customerAreaCode": {
	//	          "type": "number",
	//	          "description": "Area code of the customer"
	//	        },
	//	        "customerIntent": {
	//	          "type": "string",
	//	          "enum": ["new-customer", "existing-customer"],
	//	          "description": "Use new-customer when customer is a new customer, existing-customer when customer is an existing customer"
	//	        },
	//	        "customerSentiment": {
	//	          "type": "string",
	//	          "enum": ["positive", "negative", "neutral"],
	//	          "description": "Use positive when customer is happy, negative when customer is unhappy, neutral when customer is neutral"
	//	        }
	//	      },
	//	      "required": ["destination", "customerAreaCode", "customerIntent", "customerSentiment"]
	//	    }
	//	  }
	//	}
	//
	// ```
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HandoffTool) GetMessages() []*HandoffToolMessagesItem {
	if h == nil {
		return nil
	}
	return h.Messages
}

func (h *HandoffTool) GetDestinations() []*HandoffToolDestinationsItem {
	if h == nil {
		return nil
	}
	return h.Destinations
}

func (h *HandoffTool) GetId() string {
	if h == nil {
		return ""
	}
	return h.Id
}

func (h *HandoffTool) GetOrgId() string {
	if h == nil {
		return ""
	}
	return h.OrgId
}

func (h *HandoffTool) GetCreatedAt() time.Time {
	if h == nil {
		return time.Time{}
	}
	return h.CreatedAt
}

func (h *HandoffTool) GetUpdatedAt() time.Time {
	if h == nil {
		return time.Time{}
	}
	return h.UpdatedAt
}

func (h *HandoffTool) GetRejectionPlan() *ToolRejectionPlan {
	if h == nil {
		return nil
	}
	return h.RejectionPlan
}

func (h *HandoffTool) GetFunction() *OpenAiFunction {
	if h == nil {
		return nil
	}
	return h.Function
}

func (h *HandoffTool) Type() string {
	return h.type_
}

func (h *HandoffTool) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HandoffTool) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandoffTool) SetMessages(messages []*HandoffToolMessagesItem) {
	h.Messages = messages
	h.require(handoffToolFieldMessages)
}

// SetDestinations sets the Destinations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandoffTool) SetDestinations(destinations []*HandoffToolDestinationsItem) {
	h.Destinations = destinations
	h.require(handoffToolFieldDestinations)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandoffTool) SetId(id string) {
	h.Id = id
	h.require(handoffToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandoffTool) SetOrgId(orgId string) {
	h.OrgId = orgId
	h.require(handoffToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandoffTool) SetCreatedAt(createdAt time.Time) {
	h.CreatedAt = createdAt
	h.require(handoffToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandoffTool) SetUpdatedAt(updatedAt time.Time) {
	h.UpdatedAt = updatedAt
	h.require(handoffToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandoffTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	h.RejectionPlan = rejectionPlan
	h.require(handoffToolFieldRejectionPlan)
}

// SetFunction sets the Function field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandoffTool) SetFunction(function *OpenAiFunction) {
	h.Function = function
	h.require(handoffToolFieldFunction)
}

func (h *HandoffTool) UnmarshalJSON(data []byte) error {
	type embed HandoffTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HandoffTool(unmarshaler.embed)
	h.CreatedAt = unmarshaler.CreatedAt.Time()
	h.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "handoff" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", h, "handoff", unmarshaler.Type)
	}
	h.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *h, "type")
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HandoffTool) MarshalJSON() ([]byte, error) {
	type embed HandoffTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*h),
		CreatedAt: internal.NewDateTime(h.CreatedAt),
		UpdatedAt: internal.NewDateTime(h.UpdatedAt),
		Type:      "handoff",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HandoffTool) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HandoffToolDestinationsItem struct {
	HandoffDestinationAssistant *HandoffDestinationAssistant
	HandoffDestinationDynamic   *HandoffDestinationDynamic

	typ string
}

func (h *HandoffToolDestinationsItem) GetHandoffDestinationAssistant() *HandoffDestinationAssistant {
	if h == nil {
		return nil
	}
	return h.HandoffDestinationAssistant
}

func (h *HandoffToolDestinationsItem) GetHandoffDestinationDynamic() *HandoffDestinationDynamic {
	if h == nil {
		return nil
	}
	return h.HandoffDestinationDynamic
}

func (h *HandoffToolDestinationsItem) UnmarshalJSON(data []byte) error {
	valueHandoffDestinationAssistant := new(HandoffDestinationAssistant)
	if err := json.Unmarshal(data, &valueHandoffDestinationAssistant); err == nil {
		h.typ = "HandoffDestinationAssistant"
		h.HandoffDestinationAssistant = valueHandoffDestinationAssistant
		return nil
	}
	valueHandoffDestinationDynamic := new(HandoffDestinationDynamic)
	if err := json.Unmarshal(data, &valueHandoffDestinationDynamic); err == nil {
		h.typ = "HandoffDestinationDynamic"
		h.HandoffDestinationDynamic = valueHandoffDestinationDynamic
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HandoffToolDestinationsItem) MarshalJSON() ([]byte, error) {
	if h.typ == "HandoffDestinationAssistant" || h.HandoffDestinationAssistant != nil {
		return json.Marshal(h.HandoffDestinationAssistant)
	}
	if h.typ == "HandoffDestinationDynamic" || h.HandoffDestinationDynamic != nil {
		return json.Marshal(h.HandoffDestinationDynamic)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HandoffToolDestinationsItemVisitor interface {
	VisitHandoffDestinationAssistant(*HandoffDestinationAssistant) error
	VisitHandoffDestinationDynamic(*HandoffDestinationDynamic) error
}

func (h *HandoffToolDestinationsItem) Accept(visitor HandoffToolDestinationsItemVisitor) error {
	if h.typ == "HandoffDestinationAssistant" || h.HandoffDestinationAssistant != nil {
		return visitor.VisitHandoffDestinationAssistant(h.HandoffDestinationAssistant)
	}
	if h.typ == "HandoffDestinationDynamic" || h.HandoffDestinationDynamic != nil {
		return visitor.VisitHandoffDestinationDynamic(h.HandoffDestinationDynamic)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HandoffToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (h *HandoffToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if h == nil {
		return nil
	}
	return h.ToolMessageStart
}

func (h *HandoffToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if h == nil {
		return nil
	}
	return h.ToolMessageComplete
}

func (h *HandoffToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if h == nil {
		return nil
	}
	return h.ToolMessageFailed
}

func (h *HandoffToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if h == nil {
		return nil
	}
	return h.ToolMessageDelayed
}

func (h *HandoffToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		h.typ = "ToolMessageStart"
		h.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		h.typ = "ToolMessageComplete"
		h.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		h.typ = "ToolMessageFailed"
		h.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		h.typ = "ToolMessageDelayed"
		h.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HandoffToolMessagesItem) MarshalJSON() ([]byte, error) {
	if h.typ == "ToolMessageStart" || h.ToolMessageStart != nil {
		return json.Marshal(h.ToolMessageStart)
	}
	if h.typ == "ToolMessageComplete" || h.ToolMessageComplete != nil {
		return json.Marshal(h.ToolMessageComplete)
	}
	if h.typ == "ToolMessageFailed" || h.ToolMessageFailed != nil {
		return json.Marshal(h.ToolMessageFailed)
	}
	if h.typ == "ToolMessageDelayed" || h.ToolMessageDelayed != nil {
		return json.Marshal(h.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HandoffToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (h *HandoffToolMessagesItem) Accept(visitor HandoffToolMessagesItemVisitor) error {
	if h.typ == "ToolMessageStart" || h.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(h.ToolMessageStart)
	}
	if h.typ == "ToolMessageComplete" || h.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(h.ToolMessageComplete)
	}
	if h.typ == "ToolMessageFailed" || h.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(h.ToolMessageFailed)
	}
	if h.typ == "ToolMessageDelayed" || h.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(h.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", h)
}

var (
	mcpToolFieldMessages      = big.NewInt(1 << 0)
	mcpToolFieldServer        = big.NewInt(1 << 1)
	mcpToolFieldId            = big.NewInt(1 << 2)
	mcpToolFieldOrgId         = big.NewInt(1 << 3)
	mcpToolFieldCreatedAt     = big.NewInt(1 << 4)
	mcpToolFieldUpdatedAt     = big.NewInt(1 << 5)
	mcpToolFieldRejectionPlan = big.NewInt(1 << 6)
	mcpToolFieldMetadata      = big.NewInt(1 << 7)
)

type McpTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*McpToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the server where a `tool-calls` webhook will be sent.
	//
	// Notes:
	// - Webhook is sent to this server when a tool call is made.
	// - Webhook contains the call, assistant, and phone number objects.
	// - Webhook contains the variables set on the assistant.
	// - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
	// - Webhook expects a response with tool call result.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	Metadata      *McpToolMetadata   `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *McpTool) GetMessages() []*McpToolMessagesItem {
	if m == nil {
		return nil
	}
	return m.Messages
}

func (m *McpTool) GetServer() *Server {
	if m == nil {
		return nil
	}
	return m.Server
}

func (m *McpTool) GetId() string {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *McpTool) GetOrgId() string {
	if m == nil {
		return ""
	}
	return m.OrgId
}

func (m *McpTool) GetCreatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.CreatedAt
}

func (m *McpTool) GetUpdatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.UpdatedAt
}

func (m *McpTool) GetRejectionPlan() *ToolRejectionPlan {
	if m == nil {
		return nil
	}
	return m.RejectionPlan
}

func (m *McpTool) GetMetadata() *McpToolMetadata {
	if m == nil {
		return nil
	}
	return m.Metadata
}

func (m *McpTool) Type() string {
	return m.type_
}

func (m *McpTool) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *McpTool) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *McpTool) SetMessages(messages []*McpToolMessagesItem) {
	m.Messages = messages
	m.require(mcpToolFieldMessages)
}

// SetServer sets the Server field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *McpTool) SetServer(server *Server) {
	m.Server = server
	m.require(mcpToolFieldServer)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *McpTool) SetId(id string) {
	m.Id = id
	m.require(mcpToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *McpTool) SetOrgId(orgId string) {
	m.OrgId = orgId
	m.require(mcpToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *McpTool) SetCreatedAt(createdAt time.Time) {
	m.CreatedAt = createdAt
	m.require(mcpToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *McpTool) SetUpdatedAt(updatedAt time.Time) {
	m.UpdatedAt = updatedAt
	m.require(mcpToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *McpTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	m.RejectionPlan = rejectionPlan
	m.require(mcpToolFieldRejectionPlan)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *McpTool) SetMetadata(metadata *McpToolMetadata) {
	m.Metadata = metadata
	m.require(mcpToolFieldMetadata)
}

func (m *McpTool) UnmarshalJSON(data []byte) error {
	type embed McpTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = McpTool(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "mcp" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "mcp", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *McpTool) MarshalJSON() ([]byte, error) {
	type embed McpTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*m),
		CreatedAt: internal.NewDateTime(m.CreatedAt),
		UpdatedAt: internal.NewDateTime(m.UpdatedAt),
		Type:      "mcp",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *McpTool) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type McpToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (m *McpToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if m == nil {
		return nil
	}
	return m.ToolMessageStart
}

func (m *McpToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if m == nil {
		return nil
	}
	return m.ToolMessageComplete
}

func (m *McpToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if m == nil {
		return nil
	}
	return m.ToolMessageFailed
}

func (m *McpToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if m == nil {
		return nil
	}
	return m.ToolMessageDelayed
}

func (m *McpToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		m.typ = "ToolMessageStart"
		m.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		m.typ = "ToolMessageComplete"
		m.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		m.typ = "ToolMessageFailed"
		m.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		m.typ = "ToolMessageDelayed"
		m.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m McpToolMessagesItem) MarshalJSON() ([]byte, error) {
	if m.typ == "ToolMessageStart" || m.ToolMessageStart != nil {
		return json.Marshal(m.ToolMessageStart)
	}
	if m.typ == "ToolMessageComplete" || m.ToolMessageComplete != nil {
		return json.Marshal(m.ToolMessageComplete)
	}
	if m.typ == "ToolMessageFailed" || m.ToolMessageFailed != nil {
		return json.Marshal(m.ToolMessageFailed)
	}
	if m.typ == "ToolMessageDelayed" || m.ToolMessageDelayed != nil {
		return json.Marshal(m.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type McpToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (m *McpToolMessagesItem) Accept(visitor McpToolMessagesItemVisitor) error {
	if m.typ == "ToolMessageStart" || m.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(m.ToolMessageStart)
	}
	if m.typ == "ToolMessageComplete" || m.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(m.ToolMessageComplete)
	}
	if m.typ == "ToolMessageFailed" || m.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(m.ToolMessageFailed)
	}
	if m.typ == "ToolMessageDelayed" || m.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(m.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

var (
	queryToolFieldMessages       = big.NewInt(1 << 0)
	queryToolFieldKnowledgeBases = big.NewInt(1 << 1)
	queryToolFieldId             = big.NewInt(1 << 2)
	queryToolFieldOrgId          = big.NewInt(1 << 3)
	queryToolFieldCreatedAt      = big.NewInt(1 << 4)
	queryToolFieldUpdatedAt      = big.NewInt(1 << 5)
	queryToolFieldRejectionPlan  = big.NewInt(1 << 6)
)

type QueryTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*QueryToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The knowledge bases to query
	KnowledgeBases []*KnowledgeBase `json:"knowledgeBases,omitempty" url:"knowledgeBases,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryTool) GetMessages() []*QueryToolMessagesItem {
	if q == nil {
		return nil
	}
	return q.Messages
}

func (q *QueryTool) GetKnowledgeBases() []*KnowledgeBase {
	if q == nil {
		return nil
	}
	return q.KnowledgeBases
}

func (q *QueryTool) GetId() string {
	if q == nil {
		return ""
	}
	return q.Id
}

func (q *QueryTool) GetOrgId() string {
	if q == nil {
		return ""
	}
	return q.OrgId
}

func (q *QueryTool) GetCreatedAt() time.Time {
	if q == nil {
		return time.Time{}
	}
	return q.CreatedAt
}

func (q *QueryTool) GetUpdatedAt() time.Time {
	if q == nil {
		return time.Time{}
	}
	return q.UpdatedAt
}

func (q *QueryTool) GetRejectionPlan() *ToolRejectionPlan {
	if q == nil {
		return nil
	}
	return q.RejectionPlan
}

func (q *QueryTool) Type() string {
	return q.type_
}

func (q *QueryTool) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryTool) require(field *big.Int) {
	if q.explicitFields == nil {
		q.explicitFields = big.NewInt(0)
	}
	q.explicitFields.Or(q.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryTool) SetMessages(messages []*QueryToolMessagesItem) {
	q.Messages = messages
	q.require(queryToolFieldMessages)
}

// SetKnowledgeBases sets the KnowledgeBases field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryTool) SetKnowledgeBases(knowledgeBases []*KnowledgeBase) {
	q.KnowledgeBases = knowledgeBases
	q.require(queryToolFieldKnowledgeBases)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryTool) SetId(id string) {
	q.Id = id
	q.require(queryToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryTool) SetOrgId(orgId string) {
	q.OrgId = orgId
	q.require(queryToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryTool) SetCreatedAt(createdAt time.Time) {
	q.CreatedAt = createdAt
	q.require(queryToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryTool) SetUpdatedAt(updatedAt time.Time) {
	q.UpdatedAt = updatedAt
	q.require(queryToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	q.RejectionPlan = rejectionPlan
	q.require(queryToolFieldRejectionPlan)
}

func (q *QueryTool) UnmarshalJSON(data []byte) error {
	type embed QueryTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*q),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*q = QueryTool(unmarshaler.embed)
	q.CreatedAt = unmarshaler.CreatedAt.Time()
	q.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "query" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", q, "query", unmarshaler.Type)
	}
	q.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *q, "type")
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryTool) MarshalJSON() ([]byte, error) {
	type embed QueryTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*q),
		CreatedAt: internal.NewDateTime(q.CreatedAt),
		UpdatedAt: internal.NewDateTime(q.UpdatedAt),
		Type:      "query",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, q.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (q *QueryTool) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (q *QueryToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if q == nil {
		return nil
	}
	return q.ToolMessageStart
}

func (q *QueryToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if q == nil {
		return nil
	}
	return q.ToolMessageComplete
}

func (q *QueryToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if q == nil {
		return nil
	}
	return q.ToolMessageFailed
}

func (q *QueryToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if q == nil {
		return nil
	}
	return q.ToolMessageDelayed
}

func (q *QueryToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		q.typ = "ToolMessageStart"
		q.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		q.typ = "ToolMessageComplete"
		q.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		q.typ = "ToolMessageFailed"
		q.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		q.typ = "ToolMessageDelayed"
		q.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryToolMessagesItem) MarshalJSON() ([]byte, error) {
	if q.typ == "ToolMessageStart" || q.ToolMessageStart != nil {
		return json.Marshal(q.ToolMessageStart)
	}
	if q.typ == "ToolMessageComplete" || q.ToolMessageComplete != nil {
		return json.Marshal(q.ToolMessageComplete)
	}
	if q.typ == "ToolMessageFailed" || q.ToolMessageFailed != nil {
		return json.Marshal(q.ToolMessageFailed)
	}
	if q.typ == "ToolMessageDelayed" || q.ToolMessageDelayed != nil {
		return json.Marshal(q.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (q *QueryToolMessagesItem) Accept(visitor QueryToolMessagesItemVisitor) error {
	if q.typ == "ToolMessageStart" || q.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(q.ToolMessageStart)
	}
	if q.typ == "ToolMessageComplete" || q.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(q.ToolMessageComplete)
	}
	if q.typ == "ToolMessageFailed" || q.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(q.ToolMessageFailed)
	}
	if q.typ == "ToolMessageDelayed" || q.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(q.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

var (
	slackSendMessageToolFieldMessages      = big.NewInt(1 << 0)
	slackSendMessageToolFieldId            = big.NewInt(1 << 1)
	slackSendMessageToolFieldOrgId         = big.NewInt(1 << 2)
	slackSendMessageToolFieldCreatedAt     = big.NewInt(1 << 3)
	slackSendMessageToolFieldUpdatedAt     = big.NewInt(1 << 4)
	slackSendMessageToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type SlackSendMessageTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*SlackSendMessageToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SlackSendMessageTool) GetMessages() []*SlackSendMessageToolMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *SlackSendMessageTool) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SlackSendMessageTool) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *SlackSendMessageTool) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *SlackSendMessageTool) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *SlackSendMessageTool) GetRejectionPlan() *ToolRejectionPlan {
	if s == nil {
		return nil
	}
	return s.RejectionPlan
}

func (s *SlackSendMessageTool) Type() string {
	return s.type_
}

func (s *SlackSendMessageTool) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SlackSendMessageTool) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SlackSendMessageTool) SetMessages(messages []*SlackSendMessageToolMessagesItem) {
	s.Messages = messages
	s.require(slackSendMessageToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SlackSendMessageTool) SetId(id string) {
	s.Id = id
	s.require(slackSendMessageToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SlackSendMessageTool) SetOrgId(orgId string) {
	s.OrgId = orgId
	s.require(slackSendMessageToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SlackSendMessageTool) SetCreatedAt(createdAt time.Time) {
	s.CreatedAt = createdAt
	s.require(slackSendMessageToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SlackSendMessageTool) SetUpdatedAt(updatedAt time.Time) {
	s.UpdatedAt = updatedAt
	s.require(slackSendMessageToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SlackSendMessageTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	s.RejectionPlan = rejectionPlan
	s.require(slackSendMessageToolFieldRejectionPlan)
}

func (s *SlackSendMessageTool) UnmarshalJSON(data []byte) error {
	type embed SlackSendMessageTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SlackSendMessageTool(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "slack.message.send" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "slack.message.send", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SlackSendMessageTool) MarshalJSON() ([]byte, error) {
	type embed SlackSendMessageTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Type:      "slack.message.send",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SlackSendMessageTool) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SlackSendMessageToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (s *SlackSendMessageToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if s == nil {
		return nil
	}
	return s.ToolMessageStart
}

func (s *SlackSendMessageToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if s == nil {
		return nil
	}
	return s.ToolMessageComplete
}

func (s *SlackSendMessageToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if s == nil {
		return nil
	}
	return s.ToolMessageFailed
}

func (s *SlackSendMessageToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if s == nil {
		return nil
	}
	return s.ToolMessageDelayed
}

func (s *SlackSendMessageToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		s.typ = "ToolMessageStart"
		s.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		s.typ = "ToolMessageComplete"
		s.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		s.typ = "ToolMessageFailed"
		s.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		s.typ = "ToolMessageDelayed"
		s.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SlackSendMessageToolMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "ToolMessageStart" || s.ToolMessageStart != nil {
		return json.Marshal(s.ToolMessageStart)
	}
	if s.typ == "ToolMessageComplete" || s.ToolMessageComplete != nil {
		return json.Marshal(s.ToolMessageComplete)
	}
	if s.typ == "ToolMessageFailed" || s.ToolMessageFailed != nil {
		return json.Marshal(s.ToolMessageFailed)
	}
	if s.typ == "ToolMessageDelayed" || s.ToolMessageDelayed != nil {
		return json.Marshal(s.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SlackSendMessageToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (s *SlackSendMessageToolMessagesItem) Accept(visitor SlackSendMessageToolMessagesItemVisitor) error {
	if s.typ == "ToolMessageStart" || s.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(s.ToolMessageStart)
	}
	if s.typ == "ToolMessageComplete" || s.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(s.ToolMessageComplete)
	}
	if s.typ == "ToolMessageFailed" || s.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(s.ToolMessageFailed)
	}
	if s.typ == "ToolMessageDelayed" || s.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(s.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

var (
	smsToolFieldMessages      = big.NewInt(1 << 0)
	smsToolFieldId            = big.NewInt(1 << 1)
	smsToolFieldOrgId         = big.NewInt(1 << 2)
	smsToolFieldCreatedAt     = big.NewInt(1 << 3)
	smsToolFieldUpdatedAt     = big.NewInt(1 << 4)
	smsToolFieldRejectionPlan = big.NewInt(1 << 5)
)

type SmsTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*SmsToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SmsTool) GetMessages() []*SmsToolMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *SmsTool) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SmsTool) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *SmsTool) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *SmsTool) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *SmsTool) GetRejectionPlan() *ToolRejectionPlan {
	if s == nil {
		return nil
	}
	return s.RejectionPlan
}

func (s *SmsTool) Type() string {
	return s.type_
}

func (s *SmsTool) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SmsTool) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SmsTool) SetMessages(messages []*SmsToolMessagesItem) {
	s.Messages = messages
	s.require(smsToolFieldMessages)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SmsTool) SetId(id string) {
	s.Id = id
	s.require(smsToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SmsTool) SetOrgId(orgId string) {
	s.OrgId = orgId
	s.require(smsToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SmsTool) SetCreatedAt(createdAt time.Time) {
	s.CreatedAt = createdAt
	s.require(smsToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SmsTool) SetUpdatedAt(updatedAt time.Time) {
	s.UpdatedAt = updatedAt
	s.require(smsToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SmsTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	s.RejectionPlan = rejectionPlan
	s.require(smsToolFieldRejectionPlan)
}

func (s *SmsTool) UnmarshalJSON(data []byte) error {
	type embed SmsTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SmsTool(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "sms" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "sms", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SmsTool) MarshalJSON() ([]byte, error) {
	type embed SmsTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Type:      "sms",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SmsTool) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SmsToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (s *SmsToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if s == nil {
		return nil
	}
	return s.ToolMessageStart
}

func (s *SmsToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if s == nil {
		return nil
	}
	return s.ToolMessageComplete
}

func (s *SmsToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if s == nil {
		return nil
	}
	return s.ToolMessageFailed
}

func (s *SmsToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if s == nil {
		return nil
	}
	return s.ToolMessageDelayed
}

func (s *SmsToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		s.typ = "ToolMessageStart"
		s.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		s.typ = "ToolMessageComplete"
		s.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		s.typ = "ToolMessageFailed"
		s.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		s.typ = "ToolMessageDelayed"
		s.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SmsToolMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "ToolMessageStart" || s.ToolMessageStart != nil {
		return json.Marshal(s.ToolMessageStart)
	}
	if s.typ == "ToolMessageComplete" || s.ToolMessageComplete != nil {
		return json.Marshal(s.ToolMessageComplete)
	}
	if s.typ == "ToolMessageFailed" || s.ToolMessageFailed != nil {
		return json.Marshal(s.ToolMessageFailed)
	}
	if s.typ == "ToolMessageDelayed" || s.ToolMessageDelayed != nil {
		return json.Marshal(s.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SmsToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (s *SmsToolMessagesItem) Accept(visitor SmsToolMessagesItemVisitor) error {
	if s.typ == "ToolMessageStart" || s.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(s.ToolMessageStart)
	}
	if s.typ == "ToolMessageComplete" || s.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(s.ToolMessageComplete)
	}
	if s.typ == "ToolMessageFailed" || s.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(s.ToolMessageFailed)
	}
	if s.typ == "ToolMessageDelayed" || s.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(s.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

var (
	textEditorToolFieldMessages      = big.NewInt(1 << 0)
	textEditorToolFieldSubType       = big.NewInt(1 << 1)
	textEditorToolFieldServer        = big.NewInt(1 << 2)
	textEditorToolFieldId            = big.NewInt(1 << 3)
	textEditorToolFieldOrgId         = big.NewInt(1 << 4)
	textEditorToolFieldCreatedAt     = big.NewInt(1 << 5)
	textEditorToolFieldUpdatedAt     = big.NewInt(1 << 6)
	textEditorToolFieldRejectionPlan = big.NewInt(1 << 7)
	textEditorToolFieldName          = big.NewInt(1 << 8)
)

type TextEditorTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*TextEditorToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	SubType TextEditorToolSubType `json:"subType" url:"subType"`
	// This is the server where a `tool-calls` webhook will be sent.
	//
	// Notes:
	// - Webhook is sent to this server when a tool call is made.
	// - Webhook contains the call, assistant, and phone number objects.
	// - Webhook contains the variables set on the assistant.
	// - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
	// - Webhook expects a response with tool call result.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// The name of the tool, fixed to 'str_replace_editor'
	Name TextEditorToolName `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TextEditorTool) GetMessages() []*TextEditorToolMessagesItem {
	if t == nil {
		return nil
	}
	return t.Messages
}

func (t *TextEditorTool) GetSubType() TextEditorToolSubType {
	if t == nil {
		return ""
	}
	return t.SubType
}

func (t *TextEditorTool) GetServer() *Server {
	if t == nil {
		return nil
	}
	return t.Server
}

func (t *TextEditorTool) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TextEditorTool) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TextEditorTool) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TextEditorTool) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TextEditorTool) GetRejectionPlan() *ToolRejectionPlan {
	if t == nil {
		return nil
	}
	return t.RejectionPlan
}

func (t *TextEditorTool) GetName() TextEditorToolName {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *TextEditorTool) Type() string {
	return t.type_
}

func (t *TextEditorTool) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TextEditorTool) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextEditorTool) SetMessages(messages []*TextEditorToolMessagesItem) {
	t.Messages = messages
	t.require(textEditorToolFieldMessages)
}

// SetSubType sets the SubType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextEditorTool) SetSubType(subType TextEditorToolSubType) {
	t.SubType = subType
	t.require(textEditorToolFieldSubType)
}

// SetServer sets the Server field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextEditorTool) SetServer(server *Server) {
	t.Server = server
	t.require(textEditorToolFieldServer)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextEditorTool) SetId(id string) {
	t.Id = id
	t.require(textEditorToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextEditorTool) SetOrgId(orgId string) {
	t.OrgId = orgId
	t.require(textEditorToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextEditorTool) SetCreatedAt(createdAt time.Time) {
	t.CreatedAt = createdAt
	t.require(textEditorToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextEditorTool) SetUpdatedAt(updatedAt time.Time) {
	t.UpdatedAt = updatedAt
	t.require(textEditorToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextEditorTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	t.RejectionPlan = rejectionPlan
	t.require(textEditorToolFieldRejectionPlan)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextEditorTool) SetName(name TextEditorToolName) {
	t.Name = name
	t.require(textEditorToolFieldName)
}

func (t *TextEditorTool) UnmarshalJSON(data []byte) error {
	type embed TextEditorTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TextEditorTool(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "textEditor" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "textEditor", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextEditorTool) MarshalJSON() ([]byte, error) {
	type embed TextEditorTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Type:      "textEditor",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TextEditorTool) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextEditorToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (t *TextEditorToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if t == nil {
		return nil
	}
	return t.ToolMessageStart
}

func (t *TextEditorToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if t == nil {
		return nil
	}
	return t.ToolMessageComplete
}

func (t *TextEditorToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if t == nil {
		return nil
	}
	return t.ToolMessageFailed
}

func (t *TextEditorToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if t == nil {
		return nil
	}
	return t.ToolMessageDelayed
}

func (t *TextEditorToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		t.typ = "ToolMessageStart"
		t.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		t.typ = "ToolMessageComplete"
		t.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		t.typ = "ToolMessageFailed"
		t.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		t.typ = "ToolMessageDelayed"
		t.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TextEditorToolMessagesItem) MarshalJSON() ([]byte, error) {
	if t.typ == "ToolMessageStart" || t.ToolMessageStart != nil {
		return json.Marshal(t.ToolMessageStart)
	}
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return json.Marshal(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return json.Marshal(t.ToolMessageFailed)
	}
	if t.typ == "ToolMessageDelayed" || t.ToolMessageDelayed != nil {
		return json.Marshal(t.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TextEditorToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (t *TextEditorToolMessagesItem) Accept(visitor TextEditorToolMessagesItemVisitor) error {
	if t.typ == "ToolMessageStart" || t.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(t.ToolMessageStart)
	}
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(t.ToolMessageFailed)
	}
	if t.typ == "ToolMessageDelayed" || t.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(t.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// The name of the tool, fixed to 'str_replace_editor'
type TextEditorToolName string

const (
	TextEditorToolNameStrReplaceEditor TextEditorToolName = "str_replace_editor"
)

func NewTextEditorToolNameFromString(s string) (TextEditorToolName, error) {
	switch s {
	case "str_replace_editor":
		return TextEditorToolNameStrReplaceEditor, nil
	}
	var t TextEditorToolName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TextEditorToolName) Ptr() *TextEditorToolName {
	return &t
}

// The sub type of tool.
type TextEditorToolSubType string

const (
	TextEditorToolSubTypeTextEditor20241022 TextEditorToolSubType = "text_editor_20241022"
)

func NewTextEditorToolSubTypeFromString(s string) (TextEditorToolSubType, error) {
	switch s {
	case "text_editor_20241022":
		return TextEditorToolSubTypeTextEditor20241022, nil
	}
	var t TextEditorToolSubType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TextEditorToolSubType) Ptr() *TextEditorToolSubType {
	return &t
}

var (
	transferCallToolFieldMessages      = big.NewInt(1 << 0)
	transferCallToolFieldDestinations  = big.NewInt(1 << 1)
	transferCallToolFieldId            = big.NewInt(1 << 2)
	transferCallToolFieldOrgId         = big.NewInt(1 << 3)
	transferCallToolFieldCreatedAt     = big.NewInt(1 << 4)
	transferCallToolFieldUpdatedAt     = big.NewInt(1 << 5)
	transferCallToolFieldRejectionPlan = big.NewInt(1 << 6)
)

type TransferCallTool struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*TransferCallToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.
	Destinations []*TransferCallToolDestinationsItem `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferCallTool) GetMessages() []*TransferCallToolMessagesItem {
	if t == nil {
		return nil
	}
	return t.Messages
}

func (t *TransferCallTool) GetDestinations() []*TransferCallToolDestinationsItem {
	if t == nil {
		return nil
	}
	return t.Destinations
}

func (t *TransferCallTool) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TransferCallTool) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TransferCallTool) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransferCallTool) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransferCallTool) GetRejectionPlan() *ToolRejectionPlan {
	if t == nil {
		return nil
	}
	return t.RejectionPlan
}

func (t *TransferCallTool) Type() string {
	return t.type_
}

func (t *TransferCallTool) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferCallTool) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransferCallTool) SetMessages(messages []*TransferCallToolMessagesItem) {
	t.Messages = messages
	t.require(transferCallToolFieldMessages)
}

// SetDestinations sets the Destinations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransferCallTool) SetDestinations(destinations []*TransferCallToolDestinationsItem) {
	t.Destinations = destinations
	t.require(transferCallToolFieldDestinations)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransferCallTool) SetId(id string) {
	t.Id = id
	t.require(transferCallToolFieldId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransferCallTool) SetOrgId(orgId string) {
	t.OrgId = orgId
	t.require(transferCallToolFieldOrgId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransferCallTool) SetCreatedAt(createdAt time.Time) {
	t.CreatedAt = createdAt
	t.require(transferCallToolFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransferCallTool) SetUpdatedAt(updatedAt time.Time) {
	t.UpdatedAt = updatedAt
	t.require(transferCallToolFieldUpdatedAt)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransferCallTool) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	t.RejectionPlan = rejectionPlan
	t.require(transferCallToolFieldRejectionPlan)
}

func (t *TransferCallTool) UnmarshalJSON(data []byte) error {
	type embed TransferCallTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferCallTool(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "transferCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "transferCall", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferCallTool) MarshalJSON() ([]byte, error) {
	type embed TransferCallTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Type:      "transferCall",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TransferCallTool) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransferCallToolDestinationsItem struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (t *TransferCallToolDestinationsItem) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if t == nil {
		return nil
	}
	return t.TransferDestinationAssistant
}

func (t *TransferCallToolDestinationsItem) GetTransferDestinationNumber() *TransferDestinationNumber {
	if t == nil {
		return nil
	}
	return t.TransferDestinationNumber
}

func (t *TransferCallToolDestinationsItem) GetTransferDestinationSip() *TransferDestinationSip {
	if t == nil {
		return nil
	}
	return t.TransferDestinationSip
}

func (t *TransferCallToolDestinationsItem) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		t.typ = "TransferDestinationAssistant"
		t.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		t.typ = "TransferDestinationNumber"
		t.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		t.typ = "TransferDestinationSip"
		t.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferCallToolDestinationsItem) MarshalJSON() ([]byte, error) {
	if t.typ == "TransferDestinationAssistant" || t.TransferDestinationAssistant != nil {
		return json.Marshal(t.TransferDestinationAssistant)
	}
	if t.typ == "TransferDestinationNumber" || t.TransferDestinationNumber != nil {
		return json.Marshal(t.TransferDestinationNumber)
	}
	if t.typ == "TransferDestinationSip" || t.TransferDestinationSip != nil {
		return json.Marshal(t.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferCallToolDestinationsItemVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (t *TransferCallToolDestinationsItem) Accept(visitor TransferCallToolDestinationsItemVisitor) error {
	if t.typ == "TransferDestinationAssistant" || t.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(t.TransferDestinationAssistant)
	}
	if t.typ == "TransferDestinationNumber" || t.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(t.TransferDestinationNumber)
	}
	if t.typ == "TransferDestinationSip" || t.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(t.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferCallToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (t *TransferCallToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if t == nil {
		return nil
	}
	return t.ToolMessageStart
}

func (t *TransferCallToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if t == nil {
		return nil
	}
	return t.ToolMessageComplete
}

func (t *TransferCallToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if t == nil {
		return nil
	}
	return t.ToolMessageFailed
}

func (t *TransferCallToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if t == nil {
		return nil
	}
	return t.ToolMessageDelayed
}

func (t *TransferCallToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		t.typ = "ToolMessageStart"
		t.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		t.typ = "ToolMessageComplete"
		t.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		t.typ = "ToolMessageFailed"
		t.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		t.typ = "ToolMessageDelayed"
		t.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferCallToolMessagesItem) MarshalJSON() ([]byte, error) {
	if t.typ == "ToolMessageStart" || t.ToolMessageStart != nil {
		return json.Marshal(t.ToolMessageStart)
	}
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return json.Marshal(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return json.Marshal(t.ToolMessageFailed)
	}
	if t.typ == "ToolMessageDelayed" || t.ToolMessageDelayed != nil {
		return json.Marshal(t.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferCallToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (t *TransferCallToolMessagesItem) Accept(visitor TransferCallToolMessagesItemVisitor) error {
	if t.typ == "ToolMessageStart" || t.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(t.ToolMessageStart)
	}
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(t.ToolMessageFailed)
	}
	if t.typ == "ToolMessageDelayed" || t.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(t.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

var (
	updateApiRequestToolDtoFieldMessages               = big.NewInt(1 << 0)
	updateApiRequestToolDtoFieldMethod                 = big.NewInt(1 << 1)
	updateApiRequestToolDtoFieldTimeoutSeconds         = big.NewInt(1 << 2)
	updateApiRequestToolDtoFieldCredentialId           = big.NewInt(1 << 3)
	updateApiRequestToolDtoFieldRejectionPlan          = big.NewInt(1 << 4)
	updateApiRequestToolDtoFieldName                   = big.NewInt(1 << 5)
	updateApiRequestToolDtoFieldDescription            = big.NewInt(1 << 6)
	updateApiRequestToolDtoFieldUrl                    = big.NewInt(1 << 7)
	updateApiRequestToolDtoFieldBody                   = big.NewInt(1 << 8)
	updateApiRequestToolDtoFieldHeaders                = big.NewInt(1 << 9)
	updateApiRequestToolDtoFieldBackoffPlan            = big.NewInt(1 << 10)
	updateApiRequestToolDtoFieldVariableExtractionPlan = big.NewInt(1 << 11)
)

type UpdateApiRequestToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateApiRequestToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	Method   *UpdateApiRequestToolDtoMethod         `json:"method,omitempty" url:"method,omitempty"`
	// This is the timeout in seconds for the request. Defaults to 20 seconds.
	//
	// @default 20
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`
	// The credential ID for API request authentication
	CredentialId *string `json:"credentialId,omitempty" url:"credentialId,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// This is the name of the tool. This will be passed to the model.
	//
	// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 40.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the description of the tool. This will be passed to the model.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is where the request will be sent.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// This is the body of the request.
	Body *JsonSchema `json:"body,omitempty" url:"body,omitempty"`
	// These are the headers to send with the request.
	Headers *JsonSchema `json:"headers,omitempty" url:"headers,omitempty"`
	// This is the backoff plan if the request fails. Defaults to undefined (the request will not be retried).
	//
	// @default undefined (the request will not be retried)
	BackoffPlan *BackoffPlan `json:"backoffPlan,omitempty" url:"backoffPlan,omitempty"`
	// This is the plan to extract variables from the tool's response. These will be accessible during the call and stored in `call.artifact.variableValues` after the call.
	//
	// Usage:
	// 1. Use `aliases` to extract variables from the tool's response body. (Most common case)
	//
	// ```json
	//
	//	{
	//	  "aliases": [
	//	    {
	//	      "key": "customerName",
	//	      "value": "{{customer.name}}"
	//	    },
	//	    {
	//	      "key": "customerAge",
	//	      "value": "{{customer.age}}"
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// The tool response body is made available to the liquid template.
	//
	// 2. Use `aliases` to extract variables from the tool's response body if the response is an array.
	//
	// ```json
	//
	//	{
	//	  "aliases": [
	//	    {
	//	      "key": "customerName",
	//	      "value": "{{$[0].name}}"
	//	    },
	//	    {
	//	      "key": "customerAge",
	//	      "value": "{{$[0].age}}"
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// $ is a shorthand for the tool's response body. `$[0]` is the first item in the array. `$[n]` is the nth item in the array. Note, $ is available regardless of the response body type (both object and array).
	//
	// 3. Use `aliases` to extract variables from the tool's response headers.
	//
	// ```json
	//
	//	{
	//	  "aliases": [
	//	    {
	//	      "key": "customerName",
	//	      "value": "{{tool.response.headers.customer-name}}"
	//	    },
	//	    {
	//	      "key": "customerAge",
	//	      "value": "{{tool.response.headers.customer-age}}"
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// `tool.response` is made available to the liquid template. Particularly, both `tool.response.headers` and `tool.response.body` are available. Note, `tool.response` is available regardless of the response body type (both object and array).
	//
	// 4. Use `schema` to extract a large portion of the tool's response body.
	//
	// 4.1. If you hit example.com and it returns `{"name": "John", "age": 30}`, then you can specify the schema as:
	//
	// ```json
	//
	//	{
	//	  "schema": {
	//	    "type": "object",
	//	    "properties": {
	//	      "name": {
	//	        "type": "string"
	//	      },
	//	      "age": {
	//	        "type": "number"
	//	      }
	//	    }
	//	  }
	//	}
	//
	// ```
	// These will be extracted as `{{ name }}` and `{{ age }}` respectively. To emphasize, object properties are extracted as direct global variables.
	//
	// 4.2. If you hit example.com and it returns `{"name": {"first": "John", "last": "Doe"}}`, then you can specify the schema as:
	//
	// ```json
	//
	//	{
	//	  "schema": {
	//	    "type": "object",
	//	    "properties": {
	//	      "name": {
	//	        "type": "object",
	//	        "properties": {
	//	          "first": {
	//	            "type": "string"
	//	          },
	//	          "last": {
	//	            "type": "string"
	//	          }
	//	        }
	//	      }
	//	    }
	//	  }
	//	}
	//
	// ```
	//
	// These will be extracted as `{{ name }}`. And, `{{ name.first }}` and `{{ name.last }}` will be accessible.
	//
	// 4.3. If you hit example.com and it returns `["94123", "94124"]`, then you can specify the schema as:
	//
	// ```json
	//
	//	{
	//	  "schema": {
	//	    "type": "array",
	//	    "title": "zipCodes",
	//	    "items": {
	//	      "type": "string"
	//	    }
	//	  }
	//	}
	//
	// ```
	//
	// This will be extracted as `{{ zipCodes }}`. To access the array items, you can use `{{ zipCodes[0] }}` and `{{ zipCodes[1] }}`.
	//
	// 4.4. If you hit example.com and it returns `[{"name": "John", "age": 30, "zipCodes": ["94123", "94124"]}, {"name": "Jane", "age": 25, "zipCodes": ["94125", "94126"]}]`, then you can specify the schema as:
	//
	// ```json
	//
	//	{
	//	  "schema": {
	//	    "type": "array",
	//	    "title": "people",
	//	    "items": {
	//	      "type": "object",
	//	      "properties": {
	//	        "name": {
	//	          "type": "string"
	//	        },
	//	        "age": {
	//	          "type": "number"
	//	        },
	//	        "zipCodes": {
	//	          "type": "array",
	//	          "items": {
	//	            "type": "string"
	//	          }
	//	        }
	//	      }
	//	    }
	//	  }
	//	}
	//
	// ```
	//
	// This will be extracted as `{{ people }}`. To access the array items, you can use `{{ people[n].name }}`, `{{ people[n].age }}`, `{{ people[n].zipCodes }}`, `{{ people[n].zipCodes[0] }}` and `{{ people[n].zipCodes[1] }}`.
	//
	// Note: Both `aliases` and `schema` can be used together.
	VariableExtractionPlan *VariableExtractionPlan `json:"variableExtractionPlan,omitempty" url:"variableExtractionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateApiRequestToolDto) GetMessages() []*UpdateApiRequestToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateApiRequestToolDto) GetMethod() *UpdateApiRequestToolDtoMethod {
	if u == nil {
		return nil
	}
	return u.Method
}

func (u *UpdateApiRequestToolDto) GetTimeoutSeconds() *float64 {
	if u == nil {
		return nil
	}
	return u.TimeoutSeconds
}

func (u *UpdateApiRequestToolDto) GetCredentialId() *string {
	if u == nil {
		return nil
	}
	return u.CredentialId
}

func (u *UpdateApiRequestToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateApiRequestToolDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateApiRequestToolDto) GetDescription() *string {
	if u == nil {
		return nil
	}
	return u.Description
}

func (u *UpdateApiRequestToolDto) GetUrl() *string {
	if u == nil {
		return nil
	}
	return u.Url
}

func (u *UpdateApiRequestToolDto) GetBody() *JsonSchema {
	if u == nil {
		return nil
	}
	return u.Body
}

func (u *UpdateApiRequestToolDto) GetHeaders() *JsonSchema {
	if u == nil {
		return nil
	}
	return u.Headers
}

func (u *UpdateApiRequestToolDto) GetBackoffPlan() *BackoffPlan {
	if u == nil {
		return nil
	}
	return u.BackoffPlan
}

func (u *UpdateApiRequestToolDto) GetVariableExtractionPlan() *VariableExtractionPlan {
	if u == nil {
		return nil
	}
	return u.VariableExtractionPlan
}

func (u *UpdateApiRequestToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateApiRequestToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetMessages(messages []*UpdateApiRequestToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateApiRequestToolDtoFieldMessages)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetMethod(method *UpdateApiRequestToolDtoMethod) {
	u.Method = method
	u.require(updateApiRequestToolDtoFieldMethod)
}

// SetTimeoutSeconds sets the TimeoutSeconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetTimeoutSeconds(timeoutSeconds *float64) {
	u.TimeoutSeconds = timeoutSeconds
	u.require(updateApiRequestToolDtoFieldTimeoutSeconds)
}

// SetCredentialId sets the CredentialId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetCredentialId(credentialId *string) {
	u.CredentialId = credentialId
	u.require(updateApiRequestToolDtoFieldCredentialId)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateApiRequestToolDtoFieldRejectionPlan)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetName(name *string) {
	u.Name = name
	u.require(updateApiRequestToolDtoFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetDescription(description *string) {
	u.Description = description
	u.require(updateApiRequestToolDtoFieldDescription)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetUrl(url *string) {
	u.Url = url
	u.require(updateApiRequestToolDtoFieldUrl)
}

// SetBody sets the Body field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetBody(body *JsonSchema) {
	u.Body = body
	u.require(updateApiRequestToolDtoFieldBody)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetHeaders(headers *JsonSchema) {
	u.Headers = headers
	u.require(updateApiRequestToolDtoFieldHeaders)
}

// SetBackoffPlan sets the BackoffPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetBackoffPlan(backoffPlan *BackoffPlan) {
	u.BackoffPlan = backoffPlan
	u.require(updateApiRequestToolDtoFieldBackoffPlan)
}

// SetVariableExtractionPlan sets the VariableExtractionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateApiRequestToolDto) SetVariableExtractionPlan(variableExtractionPlan *VariableExtractionPlan) {
	u.VariableExtractionPlan = variableExtractionPlan
	u.require(updateApiRequestToolDtoFieldVariableExtractionPlan)
}

func (u *UpdateApiRequestToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateApiRequestToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateApiRequestToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateApiRequestToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateApiRequestToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateApiRequestToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateApiRequestToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateApiRequestToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateApiRequestToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateApiRequestToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateApiRequestToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateApiRequestToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateApiRequestToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateApiRequestToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateApiRequestToolDtoMessagesItem) Accept(visitor UpdateApiRequestToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateApiRequestToolDtoMethod string

const (
	UpdateApiRequestToolDtoMethodPost   UpdateApiRequestToolDtoMethod = "POST"
	UpdateApiRequestToolDtoMethodGet    UpdateApiRequestToolDtoMethod = "GET"
	UpdateApiRequestToolDtoMethodPut    UpdateApiRequestToolDtoMethod = "PUT"
	UpdateApiRequestToolDtoMethodPatch  UpdateApiRequestToolDtoMethod = "PATCH"
	UpdateApiRequestToolDtoMethodDelete UpdateApiRequestToolDtoMethod = "DELETE"
)

func NewUpdateApiRequestToolDtoMethodFromString(s string) (UpdateApiRequestToolDtoMethod, error) {
	switch s {
	case "POST":
		return UpdateApiRequestToolDtoMethodPost, nil
	case "GET":
		return UpdateApiRequestToolDtoMethodGet, nil
	case "PUT":
		return UpdateApiRequestToolDtoMethodPut, nil
	case "PATCH":
		return UpdateApiRequestToolDtoMethodPatch, nil
	case "DELETE":
		return UpdateApiRequestToolDtoMethodDelete, nil
	}
	var t UpdateApiRequestToolDtoMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateApiRequestToolDtoMethod) Ptr() *UpdateApiRequestToolDtoMethod {
	return &u
}

var (
	updateBashToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateBashToolDtoFieldSubType       = big.NewInt(1 << 1)
	updateBashToolDtoFieldServer        = big.NewInt(1 << 2)
	updateBashToolDtoFieldRejectionPlan = big.NewInt(1 << 3)
	updateBashToolDtoFieldName          = big.NewInt(1 << 4)
)

type UpdateBashToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateBashToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	SubType *UpdateBashToolDtoSubType `json:"subType,omitempty" url:"subType,omitempty"`
	// This is the server where a `tool-calls` webhook will be sent.
	//
	// Notes:
	// - Webhook is sent to this server when a tool call is made.
	// - Webhook contains the call, assistant, and phone number objects.
	// - Webhook contains the variables set on the assistant.
	// - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
	// - Webhook expects a response with tool call result.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// The name of the tool, fixed to 'bash'
	Name *UpdateBashToolDtoName `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateBashToolDto) GetMessages() []*UpdateBashToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateBashToolDto) GetSubType() *UpdateBashToolDtoSubType {
	if u == nil {
		return nil
	}
	return u.SubType
}

func (u *UpdateBashToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateBashToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateBashToolDto) GetName() *UpdateBashToolDtoName {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateBashToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateBashToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBashToolDto) SetMessages(messages []*UpdateBashToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateBashToolDtoFieldMessages)
}

// SetSubType sets the SubType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBashToolDto) SetSubType(subType *UpdateBashToolDtoSubType) {
	u.SubType = subType
	u.require(updateBashToolDtoFieldSubType)
}

// SetServer sets the Server field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBashToolDto) SetServer(server *Server) {
	u.Server = server
	u.require(updateBashToolDtoFieldServer)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBashToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateBashToolDtoFieldRejectionPlan)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateBashToolDto) SetName(name *UpdateBashToolDtoName) {
	u.Name = name
	u.require(updateBashToolDtoFieldName)
}

func (u *UpdateBashToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateBashToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateBashToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBashToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateBashToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateBashToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateBashToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateBashToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateBashToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateBashToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateBashToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateBashToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateBashToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateBashToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateBashToolDtoMessagesItem) Accept(visitor UpdateBashToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// The name of the tool, fixed to 'bash'
type UpdateBashToolDtoName string

const (
	UpdateBashToolDtoNameBash UpdateBashToolDtoName = "bash"
)

func NewUpdateBashToolDtoNameFromString(s string) (UpdateBashToolDtoName, error) {
	switch s {
	case "bash":
		return UpdateBashToolDtoNameBash, nil
	}
	var t UpdateBashToolDtoName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateBashToolDtoName) Ptr() *UpdateBashToolDtoName {
	return &u
}

// The sub type of tool.
type UpdateBashToolDtoSubType string

const (
	UpdateBashToolDtoSubTypeBash20241022 UpdateBashToolDtoSubType = "bash_20241022"
)

func NewUpdateBashToolDtoSubTypeFromString(s string) (UpdateBashToolDtoSubType, error) {
	switch s {
	case "bash_20241022":
		return UpdateBashToolDtoSubTypeBash20241022, nil
	}
	var t UpdateBashToolDtoSubType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateBashToolDtoSubType) Ptr() *UpdateBashToolDtoSubType {
	return &u
}

var (
	updateComputerToolDtoFieldMessages        = big.NewInt(1 << 0)
	updateComputerToolDtoFieldSubType         = big.NewInt(1 << 1)
	updateComputerToolDtoFieldServer          = big.NewInt(1 << 2)
	updateComputerToolDtoFieldRejectionPlan   = big.NewInt(1 << 3)
	updateComputerToolDtoFieldName            = big.NewInt(1 << 4)
	updateComputerToolDtoFieldDisplayWidthPx  = big.NewInt(1 << 5)
	updateComputerToolDtoFieldDisplayHeightPx = big.NewInt(1 << 6)
	updateComputerToolDtoFieldDisplayNumber   = big.NewInt(1 << 7)
)

type UpdateComputerToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateComputerToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	SubType *UpdateComputerToolDtoSubType `json:"subType,omitempty" url:"subType,omitempty"`
	// This is the server where a `tool-calls` webhook will be sent.
	//
	// Notes:
	// - Webhook is sent to this server when a tool call is made.
	// - Webhook contains the call, assistant, and phone number objects.
	// - Webhook contains the variables set on the assistant.
	// - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
	// - Webhook expects a response with tool call result.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// The name of the tool, fixed to 'computer'
	Name *UpdateComputerToolDtoName `json:"name,omitempty" url:"name,omitempty"`
	// The display width in pixels
	DisplayWidthPx *float64 `json:"displayWidthPx,omitempty" url:"displayWidthPx,omitempty"`
	// The display height in pixels
	DisplayHeightPx *float64 `json:"displayHeightPx,omitempty" url:"displayHeightPx,omitempty"`
	// Optional display number
	DisplayNumber *float64 `json:"displayNumber,omitempty" url:"displayNumber,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateComputerToolDto) GetMessages() []*UpdateComputerToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateComputerToolDto) GetSubType() *UpdateComputerToolDtoSubType {
	if u == nil {
		return nil
	}
	return u.SubType
}

func (u *UpdateComputerToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateComputerToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateComputerToolDto) GetName() *UpdateComputerToolDtoName {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateComputerToolDto) GetDisplayWidthPx() *float64 {
	if u == nil {
		return nil
	}
	return u.DisplayWidthPx
}

func (u *UpdateComputerToolDto) GetDisplayHeightPx() *float64 {
	if u == nil {
		return nil
	}
	return u.DisplayHeightPx
}

func (u *UpdateComputerToolDto) GetDisplayNumber() *float64 {
	if u == nil {
		return nil
	}
	return u.DisplayNumber
}

func (u *UpdateComputerToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateComputerToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateComputerToolDto) SetMessages(messages []*UpdateComputerToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateComputerToolDtoFieldMessages)
}

// SetSubType sets the SubType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateComputerToolDto) SetSubType(subType *UpdateComputerToolDtoSubType) {
	u.SubType = subType
	u.require(updateComputerToolDtoFieldSubType)
}

// SetServer sets the Server field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateComputerToolDto) SetServer(server *Server) {
	u.Server = server
	u.require(updateComputerToolDtoFieldServer)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateComputerToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateComputerToolDtoFieldRejectionPlan)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateComputerToolDto) SetName(name *UpdateComputerToolDtoName) {
	u.Name = name
	u.require(updateComputerToolDtoFieldName)
}

// SetDisplayWidthPx sets the DisplayWidthPx field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateComputerToolDto) SetDisplayWidthPx(displayWidthPx *float64) {
	u.DisplayWidthPx = displayWidthPx
	u.require(updateComputerToolDtoFieldDisplayWidthPx)
}

// SetDisplayHeightPx sets the DisplayHeightPx field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateComputerToolDto) SetDisplayHeightPx(displayHeightPx *float64) {
	u.DisplayHeightPx = displayHeightPx
	u.require(updateComputerToolDtoFieldDisplayHeightPx)
}

// SetDisplayNumber sets the DisplayNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateComputerToolDto) SetDisplayNumber(displayNumber *float64) {
	u.DisplayNumber = displayNumber
	u.require(updateComputerToolDtoFieldDisplayNumber)
}

func (u *UpdateComputerToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateComputerToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateComputerToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateComputerToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateComputerToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateComputerToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateComputerToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateComputerToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateComputerToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateComputerToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateComputerToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateComputerToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateComputerToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateComputerToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateComputerToolDtoMessagesItem) Accept(visitor UpdateComputerToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// The name of the tool, fixed to 'computer'
type UpdateComputerToolDtoName string

const (
	UpdateComputerToolDtoNameComputer UpdateComputerToolDtoName = "computer"
)

func NewUpdateComputerToolDtoNameFromString(s string) (UpdateComputerToolDtoName, error) {
	switch s {
	case "computer":
		return UpdateComputerToolDtoNameComputer, nil
	}
	var t UpdateComputerToolDtoName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateComputerToolDtoName) Ptr() *UpdateComputerToolDtoName {
	return &u
}

// The sub type of tool.
type UpdateComputerToolDtoSubType string

const (
	UpdateComputerToolDtoSubTypeComputer20241022 UpdateComputerToolDtoSubType = "computer_20241022"
)

func NewUpdateComputerToolDtoSubTypeFromString(s string) (UpdateComputerToolDtoSubType, error) {
	switch s {
	case "computer_20241022":
		return UpdateComputerToolDtoSubTypeComputer20241022, nil
	}
	var t UpdateComputerToolDtoSubType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateComputerToolDtoSubType) Ptr() *UpdateComputerToolDtoSubType {
	return &u
}

var (
	updateDtmfToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateDtmfToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateDtmfToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateDtmfToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateDtmfToolDto) GetMessages() []*UpdateDtmfToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateDtmfToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateDtmfToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateDtmfToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateDtmfToolDto) SetMessages(messages []*UpdateDtmfToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateDtmfToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateDtmfToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateDtmfToolDtoFieldRejectionPlan)
}

func (u *UpdateDtmfToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateDtmfToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateDtmfToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateDtmfToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateDtmfToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateDtmfToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateDtmfToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateDtmfToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateDtmfToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateDtmfToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateDtmfToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateDtmfToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateDtmfToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateDtmfToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateDtmfToolDtoMessagesItem) Accept(visitor UpdateDtmfToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateEndCallToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateEndCallToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateEndCallToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateEndCallToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateEndCallToolDto) GetMessages() []*UpdateEndCallToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateEndCallToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateEndCallToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateEndCallToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEndCallToolDto) SetMessages(messages []*UpdateEndCallToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateEndCallToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateEndCallToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateEndCallToolDtoFieldRejectionPlan)
}

func (u *UpdateEndCallToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateEndCallToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateEndCallToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateEndCallToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateEndCallToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateEndCallToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateEndCallToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateEndCallToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateEndCallToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateEndCallToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateEndCallToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateEndCallToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateEndCallToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateEndCallToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateEndCallToolDtoMessagesItem) Accept(visitor UpdateEndCallToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateFunctionToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateFunctionToolDtoFieldAsync         = big.NewInt(1 << 1)
	updateFunctionToolDtoFieldServer        = big.NewInt(1 << 2)
	updateFunctionToolDtoFieldRejectionPlan = big.NewInt(1 << 3)
	updateFunctionToolDtoFieldFunction      = big.NewInt(1 << 4)
)

type UpdateFunctionToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateFunctionToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines if the tool is async.
	//
	//	If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	//	If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	//	Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// This is the server where a `tool-calls` webhook will be sent.
	//
	// Notes:
	// - Webhook is sent to this server when a tool call is made.
	// - Webhook contains the call, assistant, and phone number objects.
	// - Webhook contains the variables set on the assistant.
	// - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
	// - Webhook expects a response with tool call result.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// This is the function definition of the tool.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateFunctionToolDto) GetMessages() []*UpdateFunctionToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateFunctionToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateFunctionToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateFunctionToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateFunctionToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateFunctionToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateFunctionToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateFunctionToolDto) SetMessages(messages []*UpdateFunctionToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateFunctionToolDtoFieldMessages)
}

// SetAsync sets the Async field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateFunctionToolDto) SetAsync(async *bool) {
	u.Async = async
	u.require(updateFunctionToolDtoFieldAsync)
}

// SetServer sets the Server field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateFunctionToolDto) SetServer(server *Server) {
	u.Server = server
	u.require(updateFunctionToolDtoFieldServer)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateFunctionToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateFunctionToolDtoFieldRejectionPlan)
}

// SetFunction sets the Function field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateFunctionToolDto) SetFunction(function *OpenAiFunction) {
	u.Function = function
	u.require(updateFunctionToolDtoFieldFunction)
}

func (u *UpdateFunctionToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateFunctionToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateFunctionToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateFunctionToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateFunctionToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateFunctionToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateFunctionToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateFunctionToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateFunctionToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateFunctionToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateFunctionToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateFunctionToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateFunctionToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateFunctionToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateFunctionToolDtoMessagesItem) Accept(visitor UpdateFunctionToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateGoHighLevelCalendarAvailabilityToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateGoHighLevelCalendarAvailabilityToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateGoHighLevelCalendarAvailabilityToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) GetMessages() []*UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) SetMessages(messages []*UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateGoHighLevelCalendarAvailabilityToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateGoHighLevelCalendarAvailabilityToolDtoFieldRejectionPlan)
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelCalendarAvailabilityToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelCalendarAvailabilityToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGoHighLevelCalendarAvailabilityToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) Accept(visitor UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateGoHighLevelCalendarEventCreateToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateGoHighLevelCalendarEventCreateToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateGoHighLevelCalendarEventCreateToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) GetMessages() []*UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoHighLevelCalendarEventCreateToolDto) SetMessages(messages []*UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateGoHighLevelCalendarEventCreateToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoHighLevelCalendarEventCreateToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateGoHighLevelCalendarEventCreateToolDtoFieldRejectionPlan)
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelCalendarEventCreateToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelCalendarEventCreateToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGoHighLevelCalendarEventCreateToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) Accept(visitor UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateGoHighLevelContactCreateToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateGoHighLevelContactCreateToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateGoHighLevelContactCreateToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoHighLevelContactCreateToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelContactCreateToolDto) GetMessages() []*UpdateGoHighLevelContactCreateToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoHighLevelContactCreateToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateGoHighLevelContactCreateToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelContactCreateToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoHighLevelContactCreateToolDto) SetMessages(messages []*UpdateGoHighLevelContactCreateToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateGoHighLevelContactCreateToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoHighLevelContactCreateToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateGoHighLevelContactCreateToolDtoFieldRejectionPlan)
}

func (u *UpdateGoHighLevelContactCreateToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelContactCreateToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelContactCreateToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelContactCreateToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGoHighLevelContactCreateToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateGoHighLevelContactCreateToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelContactCreateToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoHighLevelContactCreateToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelContactCreateToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) Accept(visitor UpdateGoHighLevelContactCreateToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateGoHighLevelContactGetToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateGoHighLevelContactGetToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateGoHighLevelContactGetToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoHighLevelContactGetToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelContactGetToolDto) GetMessages() []*UpdateGoHighLevelContactGetToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoHighLevelContactGetToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateGoHighLevelContactGetToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelContactGetToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoHighLevelContactGetToolDto) SetMessages(messages []*UpdateGoHighLevelContactGetToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateGoHighLevelContactGetToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoHighLevelContactGetToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateGoHighLevelContactGetToolDtoFieldRejectionPlan)
}

func (u *UpdateGoHighLevelContactGetToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelContactGetToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelContactGetToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelContactGetToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGoHighLevelContactGetToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateGoHighLevelContactGetToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelContactGetToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoHighLevelContactGetToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelContactGetToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) Accept(visitor UpdateGoHighLevelContactGetToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateGoogleCalendarCheckAvailabilityToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateGoogleCalendarCheckAvailabilityToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateGoogleCalendarCheckAvailabilityToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) GetMessages() []*UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) SetMessages(messages []*UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateGoogleCalendarCheckAvailabilityToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateGoogleCalendarCheckAvailabilityToolDtoFieldRejectionPlan)
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleCalendarCheckAvailabilityToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleCalendarCheckAvailabilityToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGoogleCalendarCheckAvailabilityToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) Accept(visitor UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateGoogleCalendarCreateEventToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateGoogleCalendarCreateEventToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateGoogleCalendarCreateEventToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoogleCalendarCreateEventToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleCalendarCreateEventToolDto) GetMessages() []*UpdateGoogleCalendarCreateEventToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoogleCalendarCreateEventToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateGoogleCalendarCreateEventToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleCalendarCreateEventToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoogleCalendarCreateEventToolDto) SetMessages(messages []*UpdateGoogleCalendarCreateEventToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateGoogleCalendarCreateEventToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoogleCalendarCreateEventToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateGoogleCalendarCreateEventToolDtoFieldRejectionPlan)
}

func (u *UpdateGoogleCalendarCreateEventToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleCalendarCreateEventToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleCalendarCreateEventToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleCalendarCreateEventToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGoogleCalendarCreateEventToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateGoogleCalendarCreateEventToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleCalendarCreateEventToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoogleCalendarCreateEventToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoogleCalendarCreateEventToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) Accept(visitor UpdateGoogleCalendarCreateEventToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateGoogleSheetsRowAppendToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateGoogleSheetsRowAppendToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateGoogleSheetsRowAppendToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoogleSheetsRowAppendToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleSheetsRowAppendToolDto) GetMessages() []*UpdateGoogleSheetsRowAppendToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoogleSheetsRowAppendToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateGoogleSheetsRowAppendToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleSheetsRowAppendToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoogleSheetsRowAppendToolDto) SetMessages(messages []*UpdateGoogleSheetsRowAppendToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateGoogleSheetsRowAppendToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateGoogleSheetsRowAppendToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateGoogleSheetsRowAppendToolDtoFieldRejectionPlan)
}

func (u *UpdateGoogleSheetsRowAppendToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleSheetsRowAppendToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleSheetsRowAppendToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleSheetsRowAppendToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateGoogleSheetsRowAppendToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateGoogleSheetsRowAppendToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleSheetsRowAppendToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoogleSheetsRowAppendToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoogleSheetsRowAppendToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) Accept(visitor UpdateGoogleSheetsRowAppendToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateHandoffToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateHandoffToolDtoFieldDestinations  = big.NewInt(1 << 1)
	updateHandoffToolDtoFieldRejectionPlan = big.NewInt(1 << 2)
	updateHandoffToolDtoFieldFunction      = big.NewInt(1 << 3)
)

type UpdateHandoffToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateHandoffToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the destinations that the call can be handed off to.
	//
	// Usage:
	// 1. Single destination
	//
	// Use `assistantId` to handoff the call to a saved assistant, or `assistantName` to handoff the call to an assistant in the same squad.
	//
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-123", // or "assistantName": "Assistant123"
	//	          "description": "customer wants to be handed off to assistant-123",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        }
	//	      ],
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// 2. Multiple destinations
	//
	// 2.1. Multiple Tools, Each With One Destination (OpenAI recommended)
	//
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-123",
	//	          "description": "customer wants to be handed off to assistant-123",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        },
	//	      ],
	//	    },
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-456",
	//	          "description": "customer wants to be handed off to assistant-456",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        }
	//	      ],
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// 2.2. One Tool, Multiple Destinations (Anthropic recommended)
	//
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-123",
	//	          "description": "customer wants to be handed off to assistant-123",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        },
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-456",
	//	          "description": "customer wants to be handed off to assistant-456",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        }
	//	      ],
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// 3. Dynamic destination
	//
	// 3.1 To determine the destination dynamically, supply a `dynamic` handoff destination type and a `server` object.
	//
	//	VAPI will send a handoff-destination-request webhook to the `server.url`.
	//	The response from the server will be used as the destination (if valid).
	//
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "dynamic",
	//	          "server": {
	//	            "url": "https://example.com"
	//	          }
	//	        }
	//	      ],
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// 3.2. To pass custom parameters to the server, you can use the `function` object.
	//
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "dynamic",
	//	          "server": {
	//	            "url": "https://example.com"
	//	          },
	//	        }
	//	      ],
	//	      "function": {
	//	        "name": "handoff",
	//	        "description": "Call this function when the customer is ready to be handed off to the next assistant",
	//	        "parameters": {
	//	          "type": "object",
	//	          "properties": {
	//	            "destination": {
	//	              "type": "string",
	//	              "description": "Use dynamic when customer is ready to be handed off to the next assistant",
	//	              "enum": ["dynamic"]
	//	            },
	//	            "customerAreaCode": {
	//	              "type": "number",
	//	              "description": "Area code of the customer"
	//	            },
	//	            "customerIntent": {
	//	              "type": "string",
	//	              "enum": ["new-customer", "existing-customer"],
	//	              "description": "Use new-customer when customer is a new customer, existing-customer when customer is an existing customer"
	//	            },
	//	            "customerSentiment": {
	//	              "type": "string",
	//	              "enum": ["positive", "negative", "neutral"],
	//	              "description": "Use positive when customer is happy, negative when customer is unhappy, neutral when customer is neutral"
	//	            }
	//	          }
	//	        }
	//	      }
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// The properties `customerAreaCode`, `customerIntent`, and `customerSentiment` will be passed to the server in the webhook request body.
	Destinations []*UpdateHandoffToolDtoDestinationsItem `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// This is the optional function definition that will be passed to the LLM.
	// If this is not defined, we will construct this based on the other properties.
	//
	// For example, given the following tools definition:
	// ```json
	//
	//	{
	//	  "tools": [
	//	    {
	//	      "type": "handoff",
	//	      "destinations": [
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-123",
	//	          "description": "customer wants to be handed off to assistant-123",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        },
	//	        {
	//	          "type": "assistant",
	//	          "assistantId": "assistant-456",
	//	          "description": "customer wants to be handed off to assistant-456",
	//	          "contextEngineeringPlan": {
	//	            "type": "all"
	//	          }
	//	        }
	//	      ],
	//	    }
	//	  ]
	//	}
	//
	// ```
	//
	// We will construct the following function definition:
	// ```json
	//
	//	{
	//	  "function": {
	//	    "name": "handoff_to_assistant-123",
	//	    "description": "
	//	         Use this function to handoff the call to the next assistant.
	//	         Only use it when instructions explicitly ask you to use the handoff_to_assistant function.
	//	         DO NOT call this function unless you are instructed to do so.
	//	         Here are the destinations you can handoff the call to:
	//	         1. assistant-123. When: customer wants to be handed off to assistant-123
	//	         2. assistant-456. When: customer wants to be handed off to assistant-456
	//	    ",
	//	    "parameters": {
	//	      "type": "object",
	//	      "properties": {
	//	        "destination": {
	//	          "type": "string",
	//	          "description": "Options: assistant-123 (customer wants to be handed off to assistant-123), assistant-456 (customer wants to be handed off to assistant-456)",
	//	          "enum": ["assistant-123", "assistant-456"]
	//	        },
	//	      },
	//	      "required": ["destination"]
	//	    }
	//	  }
	//	}
	//
	// ```
	//
	// To override this function, please provide an OpenAI function definition and refer to it in the system prompt.
	// You may override parts of the function definition (i.e. you may only want to change the function name for your prompt).
	// If you choose to override the function parameters, it must include `destination` as a required parameter, and it must evaluate to either an assistantId, assistantName, or a the string literal `dynamic`.
	//
	// To pass custom parameters to the server in a dynamic handoff, you can use the function parameters, with `dynamic` as the destination.
	// ```json
	//
	//	{
	//	  "function": {
	//	    "name": "dynamic_handoff",
	//	    "description": "
	//	         Call this function when the customer is ready to be handed off to the next assistant
	//	    ",
	//	    "parameters": {
	//	      "type": "object",
	//	      "properties": {
	//	        "destination": {
	//	          "type": "string",
	//	          "enum": ["dynamic"]
	//	        },
	//	        "customerAreaCode": {
	//	          "type": "number",
	//	          "description": "Area code of the customer"
	//	        },
	//	        "customerIntent": {
	//	          "type": "string",
	//	          "enum": ["new-customer", "existing-customer"],
	//	          "description": "Use new-customer when customer is a new customer, existing-customer when customer is an existing customer"
	//	        },
	//	        "customerSentiment": {
	//	          "type": "string",
	//	          "enum": ["positive", "negative", "neutral"],
	//	          "description": "Use positive when customer is happy, negative when customer is unhappy, neutral when customer is neutral"
	//	        }
	//	      },
	//	      "required": ["destination", "customerAreaCode", "customerIntent", "customerSentiment"]
	//	    }
	//	  }
	//	}
	//
	// ```
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateHandoffToolDto) GetMessages() []*UpdateHandoffToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateHandoffToolDto) GetDestinations() []*UpdateHandoffToolDtoDestinationsItem {
	if u == nil {
		return nil
	}
	return u.Destinations
}

func (u *UpdateHandoffToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateHandoffToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateHandoffToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateHandoffToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateHandoffToolDto) SetMessages(messages []*UpdateHandoffToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateHandoffToolDtoFieldMessages)
}

// SetDestinations sets the Destinations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateHandoffToolDto) SetDestinations(destinations []*UpdateHandoffToolDtoDestinationsItem) {
	u.Destinations = destinations
	u.require(updateHandoffToolDtoFieldDestinations)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateHandoffToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateHandoffToolDtoFieldRejectionPlan)
}

// SetFunction sets the Function field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateHandoffToolDto) SetFunction(function *OpenAiFunction) {
	u.Function = function
	u.require(updateHandoffToolDtoFieldFunction)
}

func (u *UpdateHandoffToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateHandoffToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateHandoffToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateHandoffToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateHandoffToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateHandoffToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateHandoffToolDtoDestinationsItem struct {
	HandoffDestinationAssistant *HandoffDestinationAssistant
	HandoffDestinationDynamic   *HandoffDestinationDynamic

	typ string
}

func (u *UpdateHandoffToolDtoDestinationsItem) GetHandoffDestinationAssistant() *HandoffDestinationAssistant {
	if u == nil {
		return nil
	}
	return u.HandoffDestinationAssistant
}

func (u *UpdateHandoffToolDtoDestinationsItem) GetHandoffDestinationDynamic() *HandoffDestinationDynamic {
	if u == nil {
		return nil
	}
	return u.HandoffDestinationDynamic
}

func (u *UpdateHandoffToolDtoDestinationsItem) UnmarshalJSON(data []byte) error {
	valueHandoffDestinationAssistant := new(HandoffDestinationAssistant)
	if err := json.Unmarshal(data, &valueHandoffDestinationAssistant); err == nil {
		u.typ = "HandoffDestinationAssistant"
		u.HandoffDestinationAssistant = valueHandoffDestinationAssistant
		return nil
	}
	valueHandoffDestinationDynamic := new(HandoffDestinationDynamic)
	if err := json.Unmarshal(data, &valueHandoffDestinationDynamic); err == nil {
		u.typ = "HandoffDestinationDynamic"
		u.HandoffDestinationDynamic = valueHandoffDestinationDynamic
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateHandoffToolDtoDestinationsItem) MarshalJSON() ([]byte, error) {
	if u.typ == "HandoffDestinationAssistant" || u.HandoffDestinationAssistant != nil {
		return json.Marshal(u.HandoffDestinationAssistant)
	}
	if u.typ == "HandoffDestinationDynamic" || u.HandoffDestinationDynamic != nil {
		return json.Marshal(u.HandoffDestinationDynamic)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateHandoffToolDtoDestinationsItemVisitor interface {
	VisitHandoffDestinationAssistant(*HandoffDestinationAssistant) error
	VisitHandoffDestinationDynamic(*HandoffDestinationDynamic) error
}

func (u *UpdateHandoffToolDtoDestinationsItem) Accept(visitor UpdateHandoffToolDtoDestinationsItemVisitor) error {
	if u.typ == "HandoffDestinationAssistant" || u.HandoffDestinationAssistant != nil {
		return visitor.VisitHandoffDestinationAssistant(u.HandoffDestinationAssistant)
	}
	if u.typ == "HandoffDestinationDynamic" || u.HandoffDestinationDynamic != nil {
		return visitor.VisitHandoffDestinationDynamic(u.HandoffDestinationDynamic)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateHandoffToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateHandoffToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateHandoffToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateHandoffToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateHandoffToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateHandoffToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateHandoffToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateHandoffToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateHandoffToolDtoMessagesItem) Accept(visitor UpdateHandoffToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateMcpToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateMcpToolDtoFieldServer        = big.NewInt(1 << 1)
	updateMcpToolDtoFieldRejectionPlan = big.NewInt(1 << 2)
	updateMcpToolDtoFieldMetadata      = big.NewInt(1 << 3)
)

type UpdateMcpToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateMcpToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the server where a `tool-calls` webhook will be sent.
	//
	// Notes:
	// - Webhook is sent to this server when a tool call is made.
	// - Webhook contains the call, assistant, and phone number objects.
	// - Webhook contains the variables set on the assistant.
	// - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
	// - Webhook expects a response with tool call result.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	Metadata      *McpToolMetadata   `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateMcpToolDto) GetMessages() []*UpdateMcpToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateMcpToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateMcpToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateMcpToolDto) GetMetadata() *McpToolMetadata {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UpdateMcpToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMcpToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateMcpToolDto) SetMessages(messages []*UpdateMcpToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateMcpToolDtoFieldMessages)
}

// SetServer sets the Server field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateMcpToolDto) SetServer(server *Server) {
	u.Server = server
	u.require(updateMcpToolDtoFieldServer)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateMcpToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateMcpToolDtoFieldRejectionPlan)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateMcpToolDto) SetMetadata(metadata *McpToolMetadata) {
	u.Metadata = metadata
	u.require(updateMcpToolDtoFieldMetadata)
}

func (u *UpdateMcpToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateMcpToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateMcpToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMcpToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateMcpToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateMcpToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateMcpToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateMcpToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateMcpToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateMcpToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateMcpToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateMcpToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateMcpToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateMcpToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateMcpToolDtoMessagesItem) Accept(visitor UpdateMcpToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateQueryToolDtoFieldMessages       = big.NewInt(1 << 0)
	updateQueryToolDtoFieldKnowledgeBases = big.NewInt(1 << 1)
	updateQueryToolDtoFieldRejectionPlan  = big.NewInt(1 << 2)
)

type UpdateQueryToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateQueryToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The knowledge bases to query
	KnowledgeBases []*KnowledgeBase `json:"knowledgeBases,omitempty" url:"knowledgeBases,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateQueryToolDto) GetMessages() []*UpdateQueryToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateQueryToolDto) GetKnowledgeBases() []*KnowledgeBase {
	if u == nil {
		return nil
	}
	return u.KnowledgeBases
}

func (u *UpdateQueryToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateQueryToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateQueryToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateQueryToolDto) SetMessages(messages []*UpdateQueryToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateQueryToolDtoFieldMessages)
}

// SetKnowledgeBases sets the KnowledgeBases field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateQueryToolDto) SetKnowledgeBases(knowledgeBases []*KnowledgeBase) {
	u.KnowledgeBases = knowledgeBases
	u.require(updateQueryToolDtoFieldKnowledgeBases)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateQueryToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateQueryToolDtoFieldRejectionPlan)
}

func (u *UpdateQueryToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateQueryToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateQueryToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateQueryToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateQueryToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateQueryToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateQueryToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateQueryToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateQueryToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateQueryToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateQueryToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateQueryToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateQueryToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateQueryToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateQueryToolDtoMessagesItem) Accept(visitor UpdateQueryToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateSlackSendMessageToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateSlackSendMessageToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateSlackSendMessageToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateSlackSendMessageToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSlackSendMessageToolDto) GetMessages() []*UpdateSlackSendMessageToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateSlackSendMessageToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateSlackSendMessageToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSlackSendMessageToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateSlackSendMessageToolDto) SetMessages(messages []*UpdateSlackSendMessageToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateSlackSendMessageToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateSlackSendMessageToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateSlackSendMessageToolDtoFieldRejectionPlan)
}

func (u *UpdateSlackSendMessageToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSlackSendMessageToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSlackSendMessageToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSlackSendMessageToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateSlackSendMessageToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateSlackSendMessageToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateSlackSendMessageToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateSlackSendMessageToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateSlackSendMessageToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) Accept(visitor UpdateSlackSendMessageToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateSmsToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateSmsToolDtoFieldRejectionPlan = big.NewInt(1 << 1)
)

type UpdateSmsToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateSmsToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSmsToolDto) GetMessages() []*UpdateSmsToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateSmsToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateSmsToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSmsToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateSmsToolDto) SetMessages(messages []*UpdateSmsToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateSmsToolDtoFieldMessages)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateSmsToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateSmsToolDtoFieldRejectionPlan)
}

func (u *UpdateSmsToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSmsToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSmsToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSmsToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateSmsToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateSmsToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateSmsToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateSmsToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateSmsToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateSmsToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateSmsToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateSmsToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateSmsToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateSmsToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateSmsToolDtoMessagesItem) Accept(visitor UpdateSmsToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateTextEditorToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateTextEditorToolDtoFieldSubType       = big.NewInt(1 << 1)
	updateTextEditorToolDtoFieldServer        = big.NewInt(1 << 2)
	updateTextEditorToolDtoFieldRejectionPlan = big.NewInt(1 << 3)
	updateTextEditorToolDtoFieldName          = big.NewInt(1 << 4)
)

type UpdateTextEditorToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateTextEditorToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	SubType *UpdateTextEditorToolDtoSubType `json:"subType,omitempty" url:"subType,omitempty"`
	// This is the server where a `tool-calls` webhook will be sent.
	//
	// Notes:
	// - Webhook is sent to this server when a tool call is made.
	// - Webhook contains the call, assistant, and phone number objects.
	// - Webhook contains the variables set on the assistant.
	// - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
	// - Webhook expects a response with tool call result.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`
	// The name of the tool, fixed to 'str_replace_editor'
	Name *UpdateTextEditorToolDtoName `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTextEditorToolDto) GetMessages() []*UpdateTextEditorToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateTextEditorToolDto) GetSubType() *UpdateTextEditorToolDtoSubType {
	if u == nil {
		return nil
	}
	return u.SubType
}

func (u *UpdateTextEditorToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateTextEditorToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateTextEditorToolDto) GetName() *UpdateTextEditorToolDtoName {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTextEditorToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTextEditorToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTextEditorToolDto) SetMessages(messages []*UpdateTextEditorToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateTextEditorToolDtoFieldMessages)
}

// SetSubType sets the SubType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTextEditorToolDto) SetSubType(subType *UpdateTextEditorToolDtoSubType) {
	u.SubType = subType
	u.require(updateTextEditorToolDtoFieldSubType)
}

// SetServer sets the Server field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTextEditorToolDto) SetServer(server *Server) {
	u.Server = server
	u.require(updateTextEditorToolDtoFieldServer)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTextEditorToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateTextEditorToolDtoFieldRejectionPlan)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTextEditorToolDto) SetName(name *UpdateTextEditorToolDtoName) {
	u.Name = name
	u.require(updateTextEditorToolDtoFieldName)
}

func (u *UpdateTextEditorToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTextEditorToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTextEditorToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTextEditorToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateTextEditorToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateTextEditorToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTextEditorToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateTextEditorToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateTextEditorToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateTextEditorToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateTextEditorToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateTextEditorToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateTextEditorToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTextEditorToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateTextEditorToolDtoMessagesItem) Accept(visitor UpdateTextEditorToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// The name of the tool, fixed to 'str_replace_editor'
type UpdateTextEditorToolDtoName string

const (
	UpdateTextEditorToolDtoNameStrReplaceEditor UpdateTextEditorToolDtoName = "str_replace_editor"
)

func NewUpdateTextEditorToolDtoNameFromString(s string) (UpdateTextEditorToolDtoName, error) {
	switch s {
	case "str_replace_editor":
		return UpdateTextEditorToolDtoNameStrReplaceEditor, nil
	}
	var t UpdateTextEditorToolDtoName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateTextEditorToolDtoName) Ptr() *UpdateTextEditorToolDtoName {
	return &u
}

// The sub type of tool.
type UpdateTextEditorToolDtoSubType string

const (
	UpdateTextEditorToolDtoSubTypeTextEditor20241022 UpdateTextEditorToolDtoSubType = "text_editor_20241022"
)

func NewUpdateTextEditorToolDtoSubTypeFromString(s string) (UpdateTextEditorToolDtoSubType, error) {
	switch s {
	case "text_editor_20241022":
		return UpdateTextEditorToolDtoSubTypeTextEditor20241022, nil
	}
	var t UpdateTextEditorToolDtoSubType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateTextEditorToolDtoSubType) Ptr() *UpdateTextEditorToolDtoSubType {
	return &u
}

var (
	updateTransferCallToolDtoFieldMessages      = big.NewInt(1 << 0)
	updateTransferCallToolDtoFieldDestinations  = big.NewInt(1 << 1)
	updateTransferCallToolDtoFieldRejectionPlan = big.NewInt(1 << 2)
)

type UpdateTransferCallToolDto struct {
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateTransferCallToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.
	Destinations []*UpdateTransferCallToolDtoDestinationsItem `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the plan to reject a tool call based on the conversation state.
	//
	// // Example 1: Reject endCall if user didn't say goodbye
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '(?i)\\b(bye|goodbye|farewell|see you later|take care)\\b',
	//	    target: { position: -1, role: 'user' },
	//	    negate: true  // Reject if pattern does NOT match
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 2: Reject transfer if user is actually asking a question
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'regex',
	//	    regex: '\\?',
	//	    target: { position: -1, role: 'user' }
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 3: Reject transfer if user didn't mention transfer recently
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 5 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' %}
	// {% assign mentioned = false %}
	// {% for msg in userMessages %}
	//
	//	{% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
	//	  {% assign mentioned = true %}
	//	  {% break %}
	//	{% endif %}
	//
	// {% endfor %}
	// {% if mentioned %}
	//
	//	false
	//
	// {% else %}
	//
	//	true
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	//
	// // Example 4: Reject endCall if the bot is looping and trying to exit
	// ```json
	//
	//	{
	//	  conditions: [{
	//	    type: 'liquid',
	//	    liquid: `{% assign recentMessages = messages | last: 6 %}
	//
	// {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
	// {% if userMessages.size < 3 %}
	//
	//	false
	//
	// {% else %}
	//
	//	{% assign msg1 = userMessages[0].content | downcase %}
	//	{% assign msg2 = userMessages[1].content | downcase %}
	//	{% assign msg3 = userMessages[2].content | downcase %}
	//	{% comment %} Check for repetitive messages {% endcomment %}
	//	{% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
	//	  true
	//	{% comment %} Check for common loop phrases {% endcomment %}
	//	{% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
	//	  true
	//	{% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
	//	  true
	//	{% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
	//	  true
	//	{% else %}
	//	  false
	//	{% endif %}
	//
	// {% endif %}`
	//
	//	  }]
	//	}
	//
	// ```
	RejectionPlan *ToolRejectionPlan `json:"rejectionPlan,omitempty" url:"rejectionPlan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTransferCallToolDto) GetMessages() []*UpdateTransferCallToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateTransferCallToolDto) GetDestinations() []*UpdateTransferCallToolDtoDestinationsItem {
	if u == nil {
		return nil
	}
	return u.Destinations
}

func (u *UpdateTransferCallToolDto) GetRejectionPlan() *ToolRejectionPlan {
	if u == nil {
		return nil
	}
	return u.RejectionPlan
}

func (u *UpdateTransferCallToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTransferCallToolDto) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTransferCallToolDto) SetMessages(messages []*UpdateTransferCallToolDtoMessagesItem) {
	u.Messages = messages
	u.require(updateTransferCallToolDtoFieldMessages)
}

// SetDestinations sets the Destinations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTransferCallToolDto) SetDestinations(destinations []*UpdateTransferCallToolDtoDestinationsItem) {
	u.Destinations = destinations
	u.require(updateTransferCallToolDtoFieldDestinations)
}

// SetRejectionPlan sets the RejectionPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateTransferCallToolDto) SetRejectionPlan(rejectionPlan *ToolRejectionPlan) {
	u.RejectionPlan = rejectionPlan
	u.require(updateTransferCallToolDtoFieldRejectionPlan)
}

func (u *UpdateTransferCallToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTransferCallToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTransferCallToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTransferCallToolDto) MarshalJSON() ([]byte, error) {
	type embed UpdateTransferCallToolDto
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateTransferCallToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTransferCallToolDtoDestinationsItem struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (u *UpdateTransferCallToolDtoDestinationsItem) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if u == nil {
		return nil
	}
	return u.TransferDestinationAssistant
}

func (u *UpdateTransferCallToolDtoDestinationsItem) GetTransferDestinationNumber() *TransferDestinationNumber {
	if u == nil {
		return nil
	}
	return u.TransferDestinationNumber
}

func (u *UpdateTransferCallToolDtoDestinationsItem) GetTransferDestinationSip() *TransferDestinationSip {
	if u == nil {
		return nil
	}
	return u.TransferDestinationSip
}

func (u *UpdateTransferCallToolDtoDestinationsItem) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		u.typ = "TransferDestinationAssistant"
		u.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		u.typ = "TransferDestinationNumber"
		u.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		u.typ = "TransferDestinationSip"
		u.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateTransferCallToolDtoDestinationsItem) MarshalJSON() ([]byte, error) {
	if u.typ == "TransferDestinationAssistant" || u.TransferDestinationAssistant != nil {
		return json.Marshal(u.TransferDestinationAssistant)
	}
	if u.typ == "TransferDestinationNumber" || u.TransferDestinationNumber != nil {
		return json.Marshal(u.TransferDestinationNumber)
	}
	if u.typ == "TransferDestinationSip" || u.TransferDestinationSip != nil {
		return json.Marshal(u.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTransferCallToolDtoDestinationsItemVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (u *UpdateTransferCallToolDtoDestinationsItem) Accept(visitor UpdateTransferCallToolDtoDestinationsItemVisitor) error {
	if u.typ == "TransferDestinationAssistant" || u.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(u.TransferDestinationAssistant)
	}
	if u.typ == "TransferDestinationNumber" || u.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(u.TransferDestinationNumber)
	}
	if u.typ == "TransferDestinationSip" || u.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(u.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTransferCallToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateTransferCallToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateTransferCallToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateTransferCallToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateTransferCallToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateTransferCallToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateTransferCallToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTransferCallToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateTransferCallToolDtoMessagesItem) Accept(visitor UpdateTransferCallToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type CreateToolsRequest struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto
	CreateHandoffToolDto                         *CreateHandoffToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto

	typ string
}

func (c *CreateToolsRequest) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if c == nil {
		return nil
	}
	return c.CreateApiRequestToolDto
}

func (c *CreateToolsRequest) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if c == nil {
		return nil
	}
	return c.CreateDtmfToolDto
}

func (c *CreateToolsRequest) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateEndCallToolDto
}

func (c *CreateToolsRequest) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if c == nil {
		return nil
	}
	return c.CreateFunctionToolDto
}

func (c *CreateToolsRequest) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTransferCallToolDto
}

func (c *CreateToolsRequest) GetCreateHandoffToolDto() *CreateHandoffToolDto {
	if c == nil {
		return nil
	}
	return c.CreateHandoffToolDto
}

func (c *CreateToolsRequest) GetCreateBashToolDto() *CreateBashToolDto {
	if c == nil {
		return nil
	}
	return c.CreateBashToolDto
}

func (c *CreateToolsRequest) GetCreateComputerToolDto() *CreateComputerToolDto {
	if c == nil {
		return nil
	}
	return c.CreateComputerToolDto
}

func (c *CreateToolsRequest) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTextEditorToolDto
}

func (c *CreateToolsRequest) GetCreateQueryToolDto() *CreateQueryToolDto {
	if c == nil {
		return nil
	}
	return c.CreateQueryToolDto
}

func (c *CreateToolsRequest) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCalendarCreateEventToolDto
}

func (c *CreateToolsRequest) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleSheetsRowAppendToolDto
}

func (c *CreateToolsRequest) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (c *CreateToolsRequest) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if c == nil {
		return nil
	}
	return c.CreateSlackSendMessageToolDto
}

func (c *CreateToolsRequest) GetCreateSmsToolDto() *CreateSmsToolDto {
	if c == nil {
		return nil
	}
	return c.CreateSmsToolDto
}

func (c *CreateToolsRequest) GetCreateMcpToolDto() *CreateMcpToolDto {
	if c == nil {
		return nil
	}
	return c.CreateMcpToolDto
}

func (c *CreateToolsRequest) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (c *CreateToolsRequest) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelCalendarEventCreateToolDto
}

func (c *CreateToolsRequest) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelContactCreateToolDto
}

func (c *CreateToolsRequest) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelContactGetToolDto
}

func (c *CreateToolsRequest) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		c.typ = "CreateApiRequestToolDto"
		c.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		c.typ = "CreateDtmfToolDto"
		c.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		c.typ = "CreateEndCallToolDto"
		c.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		c.typ = "CreateFunctionToolDto"
		c.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		c.typ = "CreateTransferCallToolDto"
		c.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	valueCreateHandoffToolDto := new(CreateHandoffToolDto)
	if err := json.Unmarshal(data, &valueCreateHandoffToolDto); err == nil {
		c.typ = "CreateHandoffToolDto"
		c.CreateHandoffToolDto = valueCreateHandoffToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		c.typ = "CreateBashToolDto"
		c.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		c.typ = "CreateComputerToolDto"
		c.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		c.typ = "CreateTextEditorToolDto"
		c.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		c.typ = "CreateQueryToolDto"
		c.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		c.typ = "CreateGoogleCalendarCreateEventToolDto"
		c.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		c.typ = "CreateGoogleSheetsRowAppendToolDto"
		c.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		c.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		c.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		c.typ = "CreateSlackSendMessageToolDto"
		c.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		c.typ = "CreateSmsToolDto"
		c.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		c.typ = "CreateMcpToolDto"
		c.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		c.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		c.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		c.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		c.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		c.typ = "CreateGoHighLevelContactCreateToolDto"
		c.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		c.typ = "CreateGoHighLevelContactGetToolDto"
		c.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolsRequest) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateApiRequestToolDto" || c.CreateApiRequestToolDto != nil {
		return json.Marshal(c.CreateApiRequestToolDto)
	}
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return json.Marshal(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return json.Marshal(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return json.Marshal(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return json.Marshal(c.CreateTransferCallToolDto)
	}
	if c.typ == "CreateHandoffToolDto" || c.CreateHandoffToolDto != nil {
		return json.Marshal(c.CreateHandoffToolDto)
	}
	if c.typ == "CreateBashToolDto" || c.CreateBashToolDto != nil {
		return json.Marshal(c.CreateBashToolDto)
	}
	if c.typ == "CreateComputerToolDto" || c.CreateComputerToolDto != nil {
		return json.Marshal(c.CreateComputerToolDto)
	}
	if c.typ == "CreateTextEditorToolDto" || c.CreateTextEditorToolDto != nil {
		return json.Marshal(c.CreateTextEditorToolDto)
	}
	if c.typ == "CreateQueryToolDto" || c.CreateQueryToolDto != nil {
		return json.Marshal(c.CreateQueryToolDto)
	}
	if c.typ == "CreateGoogleCalendarCreateEventToolDto" || c.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(c.CreateGoogleCalendarCreateEventToolDto)
	}
	if c.typ == "CreateGoogleSheetsRowAppendToolDto" || c.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(c.CreateGoogleSheetsRowAppendToolDto)
	}
	if c.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || c.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(c.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if c.typ == "CreateSlackSendMessageToolDto" || c.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(c.CreateSlackSendMessageToolDto)
	}
	if c.typ == "CreateSmsToolDto" || c.CreateSmsToolDto != nil {
		return json.Marshal(c.CreateSmsToolDto)
	}
	if c.typ == "CreateMcpToolDto" || c.CreateMcpToolDto != nil {
		return json.Marshal(c.CreateMcpToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || c.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || c.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactCreateToolDto" || c.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelContactCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactGetToolDto" || c.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelContactGetToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolsRequestVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
	VisitCreateHandoffToolDto(*CreateHandoffToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
}

func (c *CreateToolsRequest) Accept(visitor CreateToolsRequestVisitor) error {
	if c.typ == "CreateApiRequestToolDto" || c.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(c.CreateApiRequestToolDto)
	}
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(c.CreateTransferCallToolDto)
	}
	if c.typ == "CreateHandoffToolDto" || c.CreateHandoffToolDto != nil {
		return visitor.VisitCreateHandoffToolDto(c.CreateHandoffToolDto)
	}
	if c.typ == "CreateBashToolDto" || c.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(c.CreateBashToolDto)
	}
	if c.typ == "CreateComputerToolDto" || c.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(c.CreateComputerToolDto)
	}
	if c.typ == "CreateTextEditorToolDto" || c.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(c.CreateTextEditorToolDto)
	}
	if c.typ == "CreateQueryToolDto" || c.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(c.CreateQueryToolDto)
	}
	if c.typ == "CreateGoogleCalendarCreateEventToolDto" || c.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(c.CreateGoogleCalendarCreateEventToolDto)
	}
	if c.typ == "CreateGoogleSheetsRowAppendToolDto" || c.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(c.CreateGoogleSheetsRowAppendToolDto)
	}
	if c.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || c.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(c.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if c.typ == "CreateSlackSendMessageToolDto" || c.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(c.CreateSlackSendMessageToolDto)
	}
	if c.typ == "CreateSmsToolDto" || c.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(c.CreateSmsToolDto)
	}
	if c.typ == "CreateMcpToolDto" || c.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(c.CreateMcpToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || c.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(c.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || c.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(c.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactCreateToolDto" || c.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(c.CreateGoHighLevelContactCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactGetToolDto" || c.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(c.CreateGoHighLevelContactGetToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolsResponse struct {
	ApiRequestTool                      *ApiRequestTool
	DtmfTool                            *DtmfTool
	EndCallTool                         *EndCallTool
	FunctionTool                        *FunctionTool
	TransferCallTool                    *TransferCallTool
	HandoffTool                         *HandoffTool
	BashTool                            *BashTool
	ComputerTool                        *ComputerTool
	TextEditorTool                      *TextEditorTool
	QueryTool                           *QueryTool
	GoogleCalendarCreateEventTool       *GoogleCalendarCreateEventTool
	GoogleSheetsRowAppendTool           *GoogleSheetsRowAppendTool
	GoogleCalendarCheckAvailabilityTool *GoogleCalendarCheckAvailabilityTool
	SlackSendMessageTool                *SlackSendMessageTool
	SmsTool                             *SmsTool
	McpTool                             *McpTool
	GoHighLevelCalendarAvailabilityTool *GoHighLevelCalendarAvailabilityTool
	GoHighLevelCalendarEventCreateTool  *GoHighLevelCalendarEventCreateTool
	GoHighLevelContactCreateTool        *GoHighLevelContactCreateTool
	GoHighLevelContactGetTool           *GoHighLevelContactGetTool

	typ string
}

func (c *CreateToolsResponse) GetApiRequestTool() *ApiRequestTool {
	if c == nil {
		return nil
	}
	return c.ApiRequestTool
}

func (c *CreateToolsResponse) GetDtmfTool() *DtmfTool {
	if c == nil {
		return nil
	}
	return c.DtmfTool
}

func (c *CreateToolsResponse) GetEndCallTool() *EndCallTool {
	if c == nil {
		return nil
	}
	return c.EndCallTool
}

func (c *CreateToolsResponse) GetFunctionTool() *FunctionTool {
	if c == nil {
		return nil
	}
	return c.FunctionTool
}

func (c *CreateToolsResponse) GetTransferCallTool() *TransferCallTool {
	if c == nil {
		return nil
	}
	return c.TransferCallTool
}

func (c *CreateToolsResponse) GetHandoffTool() *HandoffTool {
	if c == nil {
		return nil
	}
	return c.HandoffTool
}

func (c *CreateToolsResponse) GetBashTool() *BashTool {
	if c == nil {
		return nil
	}
	return c.BashTool
}

func (c *CreateToolsResponse) GetComputerTool() *ComputerTool {
	if c == nil {
		return nil
	}
	return c.ComputerTool
}

func (c *CreateToolsResponse) GetTextEditorTool() *TextEditorTool {
	if c == nil {
		return nil
	}
	return c.TextEditorTool
}

func (c *CreateToolsResponse) GetQueryTool() *QueryTool {
	if c == nil {
		return nil
	}
	return c.QueryTool
}

func (c *CreateToolsResponse) GetGoogleCalendarCreateEventTool() *GoogleCalendarCreateEventTool {
	if c == nil {
		return nil
	}
	return c.GoogleCalendarCreateEventTool
}

func (c *CreateToolsResponse) GetGoogleSheetsRowAppendTool() *GoogleSheetsRowAppendTool {
	if c == nil {
		return nil
	}
	return c.GoogleSheetsRowAppendTool
}

func (c *CreateToolsResponse) GetGoogleCalendarCheckAvailabilityTool() *GoogleCalendarCheckAvailabilityTool {
	if c == nil {
		return nil
	}
	return c.GoogleCalendarCheckAvailabilityTool
}

func (c *CreateToolsResponse) GetSlackSendMessageTool() *SlackSendMessageTool {
	if c == nil {
		return nil
	}
	return c.SlackSendMessageTool
}

func (c *CreateToolsResponse) GetSmsTool() *SmsTool {
	if c == nil {
		return nil
	}
	return c.SmsTool
}

func (c *CreateToolsResponse) GetMcpTool() *McpTool {
	if c == nil {
		return nil
	}
	return c.McpTool
}

func (c *CreateToolsResponse) GetGoHighLevelCalendarAvailabilityTool() *GoHighLevelCalendarAvailabilityTool {
	if c == nil {
		return nil
	}
	return c.GoHighLevelCalendarAvailabilityTool
}

func (c *CreateToolsResponse) GetGoHighLevelCalendarEventCreateTool() *GoHighLevelCalendarEventCreateTool {
	if c == nil {
		return nil
	}
	return c.GoHighLevelCalendarEventCreateTool
}

func (c *CreateToolsResponse) GetGoHighLevelContactCreateTool() *GoHighLevelContactCreateTool {
	if c == nil {
		return nil
	}
	return c.GoHighLevelContactCreateTool
}

func (c *CreateToolsResponse) GetGoHighLevelContactGetTool() *GoHighLevelContactGetTool {
	if c == nil {
		return nil
	}
	return c.GoHighLevelContactGetTool
}

func (c *CreateToolsResponse) UnmarshalJSON(data []byte) error {
	valueApiRequestTool := new(ApiRequestTool)
	if err := json.Unmarshal(data, &valueApiRequestTool); err == nil {
		c.typ = "ApiRequestTool"
		c.ApiRequestTool = valueApiRequestTool
		return nil
	}
	valueDtmfTool := new(DtmfTool)
	if err := json.Unmarshal(data, &valueDtmfTool); err == nil {
		c.typ = "DtmfTool"
		c.DtmfTool = valueDtmfTool
		return nil
	}
	valueEndCallTool := new(EndCallTool)
	if err := json.Unmarshal(data, &valueEndCallTool); err == nil {
		c.typ = "EndCallTool"
		c.EndCallTool = valueEndCallTool
		return nil
	}
	valueFunctionTool := new(FunctionTool)
	if err := json.Unmarshal(data, &valueFunctionTool); err == nil {
		c.typ = "FunctionTool"
		c.FunctionTool = valueFunctionTool
		return nil
	}
	valueTransferCallTool := new(TransferCallTool)
	if err := json.Unmarshal(data, &valueTransferCallTool); err == nil {
		c.typ = "TransferCallTool"
		c.TransferCallTool = valueTransferCallTool
		return nil
	}
	valueHandoffTool := new(HandoffTool)
	if err := json.Unmarshal(data, &valueHandoffTool); err == nil {
		c.typ = "HandoffTool"
		c.HandoffTool = valueHandoffTool
		return nil
	}
	valueBashTool := new(BashTool)
	if err := json.Unmarshal(data, &valueBashTool); err == nil {
		c.typ = "BashTool"
		c.BashTool = valueBashTool
		return nil
	}
	valueComputerTool := new(ComputerTool)
	if err := json.Unmarshal(data, &valueComputerTool); err == nil {
		c.typ = "ComputerTool"
		c.ComputerTool = valueComputerTool
		return nil
	}
	valueTextEditorTool := new(TextEditorTool)
	if err := json.Unmarshal(data, &valueTextEditorTool); err == nil {
		c.typ = "TextEditorTool"
		c.TextEditorTool = valueTextEditorTool
		return nil
	}
	valueQueryTool := new(QueryTool)
	if err := json.Unmarshal(data, &valueQueryTool); err == nil {
		c.typ = "QueryTool"
		c.QueryTool = valueQueryTool
		return nil
	}
	valueGoogleCalendarCreateEventTool := new(GoogleCalendarCreateEventTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventTool); err == nil {
		c.typ = "GoogleCalendarCreateEventTool"
		c.GoogleCalendarCreateEventTool = valueGoogleCalendarCreateEventTool
		return nil
	}
	valueGoogleSheetsRowAppendTool := new(GoogleSheetsRowAppendTool)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendTool); err == nil {
		c.typ = "GoogleSheetsRowAppendTool"
		c.GoogleSheetsRowAppendTool = valueGoogleSheetsRowAppendTool
		return nil
	}
	valueGoogleCalendarCheckAvailabilityTool := new(GoogleCalendarCheckAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCheckAvailabilityTool); err == nil {
		c.typ = "GoogleCalendarCheckAvailabilityTool"
		c.GoogleCalendarCheckAvailabilityTool = valueGoogleCalendarCheckAvailabilityTool
		return nil
	}
	valueSlackSendMessageTool := new(SlackSendMessageTool)
	if err := json.Unmarshal(data, &valueSlackSendMessageTool); err == nil {
		c.typ = "SlackSendMessageTool"
		c.SlackSendMessageTool = valueSlackSendMessageTool
		return nil
	}
	valueSmsTool := new(SmsTool)
	if err := json.Unmarshal(data, &valueSmsTool); err == nil {
		c.typ = "SmsTool"
		c.SmsTool = valueSmsTool
		return nil
	}
	valueMcpTool := new(McpTool)
	if err := json.Unmarshal(data, &valueMcpTool); err == nil {
		c.typ = "McpTool"
		c.McpTool = valueMcpTool
		return nil
	}
	valueGoHighLevelCalendarAvailabilityTool := new(GoHighLevelCalendarAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityTool); err == nil {
		c.typ = "GoHighLevelCalendarAvailabilityTool"
		c.GoHighLevelCalendarAvailabilityTool = valueGoHighLevelCalendarAvailabilityTool
		return nil
	}
	valueGoHighLevelCalendarEventCreateTool := new(GoHighLevelCalendarEventCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateTool); err == nil {
		c.typ = "GoHighLevelCalendarEventCreateTool"
		c.GoHighLevelCalendarEventCreateTool = valueGoHighLevelCalendarEventCreateTool
		return nil
	}
	valueGoHighLevelContactCreateTool := new(GoHighLevelContactCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateTool); err == nil {
		c.typ = "GoHighLevelContactCreateTool"
		c.GoHighLevelContactCreateTool = valueGoHighLevelContactCreateTool
		return nil
	}
	valueGoHighLevelContactGetTool := new(GoHighLevelContactGetTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetTool); err == nil {
		c.typ = "GoHighLevelContactGetTool"
		c.GoHighLevelContactGetTool = valueGoHighLevelContactGetTool
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolsResponse) MarshalJSON() ([]byte, error) {
	if c.typ == "ApiRequestTool" || c.ApiRequestTool != nil {
		return json.Marshal(c.ApiRequestTool)
	}
	if c.typ == "DtmfTool" || c.DtmfTool != nil {
		return json.Marshal(c.DtmfTool)
	}
	if c.typ == "EndCallTool" || c.EndCallTool != nil {
		return json.Marshal(c.EndCallTool)
	}
	if c.typ == "FunctionTool" || c.FunctionTool != nil {
		return json.Marshal(c.FunctionTool)
	}
	if c.typ == "TransferCallTool" || c.TransferCallTool != nil {
		return json.Marshal(c.TransferCallTool)
	}
	if c.typ == "HandoffTool" || c.HandoffTool != nil {
		return json.Marshal(c.HandoffTool)
	}
	if c.typ == "BashTool" || c.BashTool != nil {
		return json.Marshal(c.BashTool)
	}
	if c.typ == "ComputerTool" || c.ComputerTool != nil {
		return json.Marshal(c.ComputerTool)
	}
	if c.typ == "TextEditorTool" || c.TextEditorTool != nil {
		return json.Marshal(c.TextEditorTool)
	}
	if c.typ == "QueryTool" || c.QueryTool != nil {
		return json.Marshal(c.QueryTool)
	}
	if c.typ == "GoogleCalendarCreateEventTool" || c.GoogleCalendarCreateEventTool != nil {
		return json.Marshal(c.GoogleCalendarCreateEventTool)
	}
	if c.typ == "GoogleSheetsRowAppendTool" || c.GoogleSheetsRowAppendTool != nil {
		return json.Marshal(c.GoogleSheetsRowAppendTool)
	}
	if c.typ == "GoogleCalendarCheckAvailabilityTool" || c.GoogleCalendarCheckAvailabilityTool != nil {
		return json.Marshal(c.GoogleCalendarCheckAvailabilityTool)
	}
	if c.typ == "SlackSendMessageTool" || c.SlackSendMessageTool != nil {
		return json.Marshal(c.SlackSendMessageTool)
	}
	if c.typ == "SmsTool" || c.SmsTool != nil {
		return json.Marshal(c.SmsTool)
	}
	if c.typ == "McpTool" || c.McpTool != nil {
		return json.Marshal(c.McpTool)
	}
	if c.typ == "GoHighLevelCalendarAvailabilityTool" || c.GoHighLevelCalendarAvailabilityTool != nil {
		return json.Marshal(c.GoHighLevelCalendarAvailabilityTool)
	}
	if c.typ == "GoHighLevelCalendarEventCreateTool" || c.GoHighLevelCalendarEventCreateTool != nil {
		return json.Marshal(c.GoHighLevelCalendarEventCreateTool)
	}
	if c.typ == "GoHighLevelContactCreateTool" || c.GoHighLevelContactCreateTool != nil {
		return json.Marshal(c.GoHighLevelContactCreateTool)
	}
	if c.typ == "GoHighLevelContactGetTool" || c.GoHighLevelContactGetTool != nil {
		return json.Marshal(c.GoHighLevelContactGetTool)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolsResponseVisitor interface {
	VisitApiRequestTool(*ApiRequestTool) error
	VisitDtmfTool(*DtmfTool) error
	VisitEndCallTool(*EndCallTool) error
	VisitFunctionTool(*FunctionTool) error
	VisitTransferCallTool(*TransferCallTool) error
	VisitHandoffTool(*HandoffTool) error
	VisitBashTool(*BashTool) error
	VisitComputerTool(*ComputerTool) error
	VisitTextEditorTool(*TextEditorTool) error
	VisitQueryTool(*QueryTool) error
	VisitGoogleCalendarCreateEventTool(*GoogleCalendarCreateEventTool) error
	VisitGoogleSheetsRowAppendTool(*GoogleSheetsRowAppendTool) error
	VisitGoogleCalendarCheckAvailabilityTool(*GoogleCalendarCheckAvailabilityTool) error
	VisitSlackSendMessageTool(*SlackSendMessageTool) error
	VisitSmsTool(*SmsTool) error
	VisitMcpTool(*McpTool) error
	VisitGoHighLevelCalendarAvailabilityTool(*GoHighLevelCalendarAvailabilityTool) error
	VisitGoHighLevelCalendarEventCreateTool(*GoHighLevelCalendarEventCreateTool) error
	VisitGoHighLevelContactCreateTool(*GoHighLevelContactCreateTool) error
	VisitGoHighLevelContactGetTool(*GoHighLevelContactGetTool) error
}

func (c *CreateToolsResponse) Accept(visitor CreateToolsResponseVisitor) error {
	if c.typ == "ApiRequestTool" || c.ApiRequestTool != nil {
		return visitor.VisitApiRequestTool(c.ApiRequestTool)
	}
	if c.typ == "DtmfTool" || c.DtmfTool != nil {
		return visitor.VisitDtmfTool(c.DtmfTool)
	}
	if c.typ == "EndCallTool" || c.EndCallTool != nil {
		return visitor.VisitEndCallTool(c.EndCallTool)
	}
	if c.typ == "FunctionTool" || c.FunctionTool != nil {
		return visitor.VisitFunctionTool(c.FunctionTool)
	}
	if c.typ == "TransferCallTool" || c.TransferCallTool != nil {
		return visitor.VisitTransferCallTool(c.TransferCallTool)
	}
	if c.typ == "HandoffTool" || c.HandoffTool != nil {
		return visitor.VisitHandoffTool(c.HandoffTool)
	}
	if c.typ == "BashTool" || c.BashTool != nil {
		return visitor.VisitBashTool(c.BashTool)
	}
	if c.typ == "ComputerTool" || c.ComputerTool != nil {
		return visitor.VisitComputerTool(c.ComputerTool)
	}
	if c.typ == "TextEditorTool" || c.TextEditorTool != nil {
		return visitor.VisitTextEditorTool(c.TextEditorTool)
	}
	if c.typ == "QueryTool" || c.QueryTool != nil {
		return visitor.VisitQueryTool(c.QueryTool)
	}
	if c.typ == "GoogleCalendarCreateEventTool" || c.GoogleCalendarCreateEventTool != nil {
		return visitor.VisitGoogleCalendarCreateEventTool(c.GoogleCalendarCreateEventTool)
	}
	if c.typ == "GoogleSheetsRowAppendTool" || c.GoogleSheetsRowAppendTool != nil {
		return visitor.VisitGoogleSheetsRowAppendTool(c.GoogleSheetsRowAppendTool)
	}
	if c.typ == "GoogleCalendarCheckAvailabilityTool" || c.GoogleCalendarCheckAvailabilityTool != nil {
		return visitor.VisitGoogleCalendarCheckAvailabilityTool(c.GoogleCalendarCheckAvailabilityTool)
	}
	if c.typ == "SlackSendMessageTool" || c.SlackSendMessageTool != nil {
		return visitor.VisitSlackSendMessageTool(c.SlackSendMessageTool)
	}
	if c.typ == "SmsTool" || c.SmsTool != nil {
		return visitor.VisitSmsTool(c.SmsTool)
	}
	if c.typ == "McpTool" || c.McpTool != nil {
		return visitor.VisitMcpTool(c.McpTool)
	}
	if c.typ == "GoHighLevelCalendarAvailabilityTool" || c.GoHighLevelCalendarAvailabilityTool != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityTool(c.GoHighLevelCalendarAvailabilityTool)
	}
	if c.typ == "GoHighLevelCalendarEventCreateTool" || c.GoHighLevelCalendarEventCreateTool != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateTool(c.GoHighLevelCalendarEventCreateTool)
	}
	if c.typ == "GoHighLevelContactCreateTool" || c.GoHighLevelContactCreateTool != nil {
		return visitor.VisitGoHighLevelContactCreateTool(c.GoHighLevelContactCreateTool)
	}
	if c.typ == "GoHighLevelContactGetTool" || c.GoHighLevelContactGetTool != nil {
		return visitor.VisitGoHighLevelContactGetTool(c.GoHighLevelContactGetTool)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type DeleteToolsResponse struct {
	ApiRequestTool                      *ApiRequestTool
	DtmfTool                            *DtmfTool
	EndCallTool                         *EndCallTool
	FunctionTool                        *FunctionTool
	TransferCallTool                    *TransferCallTool
	HandoffTool                         *HandoffTool
	BashTool                            *BashTool
	ComputerTool                        *ComputerTool
	TextEditorTool                      *TextEditorTool
	QueryTool                           *QueryTool
	GoogleCalendarCreateEventTool       *GoogleCalendarCreateEventTool
	GoogleSheetsRowAppendTool           *GoogleSheetsRowAppendTool
	GoogleCalendarCheckAvailabilityTool *GoogleCalendarCheckAvailabilityTool
	SlackSendMessageTool                *SlackSendMessageTool
	SmsTool                             *SmsTool
	McpTool                             *McpTool
	GoHighLevelCalendarAvailabilityTool *GoHighLevelCalendarAvailabilityTool
	GoHighLevelCalendarEventCreateTool  *GoHighLevelCalendarEventCreateTool
	GoHighLevelContactCreateTool        *GoHighLevelContactCreateTool
	GoHighLevelContactGetTool           *GoHighLevelContactGetTool

	typ string
}

func (d *DeleteToolsResponse) GetApiRequestTool() *ApiRequestTool {
	if d == nil {
		return nil
	}
	return d.ApiRequestTool
}

func (d *DeleteToolsResponse) GetDtmfTool() *DtmfTool {
	if d == nil {
		return nil
	}
	return d.DtmfTool
}

func (d *DeleteToolsResponse) GetEndCallTool() *EndCallTool {
	if d == nil {
		return nil
	}
	return d.EndCallTool
}

func (d *DeleteToolsResponse) GetFunctionTool() *FunctionTool {
	if d == nil {
		return nil
	}
	return d.FunctionTool
}

func (d *DeleteToolsResponse) GetTransferCallTool() *TransferCallTool {
	if d == nil {
		return nil
	}
	return d.TransferCallTool
}

func (d *DeleteToolsResponse) GetHandoffTool() *HandoffTool {
	if d == nil {
		return nil
	}
	return d.HandoffTool
}

func (d *DeleteToolsResponse) GetBashTool() *BashTool {
	if d == nil {
		return nil
	}
	return d.BashTool
}

func (d *DeleteToolsResponse) GetComputerTool() *ComputerTool {
	if d == nil {
		return nil
	}
	return d.ComputerTool
}

func (d *DeleteToolsResponse) GetTextEditorTool() *TextEditorTool {
	if d == nil {
		return nil
	}
	return d.TextEditorTool
}

func (d *DeleteToolsResponse) GetQueryTool() *QueryTool {
	if d == nil {
		return nil
	}
	return d.QueryTool
}

func (d *DeleteToolsResponse) GetGoogleCalendarCreateEventTool() *GoogleCalendarCreateEventTool {
	if d == nil {
		return nil
	}
	return d.GoogleCalendarCreateEventTool
}

func (d *DeleteToolsResponse) GetGoogleSheetsRowAppendTool() *GoogleSheetsRowAppendTool {
	if d == nil {
		return nil
	}
	return d.GoogleSheetsRowAppendTool
}

func (d *DeleteToolsResponse) GetGoogleCalendarCheckAvailabilityTool() *GoogleCalendarCheckAvailabilityTool {
	if d == nil {
		return nil
	}
	return d.GoogleCalendarCheckAvailabilityTool
}

func (d *DeleteToolsResponse) GetSlackSendMessageTool() *SlackSendMessageTool {
	if d == nil {
		return nil
	}
	return d.SlackSendMessageTool
}

func (d *DeleteToolsResponse) GetSmsTool() *SmsTool {
	if d == nil {
		return nil
	}
	return d.SmsTool
}

func (d *DeleteToolsResponse) GetMcpTool() *McpTool {
	if d == nil {
		return nil
	}
	return d.McpTool
}

func (d *DeleteToolsResponse) GetGoHighLevelCalendarAvailabilityTool() *GoHighLevelCalendarAvailabilityTool {
	if d == nil {
		return nil
	}
	return d.GoHighLevelCalendarAvailabilityTool
}

func (d *DeleteToolsResponse) GetGoHighLevelCalendarEventCreateTool() *GoHighLevelCalendarEventCreateTool {
	if d == nil {
		return nil
	}
	return d.GoHighLevelCalendarEventCreateTool
}

func (d *DeleteToolsResponse) GetGoHighLevelContactCreateTool() *GoHighLevelContactCreateTool {
	if d == nil {
		return nil
	}
	return d.GoHighLevelContactCreateTool
}

func (d *DeleteToolsResponse) GetGoHighLevelContactGetTool() *GoHighLevelContactGetTool {
	if d == nil {
		return nil
	}
	return d.GoHighLevelContactGetTool
}

func (d *DeleteToolsResponse) UnmarshalJSON(data []byte) error {
	valueApiRequestTool := new(ApiRequestTool)
	if err := json.Unmarshal(data, &valueApiRequestTool); err == nil {
		d.typ = "ApiRequestTool"
		d.ApiRequestTool = valueApiRequestTool
		return nil
	}
	valueDtmfTool := new(DtmfTool)
	if err := json.Unmarshal(data, &valueDtmfTool); err == nil {
		d.typ = "DtmfTool"
		d.DtmfTool = valueDtmfTool
		return nil
	}
	valueEndCallTool := new(EndCallTool)
	if err := json.Unmarshal(data, &valueEndCallTool); err == nil {
		d.typ = "EndCallTool"
		d.EndCallTool = valueEndCallTool
		return nil
	}
	valueFunctionTool := new(FunctionTool)
	if err := json.Unmarshal(data, &valueFunctionTool); err == nil {
		d.typ = "FunctionTool"
		d.FunctionTool = valueFunctionTool
		return nil
	}
	valueTransferCallTool := new(TransferCallTool)
	if err := json.Unmarshal(data, &valueTransferCallTool); err == nil {
		d.typ = "TransferCallTool"
		d.TransferCallTool = valueTransferCallTool
		return nil
	}
	valueHandoffTool := new(HandoffTool)
	if err := json.Unmarshal(data, &valueHandoffTool); err == nil {
		d.typ = "HandoffTool"
		d.HandoffTool = valueHandoffTool
		return nil
	}
	valueBashTool := new(BashTool)
	if err := json.Unmarshal(data, &valueBashTool); err == nil {
		d.typ = "BashTool"
		d.BashTool = valueBashTool
		return nil
	}
	valueComputerTool := new(ComputerTool)
	if err := json.Unmarshal(data, &valueComputerTool); err == nil {
		d.typ = "ComputerTool"
		d.ComputerTool = valueComputerTool
		return nil
	}
	valueTextEditorTool := new(TextEditorTool)
	if err := json.Unmarshal(data, &valueTextEditorTool); err == nil {
		d.typ = "TextEditorTool"
		d.TextEditorTool = valueTextEditorTool
		return nil
	}
	valueQueryTool := new(QueryTool)
	if err := json.Unmarshal(data, &valueQueryTool); err == nil {
		d.typ = "QueryTool"
		d.QueryTool = valueQueryTool
		return nil
	}
	valueGoogleCalendarCreateEventTool := new(GoogleCalendarCreateEventTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventTool); err == nil {
		d.typ = "GoogleCalendarCreateEventTool"
		d.GoogleCalendarCreateEventTool = valueGoogleCalendarCreateEventTool
		return nil
	}
	valueGoogleSheetsRowAppendTool := new(GoogleSheetsRowAppendTool)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendTool); err == nil {
		d.typ = "GoogleSheetsRowAppendTool"
		d.GoogleSheetsRowAppendTool = valueGoogleSheetsRowAppendTool
		return nil
	}
	valueGoogleCalendarCheckAvailabilityTool := new(GoogleCalendarCheckAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCheckAvailabilityTool); err == nil {
		d.typ = "GoogleCalendarCheckAvailabilityTool"
		d.GoogleCalendarCheckAvailabilityTool = valueGoogleCalendarCheckAvailabilityTool
		return nil
	}
	valueSlackSendMessageTool := new(SlackSendMessageTool)
	if err := json.Unmarshal(data, &valueSlackSendMessageTool); err == nil {
		d.typ = "SlackSendMessageTool"
		d.SlackSendMessageTool = valueSlackSendMessageTool
		return nil
	}
	valueSmsTool := new(SmsTool)
	if err := json.Unmarshal(data, &valueSmsTool); err == nil {
		d.typ = "SmsTool"
		d.SmsTool = valueSmsTool
		return nil
	}
	valueMcpTool := new(McpTool)
	if err := json.Unmarshal(data, &valueMcpTool); err == nil {
		d.typ = "McpTool"
		d.McpTool = valueMcpTool
		return nil
	}
	valueGoHighLevelCalendarAvailabilityTool := new(GoHighLevelCalendarAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityTool); err == nil {
		d.typ = "GoHighLevelCalendarAvailabilityTool"
		d.GoHighLevelCalendarAvailabilityTool = valueGoHighLevelCalendarAvailabilityTool
		return nil
	}
	valueGoHighLevelCalendarEventCreateTool := new(GoHighLevelCalendarEventCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateTool); err == nil {
		d.typ = "GoHighLevelCalendarEventCreateTool"
		d.GoHighLevelCalendarEventCreateTool = valueGoHighLevelCalendarEventCreateTool
		return nil
	}
	valueGoHighLevelContactCreateTool := new(GoHighLevelContactCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateTool); err == nil {
		d.typ = "GoHighLevelContactCreateTool"
		d.GoHighLevelContactCreateTool = valueGoHighLevelContactCreateTool
		return nil
	}
	valueGoHighLevelContactGetTool := new(GoHighLevelContactGetTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetTool); err == nil {
		d.typ = "GoHighLevelContactGetTool"
		d.GoHighLevelContactGetTool = valueGoHighLevelContactGetTool
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteToolsResponse) MarshalJSON() ([]byte, error) {
	if d.typ == "ApiRequestTool" || d.ApiRequestTool != nil {
		return json.Marshal(d.ApiRequestTool)
	}
	if d.typ == "DtmfTool" || d.DtmfTool != nil {
		return json.Marshal(d.DtmfTool)
	}
	if d.typ == "EndCallTool" || d.EndCallTool != nil {
		return json.Marshal(d.EndCallTool)
	}
	if d.typ == "FunctionTool" || d.FunctionTool != nil {
		return json.Marshal(d.FunctionTool)
	}
	if d.typ == "TransferCallTool" || d.TransferCallTool != nil {
		return json.Marshal(d.TransferCallTool)
	}
	if d.typ == "HandoffTool" || d.HandoffTool != nil {
		return json.Marshal(d.HandoffTool)
	}
	if d.typ == "BashTool" || d.BashTool != nil {
		return json.Marshal(d.BashTool)
	}
	if d.typ == "ComputerTool" || d.ComputerTool != nil {
		return json.Marshal(d.ComputerTool)
	}
	if d.typ == "TextEditorTool" || d.TextEditorTool != nil {
		return json.Marshal(d.TextEditorTool)
	}
	if d.typ == "QueryTool" || d.QueryTool != nil {
		return json.Marshal(d.QueryTool)
	}
	if d.typ == "GoogleCalendarCreateEventTool" || d.GoogleCalendarCreateEventTool != nil {
		return json.Marshal(d.GoogleCalendarCreateEventTool)
	}
	if d.typ == "GoogleSheetsRowAppendTool" || d.GoogleSheetsRowAppendTool != nil {
		return json.Marshal(d.GoogleSheetsRowAppendTool)
	}
	if d.typ == "GoogleCalendarCheckAvailabilityTool" || d.GoogleCalendarCheckAvailabilityTool != nil {
		return json.Marshal(d.GoogleCalendarCheckAvailabilityTool)
	}
	if d.typ == "SlackSendMessageTool" || d.SlackSendMessageTool != nil {
		return json.Marshal(d.SlackSendMessageTool)
	}
	if d.typ == "SmsTool" || d.SmsTool != nil {
		return json.Marshal(d.SmsTool)
	}
	if d.typ == "McpTool" || d.McpTool != nil {
		return json.Marshal(d.McpTool)
	}
	if d.typ == "GoHighLevelCalendarAvailabilityTool" || d.GoHighLevelCalendarAvailabilityTool != nil {
		return json.Marshal(d.GoHighLevelCalendarAvailabilityTool)
	}
	if d.typ == "GoHighLevelCalendarEventCreateTool" || d.GoHighLevelCalendarEventCreateTool != nil {
		return json.Marshal(d.GoHighLevelCalendarEventCreateTool)
	}
	if d.typ == "GoHighLevelContactCreateTool" || d.GoHighLevelContactCreateTool != nil {
		return json.Marshal(d.GoHighLevelContactCreateTool)
	}
	if d.typ == "GoHighLevelContactGetTool" || d.GoHighLevelContactGetTool != nil {
		return json.Marshal(d.GoHighLevelContactGetTool)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeleteToolsResponseVisitor interface {
	VisitApiRequestTool(*ApiRequestTool) error
	VisitDtmfTool(*DtmfTool) error
	VisitEndCallTool(*EndCallTool) error
	VisitFunctionTool(*FunctionTool) error
	VisitTransferCallTool(*TransferCallTool) error
	VisitHandoffTool(*HandoffTool) error
	VisitBashTool(*BashTool) error
	VisitComputerTool(*ComputerTool) error
	VisitTextEditorTool(*TextEditorTool) error
	VisitQueryTool(*QueryTool) error
	VisitGoogleCalendarCreateEventTool(*GoogleCalendarCreateEventTool) error
	VisitGoogleSheetsRowAppendTool(*GoogleSheetsRowAppendTool) error
	VisitGoogleCalendarCheckAvailabilityTool(*GoogleCalendarCheckAvailabilityTool) error
	VisitSlackSendMessageTool(*SlackSendMessageTool) error
	VisitSmsTool(*SmsTool) error
	VisitMcpTool(*McpTool) error
	VisitGoHighLevelCalendarAvailabilityTool(*GoHighLevelCalendarAvailabilityTool) error
	VisitGoHighLevelCalendarEventCreateTool(*GoHighLevelCalendarEventCreateTool) error
	VisitGoHighLevelContactCreateTool(*GoHighLevelContactCreateTool) error
	VisitGoHighLevelContactGetTool(*GoHighLevelContactGetTool) error
}

func (d *DeleteToolsResponse) Accept(visitor DeleteToolsResponseVisitor) error {
	if d.typ == "ApiRequestTool" || d.ApiRequestTool != nil {
		return visitor.VisitApiRequestTool(d.ApiRequestTool)
	}
	if d.typ == "DtmfTool" || d.DtmfTool != nil {
		return visitor.VisitDtmfTool(d.DtmfTool)
	}
	if d.typ == "EndCallTool" || d.EndCallTool != nil {
		return visitor.VisitEndCallTool(d.EndCallTool)
	}
	if d.typ == "FunctionTool" || d.FunctionTool != nil {
		return visitor.VisitFunctionTool(d.FunctionTool)
	}
	if d.typ == "TransferCallTool" || d.TransferCallTool != nil {
		return visitor.VisitTransferCallTool(d.TransferCallTool)
	}
	if d.typ == "HandoffTool" || d.HandoffTool != nil {
		return visitor.VisitHandoffTool(d.HandoffTool)
	}
	if d.typ == "BashTool" || d.BashTool != nil {
		return visitor.VisitBashTool(d.BashTool)
	}
	if d.typ == "ComputerTool" || d.ComputerTool != nil {
		return visitor.VisitComputerTool(d.ComputerTool)
	}
	if d.typ == "TextEditorTool" || d.TextEditorTool != nil {
		return visitor.VisitTextEditorTool(d.TextEditorTool)
	}
	if d.typ == "QueryTool" || d.QueryTool != nil {
		return visitor.VisitQueryTool(d.QueryTool)
	}
	if d.typ == "GoogleCalendarCreateEventTool" || d.GoogleCalendarCreateEventTool != nil {
		return visitor.VisitGoogleCalendarCreateEventTool(d.GoogleCalendarCreateEventTool)
	}
	if d.typ == "GoogleSheetsRowAppendTool" || d.GoogleSheetsRowAppendTool != nil {
		return visitor.VisitGoogleSheetsRowAppendTool(d.GoogleSheetsRowAppendTool)
	}
	if d.typ == "GoogleCalendarCheckAvailabilityTool" || d.GoogleCalendarCheckAvailabilityTool != nil {
		return visitor.VisitGoogleCalendarCheckAvailabilityTool(d.GoogleCalendarCheckAvailabilityTool)
	}
	if d.typ == "SlackSendMessageTool" || d.SlackSendMessageTool != nil {
		return visitor.VisitSlackSendMessageTool(d.SlackSendMessageTool)
	}
	if d.typ == "SmsTool" || d.SmsTool != nil {
		return visitor.VisitSmsTool(d.SmsTool)
	}
	if d.typ == "McpTool" || d.McpTool != nil {
		return visitor.VisitMcpTool(d.McpTool)
	}
	if d.typ == "GoHighLevelCalendarAvailabilityTool" || d.GoHighLevelCalendarAvailabilityTool != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityTool(d.GoHighLevelCalendarAvailabilityTool)
	}
	if d.typ == "GoHighLevelCalendarEventCreateTool" || d.GoHighLevelCalendarEventCreateTool != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateTool(d.GoHighLevelCalendarEventCreateTool)
	}
	if d.typ == "GoHighLevelContactCreateTool" || d.GoHighLevelContactCreateTool != nil {
		return visitor.VisitGoHighLevelContactCreateTool(d.GoHighLevelContactCreateTool)
	}
	if d.typ == "GoHighLevelContactGetTool" || d.GoHighLevelContactGetTool != nil {
		return visitor.VisitGoHighLevelContactGetTool(d.GoHighLevelContactGetTool)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type GetToolsResponse struct {
	ApiRequestTool                      *ApiRequestTool
	DtmfTool                            *DtmfTool
	EndCallTool                         *EndCallTool
	FunctionTool                        *FunctionTool
	TransferCallTool                    *TransferCallTool
	HandoffTool                         *HandoffTool
	BashTool                            *BashTool
	ComputerTool                        *ComputerTool
	TextEditorTool                      *TextEditorTool
	QueryTool                           *QueryTool
	GoogleCalendarCreateEventTool       *GoogleCalendarCreateEventTool
	GoogleSheetsRowAppendTool           *GoogleSheetsRowAppendTool
	GoogleCalendarCheckAvailabilityTool *GoogleCalendarCheckAvailabilityTool
	SlackSendMessageTool                *SlackSendMessageTool
	SmsTool                             *SmsTool
	McpTool                             *McpTool
	GoHighLevelCalendarAvailabilityTool *GoHighLevelCalendarAvailabilityTool
	GoHighLevelCalendarEventCreateTool  *GoHighLevelCalendarEventCreateTool
	GoHighLevelContactCreateTool        *GoHighLevelContactCreateTool
	GoHighLevelContactGetTool           *GoHighLevelContactGetTool

	typ string
}

func (g *GetToolsResponse) GetApiRequestTool() *ApiRequestTool {
	if g == nil {
		return nil
	}
	return g.ApiRequestTool
}

func (g *GetToolsResponse) GetDtmfTool() *DtmfTool {
	if g == nil {
		return nil
	}
	return g.DtmfTool
}

func (g *GetToolsResponse) GetEndCallTool() *EndCallTool {
	if g == nil {
		return nil
	}
	return g.EndCallTool
}

func (g *GetToolsResponse) GetFunctionTool() *FunctionTool {
	if g == nil {
		return nil
	}
	return g.FunctionTool
}

func (g *GetToolsResponse) GetTransferCallTool() *TransferCallTool {
	if g == nil {
		return nil
	}
	return g.TransferCallTool
}

func (g *GetToolsResponse) GetHandoffTool() *HandoffTool {
	if g == nil {
		return nil
	}
	return g.HandoffTool
}

func (g *GetToolsResponse) GetBashTool() *BashTool {
	if g == nil {
		return nil
	}
	return g.BashTool
}

func (g *GetToolsResponse) GetComputerTool() *ComputerTool {
	if g == nil {
		return nil
	}
	return g.ComputerTool
}

func (g *GetToolsResponse) GetTextEditorTool() *TextEditorTool {
	if g == nil {
		return nil
	}
	return g.TextEditorTool
}

func (g *GetToolsResponse) GetQueryTool() *QueryTool {
	if g == nil {
		return nil
	}
	return g.QueryTool
}

func (g *GetToolsResponse) GetGoogleCalendarCreateEventTool() *GoogleCalendarCreateEventTool {
	if g == nil {
		return nil
	}
	return g.GoogleCalendarCreateEventTool
}

func (g *GetToolsResponse) GetGoogleSheetsRowAppendTool() *GoogleSheetsRowAppendTool {
	if g == nil {
		return nil
	}
	return g.GoogleSheetsRowAppendTool
}

func (g *GetToolsResponse) GetGoogleCalendarCheckAvailabilityTool() *GoogleCalendarCheckAvailabilityTool {
	if g == nil {
		return nil
	}
	return g.GoogleCalendarCheckAvailabilityTool
}

func (g *GetToolsResponse) GetSlackSendMessageTool() *SlackSendMessageTool {
	if g == nil {
		return nil
	}
	return g.SlackSendMessageTool
}

func (g *GetToolsResponse) GetSmsTool() *SmsTool {
	if g == nil {
		return nil
	}
	return g.SmsTool
}

func (g *GetToolsResponse) GetMcpTool() *McpTool {
	if g == nil {
		return nil
	}
	return g.McpTool
}

func (g *GetToolsResponse) GetGoHighLevelCalendarAvailabilityTool() *GoHighLevelCalendarAvailabilityTool {
	if g == nil {
		return nil
	}
	return g.GoHighLevelCalendarAvailabilityTool
}

func (g *GetToolsResponse) GetGoHighLevelCalendarEventCreateTool() *GoHighLevelCalendarEventCreateTool {
	if g == nil {
		return nil
	}
	return g.GoHighLevelCalendarEventCreateTool
}

func (g *GetToolsResponse) GetGoHighLevelContactCreateTool() *GoHighLevelContactCreateTool {
	if g == nil {
		return nil
	}
	return g.GoHighLevelContactCreateTool
}

func (g *GetToolsResponse) GetGoHighLevelContactGetTool() *GoHighLevelContactGetTool {
	if g == nil {
		return nil
	}
	return g.GoHighLevelContactGetTool
}

func (g *GetToolsResponse) UnmarshalJSON(data []byte) error {
	valueApiRequestTool := new(ApiRequestTool)
	if err := json.Unmarshal(data, &valueApiRequestTool); err == nil {
		g.typ = "ApiRequestTool"
		g.ApiRequestTool = valueApiRequestTool
		return nil
	}
	valueDtmfTool := new(DtmfTool)
	if err := json.Unmarshal(data, &valueDtmfTool); err == nil {
		g.typ = "DtmfTool"
		g.DtmfTool = valueDtmfTool
		return nil
	}
	valueEndCallTool := new(EndCallTool)
	if err := json.Unmarshal(data, &valueEndCallTool); err == nil {
		g.typ = "EndCallTool"
		g.EndCallTool = valueEndCallTool
		return nil
	}
	valueFunctionTool := new(FunctionTool)
	if err := json.Unmarshal(data, &valueFunctionTool); err == nil {
		g.typ = "FunctionTool"
		g.FunctionTool = valueFunctionTool
		return nil
	}
	valueTransferCallTool := new(TransferCallTool)
	if err := json.Unmarshal(data, &valueTransferCallTool); err == nil {
		g.typ = "TransferCallTool"
		g.TransferCallTool = valueTransferCallTool
		return nil
	}
	valueHandoffTool := new(HandoffTool)
	if err := json.Unmarshal(data, &valueHandoffTool); err == nil {
		g.typ = "HandoffTool"
		g.HandoffTool = valueHandoffTool
		return nil
	}
	valueBashTool := new(BashTool)
	if err := json.Unmarshal(data, &valueBashTool); err == nil {
		g.typ = "BashTool"
		g.BashTool = valueBashTool
		return nil
	}
	valueComputerTool := new(ComputerTool)
	if err := json.Unmarshal(data, &valueComputerTool); err == nil {
		g.typ = "ComputerTool"
		g.ComputerTool = valueComputerTool
		return nil
	}
	valueTextEditorTool := new(TextEditorTool)
	if err := json.Unmarshal(data, &valueTextEditorTool); err == nil {
		g.typ = "TextEditorTool"
		g.TextEditorTool = valueTextEditorTool
		return nil
	}
	valueQueryTool := new(QueryTool)
	if err := json.Unmarshal(data, &valueQueryTool); err == nil {
		g.typ = "QueryTool"
		g.QueryTool = valueQueryTool
		return nil
	}
	valueGoogleCalendarCreateEventTool := new(GoogleCalendarCreateEventTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventTool); err == nil {
		g.typ = "GoogleCalendarCreateEventTool"
		g.GoogleCalendarCreateEventTool = valueGoogleCalendarCreateEventTool
		return nil
	}
	valueGoogleSheetsRowAppendTool := new(GoogleSheetsRowAppendTool)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendTool); err == nil {
		g.typ = "GoogleSheetsRowAppendTool"
		g.GoogleSheetsRowAppendTool = valueGoogleSheetsRowAppendTool
		return nil
	}
	valueGoogleCalendarCheckAvailabilityTool := new(GoogleCalendarCheckAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCheckAvailabilityTool); err == nil {
		g.typ = "GoogleCalendarCheckAvailabilityTool"
		g.GoogleCalendarCheckAvailabilityTool = valueGoogleCalendarCheckAvailabilityTool
		return nil
	}
	valueSlackSendMessageTool := new(SlackSendMessageTool)
	if err := json.Unmarshal(data, &valueSlackSendMessageTool); err == nil {
		g.typ = "SlackSendMessageTool"
		g.SlackSendMessageTool = valueSlackSendMessageTool
		return nil
	}
	valueSmsTool := new(SmsTool)
	if err := json.Unmarshal(data, &valueSmsTool); err == nil {
		g.typ = "SmsTool"
		g.SmsTool = valueSmsTool
		return nil
	}
	valueMcpTool := new(McpTool)
	if err := json.Unmarshal(data, &valueMcpTool); err == nil {
		g.typ = "McpTool"
		g.McpTool = valueMcpTool
		return nil
	}
	valueGoHighLevelCalendarAvailabilityTool := new(GoHighLevelCalendarAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityTool); err == nil {
		g.typ = "GoHighLevelCalendarAvailabilityTool"
		g.GoHighLevelCalendarAvailabilityTool = valueGoHighLevelCalendarAvailabilityTool
		return nil
	}
	valueGoHighLevelCalendarEventCreateTool := new(GoHighLevelCalendarEventCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateTool); err == nil {
		g.typ = "GoHighLevelCalendarEventCreateTool"
		g.GoHighLevelCalendarEventCreateTool = valueGoHighLevelCalendarEventCreateTool
		return nil
	}
	valueGoHighLevelContactCreateTool := new(GoHighLevelContactCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateTool); err == nil {
		g.typ = "GoHighLevelContactCreateTool"
		g.GoHighLevelContactCreateTool = valueGoHighLevelContactCreateTool
		return nil
	}
	valueGoHighLevelContactGetTool := new(GoHighLevelContactGetTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetTool); err == nil {
		g.typ = "GoHighLevelContactGetTool"
		g.GoHighLevelContactGetTool = valueGoHighLevelContactGetTool
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetToolsResponse) MarshalJSON() ([]byte, error) {
	if g.typ == "ApiRequestTool" || g.ApiRequestTool != nil {
		return json.Marshal(g.ApiRequestTool)
	}
	if g.typ == "DtmfTool" || g.DtmfTool != nil {
		return json.Marshal(g.DtmfTool)
	}
	if g.typ == "EndCallTool" || g.EndCallTool != nil {
		return json.Marshal(g.EndCallTool)
	}
	if g.typ == "FunctionTool" || g.FunctionTool != nil {
		return json.Marshal(g.FunctionTool)
	}
	if g.typ == "TransferCallTool" || g.TransferCallTool != nil {
		return json.Marshal(g.TransferCallTool)
	}
	if g.typ == "HandoffTool" || g.HandoffTool != nil {
		return json.Marshal(g.HandoffTool)
	}
	if g.typ == "BashTool" || g.BashTool != nil {
		return json.Marshal(g.BashTool)
	}
	if g.typ == "ComputerTool" || g.ComputerTool != nil {
		return json.Marshal(g.ComputerTool)
	}
	if g.typ == "TextEditorTool" || g.TextEditorTool != nil {
		return json.Marshal(g.TextEditorTool)
	}
	if g.typ == "QueryTool" || g.QueryTool != nil {
		return json.Marshal(g.QueryTool)
	}
	if g.typ == "GoogleCalendarCreateEventTool" || g.GoogleCalendarCreateEventTool != nil {
		return json.Marshal(g.GoogleCalendarCreateEventTool)
	}
	if g.typ == "GoogleSheetsRowAppendTool" || g.GoogleSheetsRowAppendTool != nil {
		return json.Marshal(g.GoogleSheetsRowAppendTool)
	}
	if g.typ == "GoogleCalendarCheckAvailabilityTool" || g.GoogleCalendarCheckAvailabilityTool != nil {
		return json.Marshal(g.GoogleCalendarCheckAvailabilityTool)
	}
	if g.typ == "SlackSendMessageTool" || g.SlackSendMessageTool != nil {
		return json.Marshal(g.SlackSendMessageTool)
	}
	if g.typ == "SmsTool" || g.SmsTool != nil {
		return json.Marshal(g.SmsTool)
	}
	if g.typ == "McpTool" || g.McpTool != nil {
		return json.Marshal(g.McpTool)
	}
	if g.typ == "GoHighLevelCalendarAvailabilityTool" || g.GoHighLevelCalendarAvailabilityTool != nil {
		return json.Marshal(g.GoHighLevelCalendarAvailabilityTool)
	}
	if g.typ == "GoHighLevelCalendarEventCreateTool" || g.GoHighLevelCalendarEventCreateTool != nil {
		return json.Marshal(g.GoHighLevelCalendarEventCreateTool)
	}
	if g.typ == "GoHighLevelContactCreateTool" || g.GoHighLevelContactCreateTool != nil {
		return json.Marshal(g.GoHighLevelContactCreateTool)
	}
	if g.typ == "GoHighLevelContactGetTool" || g.GoHighLevelContactGetTool != nil {
		return json.Marshal(g.GoHighLevelContactGetTool)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GetToolsResponseVisitor interface {
	VisitApiRequestTool(*ApiRequestTool) error
	VisitDtmfTool(*DtmfTool) error
	VisitEndCallTool(*EndCallTool) error
	VisitFunctionTool(*FunctionTool) error
	VisitTransferCallTool(*TransferCallTool) error
	VisitHandoffTool(*HandoffTool) error
	VisitBashTool(*BashTool) error
	VisitComputerTool(*ComputerTool) error
	VisitTextEditorTool(*TextEditorTool) error
	VisitQueryTool(*QueryTool) error
	VisitGoogleCalendarCreateEventTool(*GoogleCalendarCreateEventTool) error
	VisitGoogleSheetsRowAppendTool(*GoogleSheetsRowAppendTool) error
	VisitGoogleCalendarCheckAvailabilityTool(*GoogleCalendarCheckAvailabilityTool) error
	VisitSlackSendMessageTool(*SlackSendMessageTool) error
	VisitSmsTool(*SmsTool) error
	VisitMcpTool(*McpTool) error
	VisitGoHighLevelCalendarAvailabilityTool(*GoHighLevelCalendarAvailabilityTool) error
	VisitGoHighLevelCalendarEventCreateTool(*GoHighLevelCalendarEventCreateTool) error
	VisitGoHighLevelContactCreateTool(*GoHighLevelContactCreateTool) error
	VisitGoHighLevelContactGetTool(*GoHighLevelContactGetTool) error
}

func (g *GetToolsResponse) Accept(visitor GetToolsResponseVisitor) error {
	if g.typ == "ApiRequestTool" || g.ApiRequestTool != nil {
		return visitor.VisitApiRequestTool(g.ApiRequestTool)
	}
	if g.typ == "DtmfTool" || g.DtmfTool != nil {
		return visitor.VisitDtmfTool(g.DtmfTool)
	}
	if g.typ == "EndCallTool" || g.EndCallTool != nil {
		return visitor.VisitEndCallTool(g.EndCallTool)
	}
	if g.typ == "FunctionTool" || g.FunctionTool != nil {
		return visitor.VisitFunctionTool(g.FunctionTool)
	}
	if g.typ == "TransferCallTool" || g.TransferCallTool != nil {
		return visitor.VisitTransferCallTool(g.TransferCallTool)
	}
	if g.typ == "HandoffTool" || g.HandoffTool != nil {
		return visitor.VisitHandoffTool(g.HandoffTool)
	}
	if g.typ == "BashTool" || g.BashTool != nil {
		return visitor.VisitBashTool(g.BashTool)
	}
	if g.typ == "ComputerTool" || g.ComputerTool != nil {
		return visitor.VisitComputerTool(g.ComputerTool)
	}
	if g.typ == "TextEditorTool" || g.TextEditorTool != nil {
		return visitor.VisitTextEditorTool(g.TextEditorTool)
	}
	if g.typ == "QueryTool" || g.QueryTool != nil {
		return visitor.VisitQueryTool(g.QueryTool)
	}
	if g.typ == "GoogleCalendarCreateEventTool" || g.GoogleCalendarCreateEventTool != nil {
		return visitor.VisitGoogleCalendarCreateEventTool(g.GoogleCalendarCreateEventTool)
	}
	if g.typ == "GoogleSheetsRowAppendTool" || g.GoogleSheetsRowAppendTool != nil {
		return visitor.VisitGoogleSheetsRowAppendTool(g.GoogleSheetsRowAppendTool)
	}
	if g.typ == "GoogleCalendarCheckAvailabilityTool" || g.GoogleCalendarCheckAvailabilityTool != nil {
		return visitor.VisitGoogleCalendarCheckAvailabilityTool(g.GoogleCalendarCheckAvailabilityTool)
	}
	if g.typ == "SlackSendMessageTool" || g.SlackSendMessageTool != nil {
		return visitor.VisitSlackSendMessageTool(g.SlackSendMessageTool)
	}
	if g.typ == "SmsTool" || g.SmsTool != nil {
		return visitor.VisitSmsTool(g.SmsTool)
	}
	if g.typ == "McpTool" || g.McpTool != nil {
		return visitor.VisitMcpTool(g.McpTool)
	}
	if g.typ == "GoHighLevelCalendarAvailabilityTool" || g.GoHighLevelCalendarAvailabilityTool != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityTool(g.GoHighLevelCalendarAvailabilityTool)
	}
	if g.typ == "GoHighLevelCalendarEventCreateTool" || g.GoHighLevelCalendarEventCreateTool != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateTool(g.GoHighLevelCalendarEventCreateTool)
	}
	if g.typ == "GoHighLevelContactCreateTool" || g.GoHighLevelContactCreateTool != nil {
		return visitor.VisitGoHighLevelContactCreateTool(g.GoHighLevelContactCreateTool)
	}
	if g.typ == "GoHighLevelContactGetTool" || g.GoHighLevelContactGetTool != nil {
		return visitor.VisitGoHighLevelContactGetTool(g.GoHighLevelContactGetTool)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type ListToolsResponseItem struct {
	ApiRequestTool                      *ApiRequestTool
	DtmfTool                            *DtmfTool
	EndCallTool                         *EndCallTool
	FunctionTool                        *FunctionTool
	TransferCallTool                    *TransferCallTool
	HandoffTool                         *HandoffTool
	BashTool                            *BashTool
	ComputerTool                        *ComputerTool
	TextEditorTool                      *TextEditorTool
	QueryTool                           *QueryTool
	GoogleCalendarCreateEventTool       *GoogleCalendarCreateEventTool
	GoogleSheetsRowAppendTool           *GoogleSheetsRowAppendTool
	GoogleCalendarCheckAvailabilityTool *GoogleCalendarCheckAvailabilityTool
	SlackSendMessageTool                *SlackSendMessageTool
	SmsTool                             *SmsTool
	McpTool                             *McpTool
	GoHighLevelCalendarAvailabilityTool *GoHighLevelCalendarAvailabilityTool
	GoHighLevelCalendarEventCreateTool  *GoHighLevelCalendarEventCreateTool
	GoHighLevelContactCreateTool        *GoHighLevelContactCreateTool
	GoHighLevelContactGetTool           *GoHighLevelContactGetTool

	typ string
}

func (l *ListToolsResponseItem) GetApiRequestTool() *ApiRequestTool {
	if l == nil {
		return nil
	}
	return l.ApiRequestTool
}

func (l *ListToolsResponseItem) GetDtmfTool() *DtmfTool {
	if l == nil {
		return nil
	}
	return l.DtmfTool
}

func (l *ListToolsResponseItem) GetEndCallTool() *EndCallTool {
	if l == nil {
		return nil
	}
	return l.EndCallTool
}

func (l *ListToolsResponseItem) GetFunctionTool() *FunctionTool {
	if l == nil {
		return nil
	}
	return l.FunctionTool
}

func (l *ListToolsResponseItem) GetTransferCallTool() *TransferCallTool {
	if l == nil {
		return nil
	}
	return l.TransferCallTool
}

func (l *ListToolsResponseItem) GetHandoffTool() *HandoffTool {
	if l == nil {
		return nil
	}
	return l.HandoffTool
}

func (l *ListToolsResponseItem) GetBashTool() *BashTool {
	if l == nil {
		return nil
	}
	return l.BashTool
}

func (l *ListToolsResponseItem) GetComputerTool() *ComputerTool {
	if l == nil {
		return nil
	}
	return l.ComputerTool
}

func (l *ListToolsResponseItem) GetTextEditorTool() *TextEditorTool {
	if l == nil {
		return nil
	}
	return l.TextEditorTool
}

func (l *ListToolsResponseItem) GetQueryTool() *QueryTool {
	if l == nil {
		return nil
	}
	return l.QueryTool
}

func (l *ListToolsResponseItem) GetGoogleCalendarCreateEventTool() *GoogleCalendarCreateEventTool {
	if l == nil {
		return nil
	}
	return l.GoogleCalendarCreateEventTool
}

func (l *ListToolsResponseItem) GetGoogleSheetsRowAppendTool() *GoogleSheetsRowAppendTool {
	if l == nil {
		return nil
	}
	return l.GoogleSheetsRowAppendTool
}

func (l *ListToolsResponseItem) GetGoogleCalendarCheckAvailabilityTool() *GoogleCalendarCheckAvailabilityTool {
	if l == nil {
		return nil
	}
	return l.GoogleCalendarCheckAvailabilityTool
}

func (l *ListToolsResponseItem) GetSlackSendMessageTool() *SlackSendMessageTool {
	if l == nil {
		return nil
	}
	return l.SlackSendMessageTool
}

func (l *ListToolsResponseItem) GetSmsTool() *SmsTool {
	if l == nil {
		return nil
	}
	return l.SmsTool
}

func (l *ListToolsResponseItem) GetMcpTool() *McpTool {
	if l == nil {
		return nil
	}
	return l.McpTool
}

func (l *ListToolsResponseItem) GetGoHighLevelCalendarAvailabilityTool() *GoHighLevelCalendarAvailabilityTool {
	if l == nil {
		return nil
	}
	return l.GoHighLevelCalendarAvailabilityTool
}

func (l *ListToolsResponseItem) GetGoHighLevelCalendarEventCreateTool() *GoHighLevelCalendarEventCreateTool {
	if l == nil {
		return nil
	}
	return l.GoHighLevelCalendarEventCreateTool
}

func (l *ListToolsResponseItem) GetGoHighLevelContactCreateTool() *GoHighLevelContactCreateTool {
	if l == nil {
		return nil
	}
	return l.GoHighLevelContactCreateTool
}

func (l *ListToolsResponseItem) GetGoHighLevelContactGetTool() *GoHighLevelContactGetTool {
	if l == nil {
		return nil
	}
	return l.GoHighLevelContactGetTool
}

func (l *ListToolsResponseItem) UnmarshalJSON(data []byte) error {
	valueApiRequestTool := new(ApiRequestTool)
	if err := json.Unmarshal(data, &valueApiRequestTool); err == nil {
		l.typ = "ApiRequestTool"
		l.ApiRequestTool = valueApiRequestTool
		return nil
	}
	valueDtmfTool := new(DtmfTool)
	if err := json.Unmarshal(data, &valueDtmfTool); err == nil {
		l.typ = "DtmfTool"
		l.DtmfTool = valueDtmfTool
		return nil
	}
	valueEndCallTool := new(EndCallTool)
	if err := json.Unmarshal(data, &valueEndCallTool); err == nil {
		l.typ = "EndCallTool"
		l.EndCallTool = valueEndCallTool
		return nil
	}
	valueFunctionTool := new(FunctionTool)
	if err := json.Unmarshal(data, &valueFunctionTool); err == nil {
		l.typ = "FunctionTool"
		l.FunctionTool = valueFunctionTool
		return nil
	}
	valueTransferCallTool := new(TransferCallTool)
	if err := json.Unmarshal(data, &valueTransferCallTool); err == nil {
		l.typ = "TransferCallTool"
		l.TransferCallTool = valueTransferCallTool
		return nil
	}
	valueHandoffTool := new(HandoffTool)
	if err := json.Unmarshal(data, &valueHandoffTool); err == nil {
		l.typ = "HandoffTool"
		l.HandoffTool = valueHandoffTool
		return nil
	}
	valueBashTool := new(BashTool)
	if err := json.Unmarshal(data, &valueBashTool); err == nil {
		l.typ = "BashTool"
		l.BashTool = valueBashTool
		return nil
	}
	valueComputerTool := new(ComputerTool)
	if err := json.Unmarshal(data, &valueComputerTool); err == nil {
		l.typ = "ComputerTool"
		l.ComputerTool = valueComputerTool
		return nil
	}
	valueTextEditorTool := new(TextEditorTool)
	if err := json.Unmarshal(data, &valueTextEditorTool); err == nil {
		l.typ = "TextEditorTool"
		l.TextEditorTool = valueTextEditorTool
		return nil
	}
	valueQueryTool := new(QueryTool)
	if err := json.Unmarshal(data, &valueQueryTool); err == nil {
		l.typ = "QueryTool"
		l.QueryTool = valueQueryTool
		return nil
	}
	valueGoogleCalendarCreateEventTool := new(GoogleCalendarCreateEventTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventTool); err == nil {
		l.typ = "GoogleCalendarCreateEventTool"
		l.GoogleCalendarCreateEventTool = valueGoogleCalendarCreateEventTool
		return nil
	}
	valueGoogleSheetsRowAppendTool := new(GoogleSheetsRowAppendTool)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendTool); err == nil {
		l.typ = "GoogleSheetsRowAppendTool"
		l.GoogleSheetsRowAppendTool = valueGoogleSheetsRowAppendTool
		return nil
	}
	valueGoogleCalendarCheckAvailabilityTool := new(GoogleCalendarCheckAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCheckAvailabilityTool); err == nil {
		l.typ = "GoogleCalendarCheckAvailabilityTool"
		l.GoogleCalendarCheckAvailabilityTool = valueGoogleCalendarCheckAvailabilityTool
		return nil
	}
	valueSlackSendMessageTool := new(SlackSendMessageTool)
	if err := json.Unmarshal(data, &valueSlackSendMessageTool); err == nil {
		l.typ = "SlackSendMessageTool"
		l.SlackSendMessageTool = valueSlackSendMessageTool
		return nil
	}
	valueSmsTool := new(SmsTool)
	if err := json.Unmarshal(data, &valueSmsTool); err == nil {
		l.typ = "SmsTool"
		l.SmsTool = valueSmsTool
		return nil
	}
	valueMcpTool := new(McpTool)
	if err := json.Unmarshal(data, &valueMcpTool); err == nil {
		l.typ = "McpTool"
		l.McpTool = valueMcpTool
		return nil
	}
	valueGoHighLevelCalendarAvailabilityTool := new(GoHighLevelCalendarAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityTool); err == nil {
		l.typ = "GoHighLevelCalendarAvailabilityTool"
		l.GoHighLevelCalendarAvailabilityTool = valueGoHighLevelCalendarAvailabilityTool
		return nil
	}
	valueGoHighLevelCalendarEventCreateTool := new(GoHighLevelCalendarEventCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateTool); err == nil {
		l.typ = "GoHighLevelCalendarEventCreateTool"
		l.GoHighLevelCalendarEventCreateTool = valueGoHighLevelCalendarEventCreateTool
		return nil
	}
	valueGoHighLevelContactCreateTool := new(GoHighLevelContactCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateTool); err == nil {
		l.typ = "GoHighLevelContactCreateTool"
		l.GoHighLevelContactCreateTool = valueGoHighLevelContactCreateTool
		return nil
	}
	valueGoHighLevelContactGetTool := new(GoHighLevelContactGetTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetTool); err == nil {
		l.typ = "GoHighLevelContactGetTool"
		l.GoHighLevelContactGetTool = valueGoHighLevelContactGetTool
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l ListToolsResponseItem) MarshalJSON() ([]byte, error) {
	if l.typ == "ApiRequestTool" || l.ApiRequestTool != nil {
		return json.Marshal(l.ApiRequestTool)
	}
	if l.typ == "DtmfTool" || l.DtmfTool != nil {
		return json.Marshal(l.DtmfTool)
	}
	if l.typ == "EndCallTool" || l.EndCallTool != nil {
		return json.Marshal(l.EndCallTool)
	}
	if l.typ == "FunctionTool" || l.FunctionTool != nil {
		return json.Marshal(l.FunctionTool)
	}
	if l.typ == "TransferCallTool" || l.TransferCallTool != nil {
		return json.Marshal(l.TransferCallTool)
	}
	if l.typ == "HandoffTool" || l.HandoffTool != nil {
		return json.Marshal(l.HandoffTool)
	}
	if l.typ == "BashTool" || l.BashTool != nil {
		return json.Marshal(l.BashTool)
	}
	if l.typ == "ComputerTool" || l.ComputerTool != nil {
		return json.Marshal(l.ComputerTool)
	}
	if l.typ == "TextEditorTool" || l.TextEditorTool != nil {
		return json.Marshal(l.TextEditorTool)
	}
	if l.typ == "QueryTool" || l.QueryTool != nil {
		return json.Marshal(l.QueryTool)
	}
	if l.typ == "GoogleCalendarCreateEventTool" || l.GoogleCalendarCreateEventTool != nil {
		return json.Marshal(l.GoogleCalendarCreateEventTool)
	}
	if l.typ == "GoogleSheetsRowAppendTool" || l.GoogleSheetsRowAppendTool != nil {
		return json.Marshal(l.GoogleSheetsRowAppendTool)
	}
	if l.typ == "GoogleCalendarCheckAvailabilityTool" || l.GoogleCalendarCheckAvailabilityTool != nil {
		return json.Marshal(l.GoogleCalendarCheckAvailabilityTool)
	}
	if l.typ == "SlackSendMessageTool" || l.SlackSendMessageTool != nil {
		return json.Marshal(l.SlackSendMessageTool)
	}
	if l.typ == "SmsTool" || l.SmsTool != nil {
		return json.Marshal(l.SmsTool)
	}
	if l.typ == "McpTool" || l.McpTool != nil {
		return json.Marshal(l.McpTool)
	}
	if l.typ == "GoHighLevelCalendarAvailabilityTool" || l.GoHighLevelCalendarAvailabilityTool != nil {
		return json.Marshal(l.GoHighLevelCalendarAvailabilityTool)
	}
	if l.typ == "GoHighLevelCalendarEventCreateTool" || l.GoHighLevelCalendarEventCreateTool != nil {
		return json.Marshal(l.GoHighLevelCalendarEventCreateTool)
	}
	if l.typ == "GoHighLevelContactCreateTool" || l.GoHighLevelContactCreateTool != nil {
		return json.Marshal(l.GoHighLevelContactCreateTool)
	}
	if l.typ == "GoHighLevelContactGetTool" || l.GoHighLevelContactGetTool != nil {
		return json.Marshal(l.GoHighLevelContactGetTool)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type ListToolsResponseItemVisitor interface {
	VisitApiRequestTool(*ApiRequestTool) error
	VisitDtmfTool(*DtmfTool) error
	VisitEndCallTool(*EndCallTool) error
	VisitFunctionTool(*FunctionTool) error
	VisitTransferCallTool(*TransferCallTool) error
	VisitHandoffTool(*HandoffTool) error
	VisitBashTool(*BashTool) error
	VisitComputerTool(*ComputerTool) error
	VisitTextEditorTool(*TextEditorTool) error
	VisitQueryTool(*QueryTool) error
	VisitGoogleCalendarCreateEventTool(*GoogleCalendarCreateEventTool) error
	VisitGoogleSheetsRowAppendTool(*GoogleSheetsRowAppendTool) error
	VisitGoogleCalendarCheckAvailabilityTool(*GoogleCalendarCheckAvailabilityTool) error
	VisitSlackSendMessageTool(*SlackSendMessageTool) error
	VisitSmsTool(*SmsTool) error
	VisitMcpTool(*McpTool) error
	VisitGoHighLevelCalendarAvailabilityTool(*GoHighLevelCalendarAvailabilityTool) error
	VisitGoHighLevelCalendarEventCreateTool(*GoHighLevelCalendarEventCreateTool) error
	VisitGoHighLevelContactCreateTool(*GoHighLevelContactCreateTool) error
	VisitGoHighLevelContactGetTool(*GoHighLevelContactGetTool) error
}

func (l *ListToolsResponseItem) Accept(visitor ListToolsResponseItemVisitor) error {
	if l.typ == "ApiRequestTool" || l.ApiRequestTool != nil {
		return visitor.VisitApiRequestTool(l.ApiRequestTool)
	}
	if l.typ == "DtmfTool" || l.DtmfTool != nil {
		return visitor.VisitDtmfTool(l.DtmfTool)
	}
	if l.typ == "EndCallTool" || l.EndCallTool != nil {
		return visitor.VisitEndCallTool(l.EndCallTool)
	}
	if l.typ == "FunctionTool" || l.FunctionTool != nil {
		return visitor.VisitFunctionTool(l.FunctionTool)
	}
	if l.typ == "TransferCallTool" || l.TransferCallTool != nil {
		return visitor.VisitTransferCallTool(l.TransferCallTool)
	}
	if l.typ == "HandoffTool" || l.HandoffTool != nil {
		return visitor.VisitHandoffTool(l.HandoffTool)
	}
	if l.typ == "BashTool" || l.BashTool != nil {
		return visitor.VisitBashTool(l.BashTool)
	}
	if l.typ == "ComputerTool" || l.ComputerTool != nil {
		return visitor.VisitComputerTool(l.ComputerTool)
	}
	if l.typ == "TextEditorTool" || l.TextEditorTool != nil {
		return visitor.VisitTextEditorTool(l.TextEditorTool)
	}
	if l.typ == "QueryTool" || l.QueryTool != nil {
		return visitor.VisitQueryTool(l.QueryTool)
	}
	if l.typ == "GoogleCalendarCreateEventTool" || l.GoogleCalendarCreateEventTool != nil {
		return visitor.VisitGoogleCalendarCreateEventTool(l.GoogleCalendarCreateEventTool)
	}
	if l.typ == "GoogleSheetsRowAppendTool" || l.GoogleSheetsRowAppendTool != nil {
		return visitor.VisitGoogleSheetsRowAppendTool(l.GoogleSheetsRowAppendTool)
	}
	if l.typ == "GoogleCalendarCheckAvailabilityTool" || l.GoogleCalendarCheckAvailabilityTool != nil {
		return visitor.VisitGoogleCalendarCheckAvailabilityTool(l.GoogleCalendarCheckAvailabilityTool)
	}
	if l.typ == "SlackSendMessageTool" || l.SlackSendMessageTool != nil {
		return visitor.VisitSlackSendMessageTool(l.SlackSendMessageTool)
	}
	if l.typ == "SmsTool" || l.SmsTool != nil {
		return visitor.VisitSmsTool(l.SmsTool)
	}
	if l.typ == "McpTool" || l.McpTool != nil {
		return visitor.VisitMcpTool(l.McpTool)
	}
	if l.typ == "GoHighLevelCalendarAvailabilityTool" || l.GoHighLevelCalendarAvailabilityTool != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityTool(l.GoHighLevelCalendarAvailabilityTool)
	}
	if l.typ == "GoHighLevelCalendarEventCreateTool" || l.GoHighLevelCalendarEventCreateTool != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateTool(l.GoHighLevelCalendarEventCreateTool)
	}
	if l.typ == "GoHighLevelContactCreateTool" || l.GoHighLevelContactCreateTool != nil {
		return visitor.VisitGoHighLevelContactCreateTool(l.GoHighLevelContactCreateTool)
	}
	if l.typ == "GoHighLevelContactGetTool" || l.GoHighLevelContactGetTool != nil {
		return visitor.VisitGoHighLevelContactGetTool(l.GoHighLevelContactGetTool)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

type UpdateToolsRequestBody struct {
	UpdateApiRequestToolDto                      *UpdateApiRequestToolDto
	UpdateDtmfToolDto                            *UpdateDtmfToolDto
	UpdateEndCallToolDto                         *UpdateEndCallToolDto
	UpdateFunctionToolDto                        *UpdateFunctionToolDto
	UpdateTransferCallToolDto                    *UpdateTransferCallToolDto
	UpdateHandoffToolDto                         *UpdateHandoffToolDto
	UpdateBashToolDto                            *UpdateBashToolDto
	UpdateComputerToolDto                        *UpdateComputerToolDto
	UpdateTextEditorToolDto                      *UpdateTextEditorToolDto
	UpdateQueryToolDto                           *UpdateQueryToolDto
	UpdateGoogleCalendarCreateEventToolDto       *UpdateGoogleCalendarCreateEventToolDto
	UpdateGoogleSheetsRowAppendToolDto           *UpdateGoogleSheetsRowAppendToolDto
	UpdateGoogleCalendarCheckAvailabilityToolDto *UpdateGoogleCalendarCheckAvailabilityToolDto
	UpdateSlackSendMessageToolDto                *UpdateSlackSendMessageToolDto
	UpdateSmsToolDto                             *UpdateSmsToolDto
	UpdateMcpToolDto                             *UpdateMcpToolDto
	UpdateGoHighLevelCalendarAvailabilityToolDto *UpdateGoHighLevelCalendarAvailabilityToolDto
	UpdateGoHighLevelCalendarEventCreateToolDto  *UpdateGoHighLevelCalendarEventCreateToolDto
	UpdateGoHighLevelContactCreateToolDto        *UpdateGoHighLevelContactCreateToolDto
	UpdateGoHighLevelContactGetToolDto           *UpdateGoHighLevelContactGetToolDto

	typ string
}

func (u *UpdateToolsRequestBody) GetUpdateApiRequestToolDto() *UpdateApiRequestToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateApiRequestToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateDtmfToolDto() *UpdateDtmfToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateDtmfToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateEndCallToolDto() *UpdateEndCallToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateEndCallToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateFunctionToolDto() *UpdateFunctionToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateFunctionToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateTransferCallToolDto() *UpdateTransferCallToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateTransferCallToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateHandoffToolDto() *UpdateHandoffToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateHandoffToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateBashToolDto() *UpdateBashToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateBashToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateComputerToolDto() *UpdateComputerToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateComputerToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateTextEditorToolDto() *UpdateTextEditorToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateTextEditorToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateQueryToolDto() *UpdateQueryToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateQueryToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateGoogleCalendarCreateEventToolDto() *UpdateGoogleCalendarCreateEventToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateGoogleCalendarCreateEventToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateGoogleSheetsRowAppendToolDto() *UpdateGoogleSheetsRowAppendToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateGoogleSheetsRowAppendToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateGoogleCalendarCheckAvailabilityToolDto() *UpdateGoogleCalendarCheckAvailabilityToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateGoogleCalendarCheckAvailabilityToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateSlackSendMessageToolDto() *UpdateSlackSendMessageToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateSlackSendMessageToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateSmsToolDto() *UpdateSmsToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateSmsToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateMcpToolDto() *UpdateMcpToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateMcpToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateGoHighLevelCalendarAvailabilityToolDto() *UpdateGoHighLevelCalendarAvailabilityToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateGoHighLevelCalendarAvailabilityToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateGoHighLevelCalendarEventCreateToolDto() *UpdateGoHighLevelCalendarEventCreateToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateGoHighLevelCalendarEventCreateToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateGoHighLevelContactCreateToolDto() *UpdateGoHighLevelContactCreateToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateGoHighLevelContactCreateToolDto
}

func (u *UpdateToolsRequestBody) GetUpdateGoHighLevelContactGetToolDto() *UpdateGoHighLevelContactGetToolDto {
	if u == nil {
		return nil
	}
	return u.UpdateGoHighLevelContactGetToolDto
}

func (u *UpdateToolsRequestBody) UnmarshalJSON(data []byte) error {
	valueUpdateApiRequestToolDto := new(UpdateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueUpdateApiRequestToolDto); err == nil {
		u.typ = "UpdateApiRequestToolDto"
		u.UpdateApiRequestToolDto = valueUpdateApiRequestToolDto
		return nil
	}
	valueUpdateDtmfToolDto := new(UpdateDtmfToolDto)
	if err := json.Unmarshal(data, &valueUpdateDtmfToolDto); err == nil {
		u.typ = "UpdateDtmfToolDto"
		u.UpdateDtmfToolDto = valueUpdateDtmfToolDto
		return nil
	}
	valueUpdateEndCallToolDto := new(UpdateEndCallToolDto)
	if err := json.Unmarshal(data, &valueUpdateEndCallToolDto); err == nil {
		u.typ = "UpdateEndCallToolDto"
		u.UpdateEndCallToolDto = valueUpdateEndCallToolDto
		return nil
	}
	valueUpdateFunctionToolDto := new(UpdateFunctionToolDto)
	if err := json.Unmarshal(data, &valueUpdateFunctionToolDto); err == nil {
		u.typ = "UpdateFunctionToolDto"
		u.UpdateFunctionToolDto = valueUpdateFunctionToolDto
		return nil
	}
	valueUpdateTransferCallToolDto := new(UpdateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueUpdateTransferCallToolDto); err == nil {
		u.typ = "UpdateTransferCallToolDto"
		u.UpdateTransferCallToolDto = valueUpdateTransferCallToolDto
		return nil
	}
	valueUpdateHandoffToolDto := new(UpdateHandoffToolDto)
	if err := json.Unmarshal(data, &valueUpdateHandoffToolDto); err == nil {
		u.typ = "UpdateHandoffToolDto"
		u.UpdateHandoffToolDto = valueUpdateHandoffToolDto
		return nil
	}
	valueUpdateBashToolDto := new(UpdateBashToolDto)
	if err := json.Unmarshal(data, &valueUpdateBashToolDto); err == nil {
		u.typ = "UpdateBashToolDto"
		u.UpdateBashToolDto = valueUpdateBashToolDto
		return nil
	}
	valueUpdateComputerToolDto := new(UpdateComputerToolDto)
	if err := json.Unmarshal(data, &valueUpdateComputerToolDto); err == nil {
		u.typ = "UpdateComputerToolDto"
		u.UpdateComputerToolDto = valueUpdateComputerToolDto
		return nil
	}
	valueUpdateTextEditorToolDto := new(UpdateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueUpdateTextEditorToolDto); err == nil {
		u.typ = "UpdateTextEditorToolDto"
		u.UpdateTextEditorToolDto = valueUpdateTextEditorToolDto
		return nil
	}
	valueUpdateQueryToolDto := new(UpdateQueryToolDto)
	if err := json.Unmarshal(data, &valueUpdateQueryToolDto); err == nil {
		u.typ = "UpdateQueryToolDto"
		u.UpdateQueryToolDto = valueUpdateQueryToolDto
		return nil
	}
	valueUpdateGoogleCalendarCreateEventToolDto := new(UpdateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoogleCalendarCreateEventToolDto); err == nil {
		u.typ = "UpdateGoogleCalendarCreateEventToolDto"
		u.UpdateGoogleCalendarCreateEventToolDto = valueUpdateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueUpdateGoogleSheetsRowAppendToolDto := new(UpdateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoogleSheetsRowAppendToolDto); err == nil {
		u.typ = "UpdateGoogleSheetsRowAppendToolDto"
		u.UpdateGoogleSheetsRowAppendToolDto = valueUpdateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueUpdateGoogleCalendarCheckAvailabilityToolDto := new(UpdateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		u.typ = "UpdateGoogleCalendarCheckAvailabilityToolDto"
		u.UpdateGoogleCalendarCheckAvailabilityToolDto = valueUpdateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueUpdateSlackSendMessageToolDto := new(UpdateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueUpdateSlackSendMessageToolDto); err == nil {
		u.typ = "UpdateSlackSendMessageToolDto"
		u.UpdateSlackSendMessageToolDto = valueUpdateSlackSendMessageToolDto
		return nil
	}
	valueUpdateSmsToolDto := new(UpdateSmsToolDto)
	if err := json.Unmarshal(data, &valueUpdateSmsToolDto); err == nil {
		u.typ = "UpdateSmsToolDto"
		u.UpdateSmsToolDto = valueUpdateSmsToolDto
		return nil
	}
	valueUpdateMcpToolDto := new(UpdateMcpToolDto)
	if err := json.Unmarshal(data, &valueUpdateMcpToolDto); err == nil {
		u.typ = "UpdateMcpToolDto"
		u.UpdateMcpToolDto = valueUpdateMcpToolDto
		return nil
	}
	valueUpdateGoHighLevelCalendarAvailabilityToolDto := new(UpdateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		u.typ = "UpdateGoHighLevelCalendarAvailabilityToolDto"
		u.UpdateGoHighLevelCalendarAvailabilityToolDto = valueUpdateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueUpdateGoHighLevelCalendarEventCreateToolDto := new(UpdateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoHighLevelCalendarEventCreateToolDto); err == nil {
		u.typ = "UpdateGoHighLevelCalendarEventCreateToolDto"
		u.UpdateGoHighLevelCalendarEventCreateToolDto = valueUpdateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueUpdateGoHighLevelContactCreateToolDto := new(UpdateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoHighLevelContactCreateToolDto); err == nil {
		u.typ = "UpdateGoHighLevelContactCreateToolDto"
		u.UpdateGoHighLevelContactCreateToolDto = valueUpdateGoHighLevelContactCreateToolDto
		return nil
	}
	valueUpdateGoHighLevelContactGetToolDto := new(UpdateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoHighLevelContactGetToolDto); err == nil {
		u.typ = "UpdateGoHighLevelContactGetToolDto"
		u.UpdateGoHighLevelContactGetToolDto = valueUpdateGoHighLevelContactGetToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateToolsRequestBody) MarshalJSON() ([]byte, error) {
	if u.typ == "UpdateApiRequestToolDto" || u.UpdateApiRequestToolDto != nil {
		return json.Marshal(u.UpdateApiRequestToolDto)
	}
	if u.typ == "UpdateDtmfToolDto" || u.UpdateDtmfToolDto != nil {
		return json.Marshal(u.UpdateDtmfToolDto)
	}
	if u.typ == "UpdateEndCallToolDto" || u.UpdateEndCallToolDto != nil {
		return json.Marshal(u.UpdateEndCallToolDto)
	}
	if u.typ == "UpdateFunctionToolDto" || u.UpdateFunctionToolDto != nil {
		return json.Marshal(u.UpdateFunctionToolDto)
	}
	if u.typ == "UpdateTransferCallToolDto" || u.UpdateTransferCallToolDto != nil {
		return json.Marshal(u.UpdateTransferCallToolDto)
	}
	if u.typ == "UpdateHandoffToolDto" || u.UpdateHandoffToolDto != nil {
		return json.Marshal(u.UpdateHandoffToolDto)
	}
	if u.typ == "UpdateBashToolDto" || u.UpdateBashToolDto != nil {
		return json.Marshal(u.UpdateBashToolDto)
	}
	if u.typ == "UpdateComputerToolDto" || u.UpdateComputerToolDto != nil {
		return json.Marshal(u.UpdateComputerToolDto)
	}
	if u.typ == "UpdateTextEditorToolDto" || u.UpdateTextEditorToolDto != nil {
		return json.Marshal(u.UpdateTextEditorToolDto)
	}
	if u.typ == "UpdateQueryToolDto" || u.UpdateQueryToolDto != nil {
		return json.Marshal(u.UpdateQueryToolDto)
	}
	if u.typ == "UpdateGoogleCalendarCreateEventToolDto" || u.UpdateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(u.UpdateGoogleCalendarCreateEventToolDto)
	}
	if u.typ == "UpdateGoogleSheetsRowAppendToolDto" || u.UpdateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(u.UpdateGoogleSheetsRowAppendToolDto)
	}
	if u.typ == "UpdateGoogleCalendarCheckAvailabilityToolDto" || u.UpdateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(u.UpdateGoogleCalendarCheckAvailabilityToolDto)
	}
	if u.typ == "UpdateSlackSendMessageToolDto" || u.UpdateSlackSendMessageToolDto != nil {
		return json.Marshal(u.UpdateSlackSendMessageToolDto)
	}
	if u.typ == "UpdateSmsToolDto" || u.UpdateSmsToolDto != nil {
		return json.Marshal(u.UpdateSmsToolDto)
	}
	if u.typ == "UpdateMcpToolDto" || u.UpdateMcpToolDto != nil {
		return json.Marshal(u.UpdateMcpToolDto)
	}
	if u.typ == "UpdateGoHighLevelCalendarAvailabilityToolDto" || u.UpdateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(u.UpdateGoHighLevelCalendarAvailabilityToolDto)
	}
	if u.typ == "UpdateGoHighLevelCalendarEventCreateToolDto" || u.UpdateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(u.UpdateGoHighLevelCalendarEventCreateToolDto)
	}
	if u.typ == "UpdateGoHighLevelContactCreateToolDto" || u.UpdateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(u.UpdateGoHighLevelContactCreateToolDto)
	}
	if u.typ == "UpdateGoHighLevelContactGetToolDto" || u.UpdateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(u.UpdateGoHighLevelContactGetToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolsRequestBodyVisitor interface {
	VisitUpdateApiRequestToolDto(*UpdateApiRequestToolDto) error
	VisitUpdateDtmfToolDto(*UpdateDtmfToolDto) error
	VisitUpdateEndCallToolDto(*UpdateEndCallToolDto) error
	VisitUpdateFunctionToolDto(*UpdateFunctionToolDto) error
	VisitUpdateTransferCallToolDto(*UpdateTransferCallToolDto) error
	VisitUpdateHandoffToolDto(*UpdateHandoffToolDto) error
	VisitUpdateBashToolDto(*UpdateBashToolDto) error
	VisitUpdateComputerToolDto(*UpdateComputerToolDto) error
	VisitUpdateTextEditorToolDto(*UpdateTextEditorToolDto) error
	VisitUpdateQueryToolDto(*UpdateQueryToolDto) error
	VisitUpdateGoogleCalendarCreateEventToolDto(*UpdateGoogleCalendarCreateEventToolDto) error
	VisitUpdateGoogleSheetsRowAppendToolDto(*UpdateGoogleSheetsRowAppendToolDto) error
	VisitUpdateGoogleCalendarCheckAvailabilityToolDto(*UpdateGoogleCalendarCheckAvailabilityToolDto) error
	VisitUpdateSlackSendMessageToolDto(*UpdateSlackSendMessageToolDto) error
	VisitUpdateSmsToolDto(*UpdateSmsToolDto) error
	VisitUpdateMcpToolDto(*UpdateMcpToolDto) error
	VisitUpdateGoHighLevelCalendarAvailabilityToolDto(*UpdateGoHighLevelCalendarAvailabilityToolDto) error
	VisitUpdateGoHighLevelCalendarEventCreateToolDto(*UpdateGoHighLevelCalendarEventCreateToolDto) error
	VisitUpdateGoHighLevelContactCreateToolDto(*UpdateGoHighLevelContactCreateToolDto) error
	VisitUpdateGoHighLevelContactGetToolDto(*UpdateGoHighLevelContactGetToolDto) error
}

func (u *UpdateToolsRequestBody) Accept(visitor UpdateToolsRequestBodyVisitor) error {
	if u.typ == "UpdateApiRequestToolDto" || u.UpdateApiRequestToolDto != nil {
		return visitor.VisitUpdateApiRequestToolDto(u.UpdateApiRequestToolDto)
	}
	if u.typ == "UpdateDtmfToolDto" || u.UpdateDtmfToolDto != nil {
		return visitor.VisitUpdateDtmfToolDto(u.UpdateDtmfToolDto)
	}
	if u.typ == "UpdateEndCallToolDto" || u.UpdateEndCallToolDto != nil {
		return visitor.VisitUpdateEndCallToolDto(u.UpdateEndCallToolDto)
	}
	if u.typ == "UpdateFunctionToolDto" || u.UpdateFunctionToolDto != nil {
		return visitor.VisitUpdateFunctionToolDto(u.UpdateFunctionToolDto)
	}
	if u.typ == "UpdateTransferCallToolDto" || u.UpdateTransferCallToolDto != nil {
		return visitor.VisitUpdateTransferCallToolDto(u.UpdateTransferCallToolDto)
	}
	if u.typ == "UpdateHandoffToolDto" || u.UpdateHandoffToolDto != nil {
		return visitor.VisitUpdateHandoffToolDto(u.UpdateHandoffToolDto)
	}
	if u.typ == "UpdateBashToolDto" || u.UpdateBashToolDto != nil {
		return visitor.VisitUpdateBashToolDto(u.UpdateBashToolDto)
	}
	if u.typ == "UpdateComputerToolDto" || u.UpdateComputerToolDto != nil {
		return visitor.VisitUpdateComputerToolDto(u.UpdateComputerToolDto)
	}
	if u.typ == "UpdateTextEditorToolDto" || u.UpdateTextEditorToolDto != nil {
		return visitor.VisitUpdateTextEditorToolDto(u.UpdateTextEditorToolDto)
	}
	if u.typ == "UpdateQueryToolDto" || u.UpdateQueryToolDto != nil {
		return visitor.VisitUpdateQueryToolDto(u.UpdateQueryToolDto)
	}
	if u.typ == "UpdateGoogleCalendarCreateEventToolDto" || u.UpdateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitUpdateGoogleCalendarCreateEventToolDto(u.UpdateGoogleCalendarCreateEventToolDto)
	}
	if u.typ == "UpdateGoogleSheetsRowAppendToolDto" || u.UpdateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitUpdateGoogleSheetsRowAppendToolDto(u.UpdateGoogleSheetsRowAppendToolDto)
	}
	if u.typ == "UpdateGoogleCalendarCheckAvailabilityToolDto" || u.UpdateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitUpdateGoogleCalendarCheckAvailabilityToolDto(u.UpdateGoogleCalendarCheckAvailabilityToolDto)
	}
	if u.typ == "UpdateSlackSendMessageToolDto" || u.UpdateSlackSendMessageToolDto != nil {
		return visitor.VisitUpdateSlackSendMessageToolDto(u.UpdateSlackSendMessageToolDto)
	}
	if u.typ == "UpdateSmsToolDto" || u.UpdateSmsToolDto != nil {
		return visitor.VisitUpdateSmsToolDto(u.UpdateSmsToolDto)
	}
	if u.typ == "UpdateMcpToolDto" || u.UpdateMcpToolDto != nil {
		return visitor.VisitUpdateMcpToolDto(u.UpdateMcpToolDto)
	}
	if u.typ == "UpdateGoHighLevelCalendarAvailabilityToolDto" || u.UpdateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitUpdateGoHighLevelCalendarAvailabilityToolDto(u.UpdateGoHighLevelCalendarAvailabilityToolDto)
	}
	if u.typ == "UpdateGoHighLevelCalendarEventCreateToolDto" || u.UpdateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitUpdateGoHighLevelCalendarEventCreateToolDto(u.UpdateGoHighLevelCalendarEventCreateToolDto)
	}
	if u.typ == "UpdateGoHighLevelContactCreateToolDto" || u.UpdateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitUpdateGoHighLevelContactCreateToolDto(u.UpdateGoHighLevelContactCreateToolDto)
	}
	if u.typ == "UpdateGoHighLevelContactGetToolDto" || u.UpdateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitUpdateGoHighLevelContactGetToolDto(u.UpdateGoHighLevelContactGetToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolsResponse struct {
	ApiRequestTool                      *ApiRequestTool
	DtmfTool                            *DtmfTool
	EndCallTool                         *EndCallTool
	FunctionTool                        *FunctionTool
	TransferCallTool                    *TransferCallTool
	HandoffTool                         *HandoffTool
	BashTool                            *BashTool
	ComputerTool                        *ComputerTool
	TextEditorTool                      *TextEditorTool
	QueryTool                           *QueryTool
	GoogleCalendarCreateEventTool       *GoogleCalendarCreateEventTool
	GoogleSheetsRowAppendTool           *GoogleSheetsRowAppendTool
	GoogleCalendarCheckAvailabilityTool *GoogleCalendarCheckAvailabilityTool
	SlackSendMessageTool                *SlackSendMessageTool
	SmsTool                             *SmsTool
	McpTool                             *McpTool
	GoHighLevelCalendarAvailabilityTool *GoHighLevelCalendarAvailabilityTool
	GoHighLevelCalendarEventCreateTool  *GoHighLevelCalendarEventCreateTool
	GoHighLevelContactCreateTool        *GoHighLevelContactCreateTool
	GoHighLevelContactGetTool           *GoHighLevelContactGetTool

	typ string
}

func (u *UpdateToolsResponse) GetApiRequestTool() *ApiRequestTool {
	if u == nil {
		return nil
	}
	return u.ApiRequestTool
}

func (u *UpdateToolsResponse) GetDtmfTool() *DtmfTool {
	if u == nil {
		return nil
	}
	return u.DtmfTool
}

func (u *UpdateToolsResponse) GetEndCallTool() *EndCallTool {
	if u == nil {
		return nil
	}
	return u.EndCallTool
}

func (u *UpdateToolsResponse) GetFunctionTool() *FunctionTool {
	if u == nil {
		return nil
	}
	return u.FunctionTool
}

func (u *UpdateToolsResponse) GetTransferCallTool() *TransferCallTool {
	if u == nil {
		return nil
	}
	return u.TransferCallTool
}

func (u *UpdateToolsResponse) GetHandoffTool() *HandoffTool {
	if u == nil {
		return nil
	}
	return u.HandoffTool
}

func (u *UpdateToolsResponse) GetBashTool() *BashTool {
	if u == nil {
		return nil
	}
	return u.BashTool
}

func (u *UpdateToolsResponse) GetComputerTool() *ComputerTool {
	if u == nil {
		return nil
	}
	return u.ComputerTool
}

func (u *UpdateToolsResponse) GetTextEditorTool() *TextEditorTool {
	if u == nil {
		return nil
	}
	return u.TextEditorTool
}

func (u *UpdateToolsResponse) GetQueryTool() *QueryTool {
	if u == nil {
		return nil
	}
	return u.QueryTool
}

func (u *UpdateToolsResponse) GetGoogleCalendarCreateEventTool() *GoogleCalendarCreateEventTool {
	if u == nil {
		return nil
	}
	return u.GoogleCalendarCreateEventTool
}

func (u *UpdateToolsResponse) GetGoogleSheetsRowAppendTool() *GoogleSheetsRowAppendTool {
	if u == nil {
		return nil
	}
	return u.GoogleSheetsRowAppendTool
}

func (u *UpdateToolsResponse) GetGoogleCalendarCheckAvailabilityTool() *GoogleCalendarCheckAvailabilityTool {
	if u == nil {
		return nil
	}
	return u.GoogleCalendarCheckAvailabilityTool
}

func (u *UpdateToolsResponse) GetSlackSendMessageTool() *SlackSendMessageTool {
	if u == nil {
		return nil
	}
	return u.SlackSendMessageTool
}

func (u *UpdateToolsResponse) GetSmsTool() *SmsTool {
	if u == nil {
		return nil
	}
	return u.SmsTool
}

func (u *UpdateToolsResponse) GetMcpTool() *McpTool {
	if u == nil {
		return nil
	}
	return u.McpTool
}

func (u *UpdateToolsResponse) GetGoHighLevelCalendarAvailabilityTool() *GoHighLevelCalendarAvailabilityTool {
	if u == nil {
		return nil
	}
	return u.GoHighLevelCalendarAvailabilityTool
}

func (u *UpdateToolsResponse) GetGoHighLevelCalendarEventCreateTool() *GoHighLevelCalendarEventCreateTool {
	if u == nil {
		return nil
	}
	return u.GoHighLevelCalendarEventCreateTool
}

func (u *UpdateToolsResponse) GetGoHighLevelContactCreateTool() *GoHighLevelContactCreateTool {
	if u == nil {
		return nil
	}
	return u.GoHighLevelContactCreateTool
}

func (u *UpdateToolsResponse) GetGoHighLevelContactGetTool() *GoHighLevelContactGetTool {
	if u == nil {
		return nil
	}
	return u.GoHighLevelContactGetTool
}

func (u *UpdateToolsResponse) UnmarshalJSON(data []byte) error {
	valueApiRequestTool := new(ApiRequestTool)
	if err := json.Unmarshal(data, &valueApiRequestTool); err == nil {
		u.typ = "ApiRequestTool"
		u.ApiRequestTool = valueApiRequestTool
		return nil
	}
	valueDtmfTool := new(DtmfTool)
	if err := json.Unmarshal(data, &valueDtmfTool); err == nil {
		u.typ = "DtmfTool"
		u.DtmfTool = valueDtmfTool
		return nil
	}
	valueEndCallTool := new(EndCallTool)
	if err := json.Unmarshal(data, &valueEndCallTool); err == nil {
		u.typ = "EndCallTool"
		u.EndCallTool = valueEndCallTool
		return nil
	}
	valueFunctionTool := new(FunctionTool)
	if err := json.Unmarshal(data, &valueFunctionTool); err == nil {
		u.typ = "FunctionTool"
		u.FunctionTool = valueFunctionTool
		return nil
	}
	valueTransferCallTool := new(TransferCallTool)
	if err := json.Unmarshal(data, &valueTransferCallTool); err == nil {
		u.typ = "TransferCallTool"
		u.TransferCallTool = valueTransferCallTool
		return nil
	}
	valueHandoffTool := new(HandoffTool)
	if err := json.Unmarshal(data, &valueHandoffTool); err == nil {
		u.typ = "HandoffTool"
		u.HandoffTool = valueHandoffTool
		return nil
	}
	valueBashTool := new(BashTool)
	if err := json.Unmarshal(data, &valueBashTool); err == nil {
		u.typ = "BashTool"
		u.BashTool = valueBashTool
		return nil
	}
	valueComputerTool := new(ComputerTool)
	if err := json.Unmarshal(data, &valueComputerTool); err == nil {
		u.typ = "ComputerTool"
		u.ComputerTool = valueComputerTool
		return nil
	}
	valueTextEditorTool := new(TextEditorTool)
	if err := json.Unmarshal(data, &valueTextEditorTool); err == nil {
		u.typ = "TextEditorTool"
		u.TextEditorTool = valueTextEditorTool
		return nil
	}
	valueQueryTool := new(QueryTool)
	if err := json.Unmarshal(data, &valueQueryTool); err == nil {
		u.typ = "QueryTool"
		u.QueryTool = valueQueryTool
		return nil
	}
	valueGoogleCalendarCreateEventTool := new(GoogleCalendarCreateEventTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventTool); err == nil {
		u.typ = "GoogleCalendarCreateEventTool"
		u.GoogleCalendarCreateEventTool = valueGoogleCalendarCreateEventTool
		return nil
	}
	valueGoogleSheetsRowAppendTool := new(GoogleSheetsRowAppendTool)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendTool); err == nil {
		u.typ = "GoogleSheetsRowAppendTool"
		u.GoogleSheetsRowAppendTool = valueGoogleSheetsRowAppendTool
		return nil
	}
	valueGoogleCalendarCheckAvailabilityTool := new(GoogleCalendarCheckAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCheckAvailabilityTool); err == nil {
		u.typ = "GoogleCalendarCheckAvailabilityTool"
		u.GoogleCalendarCheckAvailabilityTool = valueGoogleCalendarCheckAvailabilityTool
		return nil
	}
	valueSlackSendMessageTool := new(SlackSendMessageTool)
	if err := json.Unmarshal(data, &valueSlackSendMessageTool); err == nil {
		u.typ = "SlackSendMessageTool"
		u.SlackSendMessageTool = valueSlackSendMessageTool
		return nil
	}
	valueSmsTool := new(SmsTool)
	if err := json.Unmarshal(data, &valueSmsTool); err == nil {
		u.typ = "SmsTool"
		u.SmsTool = valueSmsTool
		return nil
	}
	valueMcpTool := new(McpTool)
	if err := json.Unmarshal(data, &valueMcpTool); err == nil {
		u.typ = "McpTool"
		u.McpTool = valueMcpTool
		return nil
	}
	valueGoHighLevelCalendarAvailabilityTool := new(GoHighLevelCalendarAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityTool); err == nil {
		u.typ = "GoHighLevelCalendarAvailabilityTool"
		u.GoHighLevelCalendarAvailabilityTool = valueGoHighLevelCalendarAvailabilityTool
		return nil
	}
	valueGoHighLevelCalendarEventCreateTool := new(GoHighLevelCalendarEventCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateTool); err == nil {
		u.typ = "GoHighLevelCalendarEventCreateTool"
		u.GoHighLevelCalendarEventCreateTool = valueGoHighLevelCalendarEventCreateTool
		return nil
	}
	valueGoHighLevelContactCreateTool := new(GoHighLevelContactCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateTool); err == nil {
		u.typ = "GoHighLevelContactCreateTool"
		u.GoHighLevelContactCreateTool = valueGoHighLevelContactCreateTool
		return nil
	}
	valueGoHighLevelContactGetTool := new(GoHighLevelContactGetTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetTool); err == nil {
		u.typ = "GoHighLevelContactGetTool"
		u.GoHighLevelContactGetTool = valueGoHighLevelContactGetTool
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateToolsResponse) MarshalJSON() ([]byte, error) {
	if u.typ == "ApiRequestTool" || u.ApiRequestTool != nil {
		return json.Marshal(u.ApiRequestTool)
	}
	if u.typ == "DtmfTool" || u.DtmfTool != nil {
		return json.Marshal(u.DtmfTool)
	}
	if u.typ == "EndCallTool" || u.EndCallTool != nil {
		return json.Marshal(u.EndCallTool)
	}
	if u.typ == "FunctionTool" || u.FunctionTool != nil {
		return json.Marshal(u.FunctionTool)
	}
	if u.typ == "TransferCallTool" || u.TransferCallTool != nil {
		return json.Marshal(u.TransferCallTool)
	}
	if u.typ == "HandoffTool" || u.HandoffTool != nil {
		return json.Marshal(u.HandoffTool)
	}
	if u.typ == "BashTool" || u.BashTool != nil {
		return json.Marshal(u.BashTool)
	}
	if u.typ == "ComputerTool" || u.ComputerTool != nil {
		return json.Marshal(u.ComputerTool)
	}
	if u.typ == "TextEditorTool" || u.TextEditorTool != nil {
		return json.Marshal(u.TextEditorTool)
	}
	if u.typ == "QueryTool" || u.QueryTool != nil {
		return json.Marshal(u.QueryTool)
	}
	if u.typ == "GoogleCalendarCreateEventTool" || u.GoogleCalendarCreateEventTool != nil {
		return json.Marshal(u.GoogleCalendarCreateEventTool)
	}
	if u.typ == "GoogleSheetsRowAppendTool" || u.GoogleSheetsRowAppendTool != nil {
		return json.Marshal(u.GoogleSheetsRowAppendTool)
	}
	if u.typ == "GoogleCalendarCheckAvailabilityTool" || u.GoogleCalendarCheckAvailabilityTool != nil {
		return json.Marshal(u.GoogleCalendarCheckAvailabilityTool)
	}
	if u.typ == "SlackSendMessageTool" || u.SlackSendMessageTool != nil {
		return json.Marshal(u.SlackSendMessageTool)
	}
	if u.typ == "SmsTool" || u.SmsTool != nil {
		return json.Marshal(u.SmsTool)
	}
	if u.typ == "McpTool" || u.McpTool != nil {
		return json.Marshal(u.McpTool)
	}
	if u.typ == "GoHighLevelCalendarAvailabilityTool" || u.GoHighLevelCalendarAvailabilityTool != nil {
		return json.Marshal(u.GoHighLevelCalendarAvailabilityTool)
	}
	if u.typ == "GoHighLevelCalendarEventCreateTool" || u.GoHighLevelCalendarEventCreateTool != nil {
		return json.Marshal(u.GoHighLevelCalendarEventCreateTool)
	}
	if u.typ == "GoHighLevelContactCreateTool" || u.GoHighLevelContactCreateTool != nil {
		return json.Marshal(u.GoHighLevelContactCreateTool)
	}
	if u.typ == "GoHighLevelContactGetTool" || u.GoHighLevelContactGetTool != nil {
		return json.Marshal(u.GoHighLevelContactGetTool)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolsResponseVisitor interface {
	VisitApiRequestTool(*ApiRequestTool) error
	VisitDtmfTool(*DtmfTool) error
	VisitEndCallTool(*EndCallTool) error
	VisitFunctionTool(*FunctionTool) error
	VisitTransferCallTool(*TransferCallTool) error
	VisitHandoffTool(*HandoffTool) error
	VisitBashTool(*BashTool) error
	VisitComputerTool(*ComputerTool) error
	VisitTextEditorTool(*TextEditorTool) error
	VisitQueryTool(*QueryTool) error
	VisitGoogleCalendarCreateEventTool(*GoogleCalendarCreateEventTool) error
	VisitGoogleSheetsRowAppendTool(*GoogleSheetsRowAppendTool) error
	VisitGoogleCalendarCheckAvailabilityTool(*GoogleCalendarCheckAvailabilityTool) error
	VisitSlackSendMessageTool(*SlackSendMessageTool) error
	VisitSmsTool(*SmsTool) error
	VisitMcpTool(*McpTool) error
	VisitGoHighLevelCalendarAvailabilityTool(*GoHighLevelCalendarAvailabilityTool) error
	VisitGoHighLevelCalendarEventCreateTool(*GoHighLevelCalendarEventCreateTool) error
	VisitGoHighLevelContactCreateTool(*GoHighLevelContactCreateTool) error
	VisitGoHighLevelContactGetTool(*GoHighLevelContactGetTool) error
}

func (u *UpdateToolsResponse) Accept(visitor UpdateToolsResponseVisitor) error {
	if u.typ == "ApiRequestTool" || u.ApiRequestTool != nil {
		return visitor.VisitApiRequestTool(u.ApiRequestTool)
	}
	if u.typ == "DtmfTool" || u.DtmfTool != nil {
		return visitor.VisitDtmfTool(u.DtmfTool)
	}
	if u.typ == "EndCallTool" || u.EndCallTool != nil {
		return visitor.VisitEndCallTool(u.EndCallTool)
	}
	if u.typ == "FunctionTool" || u.FunctionTool != nil {
		return visitor.VisitFunctionTool(u.FunctionTool)
	}
	if u.typ == "TransferCallTool" || u.TransferCallTool != nil {
		return visitor.VisitTransferCallTool(u.TransferCallTool)
	}
	if u.typ == "HandoffTool" || u.HandoffTool != nil {
		return visitor.VisitHandoffTool(u.HandoffTool)
	}
	if u.typ == "BashTool" || u.BashTool != nil {
		return visitor.VisitBashTool(u.BashTool)
	}
	if u.typ == "ComputerTool" || u.ComputerTool != nil {
		return visitor.VisitComputerTool(u.ComputerTool)
	}
	if u.typ == "TextEditorTool" || u.TextEditorTool != nil {
		return visitor.VisitTextEditorTool(u.TextEditorTool)
	}
	if u.typ == "QueryTool" || u.QueryTool != nil {
		return visitor.VisitQueryTool(u.QueryTool)
	}
	if u.typ == "GoogleCalendarCreateEventTool" || u.GoogleCalendarCreateEventTool != nil {
		return visitor.VisitGoogleCalendarCreateEventTool(u.GoogleCalendarCreateEventTool)
	}
	if u.typ == "GoogleSheetsRowAppendTool" || u.GoogleSheetsRowAppendTool != nil {
		return visitor.VisitGoogleSheetsRowAppendTool(u.GoogleSheetsRowAppendTool)
	}
	if u.typ == "GoogleCalendarCheckAvailabilityTool" || u.GoogleCalendarCheckAvailabilityTool != nil {
		return visitor.VisitGoogleCalendarCheckAvailabilityTool(u.GoogleCalendarCheckAvailabilityTool)
	}
	if u.typ == "SlackSendMessageTool" || u.SlackSendMessageTool != nil {
		return visitor.VisitSlackSendMessageTool(u.SlackSendMessageTool)
	}
	if u.typ == "SmsTool" || u.SmsTool != nil {
		return visitor.VisitSmsTool(u.SmsTool)
	}
	if u.typ == "McpTool" || u.McpTool != nil {
		return visitor.VisitMcpTool(u.McpTool)
	}
	if u.typ == "GoHighLevelCalendarAvailabilityTool" || u.GoHighLevelCalendarAvailabilityTool != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityTool(u.GoHighLevelCalendarAvailabilityTool)
	}
	if u.typ == "GoHighLevelCalendarEventCreateTool" || u.GoHighLevelCalendarEventCreateTool != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateTool(u.GoHighLevelCalendarEventCreateTool)
	}
	if u.typ == "GoHighLevelContactCreateTool" || u.GoHighLevelContactCreateTool != nil {
		return visitor.VisitGoHighLevelContactCreateTool(u.GoHighLevelContactCreateTool)
	}
	if u.typ == "GoHighLevelContactGetTool" || u.GoHighLevelContactGetTool != nil {
		return visitor.VisitGoHighLevelContactGetTool(u.GoHighLevelContactGetTool)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

var (
	updateToolsRequestFieldId = big.NewInt(1 << 0)
)

type UpdateToolsRequest struct {
	Id   string                  `json:"-" url:"-"`
	Body *UpdateToolsRequestBody `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UpdateToolsRequest) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateToolsRequest) SetId(id string) {
	u.Id = id
	u.require(updateToolsRequestFieldId)
}

func (u *UpdateToolsRequest) UnmarshalJSON(data []byte) error {
	body := new(UpdateToolsRequestBody)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	u.Body = body
	return nil
}

func (u *UpdateToolsRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.Body)
}
